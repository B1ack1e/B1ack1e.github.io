{"meta":{"title":"b1ackie'blog","subtitle":"","description":"","author":"b1ackie","url":"https://b1ack1e.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-07-07T04:21:57.734Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"/404.html","permalink":"https://b1ack1e.github.io/404.html","excerpt":"","text":""},{"title":"分类","date":"2021-07-07T04:21:57.735Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"categories/index.html","permalink":"https://b1ack1e.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-07-07T04:21:57.735Z","updated":"2021-05-31T02:54:50.000Z","comments":true,"path":"links/index.html","permalink":"https://b1ack1e.github.io/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-07T04:21:57.734Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"about/index.html","permalink":"https://b1ack1e.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2021-07-07T04:21:57.735Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"books/index.html","permalink":"https://b1ack1e.github.io/books/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-07T04:21:57.735Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"tags/index.html","permalink":"https://b1ack1e.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-07-08T05:35:10.751Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"repository/index.html","permalink":"https://b1ack1e.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"恶意代码分析-资源释放","slug":"恶意代码分析-资源释放","date":"2021-07-09T01:54:29.000Z","updated":"2021-07-09T02:42:28.245Z","comments":true,"path":"2021/07/09/恶意代码分析-资源释放/","link":"","permalink":"https://b1ack1e.github.io/2021/07/09/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/","excerpt":"","text":"本篇来分析一下自己写的资源释放的小demo。 打开程序，发现没有任何改变，没有明显的行为。 使用die工具查一下文件的基本信息 查看一下导入表，可以看到FindResource等函数，这几个函数是用来操作资源的，猜测有可能是释放了一个资源节中的资源到电脑上。 还可以看到fwrite，fopen这样的函数，那么应该就是把资源释放到了一个路径中去。 可以使用resource hacker来查看程序中的资源，如图可以看到资源信息“this is a test” 再使用IDA进行查看，可以很清楚的看到所有的流程，并且看到程序将释放的文件存放在了C:\\Windows\\System32下。 因为程序是32位程序，系统是64位，所以资源会被释放到SysWOW64文件下。因为此文件夹是用来处理运行在64位系统上的32位程序的。 到路径下查找free.txt即可找到","categories":[{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ack1e.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ack1e.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}]},{"title":"全局钩子注入","slug":"全局钩子注入","date":"2021-07-08T09:52:07.000Z","updated":"2021-07-09T10:19:27.858Z","comments":true,"path":"2021/07/08/全局钩子注入/","link":"","permalink":"https://b1ack1e.github.io/2021/07/08/%E5%85%A8%E5%B1%80%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/","excerpt":"","text":"全局钩子注入windows中大部分应用程序都是基于消息机制的，每个进程都有自己的消息队列。 局部钩子是针对某个线程的，全局钩子是作用于整个系统的基于消息的应用。全局钩子需要使用DLL文件，在DLL文件中实现相应的钩子函数。 函数介绍SetWindowsHookEx函数将程序定义的钩子函数安装到挂钩链中，安装钩子程序可以监视系统是否存在某些类型的事件，这些事件与特定线程或调用线程所在桌面中的所有线程相关联。 123456HHOOK SetWindowsHookExA( int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId); 参数idHook：要安装的钩子程序的类型，该参数具体可以见下表。 值 含义 WH_CALLWNDPROC4 安装钩子程序，在系统将消息发送到目标窗口过程之前监视消息 WH_CALLWNDPROCRET12 安装钩子程序，在目标窗口过程处理消息后监视消息 WH_CBT5 安装接受对CBT应用程序有用通知的钩子程序 WH_DEBUG9 安装可用于调试其他钩子程序的钩子程序 WH_FOREGROUNDIDLE11 安装在应用程序的前台线程即将变为空闲时调用的钩子过程，该钩子对于在空闲时执行低优先级任务很有用 WH_GETMESSAGE3 安装一个挂钩过程，它监视发送到消息队列的消息 WH_JOURNALPLAYBACK1 安装一个挂钩过程，用于发布先前由WH_JOURNALRECORD挂钩过程记录的消息 WH_JOURNALRECORD0 安装一个挂钩过程，记录发布到系统消息队列中的输入消息。这个钩子对于录制宏很有用。 WH_KEYBOARD2 安装监视按键消息的挂钩过程 WH_KEYBOARD_LL13 安装监视低级键盘输入事件的挂钩过程 WH_MOUSE7 安装监视鼠标消息的挂钩过程 WH_MOUSE_LL14 安装监视低级鼠标输入事件的挂钩过程 WH_MSGFILTER-1 安装钩子程序，用于在对话框、消息框、菜单或滚动条中监视由于输入事件而生成的消息 WH_SHELL10 安装接受对于shell应用程序有用通知的钩子程序 WH_SYSMSGFILTER6 安装钩子程序，用于在对话框、消息框、菜单或滚动条中监视由于输入事件而生成的消息，钩子程序监视与调用线程相同桌面中所有应用程序的这些消息 lpfn：一个指向钩子程序的指针。如果dwThreadId参数为0或指定由不同进程创建线程标识符，则lpfn参数必须指向DLL中的钩子过程。否则，lpfn可以指向与当前进程关联的代码中的钩子过程。 hMod：包含由lpfn参数指向的钩子过程的DLL句柄。如果dwThreadId参数指定由当前进程创建线程，并且钩子过程位于与当前进程关联的代码中，则hMod参数必须设置为NULL。 dwThreadId：与钩子程序关联的线程标识符。如果此参数为0，则钩子过程与系统中所有线程相关联。 返回值如果函数成功，则返回值是钩子过程的句柄。 如果函数失败，则返回值为NULL。 实现过程创建全局钩子，钩子函数需要在一个DLL文件中。进程的地址空间是独立的，发生对应事件的进程不能调用其他进程地址空间的钩子函数。如果钩子的实现在DLL中的话，则在对应事件发生的时候，系统会把这个DLL加载到发生事件的进程地址空间之中，使它能够调用钩子函数进行处理。创建一个全局钩子之后，在对应事件发生的时候，系统就会把DLL加载到发生事件的进程中，这样就实现了DLL注入。 设置idHook的值为WH_GETMESSAGE就可以让DLL注入到所有的进程中，因为WH_GETMESSAGE类型的钩子会监视消息队列，并且Windows系统是基于消息驱动的，所有进程都会有一个自己的消息队列，都会加载WH_GETMESSAGE类型的全局钩子DLL。 DLL文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;//共享内存#pragma data_seg(&quot;mydata&quot;)#pragma data_seg()#pragma comment(linker, &quot;/SECTION:mydata,RWS&quot;)HMODULE g_hDllModule = NULL;HHOOK g_hHook = NULL;// 钩子回调函数LRESULT GetMsgProc(int code, WPARAM wParam, LPARAM lParam)&#123; return CallNextHookEx(g_hHook, code, wParam, lParam);&#125;// 设置全局钩子BOOL SetGlobalHook()&#123; g_hHook = SetWindowsHookEx(WH_GETMESSAGE, (HOOKPROC)GetMsgProc, g_hDllModule, 0); if (NULL == g_hHook) &#123; return FALSE; &#125; return TRUE;&#125;// 卸载钩子BOOL UnsetGlobalHook()&#123; if (g_hHook) &#123; UnhookWindowsHookEx(g_hHook); &#125; return TRUE;&#125;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: &#123; g_hDllModule = hModule; break; &#125; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 全局钩子是以DLL形式加载到其他进程空间之中的，且进程都是独立的，任意修改其中的一个内存里的数据是不会影响另一个进程的。所在DLL中创建了共享内存，共享内存是指突破进程独立性，多个进程共享同一段内存。在DLL中创建共享内存，就是在DLL之中创建一个变量，然后将DLL加载到多个进程空间，只要一个进程修改了该变量值，其他进程DLL中的这个值也会改变，就相当于多个进程共享一个内存。 编写一个调用DLL的程序，test.exe 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// test.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;Windows.h&gt;int main()&#123; typedef BOOL(*typedef_SetGlobalHook)(); typedef BOOL(*typedef_UnsetGlobalHook)(); HMODULE hDll = NULL; typedef_SetGlobalHook SetGlobalHook = NULL; typedef_UnsetGlobalHook UnsetGlobalHook = NULL; BOOL bRet = FALSE; printf(&quot;按下回车开始设置钩子\\n&quot;); getchar(); do &#123; hDll = LoadLibrary(L&quot;Hook.dll&quot;); if (NULL == hDll) &#123; printf(&quot;加载DLL失败\\n错误代码%d\\n&quot;, GetLastError()); break; &#125; SetGlobalHook = (typedef_SetGlobalHook)GetProcAddress(hDll, &quot;SetGlobalHook&quot;); if (NULL == SetGlobalHook) &#123; printf(&quot;获取函数地址失败\\n错误代码%d\\n&quot;, GetLastError()); break; &#125; bRet = SetGlobalHook(); if (bRet) &#123; printf(&quot;设置钩子成功\\n&quot;); &#125; else &#123; printf(&quot;设置钩子失败\\n&quot;); &#125; system(&quot;pause&quot;); UnsetGlobalHook = (typedef_UnsetGlobalHook)GetProcAddress(hDll, &quot;UnsetGlobalHook&quot;); if (NULL == UnsetGlobalHook) &#123; printf(&quot;获取函数地址失败\\n错误代码%d\\n&quot;, GetLastError()); break; &#125; UnsetGlobalHook(); printf(&quot;卸载钩子成功\\n&quot;); &#125; while (FALSE); system(&quot;pause&quot;);&#125; 效果查看可以先试用PC hunter工具进行查看，可以看到当前没有任何消息钩子存在。 打开我们的test.exe，设置好钩子之后，再进行查看，刷新一下消息钩子列表，如图可以看到已经存在了一个消息钩子。 使用OD附加打开notepad.exe，再打开模块窗口。 再打开test.exe，进行钩子设置。可以很明显看到变化，已经注入成功了。","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"注入","slug":"注入","permalink":"https://b1ack1e.github.io/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"资源释放","slug":"资源释放","date":"2021-07-08T03:52:26.000Z","updated":"2021-07-09T03:35:22.401Z","comments":true,"path":"2021/07/08/资源释放/","link":"","permalink":"https://b1ack1e.github.io/2021/07/08/%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/","excerpt":"","text":"资源释放恶意代码会广泛的使用此技术，因为它可以使程序变得简洁，提高隐蔽性。如果一个程序需要额外的加载一些DLL、文本文件或者其他类型文件，将它们可以作为资源插入到程序中，在程序运行的时候再将它们释放到本地上，这样恶意代码会更加隐蔽。 函数介绍FindResource函数，确定具有指定类型和名称的资源在指定模块中的位置12345HRSRC FindResourceW( HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType); hModule：处理包含资源的可执行文件模块。若hModule为NULL，则系统从当前进程的模块中装载资源。 lpName：指定资源名称 lpType：指定资源类型 返回值：如果函数运行成功，那么返回值为指定资源信息块的句柄。可将这个句柄传递给其它函数获取其他信息。如果失败，则返回NULL； SizeofResource函数：获取指定资源的字节数1234DWORD SizeofResource( HMODULE hModule, HRSRC hResInfo); hModule：包含资源的可执行文件模块的句柄。若hModule为NULL，则系统从当前进程的模块中装载资源。 hResInfo：资源局部。此句柄必须由函数FindResource或FindResourceEx来出创建。 返回值：如果函数运行成功，则返回值为资源的字节数；如果函数运行失败，则返回值为0； LoadResource函数：装载指定资源到全局存储器1234HGLOBAL LoadResource( HMODULE hModule, HRSRC hResInfo); hModule：包含资源的可执行文件模块的句柄。若hModule为NULL，则系统从当前进程的模块中装载资源。 hResInfo：资源局部。此句柄必须由函数FindResource或FindResourceEx来出创建。 返回值：如果函数运行成功，则返回值为相关资源数据的句柄。如果函数运行失败，则返回值为NULL。 LockResource函数：锁定资源并得到资源在内存中的第一个字节的指针123LPVOID LockResource( HGLOBAL hResData); hResData：装载资源的句柄。函数LoadResource可以返回这个句柄。 返回值：如果装载资源被锁住，则返回值是资源的第一个字节的指针；反之则为NULL。 实现过程创建一个test.txt文件，写入内容 在程序中添加一个自定义资源，自定义资源名称为“MYRES”，再将刚才创建的txt文件添加进去 程序实现源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// FreeRes.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &quot;resource.h&quot;//资源控件名称，资源名称，释放后的名称BOOL FreeRes(UINT uiResourceName,TCHAR* lpszResType,char* lpszSaveFileName) &#123; //获取指定模块的资源 HRSRC hRes = FindResource(NULL, MAKEINTRESOURCE(uiResourceName), lpszResType); if (hRes == NULL) &#123; MessageBox(NULL, L&quot;获取资源失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; //获取大小 DWORD dwSize = SizeofResource(NULL, hRes); if (dwSize == 0) &#123; MessageBox(NULL, L&quot;获取字节数失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; //装载资源 HGLOBAL hGlobal = LoadResource(NULL, hRes); if (hGlobal == NULL) &#123; MessageBox(NULL, L&quot;装载资源失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; //锁定资源 LPVOID lPvoid = LockResource(hGlobal); if(lPvoid == NULL)&#123; MessageBox(NULL, L&quot;锁定资源失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; //开始释放资源 FILE* fp; fopen_s(&amp;fp, lpszSaveFileName, &quot;wb+&quot;);//wb+读写打开或建立一个二进制文件，允许读和写 if (fp == NULL) &#123; MessageBox(NULL, L&quot;写入资源失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; fwrite(lPvoid, sizeof(char), dwSize, fp); fclose(fp); return TRUE;&#125;int main()&#123; printf(&quot;按下回车键开始释放资源\\n&quot;); getchar(); BOOL FLAG=FreeRes(IDR_MYRES2,TEXT(&quot;MYRES&quot;),&quot;free.txt&quot;); if (FLAG == TRUE) &#123; printf(&quot;释放成功\\n&quot;); &#125; else printf(&quot;释放失败\\n&quot;); getchar();&#125; 查看free.txt内容 参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}]},{"title":"写在前面的话","slug":"写在前面的话","date":"2021-07-08T03:50:10.000Z","updated":"2021-07-08T09:40:20.968Z","comments":true,"path":"2021/07/08/写在前面的话/","link":"","permalink":"https://b1ack1e.github.io/2021/07/08/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%E7%9A%84%E8%AF%9D/","excerpt":"","text":"一直都在说要写博客，但是一直都没有很好的坚持下来，上次写博客还是大二的时候，这都过去好久了。 现在自己也搭建了一个博客，希望能够好好坚持下去吧，作为日常的学习记录，也希望能够写出一些有价值的东西。 最后的最后，我是不知名小团队satter的b1ackie。","categories":[],"tags":[]}],"categories":[{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ack1e.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ack1e.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"},{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"注入","slug":"注入","permalink":"https://b1ack1e.github.io/tags/%E6%B3%A8%E5%85%A5/"}]}