<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>b1ackie&#39;blog</title>
  
  
  <link href="https://b1ack1e.github.io/atom.xml" rel="self"/>
  
  <link href="https://b1ack1e.github.io/"/>
  <updated>2021-07-09T02:42:28.245Z</updated>
  <id>https://b1ack1e.github.io/</id>
  
  <author>
    <name>b1ackie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>恶意代码分析-资源释放</title>
    <link href="https://b1ack1e.github.io/2021/07/09/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/"/>
    <id>https://b1ack1e.github.io/2021/07/09/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/</id>
    <published>2021-07-09T01:54:29.000Z</published>
    <updated>2021-07-09T02:42:28.245Z</updated>
    
    <content type="html"><![CDATA[<p>本篇来分析一下自己写的资源释放的小demo。</p><p><img src="/2021/07/09/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/1.png"></p><p>打开程序，发现没有任何改变，没有明显的行为。</p><p>使用die工具查一下文件的基本信息</p><p><img src="/2021/07/09/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/2.png"></p><p>查看一下导入表，可以看到FindResource等函数，这几个函数是用来操作资源的，猜测有可能是释放了一个资源节中的资源到电脑上。</p><p><img src="/2021/07/09/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/3.png"></p><p>还可以看到fwrite，fopen这样的函数，那么应该就是把资源释放到了一个路径中去。</p><p><img src="/2021/07/09/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/4.png"></p><p>可以使用resource hacker来查看程序中的资源，如图可以看到资源信息“this is a test”</p><p><img src="/2021/07/09/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/5.png"></p><p>再使用IDA进行查看，可以很清楚的看到所有的流程，并且看到程序将释放的文件存放在了C:\Windows\System32下。</p><p><img src="/2021/07/09/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/6.png"></p><p>因为程序是32位程序，系统是64位，所以资源会被释放到SysWOW64文件下。因为此文件夹是用来处理运行在64位系统上的32位程序的。</p><p>到路径下查找free.txt即可找到</p><p><img src="/2021/07/09/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/7.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇来分析一下自己写的资源释放的小demo。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/07/09/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6</summary>
      
    
    
    
    <category term="病毒分析" scheme="https://b1ack1e.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
    
    <category term="逆向工程" scheme="https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="病毒分析" scheme="https://b1ack1e.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>全局钩子注入</title>
    <link href="https://b1ack1e.github.io/2021/07/08/%E5%85%A8%E5%B1%80%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/"/>
    <id>https://b1ack1e.github.io/2021/07/08/%E5%85%A8%E5%B1%80%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/</id>
    <published>2021-07-08T09:52:07.000Z</published>
    <updated>2021-07-09T10:19:27.858Z</updated>
    
    <content type="html"><![CDATA[<h4 id="全局钩子注入"><a href="#全局钩子注入" class="headerlink" title="全局钩子注入"></a>全局钩子注入</h4><p>windows中大部分应用程序都是基于消息机制的，每个进程都有自己的消息队列。</p><p>局部钩子是针对某个线程的，全局钩子是作用于整个系统的基于消息的应用。全局钩子需要使用DLL文件，在DLL文件中实现相应的钩子函数。</p><h4 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h4><h5 id="SetWindowsHookEx函数"><a href="#SetWindowsHookEx函数" class="headerlink" title="SetWindowsHookEx函数"></a>SetWindowsHookEx函数</h5><p>将程序定义的钩子函数安装到挂钩链中，安装钩子程序可以监视系统是否存在某些类型的事件，这些事件与特定线程或调用线程所在桌面中的所有线程相关联。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HHOOK SetWindowsHookExA(</span><br><span class="line">  int       idHook,</span><br><span class="line">  HOOKPROC  lpfn,</span><br><span class="line">  HINSTANCE hmod,</span><br><span class="line">  DWORD     dwThreadId</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>idHook：要安装的钩子程序的类型，该参数具体可以见下表。</p><table><thead><tr><th align="left">值</th><th>含义</th></tr></thead><tbody><tr><td align="left">WH_CALLWNDPROC<br>4</td><td>安装钩子程序，在系统将消息发送到目标窗口过程之前监视消息</td></tr><tr><td align="left">WH_CALLWNDPROCRET<br>12</td><td>安装钩子程序，在目标窗口过程处理消息后监视消息</td></tr><tr><td align="left">WH_CBT<br>5</td><td>安装接受对CBT应用程序有用通知的钩子程序</td></tr><tr><td align="left">WH_DEBUG<br>9</td><td>安装可用于调试其他钩子程序的钩子程序</td></tr><tr><td align="left">WH_FOREGROUNDIDLE<br>11</td><td>安装在应用程序的前台线程即将变为空闲时调用的钩子过程，该钩子对于在空闲时执行低优先级任务很有用</td></tr><tr><td align="left">WH_GETMESSAGE<br>3</td><td>安装一个挂钩过程，它监视发送到消息队列的消息</td></tr><tr><td align="left">WH_JOURNALPLAYBACK<br>1</td><td>安装一个挂钩过程，用于发布先前由WH_JOURNALRECORD挂钩过程记录的消息</td></tr><tr><td align="left">WH_JOURNALRECORD<br>0</td><td>安装一个挂钩过程，记录发布到系统消息队列中的输入消息。这个钩子对于录制宏很有用。</td></tr><tr><td align="left">WH_KEYBOARD<br>2</td><td>安装监视按键消息的挂钩过程</td></tr><tr><td align="left">WH_KEYBOARD_LL<br>13</td><td>安装监视低级键盘输入事件的挂钩过程</td></tr><tr><td align="left">WH_MOUSE<br>7</td><td>安装监视鼠标消息的挂钩过程</td></tr><tr><td align="left">WH_MOUSE_LL<br>14</td><td>安装监视低级鼠标输入事件的挂钩过程</td></tr><tr><td align="left">WH_MSGFILTER<br>-1</td><td>安装钩子程序，用于在对话框、消息框、菜单或滚动条中监视由于输入事件而生成的消息</td></tr><tr><td align="left">WH_SHELL<br>10</td><td>安装接受对于shell应用程序有用通知的钩子程序</td></tr><tr><td align="left">WH_SYSMSGFILTER<br>6</td><td>安装钩子程序，用于在对话框、消息框、菜单或滚动条中监视由于输入事件而生成的消息，钩子程序监视与调用线程相同桌面中所有应用程序的这些消息</td></tr></tbody></table><p>lpfn：一个指向钩子程序的指针。如果dwThreadId参数为0或指定由不同进程创建线程标识符，则lpfn参数必须指向DLL中的钩子过程。否则，lpfn可以指向与当前进程关联的代码中的钩子过程。</p><p>hMod：包含由lpfn参数指向的钩子过程的DLL句柄。如果dwThreadId参数指定由当前进程创建线程，并且钩子过程位于与当前进程关联的代码中，则hMod参数必须设置为NULL。</p><p>dwThreadId：与钩子程序关联的线程标识符。如果此参数为0，则钩子过程与系统中所有线程相关联。</p><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p>如果函数成功，则返回值是钩子过程的句柄。</p><p>如果函数失败，则返回值为NULL。</p><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>创建全局钩子，钩子函数需要在一个DLL文件中。进程的地址空间是独立的，发生对应事件的进程不能调用其他进程地址空间的钩子函数。如果钩子的实现在DLL中的话，则在对应事件发生的时候，系统会把这个DLL加载到发生事件的进程地址空间之中，使它能够调用钩子函数进行处理。创建一个全局钩子之后，在对应事件发生的时候，系统就会把DLL加载到发生事件的进程中，这样就实现了DLL注入。</p><p>设置idHook的值为WH_GETMESSAGE就可以让DLL注入到所有的进程中，因为WH_GETMESSAGE类型的钩子会监视消息队列，并且Windows系统是基于消息驱动的，所有进程都会有一个自己的消息队列，都会加载WH_GETMESSAGE类型的全局钩子DLL。</p><p>DLL文件如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="comment">//共享内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">&quot;mydata&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">&quot;/SECTION:mydata,RWS&quot;</span>)</span></span><br><span class="line">HMODULE g_hDllModule = <span class="literal">NULL</span>;</span><br><span class="line">HHOOK g_hHook = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// 钩子回调函数</span></span><br><span class="line"><span class="function">LRESULT <span class="title">GetMsgProc</span><span class="params">(<span class="keyword">int</span> code, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CallNextHookEx</span>(g_hHook, code, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置全局钩子</span></span><br><span class="line"><span class="function">BOOL <span class="title">SetGlobalHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_hHook = <span class="built_in">SetWindowsHookEx</span>(WH_GETMESSAGE, (HOOKPROC)GetMsgProc, g_hDllModule, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == g_hHook)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 卸载钩子</span></span><br><span class="line"><span class="function">BOOL <span class="title">UnsetGlobalHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_hHook)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UnhookWindowsHookEx</span>(g_hHook);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">    &#123;</span><br><span class="line">        g_hDllModule = hModule;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局钩子是以DLL形式加载到其他进程空间之中的，且进程都是独立的，任意修改其中的一个内存里的数据是不会影响另一个进程的。所在DLL中创建了共享内存，共享内存是指突破进程独立性，多个进程共享同一段内存。在DLL中创建共享内存，就是在DLL之中创建一个变量，然后将DLL加载到多个进程空间，只要一个进程修改了该变量值，其他进程DLL中的这个值也会改变，就相当于多个进程共享一个内存。</p><p>编写一个调用DLL的程序，test.exe</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(*typedef_SetGlobalHook)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(*typedef_UnsetGlobalHook)</span><span class="params">()</span></span>;</span><br><span class="line">HMODULE hDll = <span class="literal">NULL</span>;</span><br><span class="line">typedef_SetGlobalHook SetGlobalHook = <span class="literal">NULL</span>;</span><br><span class="line">typedef_UnsetGlobalHook UnsetGlobalHook = <span class="literal">NULL</span>;</span><br><span class="line">BOOL bRet = FALSE;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;按下回车开始设置钩子\n&quot;</span>);</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">hDll = <span class="built_in">LoadLibrary</span>(<span class="string">L&quot;Hook.dll&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == hDll)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;加载DLL失败\n错误代码%d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">SetGlobalHook = (typedef_SetGlobalHook)<span class="built_in">GetProcAddress</span>(hDll, <span class="string">&quot;SetGlobalHook&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == SetGlobalHook)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取函数地址失败\n错误代码%d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">bRet = <span class="built_in">SetGlobalHook</span>();</span><br><span class="line"><span class="keyword">if</span> (bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;设置钩子成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;设置钩子失败\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">UnsetGlobalHook = (typedef_UnsetGlobalHook)<span class="built_in">GetProcAddress</span>(hDll, <span class="string">&quot;UnsetGlobalHook&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == UnsetGlobalHook)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取函数地址失败\n错误代码%d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">UnsetGlobalHook</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;卸载钩子成功\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (FALSE);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="效果查看"><a href="#效果查看" class="headerlink" title="效果查看"></a>效果查看</h4><p>可以先试用PC hunter工具进行查看，可以看到当前没有任何消息钩子存在。</p><p><img src="/2021/07/08/%E5%85%A8%E5%B1%80%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/1.png"></p><p>打开我们的test.exe，设置好钩子之后，再进行查看，刷新一下消息钩子列表，如图可以看到已经存在了一个消息钩子。</p><p><img src="/2021/07/08/%E5%85%A8%E5%B1%80%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/2.png"></p><p>使用OD附加打开notepad.exe，再打开模块窗口。</p><p><img src="/2021/07/08/%E5%85%A8%E5%B1%80%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/3.png"></p><p>再打开test.exe，进行钩子设置。可以很明显看到变化，已经注入成功了。</p><p><img src="/2021/07/08/%E5%85%A8%E5%B1%80%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/4.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;全局钩子注入&quot;&gt;&lt;a href=&quot;#全局钩子注入&quot; class=&quot;headerlink&quot; title=&quot;全局钩子注入&quot;&gt;&lt;/a&gt;全局钩子注入&lt;/h4&gt;&lt;p&gt;windows中大部分应用程序都是基于消息机制的，每个进程都有自己的消息队列。&lt;/p&gt;
&lt;p&gt;局部钩子是针对</summary>
      
    
    
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="恶意代码" scheme="https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
    <category term="注入" scheme="https://b1ack1e.github.io/tags/%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>资源释放</title>
    <link href="https://b1ack1e.github.io/2021/07/08/%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/"/>
    <id>https://b1ack1e.github.io/2021/07/08/%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/</id>
    <published>2021-07-08T03:52:26.000Z</published>
    <updated>2021-07-09T03:35:22.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="资源释放"><a href="#资源释放" class="headerlink" title="资源释放"></a>资源释放</h2><p>恶意代码会广泛的使用此技术，因为它可以使程序变得简洁，提高隐蔽性。如果一个程序需要额外的加载一些DLL、文本文件或者其他类型文件，将它们可以作为资源插入到程序中，在程序运行的时候再将它们释放到本地上，这样恶意代码会更加隐蔽。</p><h4 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h4><h5 id="FindResource函数，确定具有指定类型和名称的资源在指定模块中的位置"><a href="#FindResource函数，确定具有指定类型和名称的资源在指定模块中的位置" class="headerlink" title="FindResource函数，确定具有指定类型和名称的资源在指定模块中的位置"></a>FindResource函数，确定具有指定类型和名称的资源在指定模块中的位置</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HRSRC FindResourceW(</span><br><span class="line">  HMODULE hModule,</span><br><span class="line">  LPCWSTR lpName,</span><br><span class="line">  LPCWSTR lpType</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hModule：处理包含资源的可执行文件模块。若hModule为NULL，则系统从当前进程的模块中装载资源。</p><p>lpName：指定资源名称</p><p>lpType：指定资源类型</p><p>返回值：如果函数运行成功，那么返回值为指定资源信息块的句柄。可将这个句柄传递给其它函数获取其他信息。如果失败，则返回NULL；</p><h5 id="SizeofResource函数：获取指定资源的字节数"><a href="#SizeofResource函数：获取指定资源的字节数" class="headerlink" title="SizeofResource函数：获取指定资源的字节数"></a>SizeofResource函数：获取指定资源的字节数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DWORD SizeofResource(</span><br><span class="line">  HMODULE hModule,</span><br><span class="line">  HRSRC   hResInfo</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hModule：包含资源的可执行文件模块的句柄。若hModule为NULL，则系统从当前进程的模块中装载资源。</p><p>hResInfo：资源局部。此句柄必须由函数FindResource或FindResourceEx来出创建。</p><p>返回值：如果函数运行成功，则返回值为资源的字节数；如果函数运行失败，则返回值为0；</p><h5 id="LoadResource函数：装载指定资源到全局存储器"><a href="#LoadResource函数：装载指定资源到全局存储器" class="headerlink" title="LoadResource函数：装载指定资源到全局存储器"></a>LoadResource函数：装载指定资源到全局存储器</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HGLOBAL LoadResource(</span><br><span class="line">  HMODULE hModule,</span><br><span class="line">  HRSRC   hResInfo</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hModule：包含资源的可执行文件模块的句柄。若hModule为NULL，则系统从当前进程的模块中装载资源。</p><p>hResInfo：资源局部。此句柄必须由函数FindResource或FindResourceEx来出创建。</p><p>返回值：如果函数运行成功，则返回值为相关资源数据的句柄。如果函数运行失败，则返回值为NULL。</p><h5 id="LockResource函数：锁定资源并得到资源在内存中的第一个字节的指针"><a href="#LockResource函数：锁定资源并得到资源在内存中的第一个字节的指针" class="headerlink" title="LockResource函数：锁定资源并得到资源在内存中的第一个字节的指针"></a>LockResource函数：锁定资源并得到资源在内存中的第一个字节的指针</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LPVOID LockResource(</span><br><span class="line">  HGLOBAL hResData</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hResData：装载资源的句柄。函数LoadResource可以返回这个句柄。</p><p>返回值：如果装载资源被锁住，则返回值是资源的第一个字节的指针；反之则为NULL。</p><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>创建一个test.txt文件，写入内容</p><p><img src="/2021/07/08/%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/1.png"></p><p>在程序中添加一个自定义资源，自定义资源名称为“MYRES”，再将刚才创建的txt文件添加进去</p><p>程序实现源代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FreeRes.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="comment">//资源控件名称，资源名称，释放后的名称</span></span><br><span class="line"><span class="function">BOOL <span class="title">FreeRes</span><span class="params">(UINT uiResourceName,TCHAR* lpszResType,<span class="keyword">char</span>* lpszSaveFileName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取指定模块的资源</span></span><br><span class="line">    HRSRC hRes = <span class="built_in">FindResource</span>(<span class="literal">NULL</span>, <span class="built_in">MAKEINTRESOURCE</span>(uiResourceName), lpszResType);</span><br><span class="line">    <span class="keyword">if</span> (hRes == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">L&quot;获取资源失败&quot;</span>, <span class="string">L&quot;&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取大小</span></span><br><span class="line">    DWORD dwSize = <span class="built_in">SizeofResource</span>(<span class="literal">NULL</span>, hRes);</span><br><span class="line">    <span class="keyword">if</span> (dwSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">L&quot;获取字节数失败&quot;</span>, <span class="string">L&quot;&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//装载资源</span></span><br><span class="line">    HGLOBAL hGlobal = <span class="built_in">LoadResource</span>(<span class="literal">NULL</span>, hRes);</span><br><span class="line">    <span class="keyword">if</span> (hGlobal == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">L&quot;装载资源失败&quot;</span>, <span class="string">L&quot;&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//锁定资源</span></span><br><span class="line">    LPVOID lPvoid = <span class="built_in">LockResource</span>(hGlobal);</span><br><span class="line">    <span class="keyword">if</span>(lPvoid == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">L&quot;锁定资源失败&quot;</span>, <span class="string">L&quot;&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始释放资源</span></span><br><span class="line">    FILE* fp;</span><br><span class="line">    <span class="built_in">fopen_s</span>(&amp;fp, lpszSaveFileName, <span class="string">&quot;wb+&quot;</span>);<span class="comment">//wb+读写打开或建立一个二进制文件，允许读和写</span></span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">L&quot;写入资源失败&quot;</span>, <span class="string">L&quot;&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fwrite</span>(lPvoid, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>), dwSize, fp);</span><br><span class="line">    <span class="built_in">fclose</span>(fp);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下回车键开始释放资源\n&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    BOOL FLAG=<span class="built_in">FreeRes</span>(IDR_MYRES2,<span class="built_in">TEXT</span>(<span class="string">&quot;MYRES&quot;</span>),<span class="string">&quot;free.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (FLAG == TRUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;释放成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;释放失败\n&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/07/08/%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/2.png"></p><p>查看free.txt内容</p><p><img src="/2021/07/08/%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/3.png"></p><p>参考《Windows黑客编程技术详解》一书</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;资源释放&quot;&gt;&lt;a href=&quot;#资源释放&quot; class=&quot;headerlink&quot; title=&quot;资源释放&quot;&gt;&lt;/a&gt;资源释放&lt;/h2&gt;&lt;p&gt;恶意代码会广泛的使用此技术，因为它可以使程序变得简洁，提高隐蔽性。如果一个程序需要额外的加载一些DLL、文本文件或者其他类型</summary>
      
    
    
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="恶意代码" scheme="https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>写在前面的话</title>
    <link href="https://b1ack1e.github.io/2021/07/08/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%E7%9A%84%E8%AF%9D/"/>
    <id>https://b1ack1e.github.io/2021/07/08/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2%E7%9A%84%E8%AF%9D/</id>
    <published>2021-07-08T03:50:10.000Z</published>
    <updated>2021-07-08T09:40:20.968Z</updated>
    
    <content type="html"><![CDATA[<p>一直都在说要写博客，但是一直都没有很好的坚持下来，上次写博客还是大二的时候，这都过去好久了。</p><p>现在自己也搭建了一个博客，希望能够好好坚持下去吧，作为日常的学习记录，也希望能够写出一些有价值的东西。</p><p>最后的最后，我是不知名小团队satter的b1ackie。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一直都在说要写博客，但是一直都没有很好的坚持下来，上次写博客还是大二的时候，这都过去好久了。&lt;/p&gt;
&lt;p&gt;现在自己也搭建了一个博客，希望能够好好坚持下去吧，作为日常的学习记录，也希望能够写出一些有价值的东西。&lt;/p&gt;
&lt;p&gt;最后的最后，我是不知名小团队satter的b1a</summary>
      
    
    
    
    
  </entry>
  
</feed>
